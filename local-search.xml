<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SQL优化(3)-索引与优化原理(上)</title>
    <link href="/2020/08/13/SQL%E4%BC%98%E5%8C%96(3)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8A)/"/>
    <url>/2020/08/13/SQL%E4%BC%98%E5%8C%96(3)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<p>上一篇，我们重走了一遍数据库索引的历史，认识了B+树结构，这一篇我们回归现实中的MySQL数据库，初步学习具体的SQL优化原则，并尝试从索引底层原理出发，分析为什么会有那么多的“规则”。</p><h1 id="为什么要学习SQL优化"><a href="#为什么要学习SQL优化" class="headerlink" title="为什么要学习SQL优化"></a>为什么要学习SQL优化</h1><p>我的前东家是做招聘服务的，所以不可避免地要查询行业分类。通常来说，前端可以采用根据parentId分步加载的方式获取行业类别，但有些场景也需要全量嵌套查询：查询行业分类及其子分类。</p><p>这里我们就假定直接查询所有分类及其子分类：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584876552845-1508cebc-e24b-4812-b5f1-d44df431105b-20210923151052749.png" alt="img"></p><p>我自己设计了一个简单版的表结构，大概如下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584876666317-5f0f97f0-aa23-4be1-a7bf-e1d8fce54587-20210923151044115.png" alt="img"></p><p>表中有1106条数据：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877002375-f8dd6ff0-eff5-485b-a2e7-277a049ffdaa-20210923151103929.png" alt="img"></p><p>经过《实用小算法》的学习，我们很容易写出以下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询行业分类及其子分类</span><br><span class="hljs-comment"> */</span><br>@Test<br>public void test<span class="hljs-constructor">Cascade()</span> &#123;<br><br>    <span class="hljs-comment">// 查询数据库，得到所有行业类别</span><br>    List&lt;SysPosition&gt; sysPositionList = sysPositionMapper.select<span class="hljs-constructor">All()</span>;<br><br>    long start = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br><br>    Map&lt;String, SysPosition&gt; sysPositionMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>    List&lt;SysPosition&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-comment">// 第一步：List转Map</span><br>    <span class="hljs-keyword">for</span> (SysPosition sysPosition : sysPositionList) &#123;<br>        sysPositionMap.put(sysPosition.get<span class="hljs-constructor">Code()</span>, sysPosition);<br>    &#125;<br><br>    <span class="hljs-comment">// 第二步：遍历List，利用Map完成嵌套</span><br>    <span class="hljs-keyword">for</span> (SysPosition sysPosition : sysPositionList) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-1&quot;</span>.equals(sysPosition.get<span class="hljs-constructor">ParentCode()</span>)) &#123;<br>            result.add(sysPosition);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            SysPosition parent = sysPositionMap.get(sysPosition.get<span class="hljs-constructor">ParentCode()</span>);<br>            parent.get<span class="hljs-constructor">Children()</span>.add(sysPosition);<br>        &#125;<br>    &#125;<br><br>    long <span class="hljs-keyword">end</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (<span class="hljs-keyword">end</span> - start));<br>&#125;<br></code></pre></td></tr></table></figure><p>在《实用小算法》中，我们分析过效率：List转Map这种方式会有2N次循环，也就是会循环2212次。</p><p>大家猜上面程序耗时多少？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877133249-0f113716-f40b-4824-be73-a6fbc5eac808-20210923151113333.png" alt="img"></p><p>只需1<strong>毫秒</strong>。</p><p>对于CPU来说，计算内存中的数据是非常快的，几千次的循环基本可以忽略不计。</p><p>你们想知道之前《实用小算法》的第一版算法耗时多少吗？测一下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877340185-9be080f5-c98b-4ef3-9dbc-6b6e690f36a4-20210923151121192.png" alt="img"></p><p>也<strong>只要</strong>33毫秒。</p><p>要知道，第一版算法在这种情况下可是循环了1106*1106 = 100w+次！！<strong>但是对于CPU来说，不足挂齿。</strong>当然，这是单次调用的差距，想象一下这个接口每天要被几十万、甚至几百万用户调用，累计差距还是很可观的。</p><p>通过上面的案例，我想说的是：绝大多数情况下，内存中数据的处理耗时几乎可以忽略不计。</p><p>大家有没有发现，上面的程序并没有把Mapper查询数据库的操作计入时间？数据库select操作会很耗时吗？</p><p>我在某网站的专栏中看到过关于数据库insert的一段话：</p><p>插入行所需的时间由以下因素决定（参考MySQL 5.7参考手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html">8.2.4.1优化INSERT语句</a>）</p><ul><li><p>连接：30%</p></li><li><p>向服务器发送查询：20%</p></li><li><p>解析查询：20%</p></li><li><p>插入行：10% * 行的大小</p></li><li><p>插入索引：10% * 索引数</p></li><li><p>结束：10%</p></li></ul><p>可发现大部分时间耗费在客户端与服务端通信的时间，因此可以使用 insert 包含多个值来减少客户端和服务器之间的通信。我们通过实验来验证下一次插入多行与一次插入一行的效率对比。</p><p>上面虽然说得是insert，但select的情况其实也差不多。现在我把Mapper查询的时间也包括进来：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877601504-4c6d4ea7-967a-4e78-9d0c-1219fc21c491-20210923151138685.png" alt="img"></p><p><strong>竟然暴增到496毫秒！！</strong></p><p>好了，这个例子告诉我们，网络请求（以及IO操作）是非常耗时的操作，我们应该尽量避免在循环中调用网络请求或进行IO操作，比如：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877845815-757a0f69-eaee-42bc-90b4-d4949e03cb0c-20210923151148208.png" alt="img"></p><p>这是非常差劲的写法。</p><p>OK，到这里大家应该能形成一个认知：一次正常的请求，最可能出现性能瓶颈的地方就是网络请求及IO操作（通常而言性能瓶颈往往出现在数据库）。</p><p>要想优化数据的查询，大方向有两个：</p><ul><li>优化关系型数据库本身，比如增加索引等</li><li>借助大数据和ES，转嫁查询压力（本质已经和关系型数据库无关了）</li></ul><p>对于一般小公司而言，大数据和ES还是稀罕物，所以当我们讨论性能优化时，SQL优化几乎是重点！和SQL的性能提升相比，代码的优化有时是微不足道的。<strong>即使有优化，归根到底其实还是减少、减小对数据库的请求。</strong>大家应该要感到高兴，因为你们终于也将登堂入室，要去探索SQL优化了。</p><p>没有特殊情况的话，本文讨论的内容都是基于InnoDB引擎</p><p>在我看来，对于一般的Java开发而言，SQL优化分为几个层次：</p><ul><li><p>索引优化 70%</p></li><li><p>事务及锁 20%</p></li><li><p>读写分离等 10%</p></li></ul><p>其中，索引优化是最重要、也是一般Java开发人员最常用的手段。</p><h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><p>索引的分类可能有不同维度，这里不追求特别准确的分类，毕竟不是做学术，只要感性认识几种即可。</p><p>打开Navicat，尝试创建索引时会发现有4种索引类型可以选择：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589520399248-9a8373e7-567f-4ab5-9d74-f39ac0bb3332-20210923151215022.png" alt="img"></p><ul><li><p>全文索引</p></li><li><p>普通索引</p></li><li><p>空间索引</p></li><li><p>唯一索引</p></li></ul><p>普通索引就可以组织树结构了，而唯一索引在普通索引的基础上还要求索引列不能重复。比如，假设我们给student表的name列加了唯一索引，如果表中已经存在”张三”，那么再次插入”张三”将会报错。</p><p>MySQL这种关系型数据库并不适合进行全文检索（考虑Elastic Search），所以全文索引一般很少使用。</p><p>至于空间索引，我也不知道是什么。</p><p>实际开发常用的索引只有<strong>普通索引</strong>和<strong>唯一索引</strong>，其他的可以不用理会（主键索引其实相当于唯一索引+非NULL）。</p><h1 id="索引的实现方式"><a href="#索引的实现方式" class="headerlink" title="索引的实现方式"></a>索引的实现方式</h1><p>常见的索引实现方式有两种，通过B+树结构或hash算法实现。</p><p><strong>特别注意，这里虽然写的是”BTREE”，但MySQL确实使用的是B+Tree。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589533482892-ea6a7e77-c129-45e3-8519-827ae57c69c7-20210923151221445.png" alt="img"></p><p>这个概念，其实和上面“索引的类型”并不冲突。</p><p>比如，对于普通索引，我们可以使用B+树的结构组织索引，也可以使用hash算法实现。经过上一篇的学习，我们对B+树结构已经比较了解，所以这里单独聊一下hash索引。</p><p>所谓hash索引，其实就是利用<strong>哈希算法为索引列计算得到唯一的存储地址</strong>，一般来说这个地址是不会重复的（重复的情况被称为哈希冲突）。</p><p>举个燕十八老师说的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589533947057-755cdba3-b196-44cd-88c4-813dc6397463-20210923151227170.png" alt="img"></p><p>在墙上装一根弹性永不衰变的弹簧，每次拿不同的物件把弹簧压到极限后放开，不同的物件最终落点会不同。比如你上回存了一本书，那么下次想要找到这本书时，只需要拿一本<strong>一模一样的书</strong>重新弹一下，即可在本次落点处找到上次那本书。</p><p>数据库hash索引的设计也类似，假设你要存入id=10086的数据，就需要通过hash算法对id进行计算，得到一个存储位置后写入数据。下次拿着id=10086查询时，只要按同样的算法再次计算，就能马上找到对应的数据，是不是很快呢~</p><p>需要注意的是，弹簧的例子用来比喻hash算法虽然挺形象的，但可能会让人误以为越重的物品落点越近，越轻的物品落点越远，进而得出结论：hash索引可以进行范围查找。</p><p>其实并不是如此。</p><p>hash算法有个比较显著的特征：即使源数据具备一定的相关性，经过hash映射后得到的结果也会变得“很散”，没有规律可循。回到之前的例子中，你可以理解为重量并不是影响书本最终落点的唯一因素，书的材质、形状等都占有一定比例，最终体现到空气阻力上导致落点的不规则。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608951320970-75bcceba-6e55-4737-9e29-8a7da83502b6-20210923151233076.png" alt="img"></p><p>不知道大家还是否记得，在JavaSE阶段接触HashMap时，很多人会发现put的顺序和get的顺序并不一定相同。比如put的顺序是1000克、500克、300克，而get的顺序却是500克、300克、1000克。也就是说，经过hash计算后，数据的相关性会大大减弱。</p><p>所以，当你希望查找500g~1000g的书本时，就无法利用边界值进行范围查找。而B+树<strong>叶子节点是有序链表</strong>，范围查询非常方便。</p><p><strong>hash索引除了无法进行范围查找外，还不能进行模糊搜索。</strong></p><p>hash算法本身代表着精确定位，依赖于计算的入参得出“唯一”的值，所以无法进行模糊匹配。比如，你给我”bravo”，我可以计算唯一的hash值，你给我”bra%”，我会以为这人就叫”bra%”，也计算一个值，<strong>而****这个值代表着”bra%”计算得到的落点，而不是”所有以bra开头的数据”的落点</strong>，显然是不对的。</p><p>但B+树可以进行模糊搜索，你可以姑且认为因为它会顺着树查找，并在装有数据的节点内调用类似Java的String#startWith()方法进行比较。</p><p>hash索引的优劣势</p><ul><li>优势：速度非常快，只需一次计算即可得到地址，时间复杂度O(1)，而B+树是O(logn)</li><li>劣势：不支持模糊查询、范围查询、索引排序（本身就是不规则的，如何利用索引排序呢）</li></ul><p>最后，《实用小算法》中List转HashMap的操作其实就是借鉴了hash索引！</p><h1 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h1><p>索引的创建时机一般有两处：</p><ul><li>起初，建表时顺便建立索引</li><li>后期，修改表结构创建索引（一般都是这样，因为很难未卜先知，提前优化等于瞎优化）</li></ul><p>比如，一开始就创建索引：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589520661369-1d8b2328-8dca-4f08-8fb4-94df84b770b5-20210923151242400.png" alt="img"></p><p>这张表有两个索引：主键索引、auditor_id普通索引。</p><p>主键索引并不属于上面介绍的4种索引类型之一，但所谓的Primary Key可以看做 唯一索引 + NOT NULL约束。</p><p>后期如果需要添加索引，可以通过两种方式：</p><ul><li>SQL语句</li><li>Navicat图形界面</li></ul><p>利用SQL语句添加索引：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 1.添加PRIMARY KEY（主键索引） </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span> (`<span class="hljs-keyword">column</span>`) ;<br><span class="hljs-comment">-- 2.添加UNIQUE(唯一索引) </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> (`<span class="hljs-keyword">column</span>`);<br><span class="hljs-comment">-- 3.添加INDEX(普通索引) </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (`<span class="hljs-keyword">column</span>`);<br><span class="hljs-comment">-- 4.添加FULLTEXT(全文索引) </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> FULLTEXT (`<span class="hljs-keyword">column</span>`);<br><span class="hljs-comment">-- 5.添加联合索引 </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (`column1`, `column2`, `column3`);<br></code></pre></td></tr></table></figure><p>在本案例中，可以写：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ALTER TABLE `moneywithdraw` ADD INDEX idx_auditor_id (`auditor_id`)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>利用Navicat图形界面创建<strong>单列索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589521376561-1c62b92e-60ae-4d06-ad73-6cfa4c69101b-20210923151251589.png" alt="img"></p><p>利用Navicat图形界面创建<strong>联合索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589521546600-37ba8127-ad31-4f94-a137-e1986de9354f-20210923151256752.png" alt="img"></p><p>哦，对了，数据量太大的表，不要自己随便加索引，搞不好会锁表哦…后面有机会再说。总之，你可以“懂索引”，但要“动索引”前，最好三思。</p><h1 id="索引的好与坏"><a href="#索引的好与坏" class="headerlink" title="索引的好与坏"></a>索引的好与坏</h1><p>提到索引，很多人就会说：哦，索引能提高查询速度。一般这么说的人，可能学得还不错，但绝对还没有完全掌握索引的底层原理。</p><p>如果你认为索引的优势只是加快查询，那就太小看索引了。</p><p>索引的优势是：</p><ul><li><p>加快查询速度（包括关联查询）</p></li><li><p>加快排序速度（ORDER BY）</p></li><li><p>加快分组速度（GROUP BY）</p></li></ul><p>虽然加快排序、加快分组最终还是体现在加快查询速度上，但能主动意识到这一点算是一种突破。只有当你意识到索引能加快排序和分组，你才会在写ORDER BY和GROUP BY时有意识地利用索引分组和排序（最左匹配原则），从而写出更优的SQL。</p><p>索引的劣势：</p><ul><li><p>创建索引是需要付出代价的，主要体现在维护成本、空间成本和回表成本。也就是说<strong>索引能提高查询效率，但往往会降低增删改的速度</strong>（字典新增几百个字，需要额外编排目录吧，要多占几页纸吧）</p></li><li><p>如果使用了联合索引，还需要考虑索引失效问题（下篇介绍联合索引）</p></li><li><p>太多的索引会增加查询优化器的选择时间（选择太多也麻烦）</p></li></ul><h1 id="建索引的原则"><a href="#建索引的原则" class="headerlink" title="建索引的原则"></a>建索引的原则</h1><p>很多人觉得SQL优化才是重中之重，创建索引只需要一行代码即可，没什么大不了的。但现在你已经知道了索引的优势与劣势，你会明白“在合适的时候、合适的字段建立索引”是多么空泛的口号。创建索引的判断依据究竟是什么呢？</p><p>创建索引有4个大原则：</p><ul><li><p>索引并不是越多越好，联合索引应该优于多个单列索引</p></li><li><p>索引应该建立在区分度高的字段上</p></li><li><p>尽量给查询频繁的字段创建索引，避免为修改频繁的字段创建索引</p></li><li><p>避免重复索引</p></li></ul><p>第一个原则背后的原因是，实际上数据库一次查询只会选择<strong>一棵索引树</strong>（不包括回表），更专业的说法是每次查询只会选择一个执行计划。即使你给a,b,c,d,e,f,g…所有列都加了索引，SELECT xx, xxx FROM table WHERE …时，数据库也只会<strong>择优****选择</strong>一个执行计划进行查询。</p><p>需要注意的是，<strong>每建一个索引，就需要维护一棵索引树，</strong>所以索引绝对不是越多越好，不合适的索引会增加数据库的负担。比如，你已经搞了一个根据拼音查找汉字的目录，又想根据偏旁部首来，那没辙了，只能劳烦您自己再搞一个目录了。</p><p>看到这，你可能会反问：我靠，那MySQL也太笨了吧，为什么这么死心眼一次只利用一个索引？</p><p>比较粗浅的理由是：你根据拼音查完汉字以后，还会根据偏旁部首再查一遍吗？</p><p>比较正经的理由是：按我个人的理解，索引本身的出发点是“走完一遍索引后，数据库应该返回<strong>精确的结果</strong>或<strong>很小的结果集</strong>”，从成本上考虑，此时再走一遍索引还不如直接遍历结果集来得快。当然，要想一次索引就得到精确的结果集，着实需要下一番苦功夫。给哪个字段加索引好呢？我建议，应该尽可能给区分度高的字段添加索引。</p><p>什么是区分度很高？这就是建索引的第二个原则啦。比如，表中有100w学生数据，你如果在sex列加索引，那么根据sex大概只能过滤掉50w数据，剩下的结果集仍然很大，说明这个索引建得不太合适，区分度太低了。</p><p>第三个原则就是字面意思。比如一本字典根据内容编好目录以后，隔三差五地就有新词汇要往里面加，或者经常要修改汉字读音，一顿操作后必然要连累目录，只能重新编排啦。也就是说，为了保证目录能正确指向对应的汉字，每次增删改后都要额外多一个操作：重新修订目录。</p><p>总之要意识到索引在加快查询的同时几乎必然会对修改产生负担，所以创建索引并没有那么简单，它绝对是一门“平衡的艺术”。</p><p>第四个原则是，比如已经建立a索引，又建立index(a,b,c)联合索引，此时单列索引a就是冗余的，因为联合索引已经可以保证符合条件时会利用a索引。<strong>在物理存储上，a单列索引和index(a, b, c)是两个独立的B+树，</strong>重复的索引会增加维护成本。</p><p>以上四个原则，后面的内容还会重新提到。</p><h1 id="MySQL常用引擎"><a href="#MySQL常用引擎" class="headerlink" title="MySQL常用引擎"></a>MySQL常用引擎</h1><p>MySQL的引擎有很多种，但最常听到的就MyISAM和InnoDB，而实际开发几乎99%选择使用InnoDB，而且MySQL5.6还是哪个版本以后默认引擎就从MyISAM变成了InnoDB，所以这里着重介绍InnoDB，简略介绍MyISAM。</p><p>对于两种引擎的介绍，可以看：<a href="https://www.bilibili.com/video/BV1RE41187Yo?p=9">存储引擎简介</a></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589527342910-49ca1484-7ba5-4924-944f-d1008cd46e85-20210923151312836.png" alt="img"></p><p>这里主要想和大家讨论MyISAM和InnoDB在索引组织上的区别。大家应该都已经知道，MyISAM和InnoDB存储数据的方式是不同的。</p><p>MyISAM的每张表在存储时会分为3个文件：</p><ul><li><p>表结构</p></li><li><p>表数据</p></li><li><p>索引</p></li></ul><p>也就是说，表数据和索引是分别独立存储的。</p><p>而InnoDB的表数据在存储时只分为2个文件：</p><ul><li>表结构</li><li>表数据+索引</li></ul><p>需要注意的是，InnoDB所有表的数据和索引都在同一个文件里（见下一个小节）。</p><h1 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h1><p>对于BTREE索引而言，从数据的组织形式来看，索引又可以分为两大类：</p><ul><li>聚簇索引</li><li>非聚簇索引</li></ul><p>所谓聚簇索引，可以简单理解为索引和数据是“聚合”在一起的，而非聚簇索引的数据和索引是分开的。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589532501128-7bf641bd-946e-446b-9a0f-a581b3f13887-20210923151325454.png" alt="img"></p><p>根据InnoDB引擎的<strong>主键索引</strong>查询时无需回表，每一行完整的数据都直接挂在叶子节点下，可以直接返回。也就是说，对于InnoDB的<strong>主键索引</strong>而言，数据即索引，索引即数据。<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589586538060-89e3781c-22ed-4b16-a734-d5466af2d6aa-20210923151335790.png" alt="img"></p><p>MyISAM不是很重要，不提了。</p><p>InnoDB的索引也并不是都不需要回表，根据是否需要回表其实可以分为两类：主键索引、辅助索引（或者叫二级索引、普通索引）。</p><p>会什么要做这种区分呢？</p><p>假设一个场景：</p><p>新建一张表后，自然会产生主键索引。但后期发现name字段查询很频繁，于是加了name索引。</p><p><strong>如果name索引也和主键索引一样挂着数据，那么两个索引数据就会重复。想象一下，现在磁盘中有一颗叫name的树和一棵叫id的树，一个以name为节点，一个以id为节点，相同的是最底层叶子节点都挂着完整的表数据。也就是说，磁盘中存了两份一模一样的student数据。且不说数据冗余，更新时还可能产生数据不一致（要同步数据，确保多张表的数据一致性）。</strong></p><p>所以InnoDB的做法是，辅助索引只存储索引列+主键，必要时进行“回表”操作：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589536446002-5fddd16a-59f2-4928-b10e-088aaa01f927-20210923151343933.png" alt="img"></p><p>由于SELECT * FROM stu WHERE name=’bravo’中，查询的数据是*，也就是整行数据。而上面的辅助索引只存了主键+name，所以必须回表：拿着主键再去跑一遍主键索引，最终返回整行数据。</p><p>现在，我们可以给MyISAM和InnoDB的索引分类做个简单的总结：</p><ul><li><p>MyISAM：非聚簇索引，需要回表</p></li><li><p>InnoDB：</p></li><li><ul><li>聚簇索引：主键索引，叶子节点是表数据，不需要回表</li><li>非聚簇索引：辅助索引（唯一索引、普通索引），叶子节点是主键，必要时需要根据主键回表查询</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608956710604-75cdbc20-a59e-473f-9e98-b963ac3cd49d-20210923151351478.png" alt="img"></p><p>InnoDB每张表只能有一个主键索引，辅助索引则可以有多个。表数据只有一份，挂在主键索引下面。</p><p>需要注意的是，如有可能，应该尽量避免回表。<strong>SQL优化的本质其实就是减少/减小磁盘IO</strong>，而回表必然会增加磁盘IO次数。</p><p>举个例子，假设某张表总共就两棵索引树：主键索引+name辅助索引，两棵树高度都是3。由于只有主键索引下才挂着表数据，所以对于SELECT * FROM table WHERE name=’xxx’来说，需要先走辅助索引取得id，再根据id走一遍主键索引。假设两棵树需要的数据都在第三层，那么这条SQL需要进行6次逻辑IO访问。而如果直接根据id查询，就可以直接走主键索引，IO次数为3。</p><p>所以，<strong>通常情况下</strong>辅助索引查询都是需要回表的，比主键索引查询多扫描一棵索引树（自身+主键索引），实际编写SQL时，应该尽量走主键索引。</p><p>那么，<strong>什么情况下</strong>辅助索引可以避免回表吗？</p><h1 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h1><p>索引覆盖这个名字，咋一听不知所云，所以很多初学者一直搞不明白什么意思，其实它最大的作用就是：避免回表。</p><p>下面通过一个案例来说明。</p><p>假设有个需求：前端需要支持<strong>根据用户名模糊搜索订单，</strong>而页面需要的字段如下。</p><table><thead><tr><th><strong>id</strong></th><th><strong>productName</strong></th><th><strong>price</strong></th><th><strong>userName</strong></th><th><strong>userAge</strong></th></tr></thead><tbody><tr><td>1</td><td>iphone12</td><td>5999</td><td>bravo1988</td><td>18</td></tr></tbody></table><p>一个可行的方案是：</p><ol><li><p>在t_user表中根据name搜索用户，得到user_id、user_name、user_age</p></li><li><p>在t_order表中根据user_id查询订单</p></li><li><p>在内存中根据user_id匹配order和user数据后返回</p></li></ol><p>由于t_user表此时的查询条件是user_name，为了加快t_user表的查询速度，可以给user_name加普通索引。但，这样真的好吗？我劝！不要犯这样的聪明，小聪明啊。</p><p>你要知道，此时我们从t_user表查询的可不止user_name，还有user_age和id。如果只是给user_name加了索引，那么此时磁盘中产生的索引树是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610162572296-97295d9c-ab7c-444b-a99a-6c8ea8f106eb-20210923151400366.png" alt="img"></p><p>这棵树的非叶子节点是user_name，叶子节点是id，<strong>也就是说从这棵树上我们只能得到user_name和user_id</strong>，至于user_age，MySQL底层只能跳出name索引树，然后跑到隔壁主键索引获取。整个过程被称为回表，而回表意味着多跑一趟。</p><p>此时我们可以给user_name和user_age加一个联合索引，这样就能产生所谓的“索引覆盖”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610162521710-d2586c99-f888-4db1-b713-3a69dc59028d-20210923151409810.png" alt="img"></p><p>当辅助索引上的字段完全满足本次查询的列时，就是所谓的索引覆盖，这是一个好消息，意味着不需要回表，查询效率将会大大提高。这也是为什么SQL优化原则中经常会强调：尽量只取必要的字段，避免SELECT *（提高索引覆盖的几率，查询的字段越多，几率越低）。</p><p>即使目前表中只有两个字段且已经索引覆盖，也不要写SELECT *。因为后期随着业务扩展，这张表会新增其他字段，此时SELECT *将不再覆盖索引！</p><p>为了方便记忆，大家可以把索引覆盖理解为 索引的字段 &gt;= 查询需要的字段。比如联合索引的字段是index(a,b,c)，那么此时SELCT a, b就会发生索引覆盖，索引覆盖最大的好处是避免回表。</p><p>需要强调的是，覆盖索引和联合索引没有必然关系。比如我只给user_name加单索引，而我查询语句是</p><p>SELECT id, user_name FROM t_user WHERE name=’bravo’;</p><p>此时也是索引覆盖。所以，<strong>能否索引覆盖不取决于索引单方面，需要查询配合。</strong></p><p>关于联合索引，我们放在下一篇介绍。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化(2)-索引与B+树</title>
    <link href="/2020/08/11/SQL%E4%BC%98%E5%8C%96-%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/"/>
    <url>/2020/08/11/SQL%E4%BC%98%E5%8C%96-%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>对于60%的程序员而言，Java的三层架构Controller、Service、Dao可以说是“越往后走天越黑”，特别是到了Dao层，提着灯笼也只能看到脚边一米开外的河边小石子，只闻对岸风啸马嘶却不知到底是人是鬼，只能借着MyBatis或JPA这些ORM框架隔着宽宽的河举行一场又一场的刺刀战，你砍我一刀，我刺你一剑。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589374354625-30b6de0f-8337-4db5-964b-6c6df7ae09ad-20210923150111295.png" alt="img"></p><p>诚然，很多人对MySQL数据库的印象就是一个模糊的大铁柜，闭上眼睛深吸一口气仿佛还能嗅到一股铁锈味。只知柜子里藏着很多张表，表里面存着很多行数据，再详细一点的呢？不知道。</p><p>MySQL有太多太多细节，根本无法用四、五篇文章说透，但我仍希望这个系列的文章能成为非常好的入门教程，让从来没接触过SQL优化的同学也能快速建立较为系统的知识框架，方便日后学习其他专栏时进一步拓展。</p><hr><h1 id="柏青哥"><a href="#柏青哥" class="headerlink" title="柏青哥"></a>柏青哥</h1><p>大家小时候在游戏厅看过下面这种机器吗：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589354675837-5eaba89f-fb57-4fdf-aa7e-80573ada61a6-20210923150439959.png" alt="img"></p><p>日本人管它叫柏青哥（パチンコ），玩法是：</p><p>从机器最上方的唯一入口投入一颗钢珠，由于重力的作用，钢珠会往下落。机器是直立的，面板上有很多突出的圆柱，它们的作用是随机改变钢珠的落点。最终，钢珠掉落在下方的某个槽中。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589355808319-788e3454-19ae-4c57-9707-b68edc99f05c-20210923150137448.png" alt="img"></p><p>这里提柏青哥，是为后面的B+树及分析B+树搜索过程做铺垫。到时你会发现，沿着索引树搜索的过程和柏青哥小钢珠的下落过程是多么相似！</p><p>很多人都听过数据库索引，但是很少人会去思考下面几个问题：</p><ul><li><p>索引是什么</p></li><li><p>为什么需要索引</p></li><li><p>索引怎么起作用</p></li></ul><p>在历史的长河中，索引的出现几乎是必然的。不信？那就跟我重走一遍历史吧。</p><p>请大家先忘了MySQL、Oracle等乱七八糟的玩意儿，就假设你是上世纪第一批程序员，此时连正儿八经的数据库都没有，需要由你来开天辟地。目前摆在你面前的最大难题是：如何较为<strong>高效地</strong>存取数据？</p><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p>最直观的想法就是存“格子”里，也就是将数据存在线性结构的容器中，比如数组或链表。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589356217794-f7c00e60-53e2-447d-a2b5-2c97d4726d0c-20210923150143937.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589357468320-10555c9b-b1f5-41a7-922d-73ea4f70c03c-20210923150149784.png" alt="img"></p><p>用线性结构存储数据<strong>短期</strong>看是没问题的，但是一家名为SUN的公司发现，随着公司业务增长，平台要经手的用户数据越来越多，特别是今年，他们收到了很多客户的信件投诉，说网页数据的加载越来越慢了！</p><p>SUN的工程师做了个实验，一个线性表如果存了42亿条数据，想要找到id=100的数据，游标只需爬99格即可返回，但如果id=10000000，就要爬将近1000w个格子才能返回。对于这42亿条数据，平均查询次数是21亿次！！</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>作为改进，有人提出用树结构来存储数据。比如，如果要找id=6的数据，那么只要比较3次，小于爬格子次数（5次）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358245965-f357a5d0-90fc-49e7-affe-8cfa11a2243d-20210923150156142.png" alt="img"></p><p>如果要找id=9的数据，只要比较4次，小于爬格子次数（8次）。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358394072-a5d5f642-25e5-4d01-ba52-ba7251609d4a-20210923150201825.png" alt="img"></p><p>结合两次实验，SUN的工程师发现：</p><p>在一棵树中找到目标数据所需的比较次数 = 目标数据所在的层级</p><p>如果用一棵树来存储42亿条数据，即232=42亿，树的层级是32，最差的情况也只要查32次（需要是二叉平衡树），远远小于线性结构的平均21亿次，这是非常夸张的。</p><p>注意，在线性结构的案例中，不是我故意不用二分查找，而是不能使用二分查找。一般来说，<strong>对于线性结构的数据集合，如果要使用二分查找，那么整个数据都要事先在内存中，</strong>但显然没人会这样做！相比在内存中对线性结构进行二分查找，树在逻辑上天然支持二分查找。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608365614192-1f7e343b-f3fc-4dd6-b4c7-90d64f7569d9-20210923150207584.png" alt="img"></p><p>然而，树结构也分好几种：</p><ul><li><p>Binary Search Tree（二叉查找树）</p></li><li><p>AVL Tree（二叉平衡树）</p></li><li><p>B Tree（平衡树）</p></li><li><p>B+ Tree（大名鼎鼎的B+树，对B Tree的改进）</p></li><li><p>…</p></li></ul><p>大家可以访问<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a>这个网站动手玩一下，特别注意上面的4种树：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589360823134-4c779906-c5d8-4ea4-ab72-47af54d8af3c-20210923150214447.png" alt="img"></p><p>如果你听我的建议，打开上面的网站选择Binary Search Tree并按1,2,3,4…的顺序插入数据时，<strong>它其实变成了线性结构：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358856443-e8032dc1-b241-4f23-9c43-883c36b3b25e-20210923150222903.png" alt="img"></p><p>显然，这不是我们想要的结果，因为刚才已经讨论过，线性结构不适合存储大数据，等后期数据量大了以后要爬很多“格子”。</p><h1 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h1><p>相比来说，AVL Tree更符合SUN工程师的需求：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358993173-e6bd2cc0-279a-4d98-8fdc-68abf82b2744-20210923150229048.png" alt="img"></p><p>二叉平衡树会在数据插入完毕后<strong>自动调整节点，好让“树的层级”不至于太深。（赶紧去动手玩一下）</strong></p><p>按理来说，如果我们按二叉平衡树组织表数据的话，应该是非常完美的。你想啊，42亿数据中找一条记录最多只需比较32次，尤其是对于CPU来说，<strong>别说32次比较，哪怕32w次简单数据的比较都不会超过0.1秒。</strong>但是！问题在于这里所谓的“32w次简单数据的比较不会超过0.1秒”有个前提条件：<strong>数据必须全部在内存中。</strong></p><p>而我们的表数据因为数据量很大，而且需要持久化，所以一般来说是存在磁盘中，等需要使用时再从磁盘载入内存，也就是涉及磁盘-内存的IO操作。</p><p>通常情况下，没有人会直接把500w行数据一次性加载到内存中进行二分查找，内存极有可能顶不住（同时访问多张表，全部加载）。所以，最终我们组织数据库的方式只能是：</p><ul><li><p>把数据存在磁盘中</p></li><li><p>数据按树结构组织</p></li><li><p>查询时分块读取数据并比较，持续进行磁盘IO读取节点，直到找到目标数据</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608365864685-03842132-d684-4a5b-9ca8-42ceb43181f7-20210923150235370.png" alt="img"></p><p>每一个节点存储“一小块数据”，分多次IO读取每一块数据到内存判断，直到找到匹配的数据。</p><h1 id="二叉平衡树与磁盘IO"><a href="#二叉平衡树与磁盘IO" class="headerlink" title="二叉平衡树与磁盘IO"></a>二叉平衡树与磁盘IO</h1><p>数据存在磁盘中，没问题。</p><p>数据桉树结构组织，没问题。</p><p><strong>查询时分块读取数据，有一点点问题。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589361951577-71cfd4b1-bfd8-44cc-a968-5de2d821fe2b-20210923150241680.png" alt="img"></p><p>磁盘IO是非常耗时的操作，耗时到什么程度呢？大家可能都听过各个语言的执行效率：</p><p>C &gt; C++ &gt; Java &gt;&gt; Python</p><p>但这些都是在内存层面谈论语言自身的执行效率，而实际上开发一个Web应用，无论用上述哪个语言，对于普通应用而言，都是可以满足用户需求的，真正的瓶颈是IO（网络IO和磁盘IO）。就好比F1赛车、奥迪A4和拖拉机一起跑在北京4环的路上，限制它们的不是引擎，而是堵车。</p><p>所以，二叉平衡树虽然查找42亿数据最多只需32次，但是32次磁盘IO还是不能接受的。</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>基于上面的分析，如果考虑磁盘IO，那么原本优秀的二叉平衡树将显得不再那么优秀。错的不是二叉平衡树，而是我们没有那么大的内存，也不方便把数据都放内存（考虑数据丢失与持久化）。</p><p>但现在不是考虑谁对谁错的时候，要想优化当前数据库，关键是减少磁盘IO次数，<strong>而影响IO次数的关键因素就是树的层级（深度）！</strong>举个例子，如果目标数据在第二层，那么只要比较到第二层，就找到目标数据直接返回，不用再继续磁盘IO读取下一个节点。而如果数据在32层，那么就需要进行32次磁盘IO，比较到最后一层的节点。</p><p>那么，如何减少树的层级呢（让树变矮）？</p><p>请大家思考一下232中的“2”指的是什么？</p><p>其实就是“二叉平衡树”的“二”，而指数32代表树的层级。也就是说，如果以二叉平衡树的结构组织42亿行数据，那么树的深度是32。如果是“三叉平衡树”呢？</p><p>3?? = 232 </p><p>3的指数大概为21。也就是说，如果用“三叉树”组织数据，那么层级将会减少到21，也就意味着磁盘IO次数最多为21次。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589362752238-4daa5676-b2c3-419f-9016-a3cf84bb057f-20210923150255800.png" alt="img"></p><p>所以，到这里我们已经有答案了：要想减少二叉平衡树的磁盘IO次数，需要增加它的“叉”，变成“N叉平衡树”，从而减少树的深度。</p><p>此时有位长者说了一句：你们心里没点B树吗。</p><p>听到这，SUN的工程师颇受启发：对哦，直接用B树就好了。</p><p>B树有个“阶”的概念，比如“三叉平衡”的B树其实叫“3阶B树”。</p><p>通过上面的图，我们会发现“N阶B树”<strong>每个节点可以存N-1个数据</strong>（二叉平衡树每个节点只存1个数据），且每个节点至多可以连接N个子节点。</p><p>这样组织的好处是，<strong>每次加载一个节点时都可以从磁盘带出更多条数据，从而减少磁盘IO的次数。</strong>比如原先比完id=3，接下来要和id=5比较，需要再从磁盘中把id=5的数据读出来。而现在当前节点已经有id=3,id=5的数据了，直接比较即可，无需做磁盘IO。</p><p>这是典型的“空间换时间”。</p><p>但B树最难的地方不是结构本身，而是如何实现这种结构，尤其是如何通过B树组织数据库的表数据？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589370021227-2ce244b2-e5de-4aeb-8a57-5cfb81109d80-20210923150305159.png" alt="img"></p><p>举个例子，当我要找id=7的数据时，需要先找到根节点，和id=4的节点比较，由于7&gt;4，所以选择右侧那一支，接着因为6&lt;7&lt;8，所以这个节点中三个addr选择中间的addr，顺着这个地址找到7的节点，然后取出数据。</p><p>需要注意的是，当一个节点被加载到内存后，这个节点内部的数据就可以通过二分查找得到啦，所以那么id=7去上图右边节点查找正确的addr是很快的。</p><p>上面只是演示了3阶B树，实际上1个节点可以存更多数据，做成N阶B树：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589370580691-8b9a4589-4f48-42cb-9daf-918ad3183d99-20210923150314176.png" alt="img"></p><p>分析到这里，历史的话剧就告一个段落，让我们看看MySQL索引的真正实现方式吧。</p><h1 id="B-树与索引"><a href="#B-树与索引" class="headerlink" title="B+树与索引"></a>B+树与索引</h1><p>实际上MySQL索引采用的是B+树，而不是B树。</p><p>为什么不用B树呢？</p><p>在操作系统中有个叫“页”的概念，是用来存储数据的一种单位，大小为4k。MySQL中也有“页”的概念，但大小为16k，你可以理解为MySQL中的“页”就是上面B树的一个个节点。</p><p>那么问题来了：你知道日常开发中，表中的一行数据大概占多少字节吗？</p><p>让我们来计算一下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589371147835-6bf74fd5-b52c-4abc-869a-88fd74c96e0a-20210923150326037.png" alt="img"></p><p>在上面这张表中，按每列数据类型推算，一行数据大概 8+150+150+150+150+9+2+9+750+5+5+8+8=1404字节，就算1k好了，因为节点最大size是16k，所以每个节点最多只能存16行数据。</p><p>我们之前之所以从二叉平衡树转为B树，是因为B树的每个节点可以存更多数据。但上面的计算告诉我们，其实也就是比二叉平衡树多了15条数据而已。</p><p>但原则是对的，为了尽可能使树“变矮”从而减少磁盘IO，最好的做法是让<strong>一个节点尽可能地塞入更多的数据。</strong></p><p>不过把整行数据塞到节点中，有点太浪费了，我们其实可以<strong>把每一行数据的主键存进去。</strong>即使用bigint类型做主键，一个主键也就8个字节。假设每个主键对应一个addr（指针），MySQL中一个指针为6个字节，那么节点内每个主键-地址这样形式的数据能存16*1024/14=1170个。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589376951699-3f01f932-8684-414e-8dcb-2c0573837744-20210923150332743.png" alt="img"></p><p>这其实就是B+树对B树的改造。</p><p><strong>所谓的B+树，就是把原先B树中分散在各个节点的数据都“赶到”最底层的叶子节点，非叶子节点只存储主键-addr形式的数据：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589372895183-3540a1e5-82ba-4d3d-9dca-252f95007eee-20210923150338523.png" alt="img"></p><p>最终，一棵3层的B+树，最底下的叶子节点总共能存2000w条数据。</p><p>有部分同学可能还是不明白B+树为什么比B树能存储更多数据，这里再举个最极端的例子，假设一行表数据8k，而一个节点容量是16k，如果是B Tree，那么一个节点只能存两行数据，最终每个节点只能“夹带”3个addr，只能指向3个子节点：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589377482590-ca616c4f-89de-4de2-b459-1b7ef408a5ff-20210923150345350.png" alt="img"></p><p>但如果是B+ Tree，只存主键：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589377712338-9f1bfde7-bce8-4ecb-a9a0-27d1a5670b67-20210923150352723.png" alt="img"></p><p>那么最上面的节点可以存更多的主键，指向更多的下级节点，就有更多的“16k数据”。上面还只是分析单个节点的情况，如果放眼整棵索引树，最终叶子节点会多很多很多的“16k数据”。</p><p>从MySQL学习者的角度而言，我们只需要知道B+树2个很重要的特征：</p><ul><li>非叶子节点不存数据</li><li>叶子节点数据用链表相连</li></ul><p>所以更详细的版本是：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589448311743-b494fa66-02d0-43b8-ab9f-f920caec8af2-20210923150358426.png" alt="img"></p><p>叶子节点是有序链表，可以帮助做范围查询。</p><p>最后，还有个问题，如果我不提估计很少有人会考虑：B+树如何查找数据。</p><p>为什么会有这个疑问呢？</p><p>之前说过，B数的节点存了完整的数据，假设数据总共3层，而你要找的数据在第2层的某个节点，当你找到后便可以直接返回整行数据。而B+树为了一个节点能存入更多的addr，节点内部只存了主键id，所以即使你在第二层找到匹配的id，还是不能直接返回，必须继续往下，直到在叶子节点读取完整数据。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589421184838-106cccdb-a84e-448f-8806-58e9dfa9b76e-20210923150406906.gif" alt="img"></p><p>讨论到这，我们来对比一下B树和B+树：</p><ul><li><p>B树的节点都会存储整行数据，占用空间大存储addr少，而B+树的非叶子节点只存储主键，能容纳更多addr</p></li><li><p>由于非叶子节点能容纳更多addr，那么同一个节点能指向更多下级节点，所以相同数据量时，B+树通常更加“矮”，IO更少</p></li><li><p>B树的查询效率是不稳定的，最好情况是根节点，最差情况是叶子节点，而B+树是稳定的，每次都要查询到叶子节点</p></li><li><p>B+树的叶子节点是有序列表，非常便于范围查询</p></li></ul><p>对于第三点，很多人可能觉得B+树每次都是稳定地查询叶子节点，还不如B树（最好情况根节点就返回了）。其实上面分析过了，B+树每个节点能存储的数据是B树的1170/16≈73倍，意味着B+树每个节点可以连接的分支更多，相同数据量的情况下，B+树远远矮于B树。比如B树的查询IO次数是1~100，而B+树恒定为3，你觉得哪个效率高？</p><p>回头看看柏青哥，钢珠掉落的过程是不是很像沿着索引查找数据呢~</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589373836878-c32bc126-fc73-48e4-ae95-d7e23ccf77c8-20210923150420395.png" alt="img"></p><p>学到这里，相信Dao层的对岸到底是什么，大家心里已经有B+树了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589374780467-c8dbebf7-eb2e-418b-8536-cc90aea27b37-20210923150427648.png" alt="img"></p><p>至此，我们回过头来给索引下个定义：</p><p><strong>索引是一种数据结构，</strong>用于高效搜索目标数据，在MySQL中具体实现为B+树（InnoDB引擎）。</p><p>最后说一句，没有所谓的“B减树”，很多人可能看到B树的英文表示法是”B-Tree”，误读为“B减树”。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UDP&amp;TCP</title>
    <link href="/2020/07/29/UDP%20&amp;%20TCP%20/"/>
    <url>/2020/07/29/UDP%20&amp;%20TCP%20/</url>
    
    <content type="html"><![CDATA[<p>讲解 TCP 三次握手和四次握手之前，我们先了解一下 TCP 和 UDP 这两个重量级的传输层协议。</p><p>💦 <strong>用户数据报协议 UDP</strong>（User Datagram Protocol）：</p><ul><li><strong>UDP 在传送数据之前不需要先建立连接</strong>，远程主机在收到 UDP 报文后，不需要给出任何确认。</li><li>虽然 UDP <strong>不提供可靠交付</strong>，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等</li></ul><p>💦 <strong>传输控制协议 TCP</strong>（Transmission Control Protocol）：</p><ul><li>TCP 提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 不提供广播或多播服务。由于 TCP 要提供<strong>可靠</strong>的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</li><li>TCP <strong>一般用于文件传输、发送和接收邮件、远程登录等场景</strong>。</li></ul><h2 id="2-TCP-报文段首部格式"><a href="#2-TCP-报文段首部格式" class="headerlink" title="2. TCP 报文段首部格式"></a>2. TCP 报文段首部格式</h2><p>TCP 报文段的具体格式大家可以不必都记住，但是其中的几个<strong>控制位</strong>与我们接下来要讲的三次握手和四次挥手息息相关，大家一定要牢记。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144029349" alt="图片"></p><p>首部固定部分各字段意义如下：</p><ul><li><p>1 - <strong>源端口和目的端口</strong>：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址</p></li><li><p>2 - <strong>序号/序列号</strong>（Sequense Number，SN）：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。<strong>初始序号称为 Init Sequense Number, ISN</strong>（序号/序列号这个字段很重要，大家留个印象，下文会详细讲解）</p><p>例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。</p></li><li><p>3 - <strong>确认号 ack</strong>：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。</p></li><li><p>4 - <strong>数据偏移</strong>（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。</p></li><li><p>5 - <strong>保留</strong>：占 6 位，应置为 0，保留为今后使用。</p></li></ul><p>⭐ 大家看上图，保留位的右边还有 6 个控制位（重要），这是TCP 用来说明该报文段性质的：</p><ul><li><p><strong>紧急位 URG</strong>：当 URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。该控制位需配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）</p><p>举个例子：我们需要取消一个已经发送了很长程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这个指令将存储在接收 TCP 的缓存末尾，只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程，这样做就无法实现立即中断。</p></li><li><p><strong>确认 ACK</strong>：仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</p></li><li><p><strong>推送 PSH</strong>：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。</p></li><li><p><strong>复位 RST</strong>：当 RST = 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。</p></li><li><p><strong>同步 SYN</strong>：SYN = 1 表示这是一个连接请求或连接接受报文。</p><p>当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 且 ACK = 1。</p></li><li><p><strong>终止 FIN</strong>：用来释放一个连接。当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p></li></ul><h2 id="3-TCP-三次握手建立连接"><a href="#3-TCP-三次握手建立连接" class="headerlink" title="3. TCP 三次握手建立连接"></a>3. TCP 三次握手建立连接</h2><h3 id="①-三次握手过程详解"><a href="#①-三次握手过程详解" class="headerlink" title="① 三次握手过程详解"></a>① 三次握手过程详解</h3><p>三次握手的原文是 <code>three-way handshake</code>，整个名词的可以翻译为：<strong>需要三个步骤才能建立握手/连接的机制</strong>。当然，三次握手也可以叫 <code>three-message handshake</code>，通过三条消息来建立的握手/连接。</p><p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的 <strong>初始化序列号(Init Sequense Number,  <code>ISN</code>)</strong> 为后面的可靠性传输做准备。</p><p>三次握手过程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144034490" alt="图片"></p><p>回顾一下图中字符的含义：</p><ul><li><code>SYN</code>：连接请求/接收 报文段</li><li><code>seq</code>：发送的第一个字节的序号</li><li><code>ACK</code>：确认报文段</li><li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p><strong>刚开始客户端处于 <code>Closed</code> 的状态，而服务端处于 <code>Listen</code> 状态</strong>：</p><blockquote><p><code>CLOSED</code>：没有任何连接状态</p><p><code>LISTEN</code>：侦听来自远方 TCP 端口的连接请求</p></blockquote><p><strong>1）第一次握手</strong>：客户端向服务端发送一个 SYN 报文（SYN = 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq = x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 <code>SYN_Send</code> 状态。</p><blockquote><p><code>SYN-SENT</code> ：在发送连接请求后等待匹配的连接请求</p></blockquote><p><strong>2）第二次握手</strong>：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN = 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq = y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 <code>SYN_REVD</code> 的状态。</p><blockquote><p><code>SYN-RECEIVED</code>：在收到和发送一个连接请求后等待对连接请求的确认</p></blockquote><p><strong>3）第三次握手</strong>：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 <code>Establised</code> 状态。</p><p>服务器收到 ACK 报文之后，也处于 <code>Establised 状态</code>，至此，双方建立起了 TCP 连接。</p><blockquote><p><code>ESTABLISHED</code>：代表一个打开的连接，数据可以传送给用户</p></blockquote><h3 id="②-为什么要三次握手"><a href="#②-为什么要三次握手" class="headerlink" title="② 为什么要三次握手"></a>② 为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的</strong>。</p><p>只有经过三次握手才能确认双发的收发功能都正常，缺一不可：</p><ul><li><p>第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常</p></li><li><p>第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：</p><p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p><p>服务器确认了：对方发送正常，自己接收正常</p></li><li><p>第三次握手（客户端发送 ACK 报文给服务器）：</p><p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p><p>服务器确认了：自己发送、接收正常，对方发送、接收正常</p></li></ul><h3 id="③-ISN-Initial-Sequence-Number-是固定的吗"><a href="#③-ISN-Initial-Sequence-Number-是固定的吗" class="headerlink" title="③ ISN (Initial Sequence Number) 是固定的吗"></a>③ ISN (Initial Sequence Number) 是固定的吗</h3><p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据</strong>。</p><p>当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。<strong>如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的</strong>。</p><h3 id="④-三次握手过程中可以携带数据吗"><a href="#④-三次握手过程中可以携带数据吗" class="headerlink" title="④ 三次握手过程中可以携带数据吗"></a>④ 三次握手过程中可以携带数据吗</h3><p>第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手绝对不可以携带数据</strong></p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>⭐ <strong>简单的记忆就是，请求连接/接收 即 <code>SYN = 1</code> 的时候不能携带数据</strong></p><p>而对于第三次的话，此时客户端已经处于 <code>ESTABLISHED</code> 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。</p><h3 id="⑤-半连接队列"><a href="#⑤-半连接队列" class="headerlink" title="⑤ 半连接队列"></a>⑤ 半连接队列</h3><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code> 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>当然还有一个<strong>全连接队列</strong>，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><h3 id="⑥-SYN-洪泛攻击"><a href="#⑥-SYN-洪泛攻击" class="headerlink" title="⑥ SYN 洪泛攻击"></a>⑥ SYN 洪泛攻击</h3><p>SYN 攻击就是 <strong>Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包</strong>，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</p><h3 id="⑦-如果第三次握手丢失了，客户端服务端会如何处理"><a href="#⑦-如果第三次握手丢失了，客户端服务端会如何处理" class="headerlink" title="⑦ 如果第三次握手丢失了，客户端服务端会如何处理"></a>⑦ 如果第三次握手丢失了，客户端服务端会如何处理</h3><p>服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><h2 id="4-TCP-四次挥手释放连接"><a href="#4-TCP-四次挥手释放连接" class="headerlink" title="4. TCP 四次挥手释放连接"></a>4. TCP 四次挥手释放连接</h2><h3 id="①-四次挥手过程详解"><a href="#①-四次挥手过程详解" class="headerlink" title="① 四次挥手过程详解"></a>① 四次挥手过程详解</h3><p>建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的<strong>半关闭</strong>（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 连接的释放需要发送四个包（执行四个步骤），因此称为四次挥手(<code>Four-way handshake</code>)，<strong>客户端或服务端均可主动发起挥手动作</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144040116" alt="图片"></p><p>回顾一下上图中符号的意思：</p><ul><li><code>FIN</code> ：连接终止位</li><li><code>seq</code>：发送的第一个字节的序号</li><li><code>ACK</code>：确认报文段</li><li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p>刚开始双方都处于<code>ESTABLISHED</code> 状态，假设是客户端先发起关闭请求。四次挥手的过程如下：</p><p><strong>1）第一次挥手</strong>：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并<strong>停止再发送数据，主动关闭 TCP 连接</strong>。此时客户端处于 <code>FIN_WAIT1</code> 状态，等待服务端的确认。</p><blockquote><p><code>FIN-WAIT-1</code> - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></blockquote><p><strong>2）第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。</p><blockquote><p><code>CLOSE-WAIT</code> - 等待从本地用户发来的连接中断请求；</p></blockquote><p><strong>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放</strong>。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待 2）状态，等待服务端发出的连接释放报文段。</p><blockquote><p><code>FIN-WAIT-2</code> - 从远程TCP等待连接中断请求；</p></blockquote><p><strong>3）第三次挥手</strong>：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态，等待客户端的确认。</p><blockquote><p><code>LAST-ACK</code> - 等待原来发向远程TCP的连接中断请求的确认；</p></blockquote><p><strong>4）第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 <strong><code>TIME_WAIT</code> （时间等待）状态</strong>。</p><blockquote><p><code>TIME-WAIT</code> - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></blockquote><p>🚨 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，<strong>需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 <code>CLOSED</code> 状态</strong>（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 <code>CLOSED</code> 状态。</p><h3 id="②-为什么要四次挥手"><a href="#②-为什么要四次挥手" class="headerlink" title="② 为什么要四次挥手"></a>② 为什么要四次挥手</h3><p>由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就<strong>完全关闭</strong>了TCP连接。</p><p><strong>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手</strong>。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Communication protocol</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双亲委派机制</title>
    <link href="/2020/06/15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/06/15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在介绍双亲委派机制的时候，不得不提ClassLoader（类加载器）。说ClassLoader之前，我们得先了解下Java的基本知识。<br>  Java是运行在Java的虚拟机(JVM)中的，但是它是如何运行在JVM中了呢？我们在IDE中编写的Java源代码被编译器编译成.class的字节码文件。然后由我们得ClassLoader负责将这些class文件给加载到JVM中去执行。<br>  JVM中提供了三层的ClassLoader：</p><p>Bootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader。</p><p>ExtClassLoader：主要负责加载jre/lib/ext目录下的一些扩展的jar。</p><p>AppClassLoader：主要负责加载应用程序的主函数类</p><p>那如果有一个我们写的Hello.java编译成的Hello.class文件，它是如何被加载到JVM中的呢？别着急，请继续往下看。</p><p>双亲委派机制</p><p>我打开了我的AndroidStudio，搜索了下“ClassLoader”,然后打开“java.lang”包下的ClassLoader类。然后将代码翻到loadClass方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-keyword">false</span>);<br>&#125;<br><span class="hljs-comment">//              -----??-----</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>        <span class="hljs-comment">// 首先，检查是否已经被类加载器加载过</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 存在父加载器，递归的交由父加载器</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 直到最上面的Bootstrap类加载器</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br> <br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这段代码已经很好的解释了双亲委派机制，为了大家更容易理解，我做了一张图来描述一下上面这段代码的流程：  </p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70.png"></p><p>从上图中我们就更容易理解了，当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。那么有人就有下面这种疑问了？</p><p>为什么要设计这种机制</p><p>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。</p><p>总结了一张脑图如下：</p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70-20210719110251508.png" style="zoom:200%;" />]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis哨兵模式</title>
    <link href="/2020/05/22/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/22/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p><h3 id="一、哨兵模式概述"><a href="#一、哨兵模式概述" class="headerlink" title="一、哨兵模式概述"></a>一、哨兵模式概述</h3><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/sen1.png"></p><p>这里的哨兵有两个作用</p><ul><li><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</p></li><li><p>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</p></li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p>用文字描述一下<strong>故障切换（failover）</strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><hr><h3 id="二、Redis配置哨兵模式"><a href="#二、Redis配置哨兵模式" class="headerlink" title="二、Redis配置哨兵模式"></a>二、Redis配置哨兵模式</h3><p>配置3个哨兵和1主2从的Redis服务器来演示这个过程。</p><p>| 服务类型  |是否是主服务器 |ip地址| 端口|<br>| :——— | :———— | :———— | :———— | :———— |<br>|redis|是|192.168.11.128|6379|<br>|redis|否|192.168.11.129|6379|<br>|redis|否|192.168.11.130|6379|<br>|sentinel|-|192.168.11.128|26379|<br>|sentinel|-|192.168.11.129|26379|<br>|sentinel|-|192.168.11.130|26379|</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/sen2.png"></p><p>首先配置Redis的主从服务器，修改redis.conf文件如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 使得Redis服务器可以跨网络访问<br>bind 0.0.0.0<br># 设置密码<br>requirepass &quot;123456&quot;<br># 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置<br>slaveof 192.168.11.128 6379<br># 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置<br>masterauth 123456<br></code></pre></td></tr></table></figure><p>上述内容主要是配置Redis服务器，从服务器比主服务器多一个slaveof的配置和密码。</p><p>配置3个哨兵，每个哨兵的配置都是一样的。在Redis安装目录下有一个sentinel.conf文件，copy一份进行修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 禁止保护模式<br>protected-mode no<br># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。<br>sentinel monitor mymaster 192.168.11.128 6379 2<br># sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码<br># sentinel auth-pass <span class="hljs-tag">&lt;<span class="hljs-name">master-name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br>sentinel auth-pass mymaster 123456<br></code></pre></td></tr></table></figure><p>上述关闭了保护模式，便于测试。</p><p>有了上述的修改，我们可以进入Redis的安装目录的src目录，通过下面的命令启动服务器和哨兵</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 启动Redis服务器进程<br>./redis-server ../redis.conf<br># 启动哨兵进程<br>./redis-sentinel ../sentinel.conf<br></code></pre></td></tr></table></figure><p>注意启动的顺序。首先是主机（192.168.11.128）的Redis服务进程，然后启动从机的服务进程，最后启动3个哨兵的服务进程。</p><hr><h3 id="三、Java中使用哨兵模式"><a href="#三、Java中使用哨兵模式" class="headerlink" title="三、Java中使用哨兵模式"></a>三、Java中使用哨兵模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试Redis哨兵模式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSentinels</span> </span>&#123;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;resource&quot;)</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSentinel</span><span class="hljs-params">()</span> </span>&#123;<br>        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>);<br>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>);<br>        jedisPoolConfig.setMinIdle(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 哨兵信息</span><br>        Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;192.168.11.128:26379&quot;</span>,<br>                <span class="hljs-string">&quot;192.168.11.129:26379&quot;</span>,<span class="hljs-string">&quot;192.168.11.130:26379&quot;</span>));<br>        <span class="hljs-comment">// 创建连接池</span><br>        JedisSentinelPool pool = <span class="hljs-keyword">new</span> JedisSentinelPool(<span class="hljs-string">&quot;mymaster&quot;</span>, sentinels,jedisPoolConfig,<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">// 获取客户端</span><br>        Jedis jedis = pool.getResource();<br>        <span class="hljs-comment">// 执行两个命令</span><br>        jedis.set(<span class="hljs-string">&quot;mykey&quot;</span>, <span class="hljs-string">&quot;myvalue&quot;</span>);<br>        String value = jedis.get(<span class="hljs-string">&quot;mykey&quot;</span>);<br>        System.out.println(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是通过Jedis进行使用的，同样也可以使用Spring进行配置RedisTemplate使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;poolConfig&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 最大空闲数 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 最大连接数 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxTotal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 最大等待时间 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxWaitMillis&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;connectionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolConfig&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;poolConfig&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sentinelConfig&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sentinelConfig&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-comment">&lt;!-- JDK序列化器 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdkSerializationRedisSerializer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-comment">&lt;!-- String序列化器 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stringRedisSerializer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;redisTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connectionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;connectionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keySerializer&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stringRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultSerializer&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stringRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;valueSerializer&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jdkSerializationRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-comment">&lt;!-- 哨兵配置 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sentinelConfig&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisSentinelConfiguration&quot;</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 服务名称 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;master&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mymaster&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 哨兵服务IP和端口 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sentinels&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;192.168.11.128&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26379&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;192.168.11.129&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26379&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;192.168.11.130&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26379&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="四、哨兵模式的其他配置项"><a href="#四、哨兵模式的其他配置项" class="headerlink" title="四、哨兵模式的其他配置项"></a>四、哨兵模式的其他配置项</h3><table><thead><tr><th align="left">配置项</th><th align="left">参数类型</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">port</td><td align="left">整数</td><td align="left">启动哨兵进程端口</td></tr><tr><td align="left">dir</td><td align="left">文件夹目录</td><td align="left">哨兵进程服务临时文件夹，默认为/tmp，要保证有可写入的权限</td></tr><tr><td align="left">sentinel down-after-milliseconds</td><td align="left">&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td align="left">指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）</td></tr><tr><td align="left">sentinel parallel-syncs</td><td align="left">&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td><td align="left">指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高</td></tr><tr><td align="left">sentinel failover-timeout</td><td align="left">&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td align="left">指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟</td></tr><tr><td align="left">sentinel notification-script</td><td align="left">&lt;服务名称&gt;&lt;脚本路径&gt;</td><td align="left">指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，比较常用</td></tr></tbody></table><p>sentinel down-after-milliseconds配置项只是一个哨兵在超过规定时间依旧没有得到响应后，会自己认为主机不可用。对于其他哨兵而言，并不是这样认为。哨兵会记录这个消息，当拥有认为主观下线的哨兵达到sentinel monitor所配置的数量时，就会发起一次投票，进行failover，此时哨兵会重写Redis的哨兵配置文件，以适应新场景的需要。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>redis</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis常用命令</title>
    <link href="/2020/05/21/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/05/21/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://1drv.ms/u/s!AuIKtprkDa8kjCfpQcXgXISfDleN?e=jKW0qf">课件地址</a>      <a href="http://redisdoc.com/">redis命令大全</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-server /配置文件位置     #启动redis <br>redis-cli -p 6379     #切换到redis控制台 redis默认端口 6379<br>redis-cli shutdown   #单实例关闭<br>redis-cli -p 6379 shutdown    #多实例关闭，指定端口关闭<br>select db #切换到该数据库 0 - 15 <br>dbsize #查看当前库key的数量<br>flushdb #清空当当前库<br>flushall #清空16个库 慎用！<br></code></pre></td></tr></table></figure><h2 id="Redis-键（key）"><a href="#Redis-键（key）" class="headerlink" title="Redis 键（key）"></a><strong>Redis 键（key）</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">keys *  #查看所有keys <br>exists key  #判断key是否存在<br>move key db  #将key移动到db  当前库就没有了<br>expire key second  # 为key设置过期时间 单位秒<br>ttl key  #查看该key 还有多少秒过期  -1表示永不过期   -2表示已过期（过期后该key被移除）<br>type key #查看该key类型<br>del key #删除该key<br></code></pre></td></tr></table></figure><h2 id="Redis-String"><a href="#Redis-String" class="headerlink" title="Redis String"></a><strong>Redis String</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">set key #设置该key的value<br>get key #获取该key的value<br>del key #删除该key<br>append key value #在该key后面添加value<br>strlen key #获取该key长度<br>incr key  #该key的值 加1  该key的值必须是数字 <br>decr key  #该key的值 减1  该key的值必须是数字 <br>incrby key num # 该key的值加 num 该key的值必须是数字 <br>decrby key num # 该key的值减 num 该key的值必须是数字 <br>getrange key start end # 获取start和end区间的值， 0  -1 为获取全部<br>setrange key offset value  # 设置该key从offset开始的值为value <br>setex key second value # set with expire 设置该key的值为value 存活时间为second <br>setnx key value # set if not exist 如果该key不存在，设置该key的值为value<br>mset key value key value ...  #一次存入多个键值对<br>mget key key key ... #一次取出多个key的value<br>msetnx key value key value # 一次存入多个键值对  key必须是未存在#个key已存在，则整个命令失败<br></code></pre></td></tr></table></figure><h2 id="Redis-List-列表-有序可重"><a href="#Redis-List-列表-有序可重" class="headerlink" title="Redis List(列表  有序可重)"></a><strong>Redis List</strong>(列表  有序可重)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">lpush key value value value  # 存入一个list value之间用空格分开 往左端加 若key已存在 则添加元素<br>rpush key value value value  # 存入一个list value之间用空格分开 往右端加 若key已存在 则添加元素<br>lrange key statr stop  # 取出key中value 从start开始 stop结束  0 -1 表示取出全部<br>lpop key  # 从该key的list左边 单次出栈<br>rpop key  # 从该key的lits右边 单次出栈<br>lindex key index # 按index获取list中的值 从0开始 <br>llen key  # 获取该key的list的长度<br>lrem key count value  #删除该key的list中count个值为value的元素<br>ltrim key start stop  #截取key的list中 从start 到 stop的元素 ，重新赋值给key<br>rpoplpush source destination  # 获取source最右端元素，移动到destination最左端 <br>lset key index value  # 将该key的list的第index位元素的值设置为value<br>linsert key before|after pivot value #在key对应的list的  pivot元素前(befroe)或后(after)  插入值为value的元素<br><span class="hljs-meta"> </span><br><span class="hljs-meta">#</span><span class="bash"> REDIS LIST是一个字符串了链表，left、right都可以插入添加</span><br><span class="hljs-meta">#</span><span class="bash"> 如果键不存在，创建新的链表</span> <br><span class="hljs-meta">#</span><span class="bash"> 如果键已存在，新增内容 lpush往左端加 rpush往右端加</span><br><span class="hljs-meta">#</span><span class="bash"> 如果值全部移除，对应的键也就消失了</span><br><span class="hljs-meta">#</span><span class="bash"> 链表的操作 头尾效率都极高 ，但是对中间元素操作的效率很惨淡</span><br><br></code></pre></td></tr></table></figure><h2 id="Redis-Set-集合-无序不可重"><a href="#Redis-Set-集合-无序不可重" class="headerlink" title="Redis Set(集合  无序不可重)"></a><strong>Redis Set(集合  无序不可重)</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">sadd key member member .. # 添加键为key 值为member 的set  若key已存在 则添加元素  元素不能重复 <br>smembers key # 查看该key的所有元素<br>sismember key member # 产看该key中是否有member元素 有返回 1 无返回 0<br>scard key #获取集合里的元素个数<br>srem key value #删除key对应的集合中值为value的元素<br>srandmember key count #从key集合中随机获取count个元素<br>spop key  #从key集合中随机出栈1个元素<br>smove key1 key2 key1中某个值    # 将key1中的某个值赋给key2<br>sdiff key1 key2   # 已key1为全集 求key2相对key1的差集<br>sinter key1 key2  # 求key1 key2的交集 <br>sunion key1 key2  # 求key1 key2的并集 （自动去重）<br></code></pre></td></tr></table></figure><h2 id="Redis-Hash-hash的value是以键值对的形式存储的-key-value-key-value"><a href="#Redis-Hash-hash的value是以键值对的形式存储的-key-value-key-value" class="headerlink" title="Redis Hash(hash的value是以键值对的形式存储的    key  value(key  value)  )"></a><strong>Redis Hash</strong>(hash的value是以键值对的形式存储的    key  value(key  value)  )</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">hset key Vkey Vvalue   #添加键为key 值为Vkey Vvalue 的hash （ hash的格式为 key value(key value) ）<br>hget key Vkey  #获取键为key的hash的 value key 为Vkey的 value<br>hmset key Vkey Vvalue Vkey Vvalue ...  # 添加键为key的hash的 多个value <br>hmget key Vkey Vkey Vkey ...  #获取键为key的hash的多个value的 valueKey为Vkey的 value<br>hgetall key  #获取键为key的hash的所有value （键值对形式）<br>hdel key Vkey  #删除键为key的hash的value的 键为Vkey的 value <br>hlen key  #获取键为key的hash的长度 <br>hexists key Vkey  #判断键为key的hash中是否存在 键为Vkey的 value 存在返回1 不存在返回0<br>hkeys key  #获取键为key的 hash中 所有value的 key<br>hvals key #获取键为key的hash中 所有value 的value<br>hincrby key Vkey num   # 给key对应的value的 value key所对应的 value value 加num（整数）（Vkey对应的value必须数integer）<br>hincrbyfloat key Vkey float   # 给key对应的value的 value key所对应的 value value 加float （小数）<br>hsetnx key Vkey Vvalue   #给key对应的hash数据添加新的value键值对 （Vkey Vvalue） Vkey不能已存在<br></code></pre></td></tr></table></figure><h2 id="Redis-Zset-sorted-set-有序不可重集合"><a href="#Redis-Zset-sorted-set-有序不可重集合" class="headerlink" title="Redis Zset (sorted set) 有序不可重集合"></a><strong>Redis Zset (sorted set)</strong> 有序不可重集合</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在<span class="hljs-built_in">set</span>基础上，加一个score值。<span class="hljs-built_in">set</span>是k1 v1 v2 v3， zset是k1 score1 v1 score2 v2</span><br>zadd key score value score value ....  #添加键为key 索引为score 值为value的Zset数据 <br>zrange key min max  #获取min max闭区间内该key对应的所有value (min 和 max 为value对应的下标 从0开始) 0 -1表示全部<br>zrangebyscore key startScore stopScore  #获取 startScore stopScore闭区间内该key对应的所有value<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 在命令最后加上 withscores可以显示每个vvalue对应的score</span></span> <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 在startScore 或是 stopScore前加 &quot;(&quot; 表示开区间  如 startScore (stopScore 等于 [startScore stopScore) ，&quot;(&quot;后的索引对应的value将被排除在结果中</span></span> <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># stopScore为 &quot;+inf&quot; 表示获取 startScore到 end 闭区间内的所有value</span></span><br>zrangebyscore key startScore stopScore limit start step #分页显示[startScope stopScore]内结果集，start为开始索引 step为步进 <br>zrem key value  #删除该key对应的zset集合中的对应value<br>zcard key #获取该集合中的元素个数<br>zcount key startScore stopScore #获取 [startScope stopScore] 闭区间内元素个数<br>zrank key value #获取该value在该集合中的下标 (0开始)<br>zscore key value #获取该value在该集合下对应的score<br>zrevrank key value #获取该value在该集合中的逆下标 <br>zrevrange key min max # #逆序获取min max闭区间内该key对应的所有value(min 和 max 为value对应的下标 从0开始)  0 -1表示全部<br>zrevrangebyscore key stopScore startScore #获取  stopScore startScore 闭区间内的所有value <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>redis</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis笔记</title>
    <link href="/2020/05/21/Redis/"/>
    <url>/2020/05/21/Redis/</url>
    
    <content type="html"><![CDATA[<p>##<strong>Redis基本数据类型</strong></p><ol><li>字符串：redis没有直接使用C语言传统的字符串表示，而是自己实现的叫做简单动态字符串SDS的抽象类型。C语言的字符串不记录自身的长度信息，而SDS则保存了长度信息，这样将获取字符串长度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串长度时所需的内存重分配次数。</li><li>链表linkedlist：redis链表是一个双向无环链表结构，很多发布订阅、慢查询、监视器功能都是使用到了链表来实现，每个链表的节点由一个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。</li><li>字典hashtable：用于保存键值对的抽象数据结构。redis使用hash表作为底层实现，每个字典带有两个hash表，供平时使用和rehash时使用，hash表使用链地址法来解决键冲突，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对hash表进行扩容或者缩容的时候，为了服务的可用性，rehash的过程不是一次性完成的，而是渐进式的。</li><li>跳跃表skiplist：跳跃表是有序集合的底层实现之一，redis中在实现有序集合键和集群节点的内部结构中都是用到了跳跃表。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表信息（表头、表尾节点、长度等），zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1-32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。</li><li>整数集合intset：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</li><li>压缩列表ziplist：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li></ol><p>基于这些基础的数据结构，redis封装了自己的对象系统，包含字符串对象string、列表对象list、哈希对象hash、集合对象set、有序集合对象zset，每种对象都用到了至少一种基础的数据结构。</p><p>redis通过encoding属性设置对象的编码形式来提升灵活性和效率，基于不同的场景redis会自动做出优化。不同对象的编码如下：</p><ol><li>字符串对象string：int整数、embstr编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：ziplist、linkedlist</li><li>哈希对象hash：ziplist、hashtable</li><li>集合对象set：intset、hashtable</li><li>有序集合对象zset：ziplist、skiplist</li></ol><h2 id="Redis为什么快呢？"><a href="#Redis为什么快呢？" class="headerlink" title="Redis为什么快呢？"></a><strong>Redis为什么快呢？</strong></h2><p>redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几十倍。速度快的原因主要有几点：</p><ol><li>完全基于内存操作</li><li>C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高</li><li>使用单线程，无上下文的切换成本</li><li>基于非阻塞的IO多路复用机制</li></ol><h2 id="那为什么Redis6-0之后又改用多线程呢"><a href="#那为什么Redis6-0之后又改用多线程呢" class="headerlink" title="那为什么Redis6.0之后又改用多线程呢?"></a><strong>那为什么Redis6.0之后又改用多线程呢?</strong></h2><p>redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。</p><p>这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。</p><h2 id="什么是热key吗？热key问题怎么解决？"><a href="#什么是热key吗？热key问题怎么解决？" class="headerlink" title="什么是热key吗？热key问题怎么解决？"></a><strong>什么是热key吗？热key问题怎么解决？</strong></h2><p>所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/1.jpg"></p><p>针对热key的解决方案：</p><ol><li>提前把热key打散到不同的服务器，降低压力</li><li>加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询</li></ol><h2 id="什么是缓存击穿、缓存穿透、缓存雪崩？"><a href="#什么是缓存击穿、缓存穿透、缓存雪崩？" class="headerlink" title="什么是缓存击穿、缓存穿透、缓存雪崩？"></a><strong>什么是缓存击穿、缓存穿透、缓存雪崩？</strong></h2><p>###<strong>缓存击穿</strong></p><p>缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上，这个和热key的问题比较类似，只是说的点在于过期导致请求全部打到DB上而已。</p><p>解决方案：</p><ol><li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了。</li><li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/2.jpg"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h3><p>缓存穿透是指查询不存在缓存中的数据，每次请求都会打到DB，就像缓存不存在一样。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/3.jpg"></p><p>针对这个问题，加一层布隆过滤器。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。</p><p>这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。</p><p>显然，使用布隆过滤器之后会有一个问题就是误判，因为它本身是一个数组，可能会有多个值落到同一个位置，那么理论上来说只要我们的数组长度够长，误判的概率就会越低，这种问题就根据实际情况来就好了。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/4.jpg"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃，称为雪崩。雪崩和击穿、热key的问题不太一样的是，他是指大规模的缓存都过期失效了。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/5.jpg"></p><p>针对雪崩几个解决方案：</p><ol><li>针对不同key设置不同的过期时间，避免同时过期</li><li>限流，如果redis宕机，可以限流，避免同时刻大量请求打崩DB</li><li>二级缓存，同热key的方案。</li></ol><h2 id="Redis的过期策略有哪些？"><a href="#Redis的过期策略有哪些？" class="headerlink" title="Redis的过期策略有哪些？"></a><strong>Redis的过期策略有哪些？</strong></h2><p>redis主要有2种过期删除策略</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><strong>惰性删除</strong></h3><p>惰性删除指的是当我们查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/6.jpg"></p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a><strong>定期删除</strong></h3><p>定期删除指的是redis每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。</p><p>###<strong>那么定期+惰性都没有删除过期的key怎么办？</strong></p><p>假设redis每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存在redis里面无法被删除，这时候就会走到redis的内存淘汰机制。</p><ol><li>volatile-lru：从已设置过期时间的key中，移出最近最少使用的key进行淘汰</li><li>volatile-ttl：从已设置过期时间的key中，移出将要过期的key</li><li>volatile-random：从已设置过期时间的key中随机选择key淘汰</li><li>allkeys-lru：从key中选择最近最少使用的进行淘汰</li><li>allkeys-random：从key中随机选择key进行淘汰</li><li>noeviction：当内存达到阈值的时候，新写入操作报错</li></ol><p>##<strong>持久化方式有哪些？有什么区别？</strong></p><p>redis持久化方案分为RDB和AOF两种。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h3><p>RDB持久化可以手动执行也可以根据配置定期执行，它的作用是将某个时间点上的数据库状态保存到RDB文件中，RDB文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态。由于RDB文件是保存在硬盘上的，所以即使redis崩溃或者退出，只要RDB文件存在，就可以用它来恢复还原数据库的状态。</p><p>可以通过SAVE或者BGSAVE来生成RDB文件。</p><p>SAVE命令会阻塞redis进程，直到RDB文件生成完毕，在进程阻塞期间，redis不能处理任何命令请求，这显然是不合适的。</p><p>BGSAVE则是会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h3><p>AOF和RDB不同，AOF是通过保存redis服务器所执行的写命令来记录数据库状态的。</p><p>AOF通过追加、写入、同步三个步骤来实现持久化机制。</p><ol><li>当AOF持久化处于激活状态，服务器执行完写命令之后，写命令将会被追加append到aof_buf缓冲区的末尾</li><li>在服务器每结束一个事件循环之前，将会调用flushAppendOnlyFile函数决定是否要将aof_buf的内容保存到AOF文件中，可以通过配置appendfsync来决定。</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">always</span> <span class="hljs-string">##aof_buf内容写入并同步到AOF文件</span><br><span class="hljs-attr">everysec</span> <span class="hljs-string">##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步</span><br><span class="hljs-attr">no</span> <span class="hljs-string">##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定</span><br></code></pre></td></tr></table></figure><p>如果不设置，默认选项将会是everysec，因为always来说虽然最安全（只会丢失一次事件循环的写命令），但是性能较差，而everysec模式只不过会可能丢失1秒钟的数据，而no模式的效率和everysec相仿，但是会丢失上次同步AOF文件之后的所有写命令数据。</p><p>##<strong>怎么实现Redis的高可用？</strong></p><p>要想实现高可用，一台机器肯定是不够的，而redis要保证高可用，有2个可选方案。</p><p>###<strong>主从架构</strong></p><p>主从模式是最简单的实现高可用的方案，核心就是主从同步。主从同步的原理如下：</p><ol><li>slave发送sync命令到master</li><li>master收到sync之后，执行bgsave，生成RDB全量文件</li><li>master把slave的写命令记录到缓存</li><li>bgsave执行完毕之后，发送RDB文件到slave，slave执行</li><li>master发送缓存中的写命令到slave，slave执行</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/7.jpg"></p><p>这里我写的这个命令是sync，但是在redis2.8版本之后已经使用psync来替代sync了，原因是sync命令非常消耗系统资源，而psync的效率更高。</p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a><strong>哨兵</strong></h3><p>基于主从方案的缺点还是很明显的，假设master宕机，那么就不能写入数据，那么slave也就失去了作用，整个架构就不可用了，除非你手动切换，主要原因就是因为没有自动故障转移机制。而哨兵(sentinel)的功能比单纯的主从架构全面的多了，它具备自动故障转移、集群监控、消息通知等功能。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/8.jpg"></p><p>哨兵可以同时监视多个主从服务器，并且在被监视的master下线时，自动将某个slave提升为master，然后由新的master继续接收命令。整个过程如下：</p><ol><li>初始化sentinel，将普通的redis代码替换成sentinel专用代码</li><li>初始化masters字典和服务器信息，服务器信息主要保存ip:port，并记录实例的地址和ID</li><li>创建和master的两个连接，命令连接和订阅连接，并且订阅sentinel:hello频道</li><li>每隔10秒向master发送info命令，获取master和它下面所有slave的当前信息</li><li>当发现master有新的slave之后，sentinel和新的slave同样建立两个连接，同时每个10秒发送info命令，更新master信息</li><li>sentinel每隔1秒向所有服务器发送ping命令，如果某台服务器在配置的响应时间内连续返回无效回复，将会被标记为下线状态</li><li>选举出领头sentinel，领头sentinel需要半数以上的sentinel同意</li><li>领头sentinel从已下线的的master所有slave中挑选一个，将其转换为master</li><li>让所有的slave改为从新的master复制数据</li><li>将原来的master设置为新的master的从服务器，当原来master重新回复连接时，就变成了新master的从服务器</li></ol><p>sentinel会每隔1秒向所有实例（包括主从服务器和其他sentinel）发送ping命令，并且根据回复判断是否已经下线，这种方式叫做主观下线。当判断为主观下线时，就会向其他监视的sentinel询问，如果超过半数的投票认为已经是下线状态，则会标记为客观下线状态，同时触发故障转移。</p><h2 id="redis集群的原理"><a href="#redis集群的原理" class="headerlink" title="redis集群的原理"></a><strong>redis集群的原理</strong></h2><p>如果说依靠哨兵可以实现redis的高可用，如果还想在支持高并发同时容纳海量的数据，那就需要redis集群。redis集群是redis提供的分布式数据存储方案，集群通过数据分片sharding来进行数据的共享，同时提供复制和故障转移的功能。</p><p>###<strong>节点</strong></p><p>一个redis集群由多个节点node组成，而多个node之间通过cluster meet命令来进行连接，节点的握手过程：</p><ol><li>节点A收到客户端的cluster meet命令</li><li>A根据收到的IP地址和端口号，向B发送一条meet消息</li><li>节点B收到meet消息返回pong</li><li>A知道B收到了meet消息，返回一条ping消息，握手成功</li><li>最后，节点A将会通过gossip协议把节点B的信息传播给集群中的其他节点，其他节点也将和B进行握手</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/9.jpg"></p><h3 id="槽slot"><a href="#槽slot" class="headerlink" title="槽slot"></a><strong>槽slot</strong></h3><p>redis通过集群分片的形式来保存数据，整个集群数据库被分为16384个slot，集群中的每个节点可以处理0-16384个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有一个slot没有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。</p><p>slot是一个位数组，数组的长度是16384/8=2048，而数组的每一位用1表示被节点处理，0表示不处理，如图所示的话表示A节点处理0-7的slot。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/10.jpg"></p><p>当客户端向节点发送命令，如果刚好找到slot属于当前节点，那么节点就执行命令，反之，则会返回一个MOVED命令到客户端指引客户端转向正确的节点。（MOVED过程是自动的）</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/11.jpg"></p><p>如果增加或者移出节点，对于slot的重新分配也是非常方便的，redis提供了工具帮助实现slot的迁移，整个过程是完全在线的，不需要停止服务。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a><strong>故障转移</strong></h3><p>如果节点A向节点B发送ping消息，节点B没有在规定的时间内响应pong，那么节点A会标记节点B为pfail疑似下线状态，同时把B的状态通过消息的形式发送给其他节点，如果超过半数以上的节点都标记B为pfail状态，B就会被标记为fail下线状态，此时将会发生故障转移，优先从复制数据较多的从节点选择一个成为主节点，并且接管下线节点的slot，整个过程和哨兵非常类似，都是基于Raft协议做选举。</p><p>##<strong>Redis事务机制</strong></p><p>redis通过MULTI、EXEC、WATCH等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，并且在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。事务的执行过程如下：</p><ol><li>服务端收到客户端请求，事务以MULTI开始</li><li>如果客户端正处于事务状态，则会把事务放入队列同时返回给客户端QUEUED，反之则直接执行这个命令</li><li>当收到客户端EXEC命令时，WATCH命令监视整个事务中的key是否有被修改，如果有则返回空回复到客户端表示失败，否则redis会遍历整个事务队列，执行队列中保存的所有命令，最后返回结果给客户端</li></ol><p>WATCH的机制本身是一个CAS的机制，被监视的key会被保存到一个链表中，如果某个key被修改，那么REDIS_DIRTY_CAS标志将会被打开，这时服务器会拒绝执行事务。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>redis</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis分布式锁</title>
    <link href="/2020/03/04/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2020/03/04/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>这篇文章我想和你聊一聊，关于 Redis 分布式锁的「安全性」问题。</p><p>Redis 分布式锁的话题，很多文章已经写烂了，我为什么还要写这篇文章呢？</p><p>因为我发现网上 99% 的文章，并没有把这个问题真正讲清楚。导致很多读者看了很多文章，依旧云里雾里。例如下面这些问题，你能清晰地回答上来吗？</p><ul><li>基于 Redis 如何实现一个分布式锁？</li><li>Redis 分布式锁真的安全吗？</li><li>Redis 的 Redlock 有什么问题？一定安全吗？</li><li>业界争论 Redlock，到底在争论什么？哪种观点是对的？</li><li>分布式锁到底用 Redis 还是 Zookeeper？</li><li>实现一个有「容错性」的分布式锁，都需要考虑哪些问题？</li></ul><p>这篇文章，我就来把这些问题彻底讲清楚。</p><p>读完这篇文章，你不仅可以彻底了解分布式锁，还会对「分布式系统」有更加深刻的理解。</p><p><strong>文章有点长，但干货很多，希望你可以耐心读完。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101801037.png" alt="图片"></strong></p><h1 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h1><p>在开始讲分布式锁之前，有必要简单介绍一下，为什么需要分布式锁？</p><p>与分布式锁相对应的是「单机锁」，我们在写多线程程序时，避免同时操作一个共享变量产生数据问题，通常会使用一把锁来「互斥」，以保证共享变量的正确性，其使用范围是在「同一个进程」中。</p><p>如果换做是多个进程，需要同时操作一个共享资源，如何互斥呢？</p><p>例如，现在的业务应用通常都是微服务架构，这也意味着一个应用会部署多个进程，那这多个进程如果需要修改 MySQL 中的同一行记录时，为了避免操作乱序导致数据错误，此时，我们就需要引入「分布式锁」来解决这个问题了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101752919.png" alt="图片"></p><p>想要实现分布式锁，必须借助一个外部系统，所有进程都去这个系统上申请「加锁」。</p><p>而这个外部系统，必须要实现「互斥」的能力，即两个请求同时进来，只会给一个进程返回成功，另一个返回失败（或等待）。</p><p>这个外部系统，可以是 MySQL，也可以是 Redis 或 Zookeeper。但为了追求更好的性能，我们通常会选择使用 Redis 或 Zookeeper 来做。</p><p>下面我就以 Redis 为主线，由浅入深，带你深度剖析一下，分布式锁的各种「安全性」问题，帮你彻底理解分布式锁。</p><h1 id="分布式锁怎么实现？"><a href="#分布式锁怎么实现？" class="headerlink" title="分布式锁怎么实现？"></a>分布式锁怎么实现？</h1><p>我们从最简单的开始讲起。</p><p>想要实现分布式锁，必须要求 Redis 有「互斥」的能力，我们可以使用 SETNX 命令，这个命令表示<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists，即如果 key 不存在，才会设置它的值，否则什么也不做。</p><p>两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p><p>客户端 1 申请加锁，加锁成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; SETNX lock 1<br>(integer) 1     // 客户端1，加锁成功<br></code></pre></td></tr></table></figure><p>客户端 2 申请加锁，因为它后到达，加锁失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; SETNX lock 1<br>(integer) 0     // 客户端2，加锁失败<br></code></pre></td></tr></table></figure><p>此时，加锁成功的客户端，就可以去操作「共享资源」，例如，修改 MySQL 的某一行数据，或者调用一个 API 请求。</p><p>操作完成后，还要及时释放锁，给后来者让出操作共享资源的机会。如何释放锁呢？</p><p>也很简单，直接使用 DEL 命令删除这个 key 即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; DEL lock // 释放锁<br>(integer) 1<br></code></pre></td></tr></table></figure><p>这个逻辑非常简单，整体的路程就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101730050.png" alt="图片"></p><p>但是，它存在一个很大的问题，当客户端 1 拿到锁后，如果发生下面的场景，就会造成「死锁」：</p><ol><li>程序处理业务逻辑异常，没及时释放锁</li><li>进程挂了，没机会释放锁</li></ol><p>这时，这个客户端就会一直占用这个锁，而其它客户端就「永远」拿不到这把锁了。</p><p>怎么解决这个问题呢？</p><h1 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h1><p>我们很容易想到的方案是，在申请锁时，给这把锁设置一个「租期」。</p><p>在 Redis 中实现时，就是给这个 key 设置一个「过期时间」。这里我们假设，操作共享资源的时间不会超过 10s，那么在加锁时，给这个 key 设置 10s 过期即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs terminal">127.0.0.1:6379&gt; SETNX lock 1    // 加锁<br>(integer) 1<br>127.0.0.1:6379&gt; EXPIRE lock 10  // 10s后自动过期<br>(integer) 1<br></code></pre></td></tr></table></figure><p>这样一来，无论客户端是否异常，这个锁都可以在 10s 后被「自动释放」，其它客户端依旧可以拿到锁。</p><p>但这样真的没问题吗？</p><p>还是有问题。</p><p>现在的操作，加锁、设置过期是 2 条命令，有没有可能只执行了第一条，第二条却「来不及」执行的情况发生呢？例如：</p><ol><li>SETNX 执行成功，执行 EXPIRE 时由于网络问题，执行失败</li><li>SETNX 执行成功，Redis 异常宕机，EXPIRE 没有机会执行</li><li>SETNX 执行成功，客户端异常崩溃，EXPIRE 也没有机会执行</li></ol><p>总之，这两条命令不能保证是原子操作（一起成功），就有潜在的风险导致过期时间设置失败，依旧发生「死锁」问题。</p><p>怎么办？</p><p>在 Redis 2.6.12 版本之前，我们需要想尽办法，保证 SETNX 和 EXPIRE 原子性执行，还要考虑各种异常情况如何处理。</p><p>但在 Redis 2.6.12 之后，Redis 扩展了 SET 命令的参数，用这一条命令就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs terminal">// 一条命令保证原子性执行<br>127.0.0.1:6379&gt; SET lock 1 EX 10 NX<br>OK<br></code></pre></td></tr></table></figure><p>这样就解决了死锁问题，也比较简单。</p><p>我们再来看分析下，它还有什么问题？</p><p>试想这样一种场景：</p><ol><li>客户端 1 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源的时间，「超过」了锁的过期时间，锁被「自动释放」</li><li>客户端 2 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源完成，释放锁（但释放的是客户端 2 的锁）</li></ol><p>看到了么，这里存在两个严重的问题：</p><ol><li><strong>锁过期</strong>：客户端 1 操作共享资源耗时太久，导致锁被自动释放，之后被客户端 2 持有</li><li><strong>释放别人的锁</strong>：客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁</li></ol><p>导致这两个问题的原因是什么？我们一个个来看。</p><p><strong>第一个问题，可能是我们评估操作共享资源的时间不准确导致的。</strong></p><p>例如，操作共享资源的时间「最慢」可能需要 15s，而我们却只设置了 10s 过期，那这就存在锁提前过期的风险。</p><p>过期时间太短，那增大冗余时间，例如设置过期时间为 20s，这样总可以了吧？</p><p>这样确实可以「缓解」这个问题，降低出问题的概率，但依旧无法「彻底解决」问题。</p><p>为什么？</p><p>原因在于，客户端在拿到锁之后，在操作共享资源时，遇到的场景有可能是很复杂的，例如，程序内部发生异常、网络请求超时等等。</p><p>既然是「预估」时间，也只能是大致计算，除非你能预料并覆盖到所有导致耗时变长的场景，但这其实很难。</p><p>有什么更好的解决方案吗？</p><p>别急，关于这个问题，我会在后面详细来讲对应的解决方案。</p><p>我们继续来看第二个问题。</p><p><strong>第二个问题在于，一个客户端释放了其它客户端持有的锁。</strong></p><p>想一下，导致这个问题的关键点在哪？</p><p>重点在于，每个客户端在释放锁时，都是「无脑」操作，并没有检查这把锁是否还「归自己持有」，所以就会发生释放别人锁的风险，这样的解锁流程，很不「严谨」！</p><p>如何解决这个问题呢？</p><h1 id="锁被别人释放怎么办"><a href="#锁被别人释放怎么办" class="headerlink" title="锁被别人释放怎么办?"></a>锁被别人释放怎么办?</h1><p>解决办法是：客户端在加锁时，设置一个只有自己知道的「唯一标识」进去。</p><p>例如，可以是自己的线程 ID，也可以是一个 UUID（随机且唯一），这里我们以 UUID 举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 锁的VALUE设置为UUID<br>127.0.0.1:6379&gt; SET lock $uuid EX 20 NX<br>OK<br></code></pre></td></tr></table></figure><blockquote><p>这里假设 20s 操作共享时间完全足够，先不考虑锁自动过期的问题。</p></blockquote><p>之后，在释放锁时，要先判断这把锁是否还归自己持有，伪代码可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 锁是自己的，才释放</span><br><span class="hljs-keyword">if</span> redis.get(<span class="hljs-string">&quot;lock&quot;</span>) == $uuid:<br>    redis.del(<span class="hljs-string">&quot;lock&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里释放锁使用的是 GET + DEL 两条命令，这时，又会遇到我们前面讲的原子性问题了。</p><ol><li>客户端 1 执行 GET，判断锁是自己的</li><li>客户端 2 执行了 SET 命令，强制获取到锁（虽然发生概率比较低，但我们需要严谨地考虑锁的安全性模型）</li><li>客户端 1 执行 DEL，却释放了客户端 2 的锁</li></ol><p>由此可见，这两个命令还是必须要原子执行才行。</p><p>怎样原子执行呢？Lua 脚本。</p><p>我们可以把这个逻辑，写成 Lua 脚本，让 Redis 来执行。</p><p>因为 Redis 处理每一个请求是「单线程」执行的，在执行一个 Lua 脚本时，其它请求必须等待，直到这个 Lua 脚本处理完成，这样一来，GET + DEL 之间就不会插入其它命令了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101642484.png" alt="图片"></p><p>安全释放锁的 Lua 脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">// 判断锁是自己的，才释放<br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;GET&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;DEL&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>好了，这样一路优化，整个的加锁、解锁的流程就更「严谨」了。</p><p>这里我们先小结一下，基于 Redis 实现的分布式锁，一个严谨的的流程如下：</p><ol><li>加锁：SET lock_key $unique_id EX $expire_time NX</li><li>操作共享资源</li><li>释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101626176.png" alt="图片"></p><p>好，有了这个完整的锁模型，让我们重新回到前面提到的第一个问题。</p><p>锁过期时间不好评估怎么办？</p><h1 id="锁过期时间不好评估怎么办？"><a href="#锁过期时间不好评估怎么办？" class="headerlink" title="锁过期时间不好评估怎么办？"></a>锁过期时间不好评估怎么办？</h1><p>前面我们提到，锁的过期时间如果评估不好，这个锁就会有「提前」过期的风险。</p><p>当时给的妥协方案是，尽量「冗余」过期时间，降低锁提前过期的概率。</p><p>这个方案其实也不能完美解决问题，那怎么办呢？</p><p>是否可以设计这样的方案：<strong>加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。</strong></p><p>这确实一种比较好的方案。</p><p>如果你是 Java 技术栈，幸运的是，已经有一个库把这些工作都封装好了：<strong>Redisson</strong>。</p><p>Redisson 是一个 Java 语言实现的 Redis SDK 客户端，在使用分布式锁时，它就采用了「自动续期」的方案来避免锁过期，这个守护线程我们一般也把它叫做「看门狗」线程。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101618896.png" alt="图片"></p><p>除此之外，这个 SDK 还封装了很多易用的功能：</p><ul><li>可重入锁</li><li>乐观锁</li><li>公平锁</li><li>读写锁</li><li>Redlock（红锁，下面会详细讲）</li></ul><p>这个 SDK 提供的 API 非常友好，它可以像操作本地锁的方式，操作分布式锁。如果你是 Java 技术栈，可以直接把它用起来。</p><blockquote><p>这里不重点介绍 Redisson 的使用，大家可以看官方 Github 学习如何使用，比较简单。</p></blockquote><p>到这里我们再小结一下，基于 Redis 的实现分布式锁，前面遇到的问题，以及对应的解决方案：</p><ul><li><strong>死锁</strong>：设置过期时间</li><li><strong>过期时间评估不好，锁提前过期</strong>：守护线程，自动续期</li><li><strong>锁被别人释放</strong>：锁写入唯一标识，释放锁先检查标识，再释放</li></ul><p>还有哪些问题场景，会危害 Redis 锁的安全性呢？</p><p>之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 的部署架构细节。</p><p>而我们在使用 Redis 时，一般会采用<strong>主从集群 + 哨兵</strong>的模式部署，这样做的好处在于，当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p><p><strong>那当「主从发生切换」时，这个分布锁会依旧安全吗？</strong></p><p>试想这样的场景：</p><ol><li>客户端 1 在主库上执行 SET 命令，加锁成功</li><li>此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）</li><li>从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101604473.png" alt="图片"></p><p>可见，当引入 Redis 副本后，分布锁还是可能会受到影响。</p><p>怎么解决这个问题？</p><p>为此，Redis 的作者提出一种解决方案，就是我们经常听到的 <strong>Redlock（红锁）</strong>。</p><p>它真的可以解决上面这个问题吗？</p><h1 id="Redlock-真的安全吗？"><a href="#Redlock-真的安全吗？" class="headerlink" title="Redlock 真的安全吗？"></a>Redlock 真的安全吗？</h1><p>好，终于到了这篇文章的重头戏。啊？上面讲的那么多问题，难道只是基础？</p><p>是的，那些只是开胃菜，真正的硬菜，从这里刚刚开始。</p><p>如果上面讲的内容，你还没有理解，我建议你重新阅读一遍，先理清整个加锁、解锁的基本流程。</p><p>如果你已经对 Redlock 有所了解，这里可以跟着我再复习一遍，如果你不了解 Redlock，没关系，我会带你重新认识它。</p><p>值得提醒你的是，<strong>后面我不仅仅是讲 Redlock 的原理，还会引出有关「分布式系统」中的很多问题，你最好跟紧我的思路，在脑中一起分析问题的答案。</strong></p><p>现在我们来看，Redis 作者提出的 Redlock 方案，是如何解决主从切换后，锁失效问题的。</p><p>Redlock 的方案基于 2 个前提：</p><ol><li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong></li><li>但主库要部署多个，官方推荐至少 5 个实例</li></ol><p>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><blockquote><p><strong>注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101557341.png" alt="图片"></p><p>Redlock 具体如何使用呢？</p><p>整体的流程是这样的，一共分为 5 步：</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 &gt;=3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p>我简单帮你总结一下，有 4 个重点：</p><ol><li>客户端在多个 Redis 实例上申请加锁</li><li>必须保证大多数节点加锁成功</li><li>大多数节点加锁的总耗时，要小于锁设置的过期时间</li><li>释放锁，要向全部节点发起释放锁请求</li></ol><blockquote><p>第一次看可能不太容易理解，建议你把上面的文字多看几遍，加深记忆。</p><p>然后，记住这 5 步，非常重要，下面会根据这个流程，剖析各种可能导致锁失效的问题假设。</p></blockquote><p>好，明白了 Redlock 的流程，我们来看 Redlock 为什么要这么做。</p><p><strong>1) 为什么要在多个实例上加锁？</strong></p><p>本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用。</p><p><strong>2) 为什么大多数加锁成功，才算成功？</strong></p><p>多个 Redis 实例一起来用，其实就组成了一个「分布式系统」。</p><p>在分布式系统中，总会出现「异常节点」，所以，在谈论分布式系统问题时，需要考虑异常节点达到多少个，也依旧不会影响整个系统的「正确性」。</p><p>这是一个分布式系统「容错」问题，这个问题的结论是：<strong>如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的。</strong></p><blockquote><p>这个问题的模型，就是我们经常听到的「拜占庭将军」问题，感兴趣可以去看算法的推演过程。</p></blockquote><p><strong>3) 为什么步骤 3 加锁成功后，还要计算加锁的累计耗时？</strong></p><p>因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久，而且，因为是网络请求，网络情况是复杂的，有可能存在<strong>延迟、丢包、超时</strong>等情况发生，网络请求越多，异常发生的概率就越大。</p><p>所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经「超过」了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。</p><p><strong>4) 为什么释放锁，要操作所有节点？</strong></p><p>在某一个 Redis 节点加锁时，可能因为「网络原因」导致加锁失败。</p><p>例如，客户端在一个 Redis 实例上加锁成功，但在读取响应结果时，网络问题导致<strong>读取失败</strong>，那这把锁其实已经在 Redis 上加锁成功了。</p><p>所以，释放锁时，不管之前有没有加锁成功，需要释放「所有节点」的锁，以保证清理节点上「残留」的锁。</p><p>好了，明白了 Redlock 的流程和相关问题，看似 Redlock 确实解决了 Redis 节点异常宕机锁失效的问题，保证了锁的「安全性」。</p><p>但事实真的如此吗？</p><h1 id="Redlock-的争论谁对谁错？"><a href="#Redlock-的争论谁对谁错？" class="headerlink" title="Redlock 的争论谁对谁错？"></a>Redlock 的争论谁对谁错？</h1><p>Redis 作者把这个方案一经提出，就马上受到业界著名的分布式系统专家的<strong>质疑</strong>！</p><p>这个专家叫 <strong>Martin</strong>，是英国剑桥大学的一名分布式系统研究员。在此之前他曾是软件工程师和企业家，从事大规模数据基础设施相关的工作。它还经常在大会做演讲，写博客，写书，也是开源贡献者。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101545963.png" alt="图片"></p><p>他马上写了篇文章，质疑这个 Redlock 的算法模型是有问题的，并对分布式锁的设计，提出了自己的看法。</p><p>之后，Redis 作者 Antirez 面对质疑，不甘示弱，也写了一篇文章，反驳了对方的观点，并详细剖析了 Redlock 算法模型的更多设计细节。</p><p>而且，关于这个问题的争论，在当时互联网上也引起了非常激烈的讨论。</p><p><strong>二人思路清晰，论据充分，这是一场高手过招，也是分布式系统领域非常好的一次思想的碰撞！双方都是分布式系统领域的专家，却对同一个问题提出很多相反的论断，究竟是怎么回事？</strong></p><p>下面我会从他们的争论文章中，提取重要的观点，整理呈现给你。</p><blockquote><p>提醒：后面的信息量极大，可能不宜理解，最好放慢速度阅读。</p></blockquote><h2 id="分布式专家-Martin-对于-Relock-的质疑"><a href="#分布式专家-Martin-对于-Relock-的质疑" class="headerlink" title="分布式专家 Martin 对于 Relock 的质疑"></a>分布式专家 Martin 对于 Relock 的质疑</h2><p>在他的文章中，主要阐述了 4 个论点：</p><p><strong>1) 分布式锁的目的是什么？</strong></p><p>Martin 表示，你必须先清楚你在使用分布式锁的目的是什么？</p><p>他认为有两个目的。</p><p><strong>第一，效率。</strong></p><p>使用分布式锁的互斥能力，是避免不必要地做同样的两次工作（例如一些昂贵的计算任务）。如果锁失效，并不会带来「恶性」的后果，例如发了 2 次邮件等，无伤大雅。</p><p><strong>第二，正确性。</strong></p><p>使用锁用来防止并发进程互相干扰。如果锁失效，会造成多个进程同时操作同一条数据，产生的后果是<strong>数据严重错误、永久性不一致、数据丢失</strong>等恶性问题，就像给患者服用了重复剂量的药物，后果很严重。</p><p>他认为，如果你是为了前者——效率，那么使用单机版 Redis 就可以了，即使偶尔发生锁失效（宕机、主从切换），都不会产生严重的后果。而使用 Redlock 太重了，没必要。</p><p><strong>而如果是为了正确性，Martin 认为 Redlock 根本达不到安全性的要求，也依旧存在锁失效的问题！</strong></p><p><strong>2) 锁在分布式系统中会遇到的问题</strong></p><p>Martin 表示，一个分布式系统，更像一个复杂的「野兽」，存在着你想不到的各种异常情况。</p><p>这些异常场景主要包括三大块，这也是分布式系统会遇到的三座大山：<strong>NPC</strong>。</p><ul><li>N：Network Delay，网络延迟</li><li>P：Process Pause，进程暂停（GC）</li><li>C：Clock Drift，时钟漂移</li></ul><p>Martin 用一个进程暂停（GC）的例子，指出了 Redlock 安全性问题：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC（时间比较久）</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取到了 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到了锁，发生「冲突」</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101536288.png" alt="图片"></p><p>Martin 认为，GC 可能发生在程序的任意时刻，而且执行时间是不可控的。</p><blockquote><p>注：当然，即使是使用没有 GC 的编程语言，在发生网络延迟、时钟漂移时，也都有可能导致 Redlock 出现问题，这里 Martin 只是拿 GC 举例。</p></blockquote><p><strong>3) 假设时钟正确的是不合理的</strong></p><p>又或者，当多个 Redis 节点「时钟」发生问题时，也会导致 Redlock <strong>锁失效</strong>。</p><ol><li>客户端 1 获取节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E</li><li>节点 C 上的时钟「向前跳跃」，导致锁到期</li><li>客户端 2 获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B</li><li>客户端 1 和 2 现在都相信它们持有了锁（冲突）</li></ol><p>Martin 觉得，Redlock 必须「强依赖」多个节点的时钟是保持同步的，一旦有节点时钟发生错误，那这个算法模型就失效了。</p><blockquote><p>即使 C 不是时钟跳跃，而是「崩溃后立即重启」，也会发生类似的问题。</p></blockquote><p>Martin 继续阐述，机器的时钟发生错误，是很有可能发生的：</p><ul><li>系统管理员「手动修改」了机器时钟</li><li>机器时钟在同步 NTP 时间时，发生了大的「跳跃」</li></ul><p>总之，Martin 认为，Redlock 的算法是建立在「同步模型」基础上的，有大量资料研究表明，同步模型的假设，在分布式系统中是有问题的。</p><p>在混乱的分布式系统的中，你不能假设系统时钟就是对的，所以，你必须非常小心你的假设。</p><p><strong>4) 提出 fecing token 的方案，保证正确性</strong></p><p>相对应的，Martin 提出一种被叫作 fecing token 的方案，保证分布式锁的正确性。</p><p>这个模型流程如下：</p><ol><li>客户端在获取锁时，锁服务可以提供一个「递增」的 token</li><li>客户端拿着这个 token 去操作共享资源</li><li>共享资源可以根据 token 拒绝「后来者」的请求</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101529458.png" alt="图片"></p><p>这样一来，无论 NPC 哪种异常情况发生，都可以保证分布式锁的安全性，因为它是建立在「异步模型」上的。</p><p>而 Redlock 无法提供类似 fecing token 的方案，所以它无法保证安全性。</p><p>他还表示，<strong>一个好的分布式锁，无论 NPC 怎么发生，可以不在规定时间内给出结果，但并不会给出一个错误的结果。也就是只会影响到锁的「性能」（或称之为活性），而不会影响它的「正确性」。</strong></p><p>Martin 的结论：</p><p><strong>1、Redlock 不伦不类</strong>：它对于效率来讲，Redlock 比较重，没必要这么做，而对于正确性来说，Redlock 是不够安全的。</p><p><strong>2、时钟假设不合理</strong>：该算法对系统时钟做出了危险的假设（假设多个节点机器时钟都是一致的），如果不满足这些假设，锁就会失效。</p><p><strong>3、无法保证正确性</strong>：Redlock 不能提供类似 fencing token 的方案，所以解决不了正确性的问题。为了正确性，请使用有「共识系统」的软件，例如 Zookeeper。</p><p>好了，以上就是 Martin 反对使用 Redlock 的观点，看起来有理有据。</p><p>下面我们来看 Redis 作者 Antirez 是如何反驳的。</p><h2 id="Redis-作者-Antirez-的反驳"><a href="#Redis-作者-Antirez-的反驳" class="headerlink" title="Redis 作者 Antirez 的反驳"></a>Redis 作者 Antirez 的反驳</h2><p>在 Redis 作者的文章中，重点有 3 个：</p><p><strong>1) 解释时钟问题</strong></p><p>首先，Redis 作者一眼就看穿了对方提出的最为核心的问题：<strong>时钟问题</strong>。</p><p>Redis 作者表示，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了，允许有「误差」。</p><p>例如要计时 5s，但实际可能记了 4.5s，之后又记了 5.5s，有一定误差，但只要不超过「误差范围」锁失效时间即可，这种对于时钟的精度要求并不是很高，而且这也符合现实环境。</p><p>对于对方提到的「时钟修改」问题，Redis 作者反驳到：</p><ol><li><strong>手动修改时钟</strong>：不要这么做就好了，否则你直接修改 Raft 日志，那 Raft 也会无法工作…</li><li><strong>时钟跳跃</strong>：通过「恰当的运维」，保证机器时钟不会大幅度跳跃（每次通过微小的调整来完成），实际上这是可以做到的</li></ol><blockquote><p>为什么 Redis 作者优先解释时钟问题？因为在后面的反驳过程中，需要依赖这个基础做进一步解释。</p></blockquote><p><strong>2) 解释网络延迟、GC 问题</strong></p><p>之后，Redis 作者对于对方提出的，网络延迟、进程 GC 可能导致 Redlock 失效的问题，也做了反驳：</p><p>我们重新回顾一下，Martin 提出的问题假设：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取节点 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到锁，发生「冲突」</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101522843.png" alt="图片"></p><p>Redis 作者反驳到，这个假设其实是有问题的，Redlock 是可以保证锁安全的。</p><p>这是怎么回事呢？</p><p>还记得前面介绍 Redlock 流程的那 5 步吗？这里我再拿过来让你复习一下。</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p><strong>注意，重点是 1-3，在步骤 3，加锁成功后为什么要重新获取「当前时间戳T2」？还用 T2 - T1 的时间，与锁的过期时间做比较？</strong></p><p>Redis 作者强调：如果在 1-3 发生了网络延迟、进程 GC 等耗时长的异常情况，那在第 3 步 T2 - T1，是可以检测出来的，如果超出了锁设置的过期时间，那这时就认为加锁会失败，之后释放所有节点的锁就好了！</p><p>Redis 作者继续论述，如果对方认为，发生网络延迟、进程 GC 是在步骤 3 之后，也就是客户端确认拿到了锁，去操作共享资源的途中发生了问题，导致锁失效，那这<strong>不止是 Redlock 的问题，任何其它锁服务例如 Zookeeper，都有类似的问题，这不在讨论范畴内。</strong></p><p>这里我举个例子解释一下这个问题：</p><ol><li>客户端通过 Redlock 成功获取到锁（通过了大多数节点加锁成功、加锁耗时检查逻辑）</li><li>客户端开始操作共享资源，此时发生网络延迟、进程 GC 等耗时很长的情况</li><li>此时，锁过期自动释放</li><li>客户端开始操作 MySQL（此时的锁可能会被别人拿到，锁失效）</li></ol><p>Redis 作者这里的结论就是：</p><ul><li>客户端在拿到锁之前，无论经历什么耗时长问题，Redlock 都能够在第 3 步检测出来</li><li>客户端在拿到锁之后，发生 NPC，那 Redlock、Zookeeper 都无能为力</li></ul><p>所以，Redis 作者认为 Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p><p><strong>3) 质疑 fencing token 机制</strong></p><p>Redis 作者对于对方提出的 fecing token 机制，也提出了质疑，主要分为 2 个问题，这里最不宜理解，请跟紧我的思路。</p><p><strong>第一</strong>，这个方案必须要求要操作的「共享资源服务器」有拒绝「旧 token」的能力。</p><p>例如，要操作 MySQL，从锁服务拿到一个递增数字的 token，然后客户端要带着这个 token 去改 MySQL 的某一行，这就需要利用 MySQL 的「事物隔离性」来做。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 两个客户端必须利用事物和隔离性达到目的<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 注意 token 的判断条件<br>UPDATE <span class="hljs-keyword">table</span> T <span class="hljs-keyword">SET</span> val <span class="hljs-operator">=</span> $new_val <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> $id <span class="hljs-keyword">AND</span> current_token <span class="hljs-operator">&lt;</span> $token<br></code></pre></td></tr></table></figure><p>但如果操作的不是 MySQL 呢？例如向磁盘上写一个文件，或发起一个 HTTP 请求，那这个方案就无能为力了，这对要操作的资源服务器，提出了更高的要求。</p><p>也就是说，大部分要操作的资源服务器，都是没有这种互斥能力的。</p><p><strong>再者，既然资源服务器都有了「互斥」能力，那还要分布式锁干什么？</strong></p><p>所以，Redis 作者认为这个方案是站不住脚的。</p><p><strong>第二</strong>，退一步讲，即使 Redlock 没有提供 fecing token 的能力，但 Redlock 已经提供了随机值（就是前面讲的 UUID），利用这个随机值，也可以达到与 fecing token 同样的效果。</p><p>如何做呢？</p><blockquote><p>Redis 作者只是提到了可以完成 fecing token 类似的功能，但却没有展开相关细节，根据我查阅的资料，大概流程应该如下，如有错误，欢迎交流~</p></blockquote><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端在操作共享资源之前，先把这个锁的 VALUE，在要操作的共享资源上做标记</li><li>客户端处理业务逻辑，最后，在修改共享资源时，判断这个标记是否与之前一样，一样才修改（类似 CAS 的思路）</li></ol><p>还是以 MySQL 为例，举个例子就是这样的：</p><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端要修改 MySQL 表中的某一行数据之前，先把锁的 VALUE 更新到这一行的某个字段中（这里假设为 current_token 字段)</li><li>客户端处理业务逻辑</li><li>客户端修改 MySQL 的这一行数据，把 VALUE 当做 WHERE 条件，再修改</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">UPDATE <span class="hljs-keyword">table</span> T <span class="hljs-keyword">SET</span> val <span class="hljs-operator">=</span> $new_val <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> $id <span class="hljs-keyword">AND</span> current_token <span class="hljs-operator">=</span> $redlock_value<br></code></pre></td></tr></table></figure><p>可见，这种方案依赖 MySQL 的事物机制，也达到对方提到的 fecing token 一样的效果。</p><p>但这里还有个小问题，是网友参与问题讨论时提出的：<strong>两个客户端通过这种方案，先「标记」再「检查+修改」共享资源，那这两个客户端的操作顺序无法保证啊？</strong></p><p>而用 Martin 提到的 fecing token，因为这个 token 是单调递增的数字，资源服务器可以拒绝小的 token 请求，保证了操作的「顺序性」！</p><p>Redis 作者对这问题做了不同的解释，我觉得很有道理，他解释道：<strong>分布式锁的本质，是为了「互斥」，只要能保证两个客户端在并发时，一个成功，一个失败就好了，不需要关心「顺序性」。</strong></p><blockquote><p>前面 Martin 的质疑中，一直很关心这个顺序性问题，但 Redis 的作者的看法却不同。</p></blockquote><p>综上，Redis 作者的结论：</p><p><strong>1、作者同意对方关于「时钟跳跃」对 Redlock 的影响，但认为时钟跳跃是可以避免的，取决于基础设施和运维。</strong></p><p><strong>2、Redlock 在设计时，充分考虑了 NPC 问题，在 Redlock 步骤 3 之前出现 NPC，可以保证锁的正确性，但在步骤 3 之后发生 NPC，不止是 Redlock 有问题，其它分布式锁服务同样也有问题，所以不在讨论范畴内。</strong></p><p>是不是觉得很有意思？</p><p>在分布式系统中，一个小小的锁，居然可能会遇到这么多问题场景，影响它的安全性！</p><p>不知道你看完双方的观点，更赞同哪一方的说法呢？</p><p>别急，后面我还会综合以上论点，谈谈自己的理解。</p><p>好，讲完了双方对于 Redis 分布锁的争论，你可能也注意到了，Martin 在他的文章中，推荐使用 Zookeeper 实现分布式锁，认为它更安全，确实如此吗？</p><h1 id="基于-Zookeeper-的锁安全吗？"><a href="#基于-Zookeeper-的锁安全吗？" class="headerlink" title="基于 Zookeeper 的锁安全吗？"></a>基于 Zookeeper 的锁安全吗？</h1><p>如果你有了解过 Zookeeper，基于它实现的分布式锁是这样的：</p><ol><li>客户端 1 和 2 都尝试创建「临时节点」，例如 /lock</li><li>假设客户端 1 先到达，则加锁成功，客户端 2 加锁失败</li><li>客户端 1 操作共享资源</li><li>客户端 1 删除 /lock 节点，释放锁</li></ol><p>你应该也看到了，Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端 1 拿到锁后，只要连接不断，就可以一直持有锁。</p><p>而且，如果客户端 1 异常崩溃了，那么这个临时节点会自动删除，保证了锁一定会被释放。</p><p><strong>不错，没有锁过期的烦恼，还能在异常时自动释放锁，是不是觉得很完美？</strong></p><p>其实不然。</p><p>思考一下，客户端 1 创建临时节点后，Zookeeper 是如何保证让这个客户端一直持有锁呢？</p><p>原因就在于，<strong>客户端 1 此时会与 Zookeeper 服务器维护一个 Session，这个 Session 会依赖客户端「定时心跳」来维持连接。</strong></p><p>如果 Zookeeper 长时间收不到客户端的心跳，就认为这个 Session 过期了，也会把这个临时节点删除。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101445733.png" alt="图片"></p><p>同样地，基于此问题，我们也讨论一下 GC 问题对 Zookeeper 的锁有何影响：</p><ol><li>客户端 1 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 发生长时间 GC</li><li>客户端 1 无法给 Zookeeper 发送心跳，Zookeeper 把临时节点「删除」</li><li>客户端 2 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 GC 结束，它仍然认为自己持有锁（冲突）</li></ol><p>可见，即使是使用 Zookeeper，也无法保证进程 GC、网络延迟异常场景下的安全性。</p><p><strong>这就是前面 Redis 作者在反驳的文章中提到的：如果客户端已经拿到了锁，但客户端与锁服务器发生「失联」（例如 GC），那不止 Redlock 有问题，其它锁服务都有类似的问题，Zookeeper 也是一样！</strong></p><p>所以，这里我们就能得出结论了：<strong>一个分布式锁，在极端情况下，不一定是安全的。</strong></p><p>如果你的业务数据非常敏感，在使用分布式锁时，一定要注意这个问题，不能假设分布式锁 100% 安全。</p><p>好，现在我们来总结一下 Zookeeper 在使用分布式锁时优劣：</p><p>Zookeeper 的优点：</p><ol><li>不需要考虑锁的过期时间</li><li>watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁</li></ol><p>但它的劣势是：</p><ol><li>性能不如 Redis</li><li>部署和运维成本高</li><li>客户端与 Zookeeper 的长时间失联，锁被释放问题</li></ol><h1 id="我对分布式锁的理解"><a href="#我对分布式锁的理解" class="headerlink" title="我对分布式锁的理解"></a>我对分布式锁的理解</h1><p>好了，前面详细介绍了基于 Redis 的 Redlock 和 Zookeeper 实现的分布锁，在各种异常情况下的安全性问题，下面我想和你聊一聊我的看法，仅供参考，不喜勿喷。</p><p><strong>1) 到底要不要用 Redlock？</strong></p><p>前面也分析了，Redlock 只有建立在「时钟正确」的前提下，才能正常工作，如果你可以保证这个前提，那么可以拿来使用。</p><p>但保证时钟正确，我认为并不是你想的那么简单就能做到的。</p><p><strong>第一，从硬件角度来说</strong>，时钟发生偏移是时有发生，无法避免。</p><p>例如，CPU 温度、机器负载、芯片材料都是有可能导致时钟发生偏移的。</p><p><strong>第二，从我的工作经历来说</strong>，曾经就遇到过时钟错误、运维暴力修改时钟的情况发生，进而影响了系统的正确性，所以，人为错误也是很难完全避免的。</p><p>所以，我对 Redlock 的个人看法是，尽量不用它，而且它的性能不如单机版 Redis，部署成本也高，我还是会优先考虑使用主从+ 哨兵的模式 实现分布式锁。</p><p>那正确性如何保证呢？第二点给你答案。</p><p><strong>2) 如何正确使用分布式锁？</strong></p><p>在分析 Martin 观点时，它提到了 fecing token 的方案，给我了很大的启发，虽然这种方案有很大的局限性，但对于保证「正确性」的场景，是一个非常好的思路。</p><p>所以，我们可以把这两者结合起来用：</p><p><strong>1、使用分布式锁，在上层完成「互斥」目的，虽然极端情况下锁会失效，但它可以最大程度把并发请求阻挡在最上层，减轻操作资源层的压力。</strong></p><p><strong>2、但对于要求数据绝对正确的业务，在资源层一定要做好「兜底」，设计思路可以借鉴 fecing token 的方案来做。</strong></p><p>两种思路结合，我认为对于大多数业务场景，已经可以满足要求了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，总结一下。</p><p>这篇文章，我们主要探讨了基于 Redis 实现的分布式锁，究竟是否安全这个问题。</p><p>从最简单分布式锁的实现，到处理各种异常场景，再到引出 Redlock，以及两个分布式专家的辩论，得出了 Redlock 的适用场景。</p><p>最后，我们还对比了 Zookeeper 在做分布式锁时，可能会遇到的问题，以及与 Redis 的差异。</p><p>这里我把这些内容总结成了思维导图，方便你理解。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640.png" alt="图片"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇文章的信息量其实是非常大的，我觉得应该把分布锁的问题，彻底讲清楚了。</p><p>如果你没有理解，我建议你多读几遍，并在脑海中构建各种假定的场景，反复思辨。</p><p>在写这篇文章时，我又重新研读了两位大神关于 Redlock 争辩的这两篇文章，可谓是是收获满满，在这里也分享一些心得给你。</p><p>1、在分布式系统环境下，看似完美的设计方案，可能并不是那么「严丝合缝」，如果稍加推敲，就会发现各种问题。所以，在思考分布式系统问题时，一定要<strong>谨慎再谨慎</strong>。</p><p>2、从 Redlock 的争辩中，我们不要过多关注对错，而是要多学习大神的思考方式，以及对一个问题严格审查的严谨精神。</p><p>最后，用 Martin 在对于 Redlock 争论过后，写下的感悟来结尾：</p><p>“<strong>前人已经为我们创造出了许多伟大的成果：站在巨人的肩膀上，我们可以才得以构建更好的软件。无论如何，通过争论和检查它们是否经得起别人的详细审查，这是学习过程的一部分。但目标应该是获取知识，而不是为了说服别人，让别人相信你是对的。有时候，那只是意味着停下来，好好地想一想。</strong>”</p><p>共勉。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie&amp;session&amp;token</title>
    <link href="/2020/03/02/Cookie&amp;Session&amp;Token/"/>
    <url>/2020/03/02/Cookie&amp;Session&amp;Token/</url>
    
    <content type="html"><![CDATA[<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>1991 年 HTTP 0.9 诞生了，当时只是为了满足大家浏览 web 文档的要求 ，所以只有 GET 请求，浏览完了就走了，两个连接之间是没有任何联系的，这也是 HTTP 为无状态的原因，因为它诞生之初就没有这个需求。</p><p>但随着交互式 Web 的兴起（所谓交互式就是你不光可以浏览，还可以登录，发评论，购物等用户操作的行为），单纯地浏览 web 已经无法满足人们的要求，比如随着网上购物的兴起，需要记录用户的购物车记录，就需要有一个机制记录每个连接的关系，这样我们就知道加入购物车的商品到底属于谁了，于是 Cookie 就诞生了。</p><blockquote><p>Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行 Session 跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。</p></blockquote><p>工作机制如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101127316" alt="图片">img</p><p>以加入购物车为例，每次浏览器请求后 server 都会将本次商品 id 存储在 Cookie 中返回给客户端，客户端会将 Cookie 保存在本地，下一次再将上次保存在本地的 Cookie 传给 server 就行了，这样每个 Cookie 都保存着用户的商品 id，购买记录也就不会丢失了</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101133075" alt="图片">img</p><p>仔细观察上图相信你不难发现随着购物车内的商品越来越多，每次请求的 cookie 也越来越大，这对每个请求来说是一个很大的负担，我只是想将一个商品加入购买车，为何要将历史的商品记录也一起返回给 server ？购物车信息其实已经记录在 server 了，浏览器这样的操作岂不是多此一举？怎么改进呢</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>仔细考虑下，由于用户的购物车信息都会保存在 Server 中，所以在 Cookie 里只要保存能识别用户身份的信息，知道是谁发起了加入购物车操作即可，这样每次请求后只要在 Cookie 里带上用户的身份信息，请求体里也只要带上本次加入购物车的商品 id，大大减少了 cookie 的体积大小，我们把这种能识别哪个请求由哪个用户发起的机制称为 Session（会话机制），生成的能识别用户身份信息的字符串称为 sessionId，它的工作机制如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101138792" alt="图片"></p><ol><li>首先用户登录，server 会为用户生成一个 session，为其分配唯一的 sessionId，这个 sessionId 是与某个用户绑定的，也就是说根据此 sessionid（假设为 abc） 可以查询到它到底是哪个用户，然后将此 sessionid 通过 cookie 传给浏览器</li><li>之后浏览器的每次添加购物车请求中只要在 cookie 里带上 sessionId=abc 这一个键值对即可，server 根据 sessionId 找到它对应的用户后，把传过来的商品 id 保存到 server 中对应用户的购物车即可</li></ol><p>可以看到通过这种方式再也不需要在 cookie 里传所有的购物车的商品 id 了，大大减轻了请求的负担！</p><p>另外通过上文不难观察出 <strong>cookie 是存储在 client 的，而 session 保存在 server</strong>，sessionId 需要借助 cookie 的传递才有意义。</p><h3 id="session-的痛点"><a href="#session-的痛点" class="headerlink" title="session 的痛点"></a>session 的痛点</h3><p>看起来通过  cookie + session 的方式是解决了问题， 但是我们忽略了一个问题，上述情况能正常工作是因为我们假设 server 是单机工作的，但实际在生产上，为了保障高可用，一般服务器至少需要两台机器，通过负载均衡的方式来决定到底请求该打到哪台机器上。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101154301" alt="图片">balance</p><p><strong>如图示：客户端请求后，由负载均衡器（如 Nginx）来决定到底打到哪台机器</strong></p><p>假设登录请求打到了 A 机器，A 机器生成了 session 并在 cookie 里添加 sessionId 返回给了浏览器，那么问题来了：下次添加购物车时如果请求打到了 B 或者 C，由于 session 是在 A 机器生成的，此时的 B,C 是找不到 session 的，那么就会发生无法添加购物车的错误，就得重新登录了，此时请问该怎么办。主要有以下三种方式</p><blockquote><p>1、session 复制</p></blockquote><p>A 生成 session 后复制到 B, C，这样每台机器都有一份 session，无论添加购物车的请求打到哪台机器，由于 session 都能找到，故不会有问题</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101201725" alt="图片">balance (1)</p><p>这种方式虽然可行，但缺点也很明显：</p><ol><li>同一样的一份 session 保存了多份，数据冗余</li><li>如果节点少还好，但如果节点多的话，特别是像阿里，微信这种由于 DAU 上亿，可能需要部署成千上万台机器，这样节点增多复制造成的性能消耗也会很大。</li></ol><blockquote><p>2、session 粘连</p></blockquote><p>这种方式是让每个客户端请求只打到固定的一台机器上，比如浏览器登录请求打到 A 机器后，后续所有的添加购物车请求也都打到 A 机器上，Nginx 的 sticky 模块可以支持这种方式，支持按 ip 或 cookie 粘连等等，如按 ip 粘连方式如下</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">upstream tomcats &#123;<br>  <span class="hljs-attribute">ip_hash;</span><br><span class="hljs-attribute">  server 10.1.1.107</span>:88;<br>  <span class="hljs-attribute">server 10.1.1.132</span>:80;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101207746" alt="图片">img</p><p>这样的话每个 client 请求到达 Nginx 后，只要它的 ip 不变，根据 ip hash 算出来的值会打到固定的机器上，也就不存在 session 找不到的问题了，当然不难看出这种方式缺点也是很明显，对应的机器挂了怎么办？</p><blockquote><p>3、session 共享</p></blockquote><p>这种方式也是目前各大公司普遍采用的方案，将 session 保存在 redis，memcached 等中间件中，请求到来时，各个机器去这些中间件取一下 session 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101212174" alt="图片">img</p><p>缺点其实也不难发现，就是每个请求都要去 redis 取一下 session，多了一次内部连接，消耗了一点性能，另外为了保证 redis 的高可用，必须做集群，当然了对于大公司来说, redis 集群基本都会部署，所以这方案可以说是大公司的首选了。</p><h3 id="Token：no-session"><a href="#Token：no-session" class="headerlink" title="Token：no session!"></a>Token：no session!</h3><p>通过上文分析我们知道通过在服务端共享 session 的方式可以完成用户的身份定位，但是不难发现也有一个小小的瑕疵：搞个校验机制我还得搭个 redis 集群？大厂确实 redis 用得比较普遍，但对于小厂来说可能它的业务量还未达到用 redis 的程度，所以有没有其他不用 server 存储 session 的用户身份校验机制呢，这就是我们今天要介绍的主角：token。</p><p>首先请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地，之后向 server 请求时在请求头带上此 token 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101217167" alt="图片">img</p><p>相信大家看了上图会发现存在两个问题</p><p>1、 token 只存储在浏览器中，服务端却没有存储，这样的话我随便搞个 token 传给 server 也行？</p><p>答：server 会有一套校验机制，校验这个 token 是否合法。</p><p>2、怎么不像 session 那样根据 sessionId 找到 userid 呢，这样的话怎么知道是哪个用户？</p><p>答：token 本身携带 uid 信息</p><p>第一个问题，如何校验 token 呢？我们可以借鉴 HTTPS 的签名机制来校验。先来看 jwt token 的组成部分</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101223022" alt="图片">img</p><p>可以看到 token 主要由三部分组成</p><ol><li>header：指定了签名算法</li><li>payload：可以指定用户 id，过期时间等非敏感数据</li><li>Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。</li></ol><p>当 server 收到浏览器传过来的 token 时，它会首先取出 token 中的 header + payload，根据密钥生成签名，然后再与 token 中的签名比对，如果成功则说明签名是合法的，即 token 是合法的。而且你会发现 payload 中存有我们的 userId，所以拿到 token 后直接在 payload 中就可获取 userid，避免了像 session 那样要从 redis 去取的开销</p><p><strong>画外音：header, payload 实际上是以 base64 的形式存在的，文中为了描述方便，省去了这一步。</strong></p><p>你会发现这种方式确实很妙，只要 server 保证密钥不泄露，那么生成的 token 就是安全的，因为如果伪造 token 的话在签名验证环节是无法通过的，就此即可判定 token 非法。</p><p>可以看到通过这种方式有效地避免了 token 必须保存在 server 的弊端，实现了分布式存储，不过需要注意的是，token 一旦由 server 生成，它就是有效的，直到过期，无法让 token 失效，除非在 server 为 token 设立一个黑名单，在校验 token 前先过一遍此黑名单，如果在黑名单里则此  token 失效，但一旦这样做的话，那就意味着黑名单就必须保存在 server，这又回到了 session 的模式，那直接用 session 不香吗。所以一般的做法是当客户端登出要让 token 失效时，直接在本地移除 token 即可，下次登录重新生成 token 就好。</p><p>另外需要注意的是 token 一般是放在 header 的 Authorization 自定义头里，不是放在 Cookie 里的，这主要是为了解决跨域不能共享 Cookie 的问题 （下文详述）</p><h3 id="Cookie-与-Token-的简单总结"><a href="#Cookie-与-Token-的简单总结" class="headerlink" title="Cookie 与 Token 的简单总结"></a>Cookie 与 Token 的简单总结</h3><blockquote><p>Cookie 有哪些局限性？</p></blockquote><p>1、 Cookie 跨站是不能共享的，这样的话如果你要实现多应用（多系统）的单点登录（SSO），使用 Cookie 来做需要的话就很困难了（要用比较复杂的 trick 来实现，有兴趣的话可以看文末参考链接）</p><p><strong>画外音: 所谓单点登录，是指在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</strong></p><p>但如果用 token 来实现 SSO 会非常简单，如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101228882" alt="图片">img</p><p>只要在 header 中的 authorize 字段（或其他自定义）加上 token 即可完成所有跨域站点的认证。</p><p>2、 在移动端原生请求是没有 cookie 之说的，而 sessionid 依赖于 cookie，sessionid 就不能用 cookie 来传了，如果用 token 的话，由于它是随着 header 的 authoriize 传过来的，也就不存在此问题，换句话说token 天生支持移动平台，可扩展性好</p><p>综上所述，token 具有存储实现简单，扩展性好这些特点。</p><blockquote><p>token 有哪些缺点</p></blockquote><p>那有人就问了，既然 token 这么好，那为什么各个大公司几乎都采用共享 session 的方式呢，可能很多人是第一次听到 token，token 不香吗? token 有以下两点劣势：</p><p>1、 token 太长了</p><p>token 是 header, payload 编码后的样式，所以一般要比 sessionId 长很多，很有可能超出 cookie 的大小限制（cookie 一般有大小限制的，如 4kb），如果你在 token 中存储的信息越长，那么 token 本身也会越长，这样的话由于你每次请求都会带上 token，对请求来是个不小的负担</p><p>2、 不太安全</p><p>网上很多文章说 token 更安全，其实不然，细心的你可能发现了，我们说 token 是存在浏览器的，再细问，存在浏览器的哪里？既然它太长放在 cookie 里可能导致 cookie 超限，那就只好放在 local storage 里，这样会造成安全隐患，因为 local storage 这类的本地存储是可以被 JS 直接读取的，另外由上文也提到，token 一旦生成无法让其失效，必须等到其过期才行，这样的话如果服务端检测到了一个安全威胁，也无法使相关的 token 失效。</p><p><strong>所以 token 更适合一次性的命令认证，设置一个比较短的有效期</strong></p><h3 id="误解-Cookie-相比-token-更不安全，比如-CSRF-攻击"><a href="#误解-Cookie-相比-token-更不安全，比如-CSRF-攻击" class="headerlink" title="误解: Cookie 相比 token 更不安全，比如 CSRF 攻击"></a>误解: Cookie 相比 token 更不安全，比如 CSRF 攻击</h3><p>首先我们需要解释下 CSRF 攻击是怎么回事</p><p>攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过（cookie 里带来 sessionId 等身份认证的信息），所以被访问的网站会认为是真正的用户操作而去运行。</p><p>比如用户登录了某银行网站（假设为 **<a href="http://www.examplebank.com/**%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BD%AC%E8%B4%A6%E5%9C%B0%E5%9D%80%E4%B8%BA">http://www.examplebank.com/**，并且转账地址为</a> <strong><a href="http://www.examplebank.com/withdraw?amount=1000&amp;transferTo=PayeeName">http://www.examplebank.com/withdraw?amount=1000&amp;transferTo=PayeeName</a></strong>），登录后 cookie 里会包含登录用户的 sessionid，攻击者可以在另一个网站上放置如下代码</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice<span class="hljs-variable">&amp;amount</span>=<span class="hljs-number">1000</span><span class="hljs-variable">&amp;for</span>=Badman&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>那么如果正常的用户误点了上面这张图片，由于相同域名的请求会自动带上 cookie，而 cookie 里带有正常登录用户的 sessionid，类似上面这样的转账操作在 server 就会成功，会造成极大的安全风险</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101238289" alt="图片">csrf 示意图</p><p>CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 cookie 都会被自动带上，这个是浏览器的机制决定的，所以很多人据此认定 cookie 不安全。</p><p>使用 token 确实避免了CSRF 的问题，但正如上文所述，由于 token 保存在 local storage，它会被 JS 读取，<strong>从存储角度来看</strong>也不安全（实际上防护 CSRF 攻击的正确方式是用 CSRF token）</p><p>所以不管是 cookie 还是 token，从存储角度来看其实都不安全，都有暴露的风险，我们所说的安全更多的是强调传输中的安全，可以用 HTTPS 协议来传输， 这样的话请求头都能被加密，也就保证了传输中的安全。</p><p>其实我们把 cookie 和 token 比较本身就不合理，一个是存储方式，一个是验证方式，正确的比较应该是 session vs token。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>session 和 token 本质上是没有区别的，都是对用户身份的认证机制，只是他们实现的校验机制不一样而已（一个保存在 server，通过在 redis 等中间件获取来校验，一个保存在 client，通过签名校验的方式来校验），多数场景上使用 session 会更合理，但如果在单点登录，一次性命令认证上使用 token 会更合适，最好在不同的业务场景中合理选型，才能达到事半功倍的效果。</p><p>巨人的肩膀</p><ul><li>Cookie Session跨站无法共享问题(单点登录解决方案)：<a href="https://blog.csdn.net/wtopps/article/details/75040224">https://blog.csdn.net/wtopps/article/details/75040224</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Communication protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态代理&amp;动态代理</title>
    <link href="/2019/12/08/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&amp;%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2019/12/08/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&amp;%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a><strong>静态代理</strong></h2><p>假设现在项目经理有一个需求：在项目现有所有类的方法前后打印日志。</p><p>你如何在<strong>不修改已有代码的前提下</strong>，完成这个需求？</p><p>我首先想到的是静态代理。具体做法是：</p><p>1.为现有的每一个类都编写一个<strong>对应的</strong>代理类，并且让它实现和目标类相同的接口（假设都有）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-001c5db900d8785d47c1a5a0c6f32762_1440w-20210902214027681.jpg" alt="img"></p><p>2.在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是说，<strong>代理对象 = 增强代码 + 目标对象（原对象）</strong>。有了代理对象后，就不用原对象了</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-e302487f952bdf8e284afc0d8d6a770b_1440w-20210902214033494.jpg" alt="img"></p><p><strong>静态代理的缺陷</strong></p><p>程序员要手动为每一个目标类编写对应的代理类。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？</p><p><strong>复习对象的创建</strong></p><p>很多初学Java的朋友眼中创建对象的过程</p><p>;<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-9cd31ab516bd967e1b8e68736931f8ba_1440w-20210903091359016.jpg" alt="img"></p><p>实际上可以换个角度，也说得通</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-eddc430b991c58039dfc79dd6f3139cc_1440w-20210903091410216.jpg" alt="img"></p><p>所谓的Class对象，是Class类的实例，而Class类是描述所有类的，比如Person类，Student类</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-c9bf695b1b9d2a0ae01cf92501492159_1440w-20210903091424896.jpg" alt="img"></p><p>可以看出，要创建一个实例，最关键的就是<strong>得到对应的Class对象。</strong>只不过对于初学者来说，new这个关键字配合构造方法，实在太好用了，底层隐藏了太多细节，一句 Person p = new Person();直接把对象返回给你了。我自己刚开始学Java时，也没意识到Class对象的存在。</p><p>分析到这里，貌似有了思路：</p><p><strong>能否不写代理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。</strong></p><p>Class对象包含了一个类的所有信息，比如构造器、方法、字段等。如果我们不写代理类，这些信息从哪获取呢？苦思冥想，突然灵光一现：代理类和目标类理应实现同一组接口。<strong>之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。</strong>还是上面这幅图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-e302487f952bdf8e284afc0d8d6a770b_1440w-20210903091438566.jpg" alt="img"></p><p>所以，可以这样说：接口拥有代理对象和目标对象共同的类信息。所以，我们可以从接口那得到理应由代理类提供的信息。但是别忘了，接口是无法创建对象的，怎么办？</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy，所以我们先聊它。</p><p>Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象。</p><p>用通俗的话说，getProxyClass()这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。打个比方，一个大内太监（接口Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小DD（构造器）…（这到底是道德の沦丧，还是人性的扭曲，欢迎走进动态代理）</p><p>所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-d187a82b1eb9c088fe60327828ee63aa_1440w-20210903091450435.jpg" alt="img"></p><p>大体思路</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-28223a1c03c1800052a5dfe4e6cb8c53_1440w-20210903091507755.jpg" alt="img"></p><p>静态代理</p><p><img src="https://pica.zhimg.com/80/v2-ba3d9206f341be466f18afbdd938a3b3_1440w.jpg?source=1940ef5c" alt="img"></p><p>动态代理</p><p>所以，按我理解，Proxy.getProxyClass()这个方法的本质就是：<strong>以Class造Class。</strong></p><p>有了Class对象，就很好办了，具体看代码：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-6b091b6d41bae1f88ba74a510acb24b1_1440w-20210903091542536.jpg" alt="img"></p><p>完美。</p><p>根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代理对象的方法，最终都会调用InvocationHandler的invoke()方法：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-92610586e77cf71ba5ce89087de52ff1_1440w-20210903091554306.jpg" alt="img"></p><p>怎么做到的呢？</p><p>上面不是说了吗，根据代理Class的构造器创建对象时，需要传入InvocationHandler。<strong>通过构造器传入一个引用，那么必然有个成员变量去接收。</strong>没错，代理对象的内部确实有个成员变量invocationHandler，而且代理对象的每个方法内部都会调用handler.invoke()！InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代理这么直接。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-b5fc8b279a6152889afdfedbb0f611cc_1440w-20210903091605600.jpg" alt="img"></p><p>大家仔细看上图右侧的动态代理，我在invocationHandler的invoke()方法中并没有写目标对象。因为一开始invocationHandler的invoke()里确实没有目标对象，需要我们手动new。<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-88147b81ee9342015374159b2671320b_1440w-20210903091623203.jpg" alt="img"></p><p>但这种写法不够优雅，属于硬编码。我这次代理A对象，下次想代理B对象还要进来改invoke()方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>CalculatorImpl target = <span class="hljs-keyword">new</span> CalculatorImpl();<br>                <span class="hljs-comment">//传入目标对象</span><br>                <span class="hljs-comment">//目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法</span><br>Calculator calculatorProxy = (Calculator) getProxy(target);<br>calculatorProxy.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>calculatorProxy.subtract(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object target)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">//参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口</span><br>Class proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());<br>Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);<br>Object proxy = constructor.newInstance(<span class="hljs-keyword">new</span> InvocationHandler() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法开始执行...&quot;</span>);<br>Object result = method.invoke(target, args);<br>System.out.println(result);<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法执行结束...&quot;</span>);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;);<br><span class="hljs-keyword">return</span> proxy;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你把实例传进来，getProxy()都能给你返回对应的代理对象。就这样，我们完美地跳过了代理类，直接创建了代理对象！</p><p>不过实际编程中，一般不用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理Class对象的过程都帮你隐藏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>CalculatorImpl target = <span class="hljs-keyword">new</span> CalculatorImpl();<br>Calculator calculatorProxy = (Calculator) getProxy(target);<br>calculatorProxy.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>calculatorProxy.subtract(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object target)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Object proxy = Proxy.newProxyInstance(<br>target.getClass().getClassLoader(),<span class="hljs-comment">/*类加载器*/</span><br>target.getClass().getInterfaces(),<span class="hljs-comment">/*让代理对象和目标对象实现相同接口*/</span><br><span class="hljs-keyword">new</span> InvocationHandler()&#123;<span class="hljs-comment">/*代理对象的方法最终都会被JVM导向它的invoke方法*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法开始执行...&quot;</span>);<br>Object result = method.invoke(target, args);<br>System.out.println(result);<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法执行结束...&quot;</span>);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br>);<br><span class="hljs-keyword">return</span> proxy;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我想应该能看懂动态代理了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-6aacbe1e9df4fe982a68fe142401952e_1440w-20210903091644194.jpg" alt="img"></p><p>最后讨论一下代理对象是什么类型。</p><p>首先，请区分两个概念：代理Class对象和代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-bb82bd129d63f77265f51b2209159269_1440w-20210903091702198.jpg" alt="img"></p><p>单从名字看，代理Class和Calculator的接口确实相去甚远，但是我们却能将代理对象赋值给接口类型：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-e869e67fc4fbc708b793ff6ea6e2c012_1440w-20210903091722724.jpg" alt="img"></p><p>千万别觉得名字奇怪，就怀疑它不能用接口接收，只要实现该接口就是该类型。</p><blockquote><p>代理对象的本质就是：和目标对象实现相同接口的实例。代理Class可以叫任何名字，whatever，只要它实现某个接口，就能成为该接口类型。</p></blockquote><p>;<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-91d716b1a95099ad364233de91fca7a3_1440w-20210903091736091.jpg" alt="img"></p><p>我写了一个MyProxy类，那么它的Class名字必然叫MyProxy。<strong>但这和能否赋值给接口没有任何关系。</strong>由于它实现了Serializable和Collection，所以myProxy（代理实例）<strong>同时</strong>是这两个接口的类型。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>我想了个很骚的比喻，希望能解释清楚：</p><p>接口Class对象是大内太监，里面的方法和字段比做他的一身武艺，但是他没有小DD（构造器），所以不能new实例。一身武艺后继无人。</p><p>那怎么办呢？</p><p>正常途径（implements）：</p><p>写一个类，实现该接口。这个就相当于大街上拉了一个人，认他做干爹。一身武艺传给他，只是比他干爹多了小DD，可以new实例。</p><p>非正常途径（动态代理）：</p><p>通过妙手圣医Proxy的克隆大法（Proxy.getProxyClass()），克隆一个Class，但是有小DD。所以这个克隆人Class可以创建实例，也就是代理对象。</p><p>代理Class其实就是附有构造器的接口Class，一样的类结构信息，却能创建实例。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-33094b28321ab388bb0db46608eae74a_1440w-20210903091759099.jpg" alt="img">JDK动态代理生成的实例</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-b99009ee292273a56ab483170b2e20aa_1440w-20210903091819161.jpg" alt="img">CGLib动态代理生成的实例</p><p>如果说继承的父类是亲爹（只有一个），那么实现的接口是干爹（可以有多个）。</p><p>实现接口是一个类认干爹的过程。接口无法创建对象，但实现该接口的类可以。</p><p>比如 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">class Student extends Person implements A, B<br></code></pre></td></tr></table></figure><p>这个类new一个实例出来，你问它：你爸爸是谁啊？它会告诉你：我只有一个爸爸Person。</p><p>但是student instanceof A interface，或者student instanceof B interface，它会告诉你两个都是它干爹（true），都可以用来接收它。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-1c36d27a6a2a49a266a7fc2ed457e532_1440w-20210903091835896.jpg" alt="img"></p><p>然而，凡是有利必有弊。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-991ea99b9038d52875ff6ba57e9032de_1440w-20210903091849332.jpg" alt="img"></p><p>也就是说，动态代理生成的代理对象，最终都可以用接口接收，和目标对象一起形成了多态，可以随意切换展示不同的功能。但是切换的同时，只能使用该接口定义的方法。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java动态代理之InvocationHandler</title>
    <link href="/2019/12/08/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BInvocationHandler/"/>
    <url>/2019/12/08/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BInvocationHandler/</url>
    
    <content type="html"><![CDATA[<p>网上关于Java的动态代理，Proxy和InvocationHandler这些概念有讲解得非常高深的文章。其实这些概念没有那么复杂。现在咱们通过一个最简单的例子认识什么是InvocationHandler。值得一提的是，InvocationHandler在Spring框架实现中被广泛使用，这意味着我们吃透了InvocationHandler，就为将来的Spring源码学习打下一个坚实的基础。</p><p>开发一个接口，包含两个方法，可以向指定的人问候“你好”或者“再见”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHello</span> </span>&#123;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个简单的类，实现这个IHello接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helloimplements</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHello</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot; GoodBye!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费这个实现类，迄今为止没什么特别的。</p><p>现在假设我们接到了这个需求：老板要求在该实现类每次问候某人时，必须把问候的细节记录到日志文件里。为了简单起见，我们在问候前打印下面的一行语句来模拟日志记录的动作。</p><p>System.out.println(“问候之前的日志记录…”);</p><p>您也许会说，这还不简单？直接修改Helloimplements的对应方法，把这行日志插入到对应方法即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183109.png"></p><p>然而，老板的要求是：不允许你修改原来的Helloimplements类。在现实场景中，Helloimplements可能是第三方的jar包提供的，我们没有办法修改代码。</p><p>您也许会说，我们可以用设计模式里的代理模式，即创建一个新的Java类作为代理类，同样实现IHello接口，然后将Helloimplements类的实例传入代理类。我们虽然被要求不允许修改Helloimplements的代码，但是可以把日志记录代码写在代理类里。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHello</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> IHello iHello;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImpl</span><span class="hljs-params">(IHello impl)</span></span>&#123;<br><br>  <span class="hljs-keyword">this</span>.iHello = impl;<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>    System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br><br>    iHello.sayHello(name);<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>     System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br><br>     iHello.sayGoogBye(name);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br><br>     Helloimplements hello = <span class="hljs-keyword">new</span> Helloimplements();<br><br>     StaticProxy proxy = <span class="hljs-keyword">new</span> StaticProxy();<br><br>     proxy.setImpl(hello);<br><br>     proxy.sayHello(<span class="hljs-string">&quot;Jerry&quot;</span>);<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种做法能够实现需求：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183127.png"></p><p>下面我们再看如何用InvocationHandler实现同样的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">InvocationHandler是一个JDK提供的标准接口。看下面的代码：<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynaProxyHello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object delegate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">bind</span><span class="hljs-params">(Object delegate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.delegate = delegate;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>        <span class="hljs-keyword">this</span>.delegate.getClass().getClassLoader(), <span class="hljs-keyword">this</span>.delegate<br>        .getClass().getInterfaces(), <span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br>            <span class="hljs-comment">// JVM通过这条语句执行原来的方法(反射机制)</span><br>            result = method.invoke(<span class="hljs-keyword">this</span>.delegate, args);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面代码里的bind方法很想我之前代理类StaticProxy的setImpl方法，只不过这个bind方法的输入参数类型更加通用。日志记录的代码写在方法invoke里。</p><p>看看如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>    DynaProxyHello helloproxy = <span class="hljs-keyword">new</span> DynaProxyHello();<br>    Helloimplements hello = <span class="hljs-keyword">new</span> Helloimplements();<br>    IHello ihello = (IHello) helloproxy.bind(hello);<br>    ihello.sayHello(<span class="hljs-string">&quot;Jerry&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行效果和StaticProxy那种解决方案完全一致。</p><p>咱们先来调试一下。当bind方法执行时，方法Proxy.newProxyInstance被调用，Helloimplements类的实例被传入。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183142.png"></p><p>我们在调试器里观察IHello ihello = (IHello) helloproxy.bind(hello)这行语句返回的ihello变量。虽然它的静态类型是IHello，但请注意，在调试器里观察它的实际类型，并不是Helloimplements的实例，而是JVM给我们加过工的，包含了我们在invoke方法里手写的那行日志记录代码。这个ihello类型为$Proxy0。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183155.png"></p><p>当这个被JVM加过工的变量的sayHello方法被调用时，JVM自动将调用转交到DynaProxyHello.invoke去：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183208.png"></p><p>于是，在invoke方法里，我们手写的日志记录代码被执行，然后通过Java反射执行原始的sayHello代码。</p><p>有的朋友可能会问，你这个InvocationHandler看起来比静态代理StaticProxy还复杂啊？有什么好处？</p><p>假设老板的需求又变了，在调用问候和说再见的方法里，要使用不同的日志记录策略。</p><p>看看用InvocationHandler如何优雅实现吧：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183221.png"></p><p>希望这个例子能让大家对Java的动态代理之InvocationHandler有了最基本的了解。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负数 &gt;&gt;&gt;运算符的计算过程</title>
    <link href="/2019/09/27/%E8%B4%9F%E6%95%B0%3E%3E%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/09/27/%E8%B4%9F%E6%95%B0%3E%3E%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>“&gt;&gt;&gt;” 表示无符号右移,正数情况下, a &gt;&gt;&gt; b 等价于 a / Math.pow(2,b)</p><p>以 -16 &gt;&gt;&gt; 2 为例子 负16右移2位</p><ol><li>将-16转为2进制 (用补码表示负数)<ul><li>16 = 00000000 00000000 00000000 00010000</li><li>取反并补码 = 11111111 11111111 11111111 11101111 + 1 = 11111111 11111111 11111111 11110000</li><li>右移2位 = 00111111 11111111 11111111 11111100 = 10进制 1073741820</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
