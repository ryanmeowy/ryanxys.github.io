<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>rabbitmq delay queue</title>
    <link href="/2021/08/29/rabbitmq%20delay%20queue/"/>
    <url>/2021/08/29/rabbitmq%20delay%20queue/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><p>在上一篇中，介绍了RabbitMQ中的死信队列是什么，何时使用以及如何使用RabbitMQ的死信队列。相信通过上一篇的学习，对于死信队列已经有了更多的了解，这一篇的内容也跟死信队列息息相关，如果你还不了解死信队列，那么建议你先进行上一篇文章的阅读。</p><p>这一篇里，我们将继续介绍RabbitMQ的高级特性，通过本篇的学习，你将收获：</p><ol><li>什么是延时队列</li><li>延时队列使用场景</li><li>RabbitMQ中的TTL</li><li>如何利用RabbitMQ来实现延时队列</li></ol><h3 id="二、本文大纲"><a href="#二、本文大纲" class="headerlink" title="二、本文大纲"></a>二、本文大纲</h3><p>以下是本文大纲：</p><p><a href="https://i.loli.net/2019/07/28/5d3d74d99699d43032.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047092.png" alt="1.png"></a></p><p>本文阅读前，需要对RabbitMQ以及死信队列有一个简单的了解。</p><h3 id="三、什么是延时队列"><a href="#三、什么是延时队列" class="headerlink" title="三、什么是延时队列"></a>三、什么是延时队列</h3><p><code>延时队列</code>，首先，它是一种队列，队列意味着内部的元素是<code>有序</code>的，元素出队和入队是有方向性的，元素从一端进入，从另一端取出。</p><p>其次，<code>延时队列</code>，最重要的特性就体现在它的<code>延时</code>属性上，跟普通的队列不一样的是，<code>普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理</code>，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。</p><p>简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p><h3 id="四、延时队列使用场景"><a href="#四、延时队列使用场景" class="headerlink" title="四、延时队列使用场景"></a>四、延时队列使用场景</h3><p>那么什么时候需要用延时队列呢？考虑一下以下场景：</p><ol><li>订单在十分钟之内未支付则自动取消。</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>账单在一周内未支付，则自动结算。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。</li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；发生店铺创建事件，十天后检查该店铺上新商品数，然后通知上新数为0的商户；发生账单生成事件，检查账单支付状态，然后自动结算未支付的账单；发生新用户注册事件，三天后检查新注册用户的活动数据，然后通知没有任何活动记录的用户；发生退款事件，在三天之后检查该订单是否已被处理，如仍未被处理，则发送消息给相关运营人员；发生预定会议事件，判断离会议开始是否只有十分钟了，如果是，则通知各个与会人员。</p><p>看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><p>更重要的一点是，不！优！雅！</p><p>没错，作为一名有追求的程序员，始终应该追求更优雅的架构和更优雅的代码风格，写代码要像写诗一样优美。【滑稽】</p><p>这时候，延时队列就可以闪亮登场了，以上场景，正是延时队列的用武之地。</p><p>既然<code>延时队列</code>可以解决很多特定场景下，带时间属性的任务需求，那么如何构造一个延时队列呢？接下来，本文将介绍如何用RabbitMQ来实现延时队列。</p><h3 id="五、RabbitMQ中的TTL"><a href="#五、RabbitMQ中的TTL" class="headerlink" title="五、RabbitMQ中的TTL"></a>五、RabbitMQ中的TTL</h3><p>在介绍延时队列之前，还需要先介绍一下RabbitMQ中的一个高级特性——<code>TTL（Time To Live）</code>。</p><p><code>TTL</code>是什么呢？<code>TTL</code>是RabbitMQ中一个消息或者队列的属性，表明<code>一条消息或者该队列中的所有消息的最大存活时间</code>，单位是毫秒。换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为“死信”（至于什么是死信，请翻看上一篇）。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。</p><p>那么，如何设置这个TTL值呢？有两种方式，第一种是在创建队列的时候设置队列的“x-message-ttl”属性，如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br>args.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">6000</span>);<br>channel.queueDeclare(queueName, durable, exclusive, autoDelete, args);<br></code></pre></div></td></tr></table></figure><p>这样所有被投递到该队列的消息都最多不会存活超过6s。</p><p>另一种方式便是针对每条消息设置TTL，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">AMQP.BasicProperties.Builder builder = <span class="hljs-keyword">new</span> AMQP.BasicProperties.Builder();<br>builder.expiration(<span class="hljs-string">&quot;6000&quot;</span>);<br>AMQP.BasicProperties properties = builder.build();<br>channel.basicPublish(exchangeName, routingKey, mandatory, properties, <span class="hljs-string">&quot;msg body&quot;</span>.getBytes());<br></code></pre></div></td></tr></table></figure><p>这样这条消息的过期时间也被设置成了6s。</p><p>但这两种方式是有区别的，<strong>如果设置了队列的TTL属性，那么一旦消息过期，就会被队列丢弃，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。</strong></p><p>另外，还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p><h3 id="六、如何利用RabbitMQ实现延时队列"><a href="#六、如何利用RabbitMQ实现延时队列" class="headerlink" title="六、如何利用RabbitMQ实现延时队列"></a>六、如何利用RabbitMQ实现延时队列</h3><p>前一篇里介绍了如果设置死信队列，前文中又介绍了TTL，至此，利用RabbitMQ实现延时队列的两大要素已经集齐，接下来只需要将它们进行调和，再加入一点点调味料，延时队列就可以新鲜出炉了。</p><p>想想看，<code>延时队列</code>，不就是想要消息延迟多久被处理吗，TTL则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就万事大吉了，因为里面的消息都是希望被立即处理的消息。</p><p>从下图可以大致看出消息的流向：</p><p><a href="https://i.loli.net/2019/07/28/5d3d743143ecc85643.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047108.png" alt="23.png"></a></p><p>生产者生产一条延时消息，根据需要延时时间的不同，利用不同的routingkey将消息路由到不同的延时队列，每个队列都设置了不同的TTL属性，并绑定在同一个死信交换机中，消息过期后，根据routingkey的不同，又会被路由到不同的死信队列中，消费者只需要监听对应的死信队列进行处理即可。</p><p>下面来看代码：</p><p>先声明交换机、队列以及他们的绑定关系：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAY_EXCHANGE_NAME = <span class="hljs-string">&quot;delay.queue.demo.business.exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAY_QUEUEA_NAME = <span class="hljs-string">&quot;delay.queue.demo.business.queuea&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAY_QUEUEB_NAME = <span class="hljs-string">&quot;delay.queue.demo.business.queueb&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAY_QUEUEA_ROUTING_KEY = <span class="hljs-string">&quot;delay.queue.demo.business.queuea.routingkey&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAY_QUEUEB_ROUTING_KEY = <span class="hljs-string">&quot;delay.queue.demo.business.queueb.routingkey&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_EXCHANGE = <span class="hljs-string">&quot;delay.queue.demo.deadletter.exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUEA_ROUTING_KEY = <span class="hljs-string">&quot;delay.queue.demo.deadletter.delay_10s.routingkey&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUEB_ROUTING_KEY = <span class="hljs-string">&quot;delay.queue.demo.deadletter.delay_60s.routingkey&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUEA_NAME = <span class="hljs-string">&quot;delay.queue.demo.deadletter.queuea&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUEB_NAME = <span class="hljs-string">&quot;delay.queue.demo.deadletter.queueb&quot;</span>;<br><br>    <span class="hljs-comment">// 声明延时Exchange</span><br>    <span class="hljs-meta">@Bean(&quot;delayExchange&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">delayExchange</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DELAY_EXCHANGE_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信Exchange</span><br>    <span class="hljs-meta">@Bean(&quot;deadLetterExchange&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">deadLetterExchange</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DEAD_LETTER_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明延时队列A 延时10s</span><br>    <span class="hljs-comment">// 并绑定到对应的死信交换机</span><br>    <span class="hljs-meta">@Bean(&quot;delayQueueA&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">delayQueueA</span><span class="hljs-params">()</span></span>&#123;<br>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span><br>        args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);<br>        <span class="hljs-comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span><br>        args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEA_ROUTING_KEY);<br>        <span class="hljs-comment">// x-message-ttl  声明队列的TTL</span><br>        args.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">6000</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(DELAY_QUEUEA_NAME).withArguments(args).build();<br>    &#125;<br><br>    <span class="hljs-comment">// 声明延时队列B 延时 60s</span><br>    <span class="hljs-comment">// 并绑定到对应的死信交换机</span><br>    <span class="hljs-meta">@Bean(&quot;delayQueueB&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">delayQueueB</span><span class="hljs-params">()</span></span>&#123;<br>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span><br>        args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);<br>        <span class="hljs-comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span><br>        args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEB_ROUTING_KEY);<br>        <span class="hljs-comment">// x-message-ttl  声明队列的TTL</span><br>        args.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">60000</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(DELAY_QUEUEB_NAME).withArguments(args).build();<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信队列A 用于接收延时10s处理的消息</span><br>    <span class="hljs-meta">@Bean(&quot;deadLetterQueueA&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">deadLetterQueueA</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(DEAD_LETTER_QUEUEA_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信队列B 用于接收延时60s处理的消息</span><br>    <span class="hljs-meta">@Bean(&quot;deadLetterQueueB&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">deadLetterQueueB</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(DEAD_LETTER_QUEUEB_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明延时队列A绑定关系</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">delayBindingA</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;delayQueueA&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@Qualifier(&quot;delayExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEA_ROUTING_KEY);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明业务队列B绑定关系</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">delayBindingB</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;delayQueueB&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@Qualifier(&quot;delayExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEB_ROUTING_KEY);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信队列A绑定关系</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">deadLetterBindingA</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;deadLetterQueueA&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信队列B绑定关系</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">deadLetterBindingB</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;deadLetterQueueB&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来，创建两个消费者，分别对两个死信队列的消息进行消费：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLetterQueueConsumer</span> </span>&#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveA</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String msg = <span class="hljs-keyword">new</span> String(message.getBody());<br>        log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,死信队列A收到消息：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> Date().toString(), msg);<br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveB</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String msg = <span class="hljs-keyword">new</span> String(message.getBody());<br>        log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,死信队列B收到消息：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> Date().toString(), msg);<br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后是消息的生产者：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayMessageSender</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg, DelayTypeEnum type)</span></span>&#123;<br>        <span class="hljs-keyword">switch</span> (type)&#123;<br>            <span class="hljs-keyword">case</span> DELAY_10s:<br>                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEA_ROUTING_KEY, msg);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> DELAY_60s:<br>                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEB_ROUTING_KEY, msg);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来，我们暴露一个web接口来生产消息：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;rabbitmq&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQMsgController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DelayMessageSender sender;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;sendmsg&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg, Integer delayType)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,收到请求，msg:&#123;&#125;,delayType:&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> Date(), msg, delayType);<br>        sender.sendMsg(msg, Objects.requireNonNull(DelayTypeEnum.getDelayTypeEnumByValue(delayType)));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>准备就绪，启动！</p><p>打开rabbitMQ的<a href="http://localhost:15672/">管理后台</a>，可以看到我们刚才创建的交换机和队列信息：</p><p><a href="https://i.loli.net/2019/07/28/5d3d54e15534398514.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047837.png" alt="2.png"></a></p><p><a href="https://i.loli.net/2019/07/28/5d3d54e17df8183993.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047418.png" alt="4.png"></a></p><p><a href="https://i.loli.net/2019/07/28/5d3d54e16952546955.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047065.png" alt="3.png"></a></p><p>接下来，我们来发送几条消息</p><p><a href="http://localhost:8080/rabbitmq/sendmsg?msg=testMsg1&amp;delayType=1">http://localhost:8080/rabbitmq/sendmsg?msg=testMsg1&amp;delayType=1</a></p><p> <a href="http://localhost:8080/rabbitmq/sendmsg?msg=testMsg2&amp;delayType=2">http://localhost:8080/rabbitmq/sendmsg?msg=testMsg2&amp;delayType=2</a></p><p>日志如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">02</span>:<span class="hljs-number">19.813</span>  INFO <span class="hljs-number">3860</span> --- <span class="hljs-selector-attr">[nio-8080-exec-9]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.RabbitMQMsgController</span>   : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">02</span>:<span class="hljs-number">19</span> CST <span class="hljs-number">2019</span>,收到请求，msg:testMsg1,delayType:<span class="hljs-number">1</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">02</span>:<span class="hljs-number">19.815</span>  INFO <span class="hljs-number">3860</span> --- <span class="hljs-selector-attr">[nio-8080-exec-9]</span> <span class="hljs-selector-class">.l</span><span class="hljs-selector-class">.DirectReplyToMessageListenerContainer</span> : SimpleConsumer <span class="hljs-selector-attr">[queue=amq.rabbitmq.reply-to, consumerTag=amq.ctag-o-qPpkWIkRm73DIrOIVhig identity=766339]</span> started<br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">02</span>:<span class="hljs-number">25.829</span>  INFO <span class="hljs-number">3860</span> --- <span class="hljs-selector-attr">[ntContainer#1-1]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.mq</span><span class="hljs-selector-class">.DeadLetterQueueConsumer</span>         : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">02</span>:<span class="hljs-number">25</span> CST <span class="hljs-number">2019</span>,死信队列A收到消息：testMsg1<br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">02</span>:<span class="hljs-number">41.326</span>  INFO <span class="hljs-number">3860</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.RabbitMQMsgController</span>   : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">02</span>:<span class="hljs-number">41</span> CST <span class="hljs-number">2019</span>,收到请求，msg:testMsg2,delayType:<span class="hljs-number">2</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">03</span>:<span class="hljs-number">41.329</span>  INFO <span class="hljs-number">3860</span> --- <span class="hljs-selector-attr">[ntContainer#0-1]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.mq</span><span class="hljs-selector-class">.DeadLetterQueueConsumer</span>         : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">03</span>:<span class="hljs-number">41</span> CST <span class="hljs-number">2019</span>,死信队列B收到消息：testMsg2<br></code></pre></div></td></tr></table></figure><p>第一条消息在6s后变成了死信消息，然后被消费者消费掉，第二条消息在60s之后变成了死信消息，然后被消费掉，这样，一个还算ok的延时队列就打造完成了。</p><p>不过，等等，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有6s和60s两个时间选项，如果需要一个小时后处理，那么就需要增加TTL为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？？</p><p>嗯，仔细想想，事情并不简单。</p><h3 id="七、RabbitMQ延时队列优化"><a href="#七、RabbitMQ延时队列优化" class="headerlink" title="七、RabbitMQ延时队列优化"></a>七、RabbitMQ延时队列优化</h3><p>显然，需要一种更通用的方案才能满足需求，那么就只能将TTL设置在消息属性里了。我们来试一试。</p><p>增加一个延时队列，用于接收设置为任意延时时长的消息，增加一个相应的死信队列和routingkey：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAY_EXCHANGE_NAME = <span class="hljs-string">&quot;delay.queue.demo.business.exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAY_QUEUEC_NAME = <span class="hljs-string">&quot;delay.queue.demo.business.queuec&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAY_QUEUEC_ROUTING_KEY = <span class="hljs-string">&quot;delay.queue.demo.business.queuec.routingkey&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_EXCHANGE = <span class="hljs-string">&quot;delay.queue.demo.deadletter.exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUEC_ROUTING_KEY = <span class="hljs-string">&quot;delay.queue.demo.deadletter.delay_anytime.routingkey&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUEC_NAME = <span class="hljs-string">&quot;delay.queue.demo.deadletter.queuec&quot;</span>;<br><br>    <span class="hljs-comment">// 声明延时Exchange</span><br>    <span class="hljs-meta">@Bean(&quot;delayExchange&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">delayExchange</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DELAY_EXCHANGE_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信Exchange</span><br>    <span class="hljs-meta">@Bean(&quot;deadLetterExchange&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">deadLetterExchange</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DEAD_LETTER_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明延时队列C 不设置TTL</span><br>    <span class="hljs-comment">// 并绑定到对应的死信交换机</span><br>    <span class="hljs-meta">@Bean(&quot;delayQueueC&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">delayQueueC</span><span class="hljs-params">()</span></span>&#123;<br>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span><br>        args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);<br>        <span class="hljs-comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span><br>        args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEC_ROUTING_KEY);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(DELAY_QUEUEC_NAME).withArguments(args).build();<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信队列C 用于接收延时任意时长处理的消息</span><br>    <span class="hljs-meta">@Bean(&quot;deadLetterQueueC&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">deadLetterQueueC</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(DEAD_LETTER_QUEUEC_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明延时列C绑定关系</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">delayBindingC</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;delayQueueC&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-meta">@Qualifier(&quot;delayExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEC_ROUTING_KEY);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信队列C绑定关系</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">deadLetterBindingC</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;deadLetterQueueC&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEC_ROUTING_KEY);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>增加一个死信队列C的消费者：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = DEAD_LETTER_QUEUEC_NAME)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveC</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    String msg = <span class="hljs-keyword">new</span> String(message.getBody());<br>    log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,死信队列C收到消息：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> Date().toString(), msg);<br>    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>再次启动！然后访问：<a href="http://localhost:8080/rabbitmq/delayMsg?msg=testMsg1delayTime=5000">http://localhost:8080/rabbitmq/delayMsg?msg=testMsg1delayTime=5000</a> 来生产消息，注意这里的单位是毫秒。</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">45</span>:<span class="hljs-number">07.033</span>  INFO <span class="hljs-number">31468</span> --- <span class="hljs-selector-attr">[nio-8080-exec-4]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.RabbitMQMsgController</span>   : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">45</span>:<span class="hljs-number">07</span> CST <span class="hljs-number">2019</span>,收到请求，msg:testMsg1,delayTime:<span class="hljs-number">5000</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">45</span>:<span class="hljs-number">11.694</span>  INFO <span class="hljs-number">31468</span> --- <span class="hljs-selector-attr">[nio-8080-exec-5]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.RabbitMQMsgController</span>   : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">45</span>:<span class="hljs-number">11</span> CST <span class="hljs-number">2019</span>,收到请求，msg:testMsg2,delayTime:<span class="hljs-number">5000</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">45</span>:<span class="hljs-number">12.048</span>  INFO <span class="hljs-number">31468</span> --- <span class="hljs-selector-attr">[ntContainer#1-1]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.mq</span><span class="hljs-selector-class">.DeadLetterQueueConsumer</span>         : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">45</span>:<span class="hljs-number">12</span> CST <span class="hljs-number">2019</span>,死信队列C收到消息：testMsg1<br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">45</span>:<span class="hljs-number">16.709</span>  INFO <span class="hljs-number">31468</span> --- <span class="hljs-selector-attr">[ntContainer#1-1]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.mq</span><span class="hljs-selector-class">.DeadLetterQueueConsumer</span>         : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">45</span>:<span class="hljs-number">16</span> CST <span class="hljs-number">2019</span>,死信队列C收到消息：testMsg2<br></code></pre></div></td></tr></table></figure><p>看起来似乎没什么问题，但不要高兴的太早，在最开始的时候，就介绍过，如果使用在消息属性上设置TTL的方式，消息可能并不会按时“死亡“，因为RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列，索引如果第一个消息的延时时长很长，而第二个消息的延时时长很短，则第二个消息并不会优先得到执行。</p><p>实验一下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">49</span>:<span class="hljs-number">02.957</span>  INFO <span class="hljs-number">31468</span> --- <span class="hljs-selector-attr">[nio-8080-exec-8]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.RabbitMQMsgController</span>   : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">49</span>:<span class="hljs-number">02</span> CST <span class="hljs-number">2019</span>,收到请求，msg:longDelayedMsg,delayTime:<span class="hljs-number">20000</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">49</span>:<span class="hljs-number">10.671</span>  INFO <span class="hljs-number">31468</span> --- <span class="hljs-selector-attr">[nio-8080-exec-9]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.RabbitMQMsgController</span>   : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">49</span>:<span class="hljs-number">10</span> CST <span class="hljs-number">2019</span>,收到请求，msg:shortDelayedMsg,delayTime:<span class="hljs-number">2000</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">49</span>:<span class="hljs-number">22.969</span>  INFO <span class="hljs-number">31468</span> --- <span class="hljs-selector-attr">[ntContainer#1-1]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.mq</span><span class="hljs-selector-class">.DeadLetterQueueConsumer</span>         : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">49</span>:<span class="hljs-number">22</span> CST <span class="hljs-number">2019</span>,死信队列C收到消息：longDelayedMsg<br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">49</span>:<span class="hljs-number">22.970</span>  INFO <span class="hljs-number">31468</span> --- <span class="hljs-selector-attr">[ntContainer#1-1]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.mq</span><span class="hljs-selector-class">.DeadLetterQueueConsumer</span>         : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">16</span>:<span class="hljs-number">49</span>:<span class="hljs-number">22</span> CST <span class="hljs-number">2019</span>,死信队列C收到消息：shortDelayedMsg<br></code></pre></div></td></tr></table></figure><p>我们先发了一个延时时长为20s的消息，然后发了一个延时时长为2s的消息，结果显示，第二个消息会在等第一个消息成为死信后才会“死亡“。</p><h3 id="八、利用RabbitMQ插件实现延迟队列"><a href="#八、利用RabbitMQ插件实现延迟队列" class="headerlink" title="八、利用RabbitMQ插件实现延迟队列"></a>八、利用RabbitMQ插件实现延迟队列</h3><p>上文中提到的问题，确实是一个硬伤，如果不能实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡，就无法设计成一个通用的延时队列。</p><p>那如何解决这个问题呢？不要慌，安装一个插件即可：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> ，下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。</p><p>接下来，进入RabbitMQ的安装目录下的sbin目录，执行下面命令让该插件生效，然后重启RabbitMQ。</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">rabbitmq-plugins <span class="hljs-builtin-name">enable</span> rabbitmq_delayed_message_exchange<br></code></pre></div></td></tr></table></figure><p>然后，我们再声明几个Bean：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedRabbitMQConfig</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAYED_QUEUE_NAME = <span class="hljs-string">&quot;delay.queue.demo.delay.queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="hljs-string">&quot;delay.queue.demo.delay.exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELAYED_ROUTING_KEY = <span class="hljs-string">&quot;delay.queue.demo.delay.routingkey&quot;</span>;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">immediateQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(DELAYED_QUEUE_NAME);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CustomExchange <span class="hljs-title">customExchange</span><span class="hljs-params">()</span> </span>&#123;<br>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        args.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class="hljs-string">&quot;x-delayed-message&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">bindingNotify</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;immediateQueue&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-meta">@Qualifier(&quot;customExchange&quot;)</span> CustomExchange customExchange)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>controller层再添加一个入口：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;delayMsg2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delayMsg2</span><span class="hljs-params">(String msg, Integer delayTime)</span> </span>&#123;<br>    log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,收到请求，msg:&#123;&#125;,delayTime:&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> Date(), msg, delayTime);<br>    sender.sendDelayMsg(msg, delayTime);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>消息生产者的代码也需要修改：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendDelayMsg</span><span class="hljs-params">(String msg, Integer delayTime)</span> </span>&#123;<br>    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, a -&gt;&#123;<br>        a.getMessageProperties().setDelay(delayTime);<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后，再创建一个消费者：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveD</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    String msg = <span class="hljs-keyword">new</span> String(message.getBody());<br>    log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,延时队列收到消息：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> Date().toString(), msg);<br>    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一切准备就绪，启动！然后分别访问以下链接：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8080</span>/rabbitmq/delayMsg<span class="hljs-number">2</span>?msg=msg<span class="hljs-number">1</span>&amp;delayTime=<span class="hljs-number">20000</span><br><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8080</span>/rabbitmq/delayMsg<span class="hljs-number">2</span>?msg=msg<span class="hljs-number">2</span>&amp;delayTime=<span class="hljs-number">2000</span><br></code></pre></div></td></tr></table></figure><p>日志如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">17</span>:<span class="hljs-number">28</span>:<span class="hljs-number">13.729</span>  INFO <span class="hljs-number">25804</span> --- <span class="hljs-selector-attr">[nio-8080-exec-2]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.RabbitMQMsgController</span>   : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">17</span>:<span class="hljs-number">28</span>:<span class="hljs-number">13</span> CST <span class="hljs-number">2019</span>,收到请求，msg:msg1,delayTime:<span class="hljs-number">20000</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">17</span>:<span class="hljs-number">28</span>:<span class="hljs-number">20.607</span>  INFO <span class="hljs-number">25804</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.RabbitMQMsgController</span>   : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">17</span>:<span class="hljs-number">28</span>:<span class="hljs-number">20</span> CST <span class="hljs-number">2019</span>,收到请求，msg:msg2,delayTime:<span class="hljs-number">2000</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">17</span>:<span class="hljs-number">28</span>:<span class="hljs-number">22.624</span>  INFO <span class="hljs-number">25804</span> --- <span class="hljs-selector-attr">[ntContainer#1-1]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.mq</span><span class="hljs-selector-class">.DeadLetterQueueConsumer</span>         : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">17</span>:<span class="hljs-number">28</span>:<span class="hljs-number">22</span> CST <span class="hljs-number">2019</span>,延时队列收到消息：msg2<br><span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">17</span>:<span class="hljs-number">28</span>:<span class="hljs-number">33.751</span>  INFO <span class="hljs-number">25804</span> --- <span class="hljs-selector-attr">[ntContainer#1-1]</span> c<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.mq</span><span class="hljs-selector-class">.DeadLetterQueueConsumer</span>         : 当前时间：Sun Jul <span class="hljs-number">28</span> <span class="hljs-number">17</span>:<span class="hljs-number">28</span>:<span class="hljs-number">33</span> CST <span class="hljs-number">2019</span>,延时队列收到消息：msg1<br></code></pre></div></td></tr></table></figure><p>第二个消息被先消费掉了，符合预期。至此，RabbitMQ实现延时队列的部分就完结了。</p><h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>延时队列在需要延时处理的场景下非常有用，使用RabbitMQ来实现延时队列可以很好的利用RabbitMQ的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过RabbitMQ集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用Java的DelayQueu，利用Redis的zset，利用Quartz或者利用kafka的时间轮，这些方式各有特点，但就像炉石传说一般，这些知识就好比手里的卡牌，知道的越多，可以用的卡牌也就越多，遇到问题便能游刃有余，所以需要大量的知识储备和经验积累才能打造出更出色的卡牌组合，让自己解决问题的能力得到更好的提升。</p><p>但另一方面，随着时间的流逝和阅历的增长，越来越感觉到自己的能力有限，无法独自面对纷繁复杂且多变的业务需求，在很多方面需要其他人的协助才能很好的完成任务。也知道闻道有先后，术业有专攻，不会再狂妄自大，觉得自己能把所有事情都搞定，也将重心慢慢转移到研究如何有效的进行团队合作上来，我相信一个高度协调的团队永远比一个人战斗要更有价值。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rabbitmq</tag>
      
      <tag>延时队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmq dead queue</title>
    <link href="/2021/08/28/rabbitmq%20dead%20queue/"/>
    <url>/2021/08/28/rabbitmq%20dead%20queue/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><p>RabbitMQ是流行的开源消息队列系统，使用erlang语言开发，由于其社区活跃度高，维护更新较快，性能稳定，深得很多企业的欢心（当然，也包括我现在所在公司【手动滑稽】）。</p><p>为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。但由于对死信队列的概念及配置不熟悉，导致曾一度陷入百度的汪洋大海，无法自拔，很多文章都看起来可行，但是实际上却并不能帮我解决实际问题。最终，在官网文档中找到了我想要的答案，通过官网文档的学习，才发现对于死信队列存在一些误解，导致配置死信队列之路困难重重。</p><p>于是本着记录和分享的精神，将死信队列的概念和配置完整的写下来，以便帮助遇到同样问题的朋友。</p><h3 id="二、本文大纲"><a href="#二、本文大纲" class="headerlink" title="二、本文大纲"></a>二、本文大纲</h3><p>以下是本文大纲：</p><p><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140349282-672707323.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250041944.png" alt="img"></a></p><p>本文阅读前，需要对RabbitMQ有一个简单的了解，偏向实战配置讲解。</p><h3 id="三、死信队列是什么"><a href="#三、死信队列是什么" class="headerlink" title="三、死信队列是什么"></a>三、死信队列是什么</h3><p>死信，在官网中对应的单词为“Dead Letter”，可以看出翻译确实非常的简单粗暴。那么死信是个什么东西呢？</p><p>“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：</p><ol><li>消息被否定确认，使用 <code>channel.basicNack</code> 或 <code>channel.basicReject</code> ，并且此时<code>requeue</code> 属性被设置为<code>false</code>。</li><li>消息在队列的存活时间超过设置的TTL时间。</li><li>消息队列的消息数量已经超过最大队列长度。</li></ol><p>那么该消息将成为“死信”。</p><p>“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。</p><h3 id="四、如何配置死信队列"><a href="#四、如何配置死信队列" class="headerlink" title="四、如何配置死信队列"></a>四、如何配置死信队列</h3><p>这一部分将是本文的关键，如何配置死信队列呢？其实很简单，大概可以分为以下步骤：</p><ol><li>配置业务队列，绑定到业务交换机上</li><li>为业务队列配置死信交换机和路由key</li><li>为死信交换机配置死信队列</li></ol><p>注意，并不是直接声明一个公共的死信队列，然后所以死信消息就自己跑到死信队列里去了。而是为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然后为每个业务队列分配一个单独的路由key。</p><p>有了死信交换机和路由key后，接下来，就像配置业务队列一样，配置死信队列，然后绑定在死信交换机上。也就是说，死信队列并不是什么特殊的队列，只不过是绑定在死信交换机上的队列。死信交换机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、Fanout、Topic】。一般来说，会为每个业务队列分配一个独有的路由key，并对应的配置一个死信队列进行监听，也就是说，一般会为每个重要的业务队列配置一个死信队列。</p><p>有了前文这些陈述后，接下来就是惊险刺激的实战环节，这里省略了RabbitMQ环境的部署和搭建环节。</p><p>先创建一个Springboot项目。然后在pom文件中添加 <code>spring-boot-starter-amqp</code> 和 <code>spring-boot-starter-web</code> 的依赖，接下来创建一个Config类，这里是关键：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BUSINESS_EXCHANGE_NAME = <span class="hljs-string">&quot;dead.letter.demo.simple.business.exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BUSINESS_QUEUEA_NAME = <span class="hljs-string">&quot;dead.letter.demo.simple.business.queuea&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BUSINESS_QUEUEB_NAME = <span class="hljs-string">&quot;dead.letter.demo.simple.business.queueb&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_EXCHANGE = <span class="hljs-string">&quot;dead.letter.demo.simple.deadletter.exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUEA_ROUTING_KEY = <span class="hljs-string">&quot;dead.letter.demo.simple.deadletter.queuea.routingkey&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUEB_ROUTING_KEY = <span class="hljs-string">&quot;dead.letter.demo.simple.deadletter.queueb.routingkey&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUEA_NAME = <span class="hljs-string">&quot;dead.letter.demo.simple.deadletter.queuea&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUEB_NAME = <span class="hljs-string">&quot;dead.letter.demo.simple.deadletter.queueb&quot;</span>;<br><br>    <span class="hljs-comment">// 声明业务Exchange</span><br>    <span class="hljs-meta">@Bean(&quot;businessExchange&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">businessExchange</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(BUSINESS_EXCHANGE_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信Exchange</span><br>    <span class="hljs-meta">@Bean(&quot;deadLetterExchange&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">deadLetterExchange</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DEAD_LETTER_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明业务队列A</span><br>    <span class="hljs-meta">@Bean(&quot;businessQueueA&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">businessQueueA</span><span class="hljs-params">()</span></span>&#123;<br>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span><br>        args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);<br><span class="hljs-comment">//       x-dead-letter-routing-key  这里声明当前队列的死信路由key</span><br>        args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEA_ROUTING_KEY);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(BUSINESS_QUEUEA_NAME).withArguments(args).build();<br>    &#125;<br><br>    <span class="hljs-comment">// 声明业务队列B</span><br>    <span class="hljs-meta">@Bean(&quot;businessQueueB&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">businessQueueB</span><span class="hljs-params">()</span></span>&#123;<br>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span><br>        args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);<br><span class="hljs-comment">//       x-dead-letter-routing-key  这里声明当前队列的死信路由key</span><br>        args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEB_ROUTING_KEY);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(BUSINESS_QUEUEB_NAME).withArguments(args).build();<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信队列A</span><br>    <span class="hljs-meta">@Bean(&quot;deadLetterQueueA&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">deadLetterQueueA</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(DEAD_LETTER_QUEUEA_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信队列B</span><br>    <span class="hljs-meta">@Bean(&quot;deadLetterQueueB&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">deadLetterQueueB</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(DEAD_LETTER_QUEUEB_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明业务队列A绑定关系</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">businessBindingA</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;businessQueueA&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@Qualifier(&quot;businessExchange&quot;)</span> FanoutExchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明业务队列B绑定关系</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">businessBindingB</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;businessQueueB&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@Qualifier(&quot;businessExchange&quot;)</span> FanoutExchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信队列A绑定关系</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">deadLetterBindingA</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;deadLetterQueueA&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明死信队列B绑定关系</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">deadLetterBindingB</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;deadLetterQueueB&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里声明了两个Exchange，一个是业务Exchange，另一个是死信Exchange，业务Exchange下绑定了两个业务队列，业务队列都配置了同一个死信Exchange，并分别配置了路由key，在死信Exchange下绑定了两个死信队列，设置的路由key分别为业务队列里配置的路由key。</p><p>下面是配置文件application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs YML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">simple</span><br>      <span class="hljs-attr">simple:</span><br>          <span class="hljs-attr">default-requeue-rejected:</span> <span class="hljs-literal">false</span><br>          <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span><br></code></pre></div></td></tr></table></figure><p>这里记得将<code>default-requeue-rejected</code>属性设置为false。</p><p>接下来，是业务队列的消费代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusinessMessageReceiver</span> </span>&#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = BUSINESS_QUEUEA_NAME)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveA</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String msg = <span class="hljs-keyword">new</span> String(message.getBody());<br>        log.info(<span class="hljs-string">&quot;收到业务消息A：&#123;&#125;&quot;</span>, msg);<br>        <span class="hljs-keyword">boolean</span> ack = <span class="hljs-keyword">true</span>;<br>        Exception exception = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (msg.contains(<span class="hljs-string">&quot;deadletter&quot;</span>))&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;dead letter exception&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            ack = <span class="hljs-keyword">false</span>;<br>            exception = e;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!ack)&#123;<br>            log.error(<span class="hljs-string">&quot;消息消费发生异常，error msg:&#123;&#125;&quot;</span>, exception.getMessage(), exception);<br>            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queues = BUSINESS_QUEUEB_NAME)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveB</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到业务消息B：&quot;</span> + <span class="hljs-keyword">new</span> String(message.getBody()));<br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后配置死信队列的消费者：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLetterMessageReceiver</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveA</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到死信消息A：&quot;</span> + <span class="hljs-keyword">new</span> String(message.getBody()));<br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveB</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到死信消息B：&quot;</span> + <span class="hljs-keyword">new</span> String(message.getBody()));<br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后，为了方便测试，写一个简单的消息生产者，并通过controller层来生产消息。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusinessMessageSender</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg)</span></span>&#123;<br>        rabbitTemplate.convertSendAndReceive(BUSINESS_EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, msg);<br>    &#125;<br>&#125;<br><span class="hljs-meta">@RequestMapping(&quot;rabbitmq&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQMsgController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BusinessMessageSender sender;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;sendmsg&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg)</span></span>&#123;<br>        sender.sendMsg(msg);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一切准备就绪，启动！</p><p>可以从RabbitMQ的管理后台中看到一共有四个队列，除默认的Exchange外还有声明的两个Exchange。</p><p><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140506771-319482381.jpg"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250041954.jpg" alt="img"></a><br><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140536938-1122765461.jpg"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250041939.jpg" alt="img"></a></p><p>接下来，访问一下url，来测试一下：</p><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http">http://localhost:8080/rabbitmq/sendmsg?msg=msg<br></code></pre></div></td></tr></table></figure><p>日志：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">收到业务消息<span class="hljs-selector-tag">A</span>：msg<br>收到业务消息<span class="hljs-selector-tag">B</span>：msg<br></code></pre></div></td></tr></table></figure><p>表示两个Consumer都正常收到了消息。这代表正常消费的消息，ack后正常返回。然后我们再来测试nck的消息。</p><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http">http://localhost:8080/rabbitmq/sendmsg?msg=deadletter<br></code></pre></div></td></tr></table></figure><p>这将会触发业务队列A的NCK，按照预期，消息被NCK后，会抛到死信队列中，因此死信队列将会出现这个消息，日志如下：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">收到业务消息A：deadletter<br>消息消费发生异常，<span class="hljs-built_in">error</span> msg:dead letter <span class="hljs-built_in">exception</span><br>java.lang.<span class="hljs-built_in">RuntimeException</span>: dead letter <span class="hljs-built_in">exception</span><br>...<br><br>收到死信消息A：deadletter<br></code></pre></div></td></tr></table></figure><p>可以看到，死信队列的Consumer接受到了这个消息，所以流程到此为止就打通了。</p><h3 id="五、死信消息的变化"><a href="#五、死信消息的变化" class="headerlink" title="五、死信消息的变化"></a>五、死信消息的变化</h3><p>那么“死信”被丢到死信队列中后，会发生什么变化呢？</p><p>如果队列配置了参数 <code>x-dead-letter-routing-key</code> 的话，“死信”的路由key将会被替换成该参数对应的值。如果没有设置，则保留该消息原有的路由key。</p><p>举个栗子：</p><p>如果原有消息的路由key是<code>testA</code>，被发送到业务Exchage中，然后被投递到业务队列QueueA中，如果该队列没有配置参数<code>x-dead-letter-routing-key</code>，则该消息成为死信后，将保留原有的路由key<code>testA</code>，如果配置了该参数，并且值设置为<code>testB</code>，那么该消息成为死信后，路由key将会被替换为<code>testB</code>，然后被抛到死信交换机中。</p><p>另外，由于被抛到了死信交换机，所以消息的Exchange Name也会被替换为死信交换机的名称。</p><p>消息的Header中，也会添加很多奇奇怪怪的字段，修改一下上面的代码，在死信队列的消费者中添加一行日志输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">log</span>.<span class="hljs-keyword">info</span>(&quot;死信消息properties：&#123;&#125;&quot;, message.getMessageProperties());<br></code></pre></div></td></tr></table></figure><p>然后重新运行一次，即可得到死信消息Header中被添加的信息：</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">死信消息properties：MessageProperties</span> <span class="hljs-string">[headers=&#123;x-first-death-exchange=dead.letter.demo.simple.business.exchange, x-death=[&#123;reason=rejected, count=1, exchange=dead.letter.demo.simple.business.exchange, time=Sun Jul 14 16:48:16 CST 2019, routing-keys=[], queue=dead.letter.demo.simple.business.queuea&#125;], x-first-death-reason=rejected, x-first-death-queue=dead.letter.demo.simple.business.queuea&#125;, correlationId=1, replyTo=amq.rabbitmq.reply-to.g2dkABZyYWJiaXRAREVTS1RPUC1DUlZGUzBOAAAPQAAAAAAB.bLbsdR1DnuRSwiKKmtdOGw==, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=dead.letter.demo.simple.deadletter.exchange, receivedRoutingKey=dead.letter.demo.simple.deadletter.queuea.routingkey, deliveryTag=1, consumerTag=amq.ctag-NSp18SUPoCNvQcoYoS2lPg, consumerQueue=dead.letter.demo.simple.deadletter.queuea]</span><br></code></pre></div></td></tr></table></figure><p>Header中看起来有很多信息，实际上并不多，只是值比较长而已。下面就简单说明一下Header中的值：</p><table><thead><tr><th align="left">字段名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">x-first-death-exchange</td><td align="left">第一次被抛入的死信交换机的名称</td></tr><tr><td align="left">x-first-death-reason</td><td align="left">第一次成为死信的原因，<code>rejected</code>：消息在重新进入队列时被队列拒绝，由于<code>default-requeue-rejected</code> 参数被设置为<code>false</code>。<code>expired</code> ：消息过期。<code>maxlen</code> ： 队列内消息数量超过队列最大容量</td></tr><tr><td align="left">x-first-death-queue</td><td align="left">第一次成为死信前所在队列名称</td></tr><tr><td align="left">x-death</td><td align="left">历次被投入死信交换机的信息列表，同一个消息每次进入一个死信交换机，这个数组的信息就会被更新</td></tr></tbody></table><h3 id="六、死信队列应用场景"><a href="#六、死信队列应用场景" class="headerlink" title="六、死信队列应用场景"></a>六、死信队列应用场景</h3><p>通过上面的信息，我们已经知道如何使用死信队列了，那么死信队列一般在什么场景下使用呢？</p><p>一般用在较为重要的业务队列中，确保未被正确消费的消息不被丢弃，一般发生消费异常可能原因主要有由于消息信息本身存在错误导致处理异常，处理过程中参数校验异常，或者因网络波动导致的查询异常等等，当发生异常时，当然不能每次通过日志来获取原消息，然后让运维帮忙重新投递消息（没错，以前就是这么干的= =）。通过配置死信队列，可以让未正确处理的消息暂存到另一个队列中，待后续排查清楚问题后，编写相应的处理代码来处理死信消息，这样比手工恢复数据要好太多了。</p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>死信队列其实并没有什么神秘的地方，不过是绑定在死信交换机上的普通队列，而死信交换机也只是一个普通的交换机，不过是用来专门处理死信的交换机。</p><p>总结一下死信消息的生命周期：</p><ol><li>业务消息被投入业务队列</li><li>消费者消费业务队列的消息，由于处理过程中发生异常，于是进行了nck或者reject操作</li><li>被nck或reject的消息由RabbitMQ投递到死信交换机中</li><li>死信交换机将消息投入相应的死信队列</li><li>死信队列的消费者消费死信消息</li></ol><p>死信消息是RabbitMQ为我们做的一层保证，其实我们也可以不使用死信队列，而是在消息消费异常时，将消息主动投递到另一个交换机中，当你明白了这些之后，这些Exchange和Queue想怎样配合就能怎么配合。比如从死信队列拉取消息，然后发送邮件、短信、钉钉通知来通知开发人员关注。或者将消息重新投递到一个队列然后设置过期时间，来进行延时消费.</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rabbitmq</tag>
      
      <tag>死信队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大白话聊透JVM</title>
    <link href="/2021/03/04/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%E9%80%8FJVM/"/>
    <url>/2021/03/04/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%E9%80%8FJVM/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载自掘金：<a href="https://juejin.im/user/5c2400afe51d45451758aa96">说出你的愿望吧丷</a></p><p>原文地址：<a href="https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28">https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及和而不深究，但会尽量效率地把知识点都抛出来</p><h2 id="一、JVM的基本介绍"><a href="#一、JVM的基本介绍" class="headerlink" title="一、JVM的基本介绍"></a>一、JVM的基本介绍</h2><p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p><p>好，其实抛开这么专业的句子不说，就知道JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357835.png"></p><h3 id="1-1-Java文件是如何被运行的"><a href="#1-1-Java文件是如何被运行的" class="headerlink" title="1.1 Java文件是如何被运行的"></a>1.1 Java文件是如何被运行的</h3><p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p><p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong> </p><h4 id="①-类加载器"><a href="#①-类加载器" class="headerlink" title="① 类加载器"></a>① 类加载器</h4><p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进JVM里面来。<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357867.png"></p><h4 id="②-方法区"><a href="#②-方法区" class="headerlink" title="② 方法区"></a>② 方法区</h4><p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p><p>类加载器将 .class 文件搬过来就是先丢到这一块上</p><h4 id="③-堆"><a href="#③-堆" class="headerlink" title="③ 堆"></a>③ 堆</h4><p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p><h4 id="④-栈"><a href="#④-栈" class="headerlink" title="④ 栈"></a>④ 栈</h4><p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p><p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用C来进行工作的，和Java没有太大的关系。</p><h4 id="⑤-程序计数器"><a href="#⑤-程序计数器" class="headerlink" title="⑤ 程序计数器"></a>⑤ 程序计数器</h4><p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357986.png"></p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ol><li>Java文件经过编译后变成 .class 字节码文件</li><li>字节码文件通过类加载器被搬运到 JVM 虚拟机中</li><li>虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li></ol><h3 id="1-2-简单的代码例子"><a href="#1-2-简单的代码例子" class="headerlink" title="1.2 简单的代码例子"></a>1.2 简单的代码例子</h3><p>一个简单的学生类<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357161.png"></p><p>一个main方法<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357322.png"></p><p>执行main方法的步骤如下:</p><ol><li> 编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li><li> JVM 找到 App 的主程序入口，执行main方法</li><li> 这个main中的第一条语句为 Student student = new Student(“tellUrDream”) ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li> 加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li><li> 执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li><li> 执行sayName()</li></ol><p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</p><h2 id="二、类加载器的介绍"><a href="#二、类加载器的介绍" class="headerlink" title="二、类加载器的介绍"></a>二、类加载器的介绍</h2><p>之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定</p><h3 id="2-1-类加载器的流程"><a href="#2-1-类加载器的流程" class="headerlink" title="2.1 类加载器的流程"></a>2.1 类加载器的流程</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h4 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="2.1.1 加载"></a>2.1.1 加载</h4><ol><li> 将class文件加载到内存</li><li> 将静态数据结构转化成方法区中运行时的数据结构</li><li> 在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</li></ol><h4 id="2-1-2-链接"><a href="#2-1-2-链接" class="headerlink" title="2.1.2 链接"></a>2.1.2 链接</h4><ol><li> 验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li><li> 准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li><li> 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li></ol><h4 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="2.1.3 初始化"></a>2.1.3 初始化</h4><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的0变成了显式初始化的3. 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p><blockquote><p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给JVM识别的特殊方法。</p></blockquote><h4 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="2.1.4 卸载"></a>2.1.4 卸载</h4><p>GC将无用对象从内存中卸载</p><h3 id="2-2-类加载器的加载顺序"><a href="#2-2-类加载器的加载顺序" class="headerlink" title="2.2 类加载器的加载顺序"></a>2.2 类加载器的加载顺序</h3><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li> BootStrap ClassLoader：rt.jar</li><li> Extension ClassLoader: 加载扩展的jar包</li><li> App ClassLoader：指定的classpath下面的jar包</li><li> Custom ClassLoader：自定义的类加载器</li></ol><h3 id="2-3-双亲委派机制"><a href="#2-3-双亲委派机制" class="headerlink" title="2.3 双亲委派机制"></a>2.3 双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载</p><p>这样做的好处是，加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>其实这个也是一个隔离的作用，避免了我们的代码影响了JDK的代码，比如我现在要来一个</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">String</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;sout;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种时候，我们的代码肯定会报错，因为在加载的时候其实是找到了rt.jar中的String.class，然后发现这也没有main方法</p><h2 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h2><h3 id="3-1-本地方法栈和程序计数器"><a href="#3-1-本地方法栈和程序计数器" class="headerlink" title="3.1 本地方法栈和程序计数器"></a>3.1 本地方法栈和程序计数器</h3><p>比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使用C来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p><p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p><p>如果执行的是native方法，那这个指针就不工作了。</p><h3 id="3-2-方法区"><a href="#3-2-方法区" class="headerlink" title="3.2 方法区"></a>3.2 方法区</h3><p>方法区主要的作用是存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。</p><h3 id="3-3-虚拟机栈和虚拟机堆"><a href="#3-3-虚拟机栈和虚拟机堆" class="headerlink" title="3.3 虚拟机栈和虚拟机堆"></a>3.3 虚拟机栈和虚拟机堆</h3><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p><h4 id="3-3-1-虚拟机栈的概念"><a href="#3-3-1-虚拟机栈的概念" class="headerlink" title="3.3.1 虚拟机栈的概念"></a>3.3.1 虚拟机栈的概念</h4><p>它是Java方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="3-3-2-虚拟机栈存在的异常"><a href="#3-3-2-虚拟机栈存在的异常" class="headerlink" title="3.3.2 虚拟机栈存在的异常"></a>3.3.2 虚拟机栈存在的异常</h4><p>如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>。</p><h4 id="3-3-3-虚拟机栈的生命周期"><a href="#3-3-3-虚拟机栈的生命周期" class="headerlink" title="3.3.3 虚拟机栈的生命周期"></a>3.3.3 虚拟机栈的生命周期</h4><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><h4 id="3-3-4-虚拟机栈的执行"><a href="#3-3-4-虚拟机栈的执行" class="headerlink" title="3.3.4 虚拟机栈的执行"></a>3.3.4 虚拟机栈的执行</h4><p>我们经常说的栈帧数据，说白了在JVM中叫栈帧，放到Java中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。</p><h4 id="3-3-5-局部变量的复用"><a href="#3-3-5-局部变量的复用" class="headerlink" title="3.3.5 局部变量的复用"></a>3.3.5 局部变量的复用</h4><p>局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。</p><p>虚拟机通过索引定位的方式使用局部变量表，范围为[0,局部变量表的slot的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些slot是可以复用的，当方法执行位置超过了某个变量，那么这个变量的slot可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p><h4 id="3-3-6-虚拟机堆的概念"><a href="#3-3-6-虚拟机堆的概念" class="headerlink" title="3.3.6 虚拟机堆的概念"></a>3.3.6 虚拟机堆的概念</h4><p>JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给GC算法进行回收。非堆内存其实我们已经说过了，就是方法区。在1.8中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是metaSpace是不存在于JVM中的，它使用的是本地内存。并有两个参数</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">MetaspaceSize：初始化元空间大小，控制发生GC<br>MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。<br></code></pre></div></td></tr></table></figure><p>移除的原因可以大致了解一下：融合HotSpot JVM和JRockit VM而做出的改变，因为JRockit是没有永久代的，不过这也间接性地解决了永久代的OOM问题。</p><h4 id="3-3-7-Eden年轻代的介绍"><a href="#3-3-7-Eden年轻代的介绍" class="headerlink" title="3.3.7 Eden年轻代的介绍"></a>3.3.7 Eden年轻代的介绍</h4><p>当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB，有兴趣可以了解一下。</p><p>当Eden空间满了之后，会触发一个叫做Minor GC（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。经过多次的 Minor GC后仍然存活的对象（<strong>这里的存活判断是15次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15</strong>）会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p><p>而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357407.png"></p><p>补充说明：关于-XX:TargetSurvivorRatio参数的问题。其实也不一定是要满足-XX:MaxTenuringThreshold才移动到老年代。可以举个例子：如对象年龄5的占30%，年龄6的占36%，年龄7的占34%，加入某个年龄段（如例子中的年龄6）后，总占用超过Survivor空间*TargetSurvivorRatio的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄6对象，就是年龄6和年龄7晋升到老年代），这时候无需等到MaxTenuringThreshold中要求的15</p><h4 id="3-3-8-如何判断一个对象需要被干掉"><a href="#3-3-8-如何判断一个对象需要被干掉" class="headerlink" title="3.3.8 如何判断一个对象需要被干掉"></a>3.3.8 如何判断一个对象需要被干掉</h4><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357718.png"></p><p>图中程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p><p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法</p><p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。</p><p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如Java，C#等都是靠这招去判定对象是否存活的。</p><p>（了解一下即可）在Java语言汇总能作为GC Roots的对象分为以下几种：</p><ol><li> 虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）</li><li> 方法区中静态变量所引用的对象（静态变量）</li><li> 方法区中常量引用的对象</li><li> 本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li><li> 已启动的且未终止的Java线程</li></ol><p>这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p><h4 id="3-3-9-如何宣告一个对象的真正死亡"><a href="#3-3-9-如何宣告一个对象的真正死亡" class="headerlink" title="3.3.9 如何宣告一个对象的真正死亡"></a>3.3.9 如何宣告一个对象的真正死亡</h4><p>首先必须要提到的是一个名叫 <strong>finalize()</strong> 的方法</p><p>finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用。</p><p>补充一句：并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在Java9中已经被标记为 <strong>deprecated</strong> ，且java.lang.ref.Cleaner（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比finalize来的更加的轻量及可靠。<br>　　<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357794.png"></p><p>判断一个对象的死亡至少需要两次标记</p><ol><li> 如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。</li><li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li></ol><p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢</p><h3 id="3-4-垃圾回收算法"><a href="#3-4-垃圾回收算法" class="headerlink" title="3.4 垃圾回收算法"></a>3.4 垃圾回收算法</h3><p>不会非常详细的展开，常用的有标记清除，复制，标记整理和分代收集算法</p><h4 id="3-4-1-标记清除算法"><a href="#3-4-1-标记清除算法" class="headerlink" title="3.4.1 标记清除算法"></a>3.4.1 标记清除算法</h4><p>标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。</p><p>其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。</p><p>不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357947.png"></p><p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题</p><h4 id="3-4-2-复制算法"><a href="#3-4-2-复制算法" class="headerlink" title="3.4.2 复制算法"></a>3.4.2 复制算法</h4><p>为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和survivor一样也是用from和to两个指针这样的玩法。fromPlace存满了，就把存活的对象copy到另一块toPlace上，然后交换指针的内容。这样就解决了碎片的问题。</p><p>这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357050.png"></p><p>不过它们分配的时候也不是按照1:1这样进行分配的，就类似于Eden和Survivor也不是等价分配是一个道理。</p><h4 id="3-4-3-标记整理算法"><a href="#3-4-3-标记整理算法" class="headerlink" title="3.4.3 标记整理算法"></a>3.4.3 标记整理算法</h4><p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357192.png"></p><h4 id="3-4-4-分代收集算法"><a href="#3-4-4-分代收集算法" class="headerlink" title="3.4.4 分代收集算法"></a>3.4.4 分代收集算法</h4><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p><p>说白了就是八仙过海各显神通，具体问题具体分析了而已。</p><h3 id="3-5-（了解）各种各样的垃圾回收器"><a href="#3-5-（了解）各种各样的垃圾回收器" class="headerlink" title="3.5 （了解）各种各样的垃圾回收器"></a>3.5 （了解）各种各样的垃圾回收器</h3><p>HotSpot VM中的垃圾回收器，以及适用场景<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357456.png"></p><p>到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old</p><p>从jdk9开始，G1收集器成为默认的垃圾收集器<br>目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。</p><h3 id="3-6-（了解）JVM的常用参数"><a href="#3-6-（了解）JVM的常用参数" class="headerlink" title="3.6 （了解）JVM的常用参数"></a>3.6 （了解）JVM的常用参数</h3><p>JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or lator)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于CMS</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr></tbody></table><p>其实还有一些打印及CMS方面的参数，这里就不以一一列举了</p><h2 id="四、关于JVM调优的一些方面"><a href="#四、关于JVM调优的一些方面" class="headerlink" title="四、关于JVM调优的一些方面"></a>四、关于JVM调优的一些方面</h2><p>根据刚刚涉及的jvm的知识点，我们可以尝试对JVM进行调优，主要就是堆内存那块</p><p>所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m。所以java堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用fullgc，所以老年代过小的话反而是会增多fullgc的）。此值对系统性能影响较大，Sun官方推荐配置为java堆的3/8。</p><h3 id="4-1-调整最大堆内存和最小堆内存"><a href="#4-1-调整最大堆内存和最小堆内存" class="headerlink" title="4.1 调整最大堆内存和最小堆内存"></a>4.1 调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(&lt;1GB)）和初始java堆最小值（默认值是物理内存的1/64(&lt;1GB))</p><p>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单</p><p>开发过程中，通常会将 -Xms 与 -Xmx两个参数配置成相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><p>我们执行下面的代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);    <span class="hljs-comment">//系统的最大空间</span><br>System.out.println(<span class="hljs-string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);  <span class="hljs-comment">//系统的空闲空间</span><br>System.out.println(<span class="hljs-string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);  <span class="hljs-comment">//当前可用的总空间</span><br></code></pre></div></td></tr></table></figure><p>注意：此处设置的是Java堆大小，也就是新生代大小 + 老年代大小<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357202.png"></p><p>设置一个VM options的参数</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-Xmx20m -Xms5m -XX:+PrintGCDetails<br></code></pre></div></td></tr></table></figure><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357274.png"></p><p>再次启动main方法</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357003.png"><br>这里GC弹出了一个Allocation Failure分配失败，这个事情发生在PSYoungGen，也就是年轻代中</p><p>这时候申请到的内存为18M，空闲内存为4.214195251464844M</p><p>我们此时创建一个字节数组看看，执行下面的代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>System.out.println(<span class="hljs-string">&quot;分配了1M空间给数组&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);  <span class="hljs-comment">//系统的最大空间</span><br>System.out.println(<span class="hljs-string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);  <span class="hljs-comment">//系统的空闲空间</span><br>System.out.println(<span class="hljs-string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br></code></pre></div></td></tr></table></figure><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357408.png"></p><p>此时free memory就又缩水了，不过total memory是没有变化的。Java会尽可能将total mem的值维持在最小堆内存大小</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>System.out.println(<span class="hljs-string">&quot;分配了10M空间给数组&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);  <span class="hljs-comment">//系统的最大空间</span><br>System.out.println(<span class="hljs-string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);  <span class="hljs-comment">//系统的空闲空间</span><br>System.out.println(<span class="hljs-string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);  <span class="hljs-comment">//当前可用的总空间</span><br></code></pre></div></td></tr></table></figure><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357835.png"></p><p>这时候我们创建了一个10M的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的total memory已经变成了15M，这就是已经申请了一次内存的结果。</p><p>此时我们再跑一下这个代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">System.gc();<br>System.out.println(<span class="hljs-string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);    <span class="hljs-comment">//系统的最大空间</span><br>System.out.println(<span class="hljs-string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);  <span class="hljs-comment">//系统的空闲空间</span><br>System.out.println(<span class="hljs-string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);  <span class="hljs-comment">//当前可用的总空间</span><br></code></pre></div></td></tr></table></figure><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357410.png"></p><p>此时我们手动执行了一次fullgc，此时total memory的内存空间又变回5.5M了，此时又是把申请的内存释放掉的结果。</p><h3 id="4-2-调整新生代和老年代的比值"><a href="#4-2-调整新生代和老年代的比值" class="headerlink" title="4.2 调整新生代和老年代的比值"></a>4.2 调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p><p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</p><h3 id="4-3-调整Survivor区和Eden区的比值"><a href="#4-3-调整Survivor区和Eden区的比值" class="headerlink" title="4.3 调整Survivor区和Eden区的比值"></a>4.3 调整Survivor区和Eden区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个Survivor区和eden的比值</p><p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p><h3 id="4-4-设置年轻代和老年代的大小"><a href="#4-4-设置年轻代和老年代的大小" class="headerlink" title="4.4 设置年轻代和老年代的大小"></a>4.4 设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p><p>-XX:MaxNewSize — 设置年轻代最大值</p><p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的Eden和Survivor的占比为8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的gc，需要注意。</p><h3 id="4-5-小总结"><a href="#4-5-小总结" class="headerlink" title="4.5 小总结"></a>4.5 小总结</h3><p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新生代的1/10</p><p>在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump文件，这个文件可以使用VisualVM或者Java自带的Java VisualVM工具。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径<br></code></pre></div></td></tr></table></figure><p>一般我们也可以通过编写脚本的方式来让OOM出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p><h3 id="4-6-永久区的设置"><a href="#4-6-永久区的设置" class="headerlink" title="4.6 永久区的设置"></a>4.6 永久区的设置</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XX:PermSize -XX:MaxPermSize<br></code></pre></div></td></tr></table></figure><p>初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。</p><p>tips：如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出OOM。</p><h3 id="4-7-JVM的栈参数调优"><a href="#4-7-JVM的栈参数调优" class="headerlink" title="4.7 JVM的栈参数调优"></a>4.7 JVM的栈参数调优</h3><h4 id="4-7-1-调整每个线程栈空间的大小"><a href="#4-7-1-调整每个线程栈空间的大小" class="headerlink" title="4.7.1 调整每个线程栈空间的大小"></a>4.7.1 调整每个线程栈空间的大小</h4><p>可以通过-Xss：调整每个线程栈空间的大小</p><p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p><h4 id="4-7-2-设置线程栈的大小"><a href="#4-7-2-设置线程栈的大小" class="headerlink" title="4.7.2 设置线程栈的大小"></a>4.7.2 设置线程栈的大小</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XXThreadStackSize：<br>    设置线程栈的大小(0 means use default stack size)<br></code></pre></div></td></tr></table></figure><p>这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供demo了</p><h3 id="4-8-可以直接跳过了-JVM其他参数介绍"><a href="#4-8-可以直接跳过了-JVM其他参数介绍" class="headerlink" title="4.8 (可以直接跳过了)JVM其他参数介绍"></a>4.8 (可以直接跳过了)JVM其他参数介绍</h3><p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p><h4 id="4-8-1-设置内存页的大小"><a href="#4-8-1-设置内存页的大小" class="headerlink" title="4.8.1 设置内存页的大小"></a>4.8.1 设置内存页的大小</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XXThreadStackSize：<br>    设置内存页的大小，不可设置过大，会影响Perm的大小<br></code></pre></div></td></tr></table></figure><h4 id="4-8-2-设置原始类型的快速优化"><a href="#4-8-2-设置原始类型的快速优化" class="headerlink" title="4.8.2 设置原始类型的快速优化"></a>4.8.2 设置原始类型的快速优化</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XX:+UseFastAccessorMethods：<br>    设置原始类型的快速优化<br></code></pre></div></td></tr></table></figure><h4 id="4-8-3-设置关闭手动GC"><a href="#4-8-3-设置关闭手动GC" class="headerlink" title="4.8.3 设置关闭手动GC"></a>4.8.3 设置关闭手动GC</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XX:+DisableExplicitGC：<br>    设置关闭System.gc()(这个参数需要严格的测试)<br></code></pre></div></td></tr></table></figure><h4 id="4-8-4-设置垃圾最大年龄"><a href="#4-8-4-设置垃圾最大年龄" class="headerlink" title="4.8.4 设置垃圾最大年龄"></a>4.8.4 设置垃圾最大年龄</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XX:MaxTenuringThreshold<br>    设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.<br>    对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,<br>    则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,<br>    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.<br></code></pre></div></td></tr></table></figure><h4 id="4-8-5-加快编译速度"><a href="#4-8-5-加快编译速度" class="headerlink" title="4.8.5 加快编译速度"></a>4.8.5 加快编译速度</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XX:+AggressiveOpts<br></code></pre></div></td></tr></table></figure><p>加快编译速度</p><h4 id="4-8-6-改善锁机制性能"><a href="#4-8-6-改善锁机制性能" class="headerlink" title="4.8.6 改善锁机制性能"></a>4.8.6 改善锁机制性能</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XX:+UseBiasedLocking<br></code></pre></div></td></tr></table></figure><h4 id="4-8-7-禁用垃圾回收"><a href="#4-8-7-禁用垃圾回收" class="headerlink" title="4.8.7 禁用垃圾回收"></a>4.8.7 禁用垃圾回收</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-Xnoclassgc<br></code></pre></div></td></tr></table></figure><h4 id="4-8-8-设置堆空间存活时间"><a href="#4-8-8-设置堆空间存活时间" class="headerlink" title="4.8.8 设置堆空间存活时间"></a>4.8.8 设置堆空间存活时间</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XX:SoftRefLRUPolicyMSPerMB<br>    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。<br></code></pre></div></td></tr></table></figure><h4 id="4-8-9-设置对象直接分配在老年代"><a href="#4-8-9-设置对象直接分配在老年代" class="headerlink" title="4.8.9 设置对象直接分配在老年代"></a>4.8.9 设置对象直接分配在老年代</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XX:PretenureSizeThreshold<br>    设置对象超过多大时直接在老年代分配，默认值是0。<br></code></pre></div></td></tr></table></figure><h4 id="4-8-10-设置TLAB占eden区的比例"><a href="#4-8-10-设置TLAB占eden区的比例" class="headerlink" title="4.8.10 设置TLAB占eden区的比例"></a>4.8.10 设置TLAB占eden区的比例</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XX:TLABWasteTargetPercent<br>    设置TLAB占eden区的百分比，默认值是1% 。 <br></code></pre></div></td></tr></table></figure><h4 id="4-8-11设置是否优先YGC"><a href="#4-8-11设置是否优先YGC" class="headerlink" title="4.8.11设置是否优先YGC"></a>4.8.11设置是否优先YGC</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-XX:+CollectGen0First<br>    设置FullGC时是否先YGC，默认值是false。<br></code></pre></div></td></tr></table></figure><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Java GC</title>
    <link href="/2020/11/22/%E6%B5%85%E8%B0%88Java%20GC/"/>
    <url>/2020/11/22/%E6%B5%85%E8%B0%88Java%20GC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="本节常见面试题"><a href="#本节常见面试题" class="headerlink" title="本节常见面试题"></a>本节常见面试题</h3><p>问题答案在文中都有提到</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有哪些？</li><li>介绍一下 CMS,G1 收集器。</li><li>Minor Gc 和 Full GC 有什么不同呢？</li></ul><h3 id="本文导火索"><a href="#本文导火索" class="headerlink" title="本文导火索"></a>本文导火索</h3><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157694.png"></p><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="1-揭开-JVM-内存分配与回收的神秘面纱"><a href="#1-揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="1 揭开 JVM 内存分配与回收的神秘面纱"></a>1 揭开 JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157744.png"></p><p>上图所示的 Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）</strong>：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">uint <span class="hljs-title">ageTable::compute_tenuring_threshold</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> survivor_capacity)</span> </span>&#123;<br> <span class="hljs-comment">//survivor_capacity是survivor空间的大小</span><br> <span class="hljs-keyword">size_t</span> desired_survivor_size = (<span class="hljs-keyword">size_t</span>)((((<span class="hljs-keyword">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="hljs-number">100</span>);<br> <span class="hljs-keyword">size_t</span> total = <span class="hljs-number">0</span>;<br> uint age = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">while</span> (age &lt; table_size) &#123;<br>     <span class="hljs-comment">//sizes数组是每个年龄段对象大小</span><br>     total += sizes[age];<br>     <span class="hljs-keyword">if</span> (total &gt; desired_survivor_size) &#123;<br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br>     age++;<br> &#125;<br> uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;<br> ...<br>&#125;<br><br></code></pre></div></td></tr></table></figure></blockquote><p>经过这次 GC 后，Eden 区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次 GC 前的“From”，新的”From”就是上次 GC 前的”To”。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157739.png" alt="堆内存常见分配策略 "></p><h3 id="1-1-对象优先在-eden-区分配"><a href="#1-1-对象优先在-eden-区分配" class="headerlink" title="1.1 对象优先在 eden 区分配"></a>1.1 对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCTest</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">byte</span>[] allocation1, allocation2;<br>allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">30900</span>*<span class="hljs-number">1024</span>];<br><span class="hljs-comment">//allocation2 = new byte[900*1024];</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过以下方式运行：<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157760.png"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code><br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157707.png"></p><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157710.jpg"></p><p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">900</span>*<span class="hljs-number">1024</span>];<br></code></pre></div></td></tr></table></figure><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157052.jpg"></p><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCTest</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;<br>allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">32000</span>*<span class="hljs-number">1024</span>];<br>allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>allocation5 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="1.2 大对象直接进入老年代"></a>1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="1-3-长期存活的对象将进入老年代"><a href="#1-3-长期存活的对象将进入老年代" class="headerlink" title="1.3 长期存活的对象将进入老年代"></a>1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="1-4-动态对象年龄判定"><a href="#1-4-动态对象年龄判定" class="headerlink" title="1.4 动态对象年龄判定"></a>1.4 动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a href="https://github.com/Snailclimb/JavaGuide/issues/1199">issue1199</a> ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p>jdk8官方文档引用 ：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a> 。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157058.png"></p><p><strong>动态年龄计算的代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">uint <span class="hljs-title">ageTable::compute_tenuring_threshold</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> survivor_capacity)</span> </span>&#123;<br><span class="hljs-comment">//survivor_capacity是survivor空间的大小</span><br><span class="hljs-keyword">size_t</span> desired_survivor_size = (<span class="hljs-keyword">size_t</span>)((((<span class="hljs-keyword">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="hljs-number">100</span>);<br><span class="hljs-keyword">size_t</span> total = <span class="hljs-number">0</span>;<br>uint age = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (age &lt; table_size) &#123;<br>  <span class="hljs-comment">//sizes数组是每个年龄段对象大小</span><br>  total += sizes[age];<br>  <span class="hljs-keyword">if</span> (total &gt; desired_survivor_size) &#123;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  age++;<br>&#125;<br>uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;<br>...<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672">issue672</a>)：<strong>关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。</strong><br>如果你去 Oracle 的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p></blockquote><h3 id="1-5-主要进行-gc-的区域"><a href="#1-5-主要进行-gc-的区域" class="headerlink" title="1.5 主要进行 gc 的区域"></a>1.5 主要进行 gc 的区域</h3><p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p><blockquote><p><del><em>“老年代 GC（Major GC/Full GC），指发生在老年代的 GC……”</em></del></p></blockquote><p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157143.png"></p><p><strong>总结：</strong></p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h2 id="2-对象已经死亡？"><a href="#2-对象已经死亡？" class="headerlink" title="2 对象已经死亡？"></a>2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157156.png"></p><h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceCountingGc</span> </span>&#123;<br>    Object instance = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ReferenceCountingGc objA = <span class="hljs-keyword">new</span> ReferenceCountingGc();<br>ReferenceCountingGc objB = <span class="hljs-keyword">new</span> ReferenceCountingGc();<br>objA.instance = objB;<br>objB.instance = objA;<br>objA = <span class="hljs-keyword">null</span>;<br>objB = <span class="hljs-keyword">null</span>;<br><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157162.png" alt="可达性分析算法 "></p><p>可作为 GC Roots 的对象包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="2-4-不可达的对象并非“非死不可”"><a href="#2-4-不可达的对象并非“非死不可”" class="headerlink" title="2.4 不可达的对象并非“非死不可”"></a>2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="2-5-如何判断一个常量是废弃常量？"><a href="#2-5-如何判断一个常量是废弃常量？" class="headerlink" title="2.5 如何判断一个常量是废弃常量？"></a>2.5 如何判断一个常量是废弃常量？</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del></p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/747">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762">reference</a>）</strong> ：</p><ol><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol></blockquote><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="2-6-如何判断一个类是无用的类"><a href="#2-6-如何判断一个类是无用的类" class="headerlink" title="2.6 如何判断一个类是无用的类"></a>2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a>3 垃圾收集算法</h2><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157177.png" alt="垃圾收集算法分类"></p><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157224.jpeg"></p><h3 id="3-2-标记-复制算法"><a href="#3-2-标记-复制算法" class="headerlink" title="3.2 标记-复制算法"></a>3.2 标记-复制算法</h3><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157338.png" alt="复制算法"></p><h3 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157406.png" alt="标记-整理算法 "></p><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a>4 垃圾收集器</h2><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157414.png" alt="垃圾收集器分类"></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157675.png" alt=" Serial 收集器 "></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157809.png" alt="ParNew 收集器 "></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><p><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p></li></ul><h3 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">-XX:+UseParallelGC<br><br><span class="hljs-code">    使用 Parallel 收集器+ 老年代串行</span><br><span class="hljs-code"></span><br>-XX:+UseParallelOldGC<br><br><span class="hljs-code">    使用 Parallel 收集器+ 老年代并行</span><br><span class="hljs-code"></span><br></code></pre></div></td></tr></table></figure><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157818.png" alt="Parallel Scavenge 收集器 "></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 java -XX:+PrintCommandLineFlags -version 命令查看</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">-XX:InitialHeapSize=<span class="hljs-number">262921408</span> -XX:MaxHeapSize=<span class="hljs-number">4206742528</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC<br><span class="hljs-keyword">java </span>version <span class="hljs-string">&quot;1.8.0_211&quot;</span><br><span class="hljs-keyword">Java(TM) </span>SE Runtime Environment (<span class="hljs-keyword">build </span><span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>_211-<span class="hljs-keyword">b12)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Java </span>HotSpot(TM) <span class="hljs-number">64</span>-<span class="hljs-keyword">Bit </span>Server VM (<span class="hljs-keyword">build </span><span class="hljs-number">25</span>.<span class="hljs-number">211</span>-<span class="hljs-keyword">b12, </span>mixed mode)<br></code></pre></div></td></tr></table></figure><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p><h3 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4.Serial Old 收集器"></a>4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="4-6-CMS-收集器"><a href="#4-6-CMS-收集器" class="headerlink" title="4.6 CMS 收集器"></a>4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157917.png" alt="CMS 垃圾收集器 "></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="4.7 G1 收集器"></a>4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="4-8-ZGC-收集器"><a href="#4-8-ZGC-收集器" class="headerlink" title="4.8 ZGC 收集器"></a>4.8 ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><p>详情可以看 ： <a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li><a href="https://my.oschina.net/hosee/blog/644618">https://my.oschina.net/hosee/blog/644618</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Redis分布式锁(下)</title>
    <link href="/2020/10/25/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8B)/"/>
    <url>/2020/10/25/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自定义Redis分布式锁的弊端"><a href="#自定义Redis分布式锁的弊端" class="headerlink" title="自定义Redis分布式锁的弊端"></a>自定义Redis分布式锁的弊端</h1><p>在上一篇我们自定义了一个Redis分布式锁，用来解决多节点定时任务的拉取问题（避免任务重复执行）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604497239038-11bf2996-86c7-4672-8c14-97003ad03379-20210923224039242.png" alt="img"></p><p>但仍然存在很多问题：</p><ul><li>加锁操作不是原子性的（setnx和expire两步操作不是原子性的，中间宕机会导致死锁）</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String lockKey, String value, <span class="hljs-keyword">long</span> expireTime, TimeUnit timeUnit)</span> </span>&#123;<br>    <span class="hljs-comment">// 1.先setnx</span><br>    Boolean lock = redisTemplate.opsForValue().setIfAbsent(lockKey, value);<br>    <span class="hljs-keyword">if</span> (lock != <span class="hljs-keyword">null</span> &amp;&amp; lock) &#123;<br>        <span class="hljs-comment">// 2.再expire</span><br>        redisTemplate.expire(lockKey, expireTime, timeUnit);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605942078377-4709a4b0-b840-46af-8790-eec570ccc526-20210923224051964.png" alt="img"></p><p>当然啦，高版本的SpringBoot Redis依赖其实提供了加锁的原子性操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 尝试上锁：setNX + expire</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> lockKey    锁</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value      对应的值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> expireTime 过期时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> timeUnit   时间单位</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String lockKey, String value, <span class="hljs-keyword">long</span> expireTime, TimeUnit timeUnit)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 可以设置4个参数，一步到位</span><br>        redisTemplate.opsForValue().set(lockKey, value, expireTime, timeUnit);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从 Redis 2.6.12 版本开始（现在6.x了…）， <a href="http://doc.redisfans.com/string/set.html#set">SET</a> 命令的行为可以通过一系列参数来修改，也因为 <a href="http://doc.redisfans.com/string/set.html#set">SET</a> 命令可以通过参数来实现和 <a href="http://doc.redisfans.com/string/setnx.html#setnx">SETNX</a> 、 <a href="http://doc.redisfans.com/string/setex.html#setex">SETEX</a> 和 <a href="http://doc.redisfans.com/string/psetex.html#psetex">PSETEX</a> 三个命令的效果，所以将来的 Redis 版本可能会废弃并最终移除 <a href="http://doc.redisfans.com/string/setnx.html#setnx">SETNX</a> 、 <a href="http://doc.redisfans.com/string/setex.html#setex">SETEX</a> 和 <a href="http://doc.redisfans.com/string/psetex.html#psetex">PSETEX</a> 这三个命令。</p><ul><li>解锁操作不是原子性的（可能造成不同节点之间互相删锁）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605944419389-2d72efb4-3f0d-4082-9836-27729be483ca-20210923224114637.png" alt="img"></p><p>虽然上一篇设计的unLock()不是原子操作，但可以避免不同节点之间互相删锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLock</span><span class="hljs-params">(String lockKey, String value)</span> </span>&#123;<br>    <span class="hljs-comment">// 1.获取锁的value，存的是MACHINE_ID</span><br>    String machineId = (String) redisTemplate.opsForValue().get(lockKey);<br>    <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(machineId) &amp;&amp; machineId.equals(value)) &#123;<br>        <span class="hljs-comment">// 2.只能删除当前节点设置的锁</span><br>        redisTemplate.delete(lockKey);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>畏难情绪作祟，不想考虑锁续期的问题，企图采用队列的方式缩减定时任务执行时间，直接把任务丢到队列中。但实际上可能存在任务堆积，个别情况下会出现：上次已经拉取某个任务并丢到Redis队列中，但由于队列比较繁忙，该任务还未被执行，数据库状态也尚未更改为status=1（已执行），结果下次又拉取一遍，重复执行（简单的解决策略是：虽然无法阻止入队，但是出队消费时可以判断where status=0后执行）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606004955240-09b70762-48c9-48db-b5ce-594f57f8037d-20210923224127881.png" alt="img"></p><p>引入Redis Message Queue会让系统变得更加复杂，我之前就因为使用了上面的模型导致各种偶发性的BUG，非常不好排查。一般来说，定时任务应该设计得简单点：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605943038778-2e521c6d-d2eb-4bf8-bfee-85386d52683f-20210923224137688.png" alt="img"></p><p>也就是说，绕来绕去，想要设计一个较完备的Redis分布式锁，必须至少解决3个问题：</p><ul><li><p>加锁原子性（setnx和expire要保证原子性，否则会容易发生死锁）</p></li><li><p>解锁原子性（不能误删别人的锁）</p></li><li><p>需要考虑业务/定时任务执行的时间，并为锁续期</p></li></ul><p>如果不考虑性能啥的，加解锁原子性都可以通过lua脚本实现（利用Redis单线程的特性）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605945261112-585bd28f-7670-4518-af85-8440d044153b-20210923224146607.png" alt="img"></p><p>一次执行一个脚本，要么成功要么失败，不会和其他指令交错执行。</p><p>最难的是如何根据实际业务的执行时间给锁续期！虽然我们已经通过判断MACHINE_ID避免了不同节点互相删除锁：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605945347715-e77ca098-bd7a-4dee-beda-1e325c6247fa-20210923224152657.png" alt="img"></p><p>但本质上我们需要的是：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606005458029-94f26b64-780d-4324-910c-f36f7dd7ccaf-20210923224200340.png" alt="img"></p><p>本文我们的主要目标就是实现锁续期！</p><p>好在Redisson已经实现了，所以目标又变成：了解Redisson的锁续期机制。</p><h1 id="Redisson案例"><a href="#Redisson案例" class="headerlink" title="Redisson案例"></a>Redisson案例</h1><h2 id="Redisson环境搭建"><a href="#Redisson环境搭建" class="headerlink" title="Redisson环境搭建"></a>Redisson环境搭建</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">server:<br>  port: 8080<br><br>spring:<br>  redis:<br>    host: # 见小册开头《阿里云服务账号》<br>    password: # 见小册开头《阿里云服务账号》<br>    database: 1<br>    <br># 调整控制台日志格式，稍微精简一些（非必要操作）<br>logging:<br>  pattern:<br>    console: &quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %thread - %msg%n&quot;<br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--大家也可以单独引入Redisson依赖，然后通过@Configuration自己配置RedissonClient--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>然后就可以在test包下测试了~</p><h2 id="lock-方法初探"><a href="#lock-方法初探" class="headerlink" title="lock()方法初探"></a>lock()方法初探</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RLockTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRLock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>::testLockOne).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>::testLockTwo).start();<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">200</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLockOne</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;bravo1988_distributed_lock&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;testLockOne尝试加锁...&quot;</span>);<br>            lock.lock();<br>            log.info(<span class="hljs-string">&quot;testLockOne加锁成功...&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;testLockOne业务开始...&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">50</span>);<br>            log.info(<span class="hljs-string">&quot;testLockOne业务结束...&quot;</span>);<br>            lock.unlock();<br>            log.info(<span class="hljs-string">&quot;testLockOne解锁成功...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLockTwo</span><span class="hljs-params">()</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;bravo1988_distributed_lock&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;testLockTwo尝试加锁...&quot;</span>);<br>            lock.lock();<br>            log.info(<span class="hljs-string">&quot;testLockTwo加锁成功...&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;testLockTwo业务开始...&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">50</span>);<br>            log.info(<span class="hljs-string">&quot;testLockTwo业务结束...&quot;</span>);<br>            lock.unlock();<br>            log.info(<span class="hljs-string">&quot;testLockTwo解锁成功...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果</p><p>2020-11-21 14:24:33 - Thread-3 - testLockTwo尝试加锁…</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne尝试加锁…</p><p>=====&gt; testLockOne()执行过程中，testLockTwo()一直阻塞 &lt;=====</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne加锁成功…</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne业务开始…</p><p>2020-11-21 14:25:23 - Thread-2 - testLockOne业务结束…</p><p>2020-11-21 14:25:23 - Thread-2 - testLockOne解锁成功…</p><p>=====&gt; testLockOne()执行结束释放锁，testLockTwo()抢到锁 &lt;=====</p><p>2020-11-21 14:25:23 - Thread-3 - testLockTwo加锁成功…</p><p>2020-11-21 14:25:23 - Thread-3 - testLockTwo业务开始…</p><p>2020-11-21 14:26:13 - Thread-3 - testLockTwo业务结束…</p><p>2020-11-21 14:26:13 - Thread-3 - testLockTwo解锁成功…</p><p>通过上面的代码，我们有以下疑问：</p><ul><li><p>lock()方法是原子性的吗？</p></li><li><p>lock()有设置过期时间吗？是多少？</p></li><li><p>lock()实现锁续期了吗？</p></li><li><p>lock()方法怎么实现阻塞的？又怎么被唤醒？</p></li></ul><p>先忘了这些，跟着我们走一遍lock()源码就明白了。</p><h1 id="lock-源码解析"><a href="#lock-源码解析" class="headerlink" title="lock()源码解析"></a>lock()源码解析</h1><p>lock()加锁，去除异常的情况，无非加锁成功、加锁失败两种情况，我们先看加锁成功的情况。</p><h2 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h2><p>我们从这段最简单的代码入手：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RLockTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLockSuccess</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;bravo1988_distributed_lock&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;准备加锁...&quot;</span>);<br>        lock.lock();<br>        log.info(<span class="hljs-string">&quot;加锁成功...&quot;</span>);<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">300</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>大家跟着我们先打几个断点（SpringBoot2.3.4）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952885069-f4e16307-9030-4a38-b154-30cd4f7f5a74-20210923224243500.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952773563-dca85b18-f11c-4511-8fdb-a737075fb5fd-20210923224252102.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952860890-484897da-0ee6-45ea-8179-ddf6f357316a-20210923224340729.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952928238-e1dc233d-d877-423f-8561-f121c821d5c8-20210923224347621.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952952657-d35ba600-5996-4a67-adee-0c39535f728c-20210923224354124.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952984223-bf8c4bda-866f-406f-b7f8-c369b6d9b1ea-20210923224359530.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605953023756-2fc503b2-44bb-47c9-baf6-a095fef000e1-20210923224410403.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605953051967-7f6f6fb5-cfba-46a5-80d1-e83f19efb80c-20210923224418693.png" alt="img"></p><p>注意啊，把截图中能看到的断点都打上。</p><p>OK，接着大家自己启动DEBUG，感受一下大致流程，然后看下面的注释：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// redisson.lock()</span><br><span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock(-<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 为了方便辨认，我直接把传进来的参数写在参数列表上</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> leaseTime=-<span class="hljs-number">1</span>, TimeUnit unit=<span class="hljs-keyword">null</span>, <span class="hljs-keyword">boolean</span> interruptibly=<span class="hljs-keyword">false</span>)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 获取当前线程id</span><br>    <span class="hljs-keyword">long</span> threadId = Thread.currentThread().getId();<br>    <span class="hljs-comment">// 尝试上锁。上锁成功返回null，上锁失败返回ttl</span><br>    Long ttl = tryAcquire(-<span class="hljs-number">1</span>, leaseTime=-<span class="hljs-number">1</span>, unit=<span class="hljs-keyword">null</span>, threadId=<span class="hljs-number">666</span>);<br>    <span class="hljs-comment">// 上锁成功，方法结束，回到主线程执行业务啦（后台有个定时任务在给当前锁续期）</span><br>    <span class="hljs-keyword">if</span> (ttl == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 上锁成功就不走下面的流程了，所以这里直接省略</span><br>    <span class="hljs-comment">// 略：加锁失败后续流程...</span><br>&#125;<br><br><span class="hljs-comment">// 尝试上锁。上锁成功返回null，上锁失败返回【当前已经存在的锁】的ttl，方便调用者判断多久之后能重新获取锁</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Long <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=-<span class="hljs-number">1</span>, TimeUnit unit=<span class="hljs-keyword">null</span>, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>)</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 有两次调用：1.tryAcquireAsync()返回Future 2.从Future获取异步结果（异步结果就是ttl）</span><br><span class="hljs-comment">    * 重点是tryAcquireAsync()</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> get(tryAcquireAsync(waitTime=-<span class="hljs-number">1</span>, leaseTime=-<span class="hljs-number">1</span>, unit=<span class="hljs-keyword">null</span>, threadId=<span class="hljs-number">666</span>));<br>&#125;<br><br><span class="hljs-comment">// 获取过期时间（非重点）</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> &lt;V&gt; <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(RFuture&lt;V&gt; future)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> commandExecutor.get(future);<br>&#125;<br><br><span class="hljs-comment">// 重点，加锁后返回RFuture，内部包含ttl。调用本方法可能加锁成功，也可能加锁失败，外界可以通过ttl判断</span><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">RFuture&lt;Long&gt; <span class="hljs-title">tryAcquireAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=-<span class="hljs-number">1</span>, TimeUnit unit=<span class="hljs-keyword">null</span>, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>)</span> </span>&#123;<br><br>    <span class="hljs-comment">// lock()默认leaseTime=-1，所以会跳过if</span><br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行lua脚本，尝试加锁并返回RFuture。这个方法是异步的，其实是把任务提交给线程池</span><br>    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(<br>                                            waitTime=-<span class="hljs-number">1</span>,<br>                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=<span class="hljs-number">30</span>秒,<br>                                            TimeUnit.MILLISECONDS, <br>                                            threadId=<span class="hljs-number">666</span>, <br>                                            RedisCommands.EVAL_LONG);<br><br>    <span class="hljs-comment">// 设置回调方法，异步线程与Redis交互得到结果后会回调BiConsumer#accept()</span><br>    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>        <span class="hljs-comment">// 发生异常时直接return</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 说明加锁成功</span><br>        <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 启动额外的线程，按照一定规则给当前锁续期</span><br>            scheduleExpirationRenewal(threadId);<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-comment">// 返回RFuture，里面有ttlRemaining</span><br>    <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>&#125;<br><br><br><span class="hljs-comment">// 执行lua脚本尝试上锁</span><br>&lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=<span class="hljs-number">30</span>*<span class="hljs-number">1000</span>, TimeUnit unit=毫秒, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;<br>    internalLockLeaseTime = unit.toMillis(leaseTime);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 大家去看一下evalWriteAsync()的参数列表，看看每个参数都代表什么，就能理解KEYS[]和ARGV[]以及整个脚本什么意思了</span><br><span class="hljs-comment">     * 如果你仔细看lua脚本，就会明白：加锁成功时返回ttlRemaining=null，加锁失败时返回ttlRemaining=xxx（上一个锁还剩多少时间）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 另外，我们自定义的Redis分布式锁采用了IdUtil生成节点id，和getLockName(threadId)本质是一样的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, command,<br>            <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,<br>            Collections.singletonList(getName()), internalLockLeaseTime, getLockName(threadId));<br>&#125;<br><br><span class="hljs-comment">// 向Redis服务器发送脚本并返回RFuture，大家可以近似看成：往线程池提交一个任务，然后将异步结果封装到CompletableFuture</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">evalWriteAsync</span><span class="hljs-params">(String key, Codec codec, RedisCommand&lt;T&gt; evalCommandType, String script, List&lt;Object&gt; keys, Object... params)</span> </span>&#123;<br>    CommandBatchService executorService = createCommandBatchService();<br>    RFuture&lt;T&gt; result = executorService.evalWriteAsync(key, codec, evalCommandType, script, keys, params);<br>    <span class="hljs-keyword">if</span> (!(commandExecutor <span class="hljs-keyword">instanceof</span> CommandBatchService)) &#123;<br>        executorService.executeAsync();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605956150610-2ce6fbe0-577a-4ab1-9540-a1d176038d02-20210923224433312.png" alt="img"></p><p>整个流程比较简单，只有两个难点：</p><ul><li>lua脚本写了啥</li><li>ttlRemainingFuture.onComplete()有什么作用</li></ul><h2 id="lua脚本解读"><a href="#lua脚本解读" class="headerlink" title="lua脚本解读"></a>lua脚本解读</h2><p>大家可以通过evalWriteAsync()的参数列表推导出KEYS、ARGV分别是什么：</p><p>KEYS[] =&gt; Collections.singletonList(getName())</p><p>ARGV[] =&gt; internalLockLeaseTime, getLockName(threadId)</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 如果不存在锁：&quot;bravo1988_distributed_lock&quot;</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 使用hincrby设置锁：hincrby bravo1988_distributed_lock a1b2c3d4:666 1</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>); <br>    <span class="hljs-comment">-- 设置过期时间。ARGV[1]==internalLockLeaseTime</span><br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]); <br>    <span class="hljs-comment">-- 返回null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>; <br>    <span class="hljs-keyword">end</span>; <br><br><span class="hljs-comment">-- 如果当前节点已经设置&quot;bravo1988_distributed_lock&quot;（注意，传了ARGV[2]==节点id）</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span> <br>    <span class="hljs-comment">-- 就COUNT++，可重入锁</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>); <br>    <span class="hljs-comment">-- 设置过期时间。ARGV[1]==internalLockLeaseTime</span><br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]); <br>  <span class="hljs-comment">-- 返回null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">end</span>; <br><br><span class="hljs-comment">-- 已经存在锁，且不是当前节点设置的，就返回锁的过期时间ttl</span><br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;pttl&#x27;</span>, KEYS[<span class="hljs-number">1</span>]);<br></code></pre></div></td></tr></table></figure><p>总的来说，Redisson设计的分布式锁是采用hash结构：</p><p><strong>LOCK_NAME</strong>（锁的KEY）+ <strong>CLIENT_ID</strong>（节点ID）+ <strong>COUNT</strong>（重入次数）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605957127624-694aaebe-2293-4641-83e8-8649823ec961-20210923224458173.png" alt="img"></p><h2 id="回调函数的作用"><a href="#回调函数的作用" class="headerlink" title="回调函数的作用"></a>回调函数的作用</h2><p>之前我们已经学过CompletableFuture的回调机制：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605406493819-8575b4ca-57e6-4afc-aba7-4840bee68138-20210923224505808.png" alt="img">RFuture#onComplete()和它很相似：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>        <span class="hljs-comment">// 发生异常时直接return</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 说明加锁成功</span><br>        <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 启动额外的线程，按照一定规则给当前锁续期</span><br>            scheduleExpirationRenewal(threadId);<br>        &#125;<br>    &#125;);<br></code></pre></div></td></tr></table></figure><p>onComplete()应该也是把回调函数推到stack中，方便后面异步线程弹栈执行。</p><p>至此，我们已经解决了之前的两个问题：</p><ul><li>lua脚本是什么意思（见注释）</li><li>ttlRemainingFuture.onComplete()有什么作用（设置回调函数，等会儿会有线程调用）</li></ul><p>虽然在CompletableFuture中已经强调过，这里还是要提一下：<strong>被回调的不是onComplete(BiConsumer)，而是****BiConsumer#accept()。</strong>主线程在调用onComplete(BiConsumer)时把它作为参数传入，然后被推入栈中<strong>：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BiConsumer consumer = (ttlRemaining, e) -&gt; &#123;<br>    <span class="hljs-comment">// 发生异常时直接return</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 说明加锁成功</span><br>    <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 启动额外的线程，按照一定规则给当前锁续期</span><br>        scheduleExpirationRenewal(threadId);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Redisson异步回调机制"><a href="#Redisson异步回调机制" class="headerlink" title="Redisson异步回调机制"></a>Redisson异步回调机制</h2><p>现在已经确定了尝试加锁后会返回RFuture，并且我们可以通过RFuture做两件事：</p><ul><li>通过RFuture获取ttlRemaining，也就是上一个锁的过期时间，如果为null则本次加锁成功，否则加锁失败，需要等待</li><li>通过RFuture设置回调函数</li></ul><p>现在疑问是：</p><ul><li><p>异步线程是谁，哪来的？</p></li><li><p>onComplete()设置的回调函数是干嘛的？</p></li><li><p>回调时的参数(ttlRemaining, e)哪来的？</p></li></ul><p>1、3两个问题非常难，源码比较绕，这里就带大家感性地体验一下，有兴趣可以自己跟源码了解。清除刚才的全部断点，只留下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958482130-e4ac51fd-c7c6-4a1c-9b8d-bc9ce3fab6a6-20210923224532665.png" alt="img"></p><p>再次DEBUG，线程会先到达return ttlRemainingFuture，随后回调BiConsumer#accept()：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958677303-5991020a-4ff9-4399-a71c-cefd1824931c-20210923224542928.png" alt="img"></p><p>回调时线程变了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958821470-c3a87de8-f677-4990-8a52-a42e572696d0-20210923224550800.png" alt="img"></p><p>大家有兴趣可以自己顺着调用栈逆推回去，还是比较复杂的，涉及到NIO、Promise等，源头还是在线程池，但其中又设计了Listeners的收集和循环唤醒：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">evalWriteAsync</span><span class="hljs-params">(String key, Codec codec, RedisCommand&lt;T&gt; evalCommandType, String script, List&lt;Object&gt; keys, Object... params)</span> </span>&#123;<br>    CommandBatchService executorService = createCommandBatchService();<br>    RFuture&lt;T&gt; result = executorService.evalWriteAsync(key, codec, evalCommandType, script, keys, params);<br>    <span class="hljs-keyword">if</span> (!(commandExecutor <span class="hljs-keyword">instanceof</span> CommandBatchService)) &#123;<br>        executorService.executeAsync();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总之，目前为止我们只需要知道：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605959979086-b4d49fc5-a37b-4872-a0d4-3f9c5a560f9d-20210923224610738.png" alt="img"></p><p>我们虽然不知道onComplete()具体如何实现回调（比CompletableFuture复杂得多），但是我们知道锁续期和RFuture的回调机制相关！</p><h2 id="Redisson如何实现锁续期"><a href="#Redisson如何实现锁续期" class="headerlink" title="Redisson如何实现锁续期"></a>Redisson如何实现锁续期</h2><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605960740451-f70e601b-0432-44a1-8e3c-34ff56b3b1c9-20210923224618495.png" alt="img"></p><p>最终会进入：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renewExpiration</span><span class="hljs-params">()</span> </span>&#123;<br>    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>    <span class="hljs-keyword">if</span> (ee == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 启动一个定时器：Timeout newTimeout(TimerTask task, long delay, TimeUnit unit);</span><br><span class="hljs-comment">    * 执行规则是：延迟internalLockLeaseTime/3后执行</span><br><span class="hljs-comment">    * 注意啊，每一个定时任务只执行一遍，而且是延迟执行。</span><br><span class="hljs-comment">    * </span><br><span class="hljs-comment">    * 那么问题就来了：</span><br><span class="hljs-comment">    * 1.internalLockLeaseTime/3是多久呢？</span><br><span class="hljs-comment">    * 2.如果定时任务只执行一遍，似乎解决不了问题啊，本质上和我们手动设置过期时间一样：多久合适呢？</span><br><span class="hljs-comment">    */</span> <br>    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="hljs-keyword">new</span> TimerTask() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>            <span class="hljs-keyword">if</span> (ent == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            Long threadId = ent.getFirstThreadId();<br>            <span class="hljs-keyword">if</span> (threadId == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 定时任务的目的是：重新执行一遍lua脚本，完成锁续期，把锁的ttl拨回到30s</span><br>            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);<br>            <span class="hljs-comment">// 设置了一个回调</span><br>            future.onComplete((res, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>                    log.error(<span class="hljs-string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="hljs-string">&quot; expiration&quot;</span>, e);<br>                    <span class="hljs-comment">// 如果宕机了，就不会续期了</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">// 如果锁还存在（没有unLock，说明业务还没结束），递归调用当前方法，不断续期</span><br>                <span class="hljs-keyword">if</span> (res) &#123;<br>                    <span class="hljs-comment">// reschedule itself</span><br>                    renewExpiration();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;, internalLockLeaseTime / <span class="hljs-number">3</span>, TimeUnit.MILLISECONDS);<br>    <br>    ee.setTimeout(task);<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 重新执行evalWriteAsync()，和加锁时的lua脚本比较类似，但有点不同</span><br><span class="hljs-comment">* 这里设置expire的参数也是internalLockLeaseTime</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 看来我们不得不去调查一下internalLockLeaseTime了！</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> RFuture&lt;Boolean&gt; <span class="hljs-title">renewExpirationAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> threadId)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,<br>            <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return 1; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-string">&quot;return 0;&quot;</span>,<br>            Collections.singletonList(getName()),<br>            internalLockLeaseTime, getLockName(threadId));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果你给renewExpirationAsync()打上断点，会发现每隔10秒，定时任务就会执行一遍：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969467749-64ac2a12-3b6d-4762-abf8-b457be9dc0e5-20210923224633703.png" alt="img"></p><p>联想到定时任务的delay是internalLockLeaseTime/3，所以推测internalLockLeaseTime为30秒。</p><p>点击internalLockLeaseTime，很容易跳转到对应的字段：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969607142-5897d87e-0841-4647-8ad1-02b308a7e66c-20210923224640385.png" alt="img"></p><p>再顺着getLockWatchdogTimeout()跳转，很快就会发现</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969777097-2f955c29-3f28-4ce2-a12a-b76455fb1e1e-20210923224647544.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969804198-7d2b61c3-da1b-4de1-aecd-5777a4994ee5-20210923224657200.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969855073-00958650-adfb-49c5-972e-37e797f5f23d-20210923224708071.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969922018-f5dc76c3-0566-4d14-9018-1ea86f17ff1c-20210923224716263.png" alt="img"></p><p>确实是30秒。</p><p>梳理一下所谓的Watchdog锁续期机制：</p><ul><li>lock()第一次成功加锁时，设置的锁过期时间默认30秒，这个值来自Watchdog变量</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 重点</span><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">RFuture&lt;Long&gt; <span class="hljs-title">tryAcquireAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=-<span class="hljs-number">1</span>, TimeUnit unit=<span class="hljs-keyword">null</span>, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>)</span> </span>&#123;<br><br>    <span class="hljs-comment">// lock()默认leaseTime=-1，所以会跳过if</span><br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行lua脚本加锁，返回RFuture。第二个参数就是leaseTime，来自LockWatchdogTimeout！！！</span><br>    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(<br>                                            waitTime=-<span class="hljs-number">1</span>,<br>                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=<span class="hljs-number">30</span>秒,<br>                                            TimeUnit.MILLISECONDS, <br>                                            threadId=<span class="hljs-number">666</span>, <br>                                            RedisCommands.EVAL_LONG);<br><br>    <span class="hljs-comment">// 设置回调方法</span><br>    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>        <span class="hljs-comment">// 发生异常时直接return</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 说明加锁成功</span><br>        <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 启动额外的线程，按照一定规则给当前锁续期</span><br>            scheduleExpirationRenewal(threadId);<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-comment">// 返回RFuture，里面有ttlRemaining</span><br>    <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>&#125;<br><br><span class="hljs-comment">// 执行lua脚本上锁</span><br>&lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=<span class="hljs-number">30</span>*<span class="hljs-number">1000</span>, TimeUnit unit=毫秒, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;<br>    <span class="hljs-comment">// 略...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>onComplete()设置回调，等Redis调用回来后，异步线程回调BiConsumer#accept()，进入scheduleExpirationRenewal(threadId)，开始<strong>每隔internalLockLeaseTime/3时间就给锁续期</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605961851949-8de820bf-97f6-4330-a580-da4003cc2123-20210923224729646.png" alt="img"></p><p>和加锁一样，执行lua脚本其实很快，所以这里的future.onComplete()虽说是异步，但很快就会被调用，然后就会递归调用renewExpiration()，然后又是一个TimerTask()，<strong>隔****internalLockLeaseTime/3后又给锁续期。</strong></p><p><strong>也就是说，Redisson的Watchdog定时任务虽然只延迟执行一次，但每次调用都会递归，所以相当于：重复延迟执行。</strong></p><p>还记得之前学习CompletableFuture时我写的一行注释吗：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605970707587-a80fb37d-b89e-4742-b675-4bfe03ca8b0c-20210923224741535.png" alt="img"></p><p>也就是说，只要主线程的任务不结束，就会一直给锁续期。</p><p>锁释放有两种情况：</p><ul><li>任务结束，主动unLock()删除锁</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">redisson.lock();<br>task();<br>redisson.unLock();<br></code></pre></div></td></tr></table></figure><ul><li>任务结束，不调用unLock()，但由于守护线程已经结束，不会有后台线程继续给锁续期，过了30秒自动过期</li></ul><p>上面我们探讨的都是加锁成功的流程，直接ttl=null就返回了，后面一大坨都是加锁失败时的判断逻辑，其中涉及到：</p><ul><li><p>while(true)死循环</p></li><li><p>阻塞等待</p></li><li><p>释放锁时Redis的Publish通知（在后面的unLock流程会看到）</p></li><li><p>其他节点收到锁释放的信号后重新争抢锁</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975498344-dd4657b8-5442-4fcd-8693-9f5e81d09531-20210923224753386.png" alt="img"></p><p>整个过程还是非常复杂的，大家有精力可以自行百度了解，后面介绍unLock()时也会涉及一部分加锁失败相关内容。</p><h1 id="unLock-源码解析"><a href="#unLock-源码解析" class="headerlink" title="unLock()源码解析"></a>unLock()源码解析</h1><p>有了lock()的经验，unLock()就简单多了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975635261-dc6265a9-2950-433f-a7f1-d46445d0a01b-20210923224803834.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975844381-fff7bf1c-36e2-4f63-9fc8-f5af8ebc0e0a-20210923224809682.png" alt="img"></p><p>相信大家还是能推断出KEYS[]和ARGV[]，这里就直接给出答案了：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 参数解释：</span><br><span class="hljs-comment">-- KEYS[1] =&gt; &quot;bravo1988_distributed_lock&quot;</span><br><span class="hljs-comment">-- KEYS[2] =&gt; getChannelName()</span><br><span class="hljs-comment">-- ARGV[1] =&gt; LockPubSub.UNLOCK_MESSAGE</span><br><span class="hljs-comment">-- ARGV[2] =&gt; internalLockLeaseTime</span><br><span class="hljs-comment">-- ARGV[3] =&gt; getLockName(threadId)</span><br><br><span class="hljs-comment">-- 锁已经不存在，返回null</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">3</span>]) == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">end</span>;<br><br><span class="hljs-comment">-- 锁还存在，执行COUNT--（重入锁的反向操作）</span><br><span class="hljs-keyword">local</span> counter = redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">3</span>], <span class="hljs-number">-1</span>);<br><br><span class="hljs-comment">-- COUNT--后仍然大于0（之前可能重入了多次）</span><br><span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 设置过期时间</span><br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">-- COUNT--后小于等于0，删除锁，并向对应的Channel发送消息（NIO），消息类型是LockPubSub.UNLOCK_MESSAGE（锁释放啦，快来抢~）</span><br><span class="hljs-keyword">else</span> <br>    redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]);<br>    redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>, KEYS[<span class="hljs-number">2</span>], ARGV[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span>;<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br></code></pre></div></td></tr></table></figure><p>也就是说，当一个锁被释放时，原先持有锁的节点会通过NIO的Channel发送LockPubSub.UNLOCK_MESSAGE，告诉其他订阅的Client：我已经释放锁啦，快来抢啊！此时原本阻塞的其他节点就会重新竞争锁。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606010300656-f21b35bd-bd46-4f02-bf73-e2913664af28-20210923224832043.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606010321812-3803dd5d-3411-4060-84f1-2f797f56946e-20210923224838169.png" alt="img"></p><p>而所谓重入和反重入，简单来说就是：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 加锁三次</span><br>redisson.lock();<br>redisson.lock();<br>redisson.lock();<br><span class="hljs-comment">// 执行业务</span><br>executeTask();<br><span class="hljs-comment">// 相应的，就要解锁三次</span><br>redisson.unLock();<br>redisson.unLock();<br>redisson.unLock();<br></code></pre></div></td></tr></table></figure><p>实际开发不会这样调用，但有时会出现子父类方法调用或者同一个线程反复调用使用同一把锁的多个方法，就会发生锁的重入（COUNT++），而当这些方法执行完毕逐个弹栈的过程中就会逐个unLock()解锁（COUNT–）。</p><h1 id="lock-leaseTime-unit-：自定义过期时间、且不续期"><a href="#lock-leaseTime-unit-：自定义过期时间、且不续期" class="headerlink" title="lock(leaseTime, unit)：自定义过期时间、且不续期"></a>lock(leaseTime, unit)：自定义过期时间、且不续期</h1><p>lock()默认会开启定时任务对锁进行续期，但Redisson还提供了另一个lock方法：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605976920059-cd4945a2-0932-4cc6-a2b5-9beac14475f9-20210923224857619.png" alt="img"></p><p>两个lock()唯一的区别是，内部调用lock()时，一个传了leaseTime=-1，另一个传了我们自己的leaseTime。对于外部调用者来说：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">redisson.lock();<br>redisson.lock(-<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>);<br></code></pre></div></td></tr></table></figure><p>这两种写法其实一样。</p><p>当然了，通常会传入有意义的leaseTime：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605977159145-10176f3a-8e5c-4d34-9f82-d5a9a684c15e-20210923224909434.png" alt="img"></p><p><strong>这种写法除了更改了锁的默认ttl时间外，还阉割了锁续期功能。</strong>也就是说，10秒后如果任务还没执行完，就会和我们手写的Redis分布式锁一样，自动释放锁。</p><p>为什么锁续期的功能失效了呢？留给大家自己解答，这里只给出参考答案：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 重点</span><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">RFuture&lt;Long&gt; <span class="hljs-title">tryAcquireAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=-<span class="hljs-number">1</span>, TimeUnit unit=<span class="hljs-keyword">null</span>, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>)</span> </span>&#123;<br><br>    <span class="hljs-comment">// lock()默认leaseTime=-1，会跳过这个if执行后面的代码。但如果是lock(10, TimeUnit.SECONDS)，会执行if并跳过后面的代码。</span><br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 其实和下面的tryLockInnerAsync()除了时间不一样外，没什么差别</span><br>        <span class="hljs-keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>    &#125;<br><br>    <span class="hljs-comment">// 但由于上面直接return了，所以下面的都不会执行！！</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(</span><br><span class="hljs-comment">                                            waitTime=-1,</span><br><span class="hljs-comment">                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=30秒,</span><br><span class="hljs-comment">                                            TimeUnit.MILLISECONDS, </span><br><span class="hljs-comment">                                            threadId=666, </span><br><span class="hljs-comment">                                            RedisCommands.EVAL_LONG);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 设置回调方法（不会执行！！）</span><br><span class="hljs-comment">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="hljs-comment">        // 发生异常时直接return</span><br><span class="hljs-comment">        if (e != null) &#123;</span><br><span class="hljs-comment">            return;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        // 说明加锁成功</span><br><span class="hljs-comment">        if (ttlRemaining == null) &#123;</span><br><span class="hljs-comment">            // 启动额外的线程，按照一定规则给当前锁续期</span><br><span class="hljs-comment">            scheduleExpirationRenewal(threadId);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 不会执行！！</span><br><span class="hljs-comment">    return ttlRemainingFuture;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>&#125;<br><br><span class="hljs-comment">// 执行lua脚本加锁</span><br>&lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=<span class="hljs-number">30</span>*<span class="hljs-number">1000</span>, TimeUnit unit=毫秒, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;<br>    <span class="hljs-comment">// 略...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>也就是说，直接执行lua加锁就返回了，没有机会启动定时任务和递归…</p><h1 id="tryLock-系列：让调用者自行决定加锁失败后的操作"><a href="#tryLock-系列：让调用者自行决定加锁失败后的操作" class="headerlink" title="tryLock()系列：让调用者自行决定加锁失败后的操作"></a>tryLock()系列：让调用者自行决定加锁失败后的操作</h1><p>之前我们已经观察到，如果多个节点都调用lock()，那么没获取到锁的节点线程会<strong>阻塞</strong>，直到原先持有锁的节点删除锁并publish LockPubSub.UNLOCK_MESSAGE 。</p><p>但如果调用者不希望阻塞呢？他有可能想着：如果加锁失败，我就直接放弃。</p><p>是啊，毕竟尝试加锁的目的可能完全相反：</p><ul><li>在保证线程安全的前提下，尽量让所有线程都执行成功</li><li>在保证线程安全的前提下，只让一个线程执行成功</li></ul><p>前者适用于秒杀、下单等操作，希望尽最大努力达成；后者适用于定时任务，只要让一个节点去执行，没有获取锁的节点应该fast-fail（快速失败）。</p><p>也就是说，节点获锁失败后，理论上可以有各种各样的处理方式：</p><ul><li><p>阻塞等待</p></li><li><p>直接放弃</p></li><li><p>试N次再放弃</p></li><li><p>…</p></li></ul><p><strong>但lock、****lock(leaseTime, timeUnit)替我们写死了：阻塞等待。</strong>即使lock(leaseTime, unit)，其实也是阻塞等待，只不过不会像lock()一样不断续期。</p><p>究其原因，主要是lock()这些方法对于加锁失败的判断是在内部写死的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605978662886-e09f2b51-ccb8-4fdb-b7f2-b2b162d0c57d-20210923224924265.png" alt="img"></p><p>而tryLock()方法则去掉了这层中间判断，<strong>把结果直接呈递到调用者面前，让调用者自己决定加锁失败后如何处理：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605978761456-207d8919-5a9e-451e-9460-3b4498f1b86c-20210923224932016.png" alt="img"></p><p>tryLock()直接返回true（加锁成功）和false（加锁失败），后续如何处理，全凭各个节点自己做出决定。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTryLock</span><span class="hljs-params">()</span> </span>&#123;<br>    RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;bravo1988_distributed_lock&quot;</span>);<br>    <span class="hljs-keyword">boolean</span> b = lock.tryLock();<br>    <span class="hljs-keyword">if</span> (b) &#123;<br>        <span class="hljs-comment">// 业务操作...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用立即结束，不阻塞</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样讲可能有点抽象，大家可以分别点进lock()和tryLock()，自行体会。总之，tryLock()中间少了一大块逻辑，因为它不插手结果的判断。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606181778959-3b05f3f9-ba72-4ada-9d4b-cb17f2871d91-20210923224943457.png" alt="img"></p><p>另外，tryLock()在加锁成功的情况下，其实和lock()是一样的，也会触发锁续期：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979113544-fd5fd678-27b0-4ee8-af1b-bb8e82b6cf5b-20210923224950350.png" alt="img"></p><p>如果你不希望触发锁续期，可以像lock(leaseTime, unit)一样指定过期时间，还可以指定加锁失败后等待多久：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLockSuccess</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;bravo1988_distributed_lock&quot;</span>);<br>    <span class="hljs-comment">// 基本等同于lock()，加锁成功也【会自动锁续期】，但获锁失败【立即返回false】，交给调用者判断是否阻塞或放弃</span><br>    lock.tryLock();<br>    <span class="hljs-comment">// 加锁成功仍然【会自动锁续期】，但获锁失败【会等待10秒】，看看这10秒内当前锁是否释放，如果是否则尝试加锁</span><br>    lock.tryLock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-comment">// 加锁成功【不会锁续期】，加锁失败【会等待10秒】，看看这10秒内当前锁是否释放，如果是否则尝试加锁</span><br>    lock.tryLock(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意哈，只传两个参数时，那个time其实是传给waitTime的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979480581-3f3ecda4-159e-475a-80d3-9854b1affea3-20210923225001508.png" alt="img"></p><p>我们之前操作的都是leaseTime，此时还是-1，也就是说如果加锁成功，还是会锁续期。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979506461-ae56c20c-6a92-44be-ac30-0944c8caaa47-20210923225007411.png" alt="img"></p><p>那waitTime是用来控制什么的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979722684-793f715f-e2ed-498f-98e1-68b8d69519e8-20210923225013679.png" alt="img"></p><p>简而言之：</p><ul><li>tryLock()加锁失败会立即返回false，而加了waitTime可以手动指定阻塞等待的时间（等一等，万一行呢）</li><li>leaseTime的作用没变，控制的是加锁成功后要不要续期</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606183066878-ce4cc7de-8cc1-4dd1-995a-b663df428550-20210923225020644.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612490364124-289ef177-9b03-4cc0-9168-f6270728cff9-20210923225025657.jpeg" alt="img"></p><p>至此，分布式锁章节暂时告一段段落。大家有兴趣的话，可以把上一篇花里胡哨的定时任务用Redisson改写，去掉Redis Message Queue（但定时任务最好还是用xxl-job等）。</p><p>Redisson的具体使用方法可以参考尚硅谷雷丰阳老师的讲解：</p><p><a href="https://www.bilibili.com/video/BV18a4y1L7nv?p=57">https://www.bilibili.com/video/BV18a4y1L7nv?p=57</a></p><h1 id="Redisson分布式锁的缺陷"><a href="#Redisson分布式锁的缺陷" class="headerlink" title="Redisson分布式锁的缺陷"></a>Redisson分布式锁的缺陷</h1><p>在哨兵模式或者主从模式下，如果master实例宕机，可能导致多个节点同时完成加锁。</p><p>以主从模式为例，由于所有的写操作都是先在master上进行，然后再同步给各个slave节点，所以master与各个slave节点之间的数据具有一定的延迟性。对于Redisson分布式锁而言，比如客户端刚对master写入Redisson锁，然后master异步复制给各个slave节点，但这个过程中master节点宕机了，其中一个slave节点经过选举变成了master节点，好巧不巧，这个slave还没同步到Reddison锁，所以其他客户端可能再次加锁。</p><p>具体情况，大家可以百度看看，解决方案也比较多。</p><p>还是那句话，但凡涉及到分布式，都没那么简单。有时引入一个解决方案后，我们不得不面对另一个问题。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Redis分布式锁(中)</title>
    <link href="/2020/10/17/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%AD)/"/>
    <url>/2020/10/17/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%AD)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Demo构思"><a href="#Demo构思" class="headerlink" title="Demo构思"></a>Demo构思</h1><p>在我看来，同样需要使用锁，动机可能完全相反：</p><ul><li>在保证线程安全的前提下，尽量让所有线程都执行成功</li><li>在保证线程安全的前提下，只让一个线程执行成功</li></ul><p>前者适用于秒杀等场景。作为商家，当然希望在不发生线程安全问题的前提下，让每一个订单都生效，直到商品售罄。此时分布式锁的写法可以是<strong>“不断重试”</strong>或<strong>“阻塞等待”</strong>，即：递归或while true循环尝试获取、阻塞等待。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604506622183-fa1bd017-75eb-485a-beed-866826fda0a8-20210923221540849.png" alt="img"></p><p>而后者适用于分布式系统或多节点项目的定时任务，比如同一份代码部署在A、B两台服务器上，而数据库共用同一个。如果不做限制，那么在同一时刻，两台服务器都会去拉取列表执行，会发生任务重复执行的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604217589786-b289e306-b9c9-4109-8dcc-9c444b5d4354-20210923221547128.png" alt="img"></p><p>此时可以考虑使用分布式锁，在cron触发的时刻只允许一个线程去往数据库拉取任务：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604217793953-9468293c-633e-49dc-9020-c69e34cb3b3e-20210923221555357.png" alt="img"></p><p>在实现Redis分布式锁控制定时任务唯一性的同时，我们引入之前的Redis消息队列。注意，这与Redis分布式锁本身无关，就是顺便复习一遍Redis消息队列而已，大家可以只实现Redis分布式锁+定时任务的部分。</p><p>整个Demo的结构大致如图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604218829172-5ce20fc4-99d0-4a26-9b62-053c240660bd-20210923221600743.png" alt="img"></p><p>当然，实际项目中一般是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604489189715-299c40b4-85c2-47c7-9bc4-75aeee053a45-20210923221605971.png" alt="img"></p><h1 id="分布式锁为什么难设计？"><a href="#分布式锁为什么难设计？" class="headerlink" title="分布式锁为什么难设计？"></a>分布式锁为什么难设计？</h1><p>首先，要和大家说一下，但凡牵涉到分布式的处理，没有一个是简单的，上面的Demo设计也不过是玩具，用来启发 大家的思路。</p><p>为什么要把Demo设计得这么复杂呢？哈哈，因为这是我在上一家公司自己设计的，遇到了很多坑…拿出来自嘲一番，与各位共勉。</p><p>我当时的设计思路是：</p><p>由于小公司没有用什么Elastic-Job啥的，就是很普通的多节点部署。为了避免任务重复执行，我想设计一个分布式锁。但因为当时根本不知道Redisson，所以就自己百度了Redis实现分布式锁的方式，然后依葫芦画瓢自己手写了一个 。</p><p>但我写完Redis分布式锁后，在实际测试过程中发现还需要考虑锁的失效时间…</p><p>这里有两个问题：</p><ul><li>为什么要设置锁的过期时间？</li><li>锁的过期时间设置多久合适？</li></ul><p>最简单的实现方案是这样的，一般没问题：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604506681868-7e03eae9-f974-481b-be00-d32180cd2fe2-20210923221614779.png" alt="img"></p><p>但极端的情况下（项目在任务进行时重启或意外宕机），可能当前任务来不及解锁就挂了（死锁），那么下一个任务就会一直被锁在方法外等待。就好比厕所里有人被熏晕了，没法开门，而外面的人又进不去…</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604506732285-dedfe3a9-bbcd-422f-bc35-fe215bbf0035-20210923221619771.png" alt="img"></p><p>此时需要装一个自动解锁的门，到时间自动开门，也就是要给锁设置一个过期时间。但紧接着又会有第二个问题：锁的失效时间设多长合适？</p><p><strong>很难定。</strong></p><p>因为随着项目的发展，<strong>定时任务的执行时间很可能是变化的。</strong></p><p>如果设置时间过长，极端点，定为365天。假设任务正常执行，比如10分钟就结束，那么线程继续往下就会执行unLock()主动解锁。但万一和上面一样宕机了，那么这个锁就要等365天后才解开。注意，宕机可不像JVM异常，它压根不会去执行finally里的unLock()。这种情况好比有个人在厕所里上大号直接掉坑里了，而自动门默认365天打开…所以，锁过期时间设置过长的坏处，本质是一旦发生宕机来不及解锁，那么过期时间越长，影响面越广，会导致其他操作阻滞。</p><p>如果设置时间过短，上一个人还没拉完，门就“咔嚓”一声开了，尴尬不，重复执行了。</p><p>终上所述，我当时之所以设计得这么复杂，就是想尽量缩短任务执行的时间，让它尽可能短（拉取后直接丢给队列，自己不处理），这样锁的时间一般设置30分钟就没啥问题。另外，对于死锁问题，我当时没有考虑宕机的情况，只考虑了意外重启…问题还有很多，文末会再总结。</p><p>请大家阅读下面代码时思考两个问题：</p><ul><li>Demo如何处理锁的过期时间</li><li>Demo如何防止死锁</li></ul><h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><p>新建一个空的SpringBoot项目。</p><p>拷贝下方代码，构建工程：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604495698917-9216d65d-baeb-4c25-8eda-4bc3adc0b593-20210923221627242.png" alt="img"></p><p>构建完以后，拷贝一份，修改端口号为8081，避免和原先的冲突</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604232665683-4d39ad7a-58f0-4bec-b043-d2e67eb68e7b-20210923221633686.png" alt="img"></p><h2 id="统一管理Redis-Key：RedisKeyConst"><a href="#统一管理Redis-Key：RedisKeyConst" class="headerlink" title="统一管理Redis Key：RedisKeyConst"></a>统一管理Redis Key：RedisKeyConst</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 统一管理Redis Key</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qiyu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisKeyConst</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分布式锁的KEY</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESUME_PULL_TASK_LOCK = <span class="hljs-string">&quot;resume_pull_task_lock&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简历异步解析任务队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESUME_PARSE_TASK_QUEUE = <span class="hljs-string">&quot;resume_parse_task_queue&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Redis消息队列：RedisMessageQueueConsumer"><a href="#Redis消息队列：RedisMessageQueueConsumer" class="headerlink" title="Redis消息队列：RedisMessageQueueConsumer"></a>Redis消息队列：RedisMessageQueueConsumer</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消费者，异步获取简历解析结果并存入数据库</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qiyu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisMessageQueueConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ContextRefreshedEvent</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisService redisService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AsyncResumeParser asyncResumeParser;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始监听RedisMessageQueue...&quot;</span>);<br>        CompletableFuture.runAsync(() -&gt; &#123;<br>            <span class="hljs-comment">// 大循环，不断监听队列任务（阻塞式）</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">// 阻塞监听</span><br>                ResumeCollectionDTO resumeCollectionDTO = (ResumeCollectionDTO) redisService.popQueue(RedisKeyConst.RESUME_PARSE_TASK_QUEUE, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>                <span class="hljs-keyword">if</span> (resumeCollectionDTO != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">int</span> rePullCount = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">int</span> retryCount = <span class="hljs-number">0</span>;<br>                    log.info(<span class="hljs-string">&quot;从队列中取出:&#123;&#125;&quot;</span>, resumeCollectionDTO.getName());<br>                    log.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始拉取简历:&#123;&#125;&quot;</span>, resumeCollectionDTO.getName());<br>                    Long asyncPredictId = resumeCollectionDTO.getAsyncPredictId();<br>                    <span class="hljs-comment">// 小循环，针对每一个任务多次调用第三方接口，直到获取最终结果或丢弃任务</span><br>                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            PredictResult result = asyncResumeParser.getResult(asyncPredictId);<br>                            rePullCount++;<br>                            <span class="hljs-comment">// 如果已经解析完毕</span><br>                            <span class="hljs-keyword">if</span> (result.getStatus() == <span class="hljs-number">2</span>) &#123;<br>                                <span class="hljs-comment">// 保存数据库</span><br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    log.info(<span class="hljs-string">&quot;简历:&#123;&#125;解析成功&quot;</span>, resumeCollectionDTO.getName());<br>                                    log.info(<span class="hljs-string">&quot;resultJson:&#123;&#125;&quot;</span>, result.getResultJson());<br>                                    ResumeCollectionDO resumeCollectionDO = objectMapper.readValue(result.getResultJson(), ResumeCollectionDO.class);<br>                                    log.info(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;保存简历:&#123;&#125;到数据库&quot;</span>, resumeCollectionDO);<br>                                    <span class="hljs-comment">// 归零</span><br>                                    rePullCount = <span class="hljs-number">0</span>;<br>                                    retryCount = <span class="hljs-number">0</span>;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                                    discardTask(resumeCollectionDTO);<br>                                    log.info(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;保存简历失败，丢弃任务&quot;</span>);<br>                                    rePullCount = <span class="hljs-number">0</span>;<br>                                    retryCount = <span class="hljs-number">0</span>;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                            &#125;<br>                            <span class="hljs-comment">// 远程服务还未解析完毕，重试</span><br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-keyword">if</span> (rePullCount &lt;= <span class="hljs-number">3</span>) &#123;<br>                                        <span class="hljs-comment">// 前3次重试，时间为1s间隔</span><br>                                        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                                        log.info(<span class="hljs-string">&quot;简历:&#123;&#125;尚未解析完毕, 准备进行第&#123;&#125;次重试, 停顿1s后进行&quot;</span>, resumeCollectionDTO.getName(), rePullCount);<br>                                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rePullCount &gt; <span class="hljs-number">3</span> &amp;&amp; rePullCount &lt;= <span class="hljs-number">6</span>) &#123;<br>                                        <span class="hljs-comment">// 说明任务比较耗时，加长等待时间</span><br>                                        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                                        log.info(<span class="hljs-string">&quot;简历:&#123;&#125;尚未解析完毕, 准备进行第&#123;&#125;次重试, 停顿2s后进行&quot;</span>, resumeCollectionDTO.getName(), rePullCount);<br>                                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rePullCount &gt; <span class="hljs-number">6</span> &amp;&amp; rePullCount &lt;= <span class="hljs-number">8</span>) &#123;<br>                                        <span class="hljs-comment">// 说明任务比较耗时，加长等待时间</span><br>                                        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                                        log.info(<span class="hljs-string">&quot;简历:&#123;&#125;尚未解析完毕, 准备进行第&#123;&#125;次重试, 停顿3s后进行&quot;</span>, resumeCollectionDTO.getName(), rePullCount);<br>                                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                                        discardTask(resumeCollectionDTO);<br>                                        log.info(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;多次拉取仍未得到结果, 丢弃简历:&#123;&#125;&quot;</span>, resumeCollectionDTO.getName());<br>                                        retryCount = <span class="hljs-number">0</span>;<br>                                        rePullCount = <span class="hljs-number">0</span>;<br>                                        <span class="hljs-keyword">break</span>;<br>                                    &#125;<br>                                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                                    discardTask(resumeCollectionDTO);<br>                                    log.info(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;任务中断异常, 简历:&#123;&#125;&quot;</span>, resumeCollectionDTO.getName());<br>                                    rePullCount = <span class="hljs-number">0</span>;<br>                                    retryCount = <span class="hljs-number">0</span>;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                            <span class="hljs-keyword">if</span> (retryCount &gt; <span class="hljs-number">3</span>) &#123;<br>                                discardTask(resumeCollectionDTO);<br>                                log.info(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;简历:&#123;&#125;重试&#123;&#125;次后放弃, rePullCount:&#123;&#125;, retryCount:&#123;&#125;&quot;</span>, resumeCollectionDTO.getName(), retryCount, rePullCount, retryCount);<br>                                rePullCount = <span class="hljs-number">0</span>;<br>                                retryCount = <span class="hljs-number">0</span>;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            retryCount++;<br>                            log.info(<span class="hljs-string">&quot;简历:&#123;&#125;远程调用异常, 准备进行第&#123;&#125;次重试...&quot;</span>, resumeCollectionDTO.getName(), retryCount);<br>                        &#125;<br>                    &#125;<br>                    log.info(<span class="hljs-string">&quot;break......&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discardTask</span><span class="hljs-params">(ResumeCollectionDTO task)</span> </span>&#123;<br>        <span class="hljs-comment">// 根据asyncPredictId删除任务...</span><br>        log.info(<span class="hljs-string">&quot;丢弃任务:&#123;&#125;...&quot;</span>, task.getName());<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="实体类：DO-DTO"><a href="#实体类：DO-DTO" class="headerlink" title="实体类：DO+DTO"></a>实体类：DO+DTO</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResumeCollectionDO</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简历id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简历名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResumeCollectionDTO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简历id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异步解析id，稍后根据id可获取最终解析结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long asyncPredictId;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简历名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="分布式锁：RedisService"><a href="#分布式锁：RedisService" class="headerlink" title="分布式锁：RedisService"></a>分布式锁：RedisService</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RedisService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向队列插入消息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue 自定义队列名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj   要存入的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushQueue</span><span class="hljs-params">(String queue, Object obj)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列取出消息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue    自定义队列名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout  最长阻塞等待时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit 时间单位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">popQueue</span><span class="hljs-params">(String queue, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试上锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String lockKey, String value, <span class="hljs-keyword">long</span> expireTime, TimeUnit timeUnit)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据MACHINE_ID解锁（只能解自己的）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">unLock</span><span class="hljs-params">(String lockKey, String value)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁，不管是不是自己的</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseLock</span><span class="hljs-params">(String lockKey, String value)</span></span>;<br><br>&#125;<br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RedisService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向队列插入消息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue 自定义队列名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj   要存入的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushQueue</span><span class="hljs-params">(String queue, Object obj)</span> </span>&#123;<br>        redisTemplate.opsForList().leftPush(queue, obj);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列取出消息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue    自定义队列名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout  最长阻塞等待时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit 时间单位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">popQueue</span><span class="hljs-params">(String queue, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForList().rightPop(queue, timeout, timeUnit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试上锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String lockKey, String value, <span class="hljs-keyword">long</span> expireTime, TimeUnit timeUnit)</span> </span>&#123;<br>        Boolean lock = redisTemplate.opsForValue().setIfAbsent(lockKey, value);<br>        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(lock)) &#123;<br>            redisTemplate.expire(lockKey, expireTime, timeUnit);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据MACHINE_ID解锁（只能解自己的）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLock</span><span class="hljs-params">(String lockKey, String value)</span> </span>&#123;<br>        String machineId = (String) redisTemplate.opsForValue().get(lockKey);<br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(machineId) &amp;&amp; machineId.equals(value)) &#123;<br>            redisTemplate.delete(lockKey);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁，不管是不是自己的</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseLock</span><span class="hljs-params">(String lockKey, String value)</span> </span>&#123;<br>        Boolean delete = redisTemplate.delete(lockKey);<br>        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(delete)) &#123;<br>            log.info(<span class="hljs-string">&quot;Spring启动，节点:&#123;&#125;成功释放上次简历汇聚定时任务锁&quot;</span>, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="定时任务：ResumeCollectionTask"><a href="#定时任务：ResumeCollectionTask" class="headerlink" title="定时任务：ResumeCollectionTask"></a>定时任务：ResumeCollectionTask</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResumeCollectionTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ContextRefreshedEvent</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当这份代码被部署到不同的服务器，启动时为每台机器分配一个唯一的机器ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MACHINE_ID = IdUtil.randomUUID();<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisService redisService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AsyncResumeParser asyncResumeParser;<br><br>    <span class="hljs-meta">@Scheduled(cron = &quot;0 */1 * * * ?&quot;)</span><br><span class="hljs-comment">//    @Scheduled(fixedDelay = 60 * 1000L)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resumeSchedule</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 尝试上锁，返回true或false，锁的过期时间设置为10分钟（实际要根据项目调整，这也是自己实现Redis分布式锁的难点之一）</span><br>        <span class="hljs-keyword">boolean</span> lock = redisService.tryLock(RedisKeyConst.RESUME_PULL_TASK_LOCK, MACHINE_ID, <span class="hljs-number">10</span>, TimeUnit.MINUTES);<br><br>        <span class="hljs-comment">// 如果当前节点成功获取锁，那么整个系统只允许当前程序去MySQL拉取待执行任务</span><br>        <span class="hljs-keyword">if</span> (lock) &#123;<br>            log.info(<span class="hljs-string">&quot;节点:&#123;&#125;获取锁成功，定时任务启动&quot;</span>, MACHINE_ID);<br>            <span class="hljs-keyword">try</span> &#123;<br>                collectResume();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.info(<span class="hljs-string">&quot;定时任务异常:&quot;</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                redisService.unLock(RedisKeyConst.RESUME_PULL_TASK_LOCK, MACHINE_ID);<br>                log.info(<span class="hljs-string">&quot;节点:&#123;&#125;释放锁，定时任务结束&quot;</span>, MACHINE_ID);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;节点:&#123;&#125;获取锁失败，放弃定时任务&quot;</span>, MACHINE_ID);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务主体：</span><br><span class="hljs-comment">     * 1.从数据库拉取符合条件的HR邮箱</span><br><span class="hljs-comment">     * 2.从HR邮箱拉取附件简历</span><br><span class="hljs-comment">     * 3.调用远程服务异步解析简历</span><br><span class="hljs-comment">     * 4.插入待处理任务到数据库，作为记录留存</span><br><span class="hljs-comment">     * 5.把待处理任务的id丢到Redis Message Queue，让Consumer去异步处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collectResume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 跳过1、2两步，假设已经拉取到简历</span><br>        log.info(<span class="hljs-string">&quot;节点:&#123;&#125;从数据库拉取任务简历&quot;</span>, MACHINE_ID);<br>        List&lt;ResumeCollectionDO&gt; resumeCollectionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        resumeCollectionList.add(<span class="hljs-keyword">new</span> ResumeCollectionDO(<span class="hljs-number">1L</span>, <span class="hljs-string">&quot;张三的简历.pdf&quot;</span>));<br>        resumeCollectionList.add(<span class="hljs-keyword">new</span> ResumeCollectionDO(<span class="hljs-number">2L</span>, <span class="hljs-string">&quot;李四的简历.html&quot;</span>));<br>        resumeCollectionList.add(<span class="hljs-keyword">new</span> ResumeCollectionDO(<span class="hljs-number">3L</span>, <span class="hljs-string">&quot;王五的简历.doc&quot;</span>));<br>        <span class="hljs-comment">// 模拟数据库查询耗时</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br><br>        log.info(<span class="hljs-string">&quot;提交任务到消息队列:&#123;&#125;&quot;</span>, resumeCollectionList.stream().map(ResumeCollectionDO::getName).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>)));<br><br>        <span class="hljs-keyword">for</span> (ResumeCollectionDO resumeCollectionDO : resumeCollectionList) &#123;<br>            <span class="hljs-comment">// 上传简历异步解析，得到异步结果id</span><br>            Long asyncPredictId = asyncResumeParser.asyncParse(resumeCollectionDO);<br><br>            <span class="hljs-comment">// 把任务插入数据库</span><br>            <span class="hljs-comment">// 略...</span><br><br>            <span class="hljs-comment">// 把任务丢到Redis Message Queue</span><br>            ResumeCollectionDTO resumeCollectionDTO = <span class="hljs-keyword">new</span> ResumeCollectionDTO();<br>            BeanUtils.copyProperties(resumeCollectionDO, resumeCollectionDTO);<br>            resumeCollectionDTO.setAsyncPredictId(asyncPredictId);<br>            redisService.pushQueue(RedisKeyConst.RESUME_PARSE_TASK_QUEUE, resumeCollectionDTO);<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 项目重启后先尝试删除之前的锁（如果存在），防止死锁等待</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> event the event to respond to</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;<br>        redisService.releaseLock(RedisKeyConst.RESUME_PULL_TASK_LOCK, MACHINE_ID);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="模拟第三方服务（异步）"><a href="#模拟第三方服务（异步）" class="headerlink" title="模拟第三方服务（异步）"></a>模拟第三方服务（异步）</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第三方提供给的简历解析服务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qiyu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncResumeParser</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟分配异步任务结果id，不用深究，没啥意义，反正每个任务都会得到一个id，稍后根据id返回最终解析结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicLong ASYNC_RESULT_ID = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Long, String&gt; results = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟第三方服务异步解析，返回解析结果</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resumeCollectionDO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">asyncParse</span><span class="hljs-params">(ResumeCollectionDO resumeCollectionDO)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> asyncPredictId = ASYNC_RESULT_ID.getAndIncrement();<br>        <span class="hljs-keyword">try</span> &#123;<br>            String resultJson = objectMapper.writeValueAsString(resumeCollectionDO);<br>            results.put(asyncPredictId, resultJson);<br>            <span class="hljs-keyword">return</span> asyncPredictId;<br>        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1L</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据异步id返回解析结果，但此时未必已经解析成功</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 解析状态</span><br><span class="hljs-comment">     * 0 初始化</span><br><span class="hljs-comment">     * 1 处理中</span><br><span class="hljs-comment">     * 2 调用成功</span><br><span class="hljs-comment">     * 3 调用失败</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> asyncPredictId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PredictResult <span class="hljs-title">getResult</span><span class="hljs-params">(Long asyncPredictId)</span> <span class="hljs-keyword">throws</span> ParseErrorException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 随机模拟异步解析的状态</span><br>        <span class="hljs-keyword">int</span> value = ThreadLocalRandom.current().nextInt(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">85</span>) &#123;<br>            <span class="hljs-comment">// 模拟解析完成</span><br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            String resultJson = results.get(asyncPredictId);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PredictResult(resultJson, <span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt;= <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-comment">// 模拟解析异常</span><br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseErrorException(<span class="hljs-string">&quot;简历解析异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果时间过短，返回status=1，表示解析中</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PredictResult(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解析异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qiyu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParseErrorException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new exception with &#123;<span class="hljs-doctag">@code</span> null&#125; as its detail message.</span><br><span class="hljs-comment">     * The cause is not initialized, and may subsequently be initialized by a</span><br><span class="hljs-comment">     * call to &#123;<span class="hljs-doctag">@link</span> #initCause&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParseErrorException</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new exception with the specified detail message.  The</span><br><span class="hljs-comment">     * cause is not initialized, and may subsequently be initialized by</span><br><span class="hljs-comment">     * a call to &#123;<span class="hljs-doctag">@link</span> #initCause&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message the detail message. The detail message is saved for</span><br><span class="hljs-comment">     *                later retrieval by the &#123;<span class="hljs-doctag">@link</span> #getMessage()&#125; method.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParseErrorException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第三方返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qiyu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PredictResult</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String resultJson;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析状态</span><br><span class="hljs-comment">     * 0 初始化</span><br><span class="hljs-comment">     * 1 处理中</span><br><span class="hljs-comment">     * 2 调用成功</span><br><span class="hljs-comment">     * 3 调用失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer status;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="模拟异常"><a href="#模拟异常" class="headerlink" title="模拟异常"></a>模拟异常</h2><p><strong>在项目运行过程中，</strong>启动这个测试类的方法，即可观察不一样的现象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisDistributedLockApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisService redisService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 作为失败案例（因为不存在777L这个解析任务，AsyncResumeParse.results会返回null）</span><br><span class="hljs-comment">     * 观察RedisMessageQueueConsumer的处理方式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        ResumeCollectionDTO resumeCollectionDTO = <span class="hljs-keyword">new</span> ResumeCollectionDTO();<br>        resumeCollectionDTO.setId(<span class="hljs-number">666L</span>);<br>        resumeCollectionDTO.setAsyncPredictId(<span class="hljs-number">777L</span>);<br>        resumeCollectionDTO.setName(<span class="hljs-string">&quot;测试1号&quot;</span>);<br><br>        redisService.pushQueue(RedisKeyConst.RESUME_PARSE_TASK_QUEUE, resumeCollectionDTO);<br><br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-comment"># </span><br>    <span class="hljs-attr">password:</span> <span class="hljs-comment"># </span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>啥都不说了，都在<del>jiu</del>代码里了。大家自己拷贝到本地，动手玩一下，加深对Redis锁和Redis消息队列的理解。</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://cloud.video.taobao.com/play/u/432628/p/1/d/hd/e/6/t/1/286252615441.mp4?auth_key=YXBwX2tleT04MDAwMDAwMTImYXV0aF9pbmZvPXsidGltZXN0YW1wRW5jcnlwdGVkIjoiMWUyYjkyMTY4NzMzYmMxMDQ2M2QyNDI5MDlhZWRjZDMifSZkdXJhdGlvbj0mdGltZXN0YW1wPTE2MzI0NTA3Mzc="}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604496815462-e6a559e8-27da-492f-b720-cf3f01e62429-20210923221905040.png" alt="img"></p><p>只有一个定时任务能去数据库拉取任务，到时多节点部署大致是下面这样（redis一般是独立部署的，和节点代码无关）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606026519366-b528e8be-3cfc-4a9a-a574-8a6ae401b41f-20210923221915282.png" alt="img"></p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>上面展示的代码其实存在很多问题，我们会在下一篇指出并讨论解决方案。</p><p>本文仅提供思路，开阔大家的眼界，<strong>千万别在自己项目中使用！！！！</strong>我当年被这个坑惨了，花里胡哨的，尤其Consumer里一大堆的sleep()，是非常low的！！</p><p><strong>对于异步调用的结果，不要循环等待，</strong>而应该分为几步：</p><ol><li><p>调用异步接口，得到异步结果唯一id</p></li><li><p>将结果id保存到任务表中，作为一个任务</p></li><li><p>启动定时任务，根据id拉取最终结果（如果还没有结果，跳过当前任务，等下一个定时任务处理）</p></li></ol><p>分布式定时任务可以考虑xxl-job或elastic-job，分布式锁推荐使用<a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">redisson</a>。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Redis分布式锁(上)</title>
    <link href="/2020/10/05/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8A)/"/>
    <url>/2020/10/05/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不论面试还是实际工作中，Redis都是避无可避的技术点。在我心里，MySQL和Redis是衡量一个程序员是否“小有所成”的两把标尺。如果他能熟练使用MySQL和Redis，以小化大，充分利用现有资源出色地完成当下需求，说明他已经成长了。</p><p>本篇文章我们一起来探讨Redis分布式锁相关的内容。</p><p>说到锁，大家第一时间想到的应该是synchronized关键字或ReentrantLock，随即想到偏向锁、自旋锁、重量级锁或者CAS甚至AQS。一般来说，我不喜欢一下子引入这么多概念，可能会把问题弄复杂，但为了方便大家理解Redis分布式锁，这里稍微提一下。</p><h1 id="JVM锁"><a href="#JVM锁" class="headerlink" title="JVM锁"></a>JVM锁</h1><p>所谓JVM锁，其实指的是诸如synchronized关键字或者ReentrantLock实现的锁。之所以统称为JVM锁，是因为我们的项目其实都是跑在JVM上的。理论上每一个项目启动后，就对应一片JVM内存，后续运行时数据的生离死别都在这一片土地上。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1620095054769-ca64b8aa-6bd0-4bdc-a4da-cc7e5d181d24-20210924103005529.png" alt="图片.png"></p><h1 id="什么是锁、怎么锁？"><a href="#什么是锁、怎么锁？" class="headerlink" title="什么是锁、怎么锁？"></a>什么是锁、怎么锁？</h1><p>明白了“JVM锁”名字的由来，我们再来聊什么是“锁”，以及怎么“锁”。</p><p>有时候我们很难阐述清楚某个事物<strong>是什么</strong>，但很容易解释它<strong>能干什么</strong>，JVM锁也是这个道理。JVM锁的出现，就是为了解决线程安全问题。所谓线程安全问题，可以简单地理解为数据不一致（与预期不一致）。</p><p>什么时候可能出现线程安全问题呢？</p><p>当同时满足以下三个条件时，才可能引发线程安全问题：</p><ul><li><p>多线程环境</p></li><li><p>有共享数据</p></li><li><p>有多条语句操作共享数据/单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）</p></li></ul><p>比如线程A、B同时对int count进行+1操作（初始值假设为1），在一定的概率下两次操作最终结果可能为2，而不是3。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604203263605-6b838677-f5b4-48cd-9298-2788c694aa15-20210924103020945.png" alt="image.png"></p><p>那么加锁为什么能解决这个问题呢？</p><p>如果不考虑原子性、内存屏障等晦涩的名词，加锁之所以能保证线程安全，核心就是“互斥”。所谓互斥，就是字面意思上的<strong>互</strong>相排<strong>斥</strong>。这里的“互相”是指谁呢？就是多线程之间！</p><p>怎么实现多线程之间的互斥呢？</p><p>引入“中间人”即可。</p><p>注意，这是个非常简单且伟大的思想。在编程世界中，通过引入“中介”最终解决问题的案例不胜枚举，包括但不限于Spring、MQ。在码农之间，甚至流传着一句话：没有什么问题是引入中间层解决不了的。</p><p>而JVM锁其实就是线程和线程彼此的“中间人”，多个线程在操作加锁数据前都必须征求“中间人”的同意：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612488996804-3ea7c557-98ae-4d76-aa5a-5933c1fe6026-20210924103037552.png" alt="图片.png"></p><p>锁在这里扮演的角色其实就是守门员，是<strong>唯一</strong>的访问入口，所有的线程都要经过它的拷问。在JDK中，锁的实现机制最常见的就是两种，分别是两个派系：</p><ul><li>synchronized关键字</li><li>AQS</li></ul><p>个人觉得synchronized关键字要比AQS难理解，但AQS的源码比较抽象。这里简要介绍一下Java对象内存结构和synchronized关键字的实现原理。</p><h1 id="Java对象内存结构"><a href="#Java对象内存结构" class="headerlink" title="Java对象内存结构"></a>Java对象内存结构</h1><p>要了解synchronized关键字，首先要知道Java对象的内存结构。强调一遍，是Java<strong>对象的内存结构</strong>。</p><p>它的存在仿佛向我们抛出一个疑问：如果有机会解剖一个Java对象，我们能看到什么？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604205724123-0a6ab812-080e-4626-8a35-db6b6a41bd04-20210924103057869.png" alt="image.png"></p><p>右上图画了两个对象，只看其中一个即可。我们可以观察到，Java对象内存结构大致分为几块：</p><ul><li><p>Mark Word（锁相关）</p></li><li><p>元数据指针（class pointer，指向当前实例所属的类）</p></li><li><p>实例数据（instance data，我们平常看到的仅仅是这一块）</p></li><li><p>对齐（padding，和内存对齐有关）</p></li></ul><p>如果此前没有了解过Java对象的内存结构，你可能会感到吃惊：天呐，我还以为Java对象就只有属性和方法！</p><p>是的，我们最熟悉实例数据这一块，而且<strong>以为只有这一块。</strong>也正是这个观念的限制，导致一部分初学者很难理解synchronized。比如初学者经常会疑惑：</p><ul><li><p>为什么任何对象都可以作为锁？</p></li><li><p>Object对象锁和类锁有什么区别？</p></li><li><p>synchronized修饰的普通方法使用的锁是什么？</p></li><li><p>synchronized修饰的静态方法使用的锁是什么？</p></li></ul><p>这一切的一切，其实都可以在Java对象内存结构中的Mark Word找到答案：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604208962907-39530cce-67a1-41ff-9855-13f3297d2c10-20210924103109319.png" alt="image.png"></p><p>很多同学可能是第一次看到这幅图，会感到有点懵，没关系，我也很头大，都一样的。</p><p>Mark Word包含的信息还是蛮多的，但这里我们只需要简单地把它理解为<strong>记录锁信息</strong>的标记即可。上图展示的是32位虚拟机下的Java对象内存，如果你仔细数一数，会发现全部bit加起来刚好是32位。64位虚拟机下的结构大同小异，就不特别介绍。</p><p>Mark Word从有限的32bit中划分出2bit，专门用作锁标志位，通俗地讲就是标记当前锁的状态。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1620095815528-242114c7-277f-4777-ad33-9e38d4c62c27.png" alt="img"></p><p>正因为每个Java对象都有Mark Word，而Mark Word能标记锁状态（把自己当做锁），所以Java中任意对象都可以作为synchronized的锁：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(person)&#123;<br>&#125;<br><span class="hljs-keyword">synchronized</span>(student)&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>所谓的this锁就是当前对象，而Class锁就是当前对象所属类的Class对象，本质也是Java对象。synchronized修饰的普通方法底层使用当前对象作为锁，synchronized修饰的静态方法底层使用Class对象作为锁。</strong></p><p>但如果要保证多个线程互斥，最基本的条件是它们<strong>使用同一把锁：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612489131320-62cceb64-2ba8-431d-985f-03cbe8f42df2-20210923220222012.png" alt="img"></p><p>对同一份数据加两把不同的锁是没有意义的，实际开发时应该注意避免下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(Person.class)&#123;<br>    <span class="hljs-comment">// 操作count</span><br>&#125;<br><br><span class="hljs-keyword">synchronized</span>(person)&#123;<br>    <span class="hljs-comment">// 操作count</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 操作count</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 操作count</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="synchronized与锁升级"><a href="#synchronized与锁升级" class="headerlink" title="synchronized与锁升级"></a>synchronized与锁升级</h1><p>大致介绍完Java对象内存结构后，我们再来解决一个新疑问：</p><p>为什么需要标记锁的状态呢？是否意味着synchronized锁有多种状态呢？</p><p>在JDK早期版本中，synchronized关键字的实现是直接基于重量级锁的。只要我们在代码中使用了synchronized，JVM就会向操作系统申请锁资源（不论当前是否真的是多线程环境），而向操作系统申请锁是比较耗费资源的，其中涉及到用户态和内核态的切换等，总之就是比较费事，且性能不高。</p><p>JDK为了解决JVM锁性能低下的问题，引入了ReentrantLock，它基于CAS+AQS，类似自旋锁。自旋的意思就是，在发生锁竞争的时候，未争取到锁的线程会在门外采取自旋的方式等待锁的释放，谁抢到谁执行。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612489200273-6e3caa00-7625-42b7-9b03-e2a87ba09633-20210923220236604.png" alt="img"></p><p>自旋锁的好处是，不需要兴师动众地切换到内核态申请操作系统的重量级锁，在JVM层面即可实现自旋等待。但世界上并没有百利而无一害的灵丹妙药，CAS自旋虽然避免了状态切换等复杂操作，却要耗费部分CPU资源，尤其当可预计上锁的时间较长且并发较高的情况下，会造成几百上千个线程同时自旋，极大增加CPU的负担。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604463084016-ce0704e8-55d9-4035-9dda-15778b125560-20210923220242536.png" alt="img"></p><p>synchronized毕竟JDK亲儿子，所以大概在JDK1.6或者更早期的版本，官方对synchronized做了优化，提出了“锁升级”的概念，把synchronized的锁划分为多个状态，也就是上图中提到的：</p><ul><li><p>无锁</p></li><li><p>偏向锁</p></li><li><p>轻量级锁（自旋锁）</p></li><li><p>重量级锁</p></li></ul><p>无锁就是一个Java对象刚new出来的状态。当这个对象第一次被一个线程访问时，该线程会把自己的线程id“贴到”它的头上（Mark Word中部分位数被修改），表示“你是我的”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604211050450-4463b6fc-3864-4822-b6a5-e8ed98283b7c-20210924103138330.png" alt="image.png"></p><p>此时是不存在锁竞争的，所以并不会有什么阻塞或等待。</p><p>为什么要设计“偏向锁”这个状态呢？</p><p>大家回忆一下，项目中并发的场景真的这么多吗？并没有吧。大部分项目的大部分时候，某个变量都是单个线程在执行，此时直接向操作系统申请重量级锁显然没有必要，因为根本不会发生线程安全问题。</p><p>而一旦发生锁竞争时，synchronized便会在一定条件下升级为轻量级锁，可以理解为一种自旋锁，具体自旋多少次以及何时放弃自旋，JDK也有一套相关的控制机制，大家可以自行了解。</p><p>同样是自旋，所以synchronized也会遇到ReentrantLock的问题：如果上锁时间长且自旋线程多，又该如何？</p><p>此时就会再次升级，变成传统意义上的重量级锁，本质上操作系统会维护一个队列，用空间换时间，避免多个线程同时自旋等待耗费CPU性能，等到上一个线程结束时唤醒等待的线程参与新一轮的锁竞争即可。</p><p>拓展阅读（没太大必要）：</p><p><a href="https://www.cnblogs.com/kubidemanong/p/9520071.html">线程安全(中)–彻底搞懂synchronized(从偏向锁到重量级锁)</a></p><p><a href="https://www.jianshu.com/p/4758852cbff4">死磕Synchronized底层实现–偏向锁</a></p><h1 id="synchronized案例"><a href="#synchronized案例" class="headerlink" title="synchronized案例"></a>synchronized案例</h1><p>让我们一起来看几个案例，加深对synchronized的理解。</p><ul><li>同一个类中的synchronized method m1和method m2互斥吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290796058-a3bfc5f5-f6be-4543-8796-a2b170d36464-20210923220322058.png" alt="img"></p><p>t1线程执行m1方法时要去读this对象锁，但是t2线程并不需要读锁，两者各管各的，没有交集（不共用一把锁）</p><ul><li>同一个类中synchronized method m1中可以调用synchronized method m2吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290844351-21fa8f5e-80ac-400f-8033-88aad2dd6960-20210923220329432.png" alt="img"></p><p>synchronized是可重入锁，可以粗浅地理解为同一个线程在已经持有该锁的情况下，可以再次获取锁，并且会在某个状态量上做+1操作（ReentrantLock也支持重入）</p><ul><li>子类同步方法synchronized method m可以调用父类的synchronized method m吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290893998-8ba4a1e0-48a4-4789-9856-b5de2539ff7c-20210923220336563.png" alt="img"></p><p>子类对象初始化前，会调用父类构造方法，在结构上相当于包裹了一个父类对象，用的都是this锁对象</p><ul><li>静态同步方法和非静态同步方法互斥吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290932744-f6d63490-b46a-4c0e-b939-c0a54764f6be-20210923220344834.png" alt="img"></p><p>各玩各的，不是同一把锁，谈不上互斥</p><h1 id="Redis分布式锁的概念"><a href="#Redis分布式锁的概念" class="headerlink" title="Redis分布式锁的概念"></a>Redis分布式锁的概念</h1><p>谈到Redis分布式锁，总是会有这样或那样的疑问：</p><ul><li><p>什么是分布式</p></li><li><p>什么是分布式锁</p></li><li><p>为什么需要分布式锁</p></li><li><p>Redis如何实现分布式锁</p></li></ul><p>前3个问题其实可以一起回答，至于Redis如何实现分布式锁，我们放在下一篇。</p><p>什么是分布式？这是个很复杂的概念，我也很难说准确，所以干脆画个图，大家各花入各眼吧：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604211829338-3b84a9f8-b551-41ba-a83e-1428ea401e13-20210923220351203.png" alt="img"></p><p>分布式有个很显著的特点是，Service A和Service B极有可能并不是部署在同一个服务器上，所以它们也不共享同一片JVM内存。<strong>而上面介绍了，要想实现线程互斥，必须保证所有访问的线程使用的是同一把锁（JVM锁此时就无法保证互斥）。</strong></p><p>对于分布式项目，有多少台服务器就有多少片JVM内存，即使每片内存中各设置一把“独一无二”的锁，从整体来看项目中的锁就不是唯一的。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604292366085-77c2f620-9dce-417e-a714-e094c690b934-20210923220359938.png" alt="img"></p><p>此时，<strong>如何保证每一个JVM上的线程共用一把锁呢？</strong></p><p>答案是：把锁抽取出来，让线程们在<strong>同一片内存</strong>相遇。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604292683347-9f095018-1aa9-464d-848e-f26b2ae69a52-20210923220408318.png" alt="img"></p><p>但锁是不能凭空存在的，本质还是要在内存中，此时可以使用Redis缓存作为锁的宿主环境，这就是Redis能构造分布式锁的原因。</p><h1 id="Redis的锁长啥样"><a href="#Redis的锁长啥样" class="headerlink" title="Redis的锁长啥样"></a>Redis的锁长啥样</h1><p>synchronized关键字和ReentrantLock，它们都是实实在在已经实现的锁，而且还有标志位啥的。但Redis就是一个内存…怎么作为锁呢?</p><p>有一点大家要明确，Redis之所以能用来做分布式锁，肯定不只是因为它是一片内存，否则JVM本身也占有内存，为什么无法自己实现分布式锁呢？</p><p>我个人的理解是，要想自定义一个分布式锁，必须至少满足几个条件：</p><ul><li><p>多进程可见（独立于多节点系统之外的一片内存）</p></li><li><p>互斥（可以通过单线程，或者某种顺序机制）</p></li><li><p>可重入</p></li></ul><p>还有个条件，默认要支持：只有持有这把锁的客户端才能解锁</p><p>以上三点Redis都能满足。在上面三个条件下，其实怎么设计锁，完全取决于个人如何定义锁。就好比现实生活中，通常我们理解的锁就是有个钥匙孔、需要插入钥匙的金属小物件。然而锁的形态可不止这么一种，随着科技的发展，什么指纹锁、虹膜锁层出不穷，但归根结底它们之所以被称为“锁”，是因为都保证了“互斥”（我行，你不行）。</p><p>如果我们能设计一种逻辑，它能造成某个场景下的“互斥事件”，那么它就可以被称为“锁”。比如，某家很有名的网红店，一天只接待一位客人。门口没有营业员，就放了一台取号机，里面放了一张票。你如果去迟了，票就没了，你就进不了这家店。这个场景下，没票的顾客进不去，被锁在门外。此时，取票机造成了“互斥事件”，那么它就可以叫做“锁”。</p><p>而Redis提供了setnx指令，如果某个key当前不存在则设置成功并返回true，否则不再重复设置，直接返回false。这不就是编程界的取号机吗？当然，实际用到的命令可不止这一个，具体如何实现，请看下一篇~</p><p>这一篇从JVM锁聊到了Redis分布式锁，还介绍了Java的对象内存结构及synchronized底层的原理，相信大家对“锁”已经有了自己的感性认识。下一篇我们将通过分布式定时任务的案例介绍Redis分布式锁的使用场景。</p><p>下次见。</p><h1 id="思考一个问题：分布式系统是否一定要分布式锁？"><a href="#思考一个问题：分布式系统是否一定要分布式锁？" class="headerlink" title="思考一个问题：分布式系统是否一定要分布式锁？"></a>思考一个问题：分布式系统是否一定要分布式锁？</h1><p>分布式系统如果要加锁是否一定要使用分布式锁呢？</p><p>可能未必。</p><p>如果你需要的是写锁，那么可能确实需要分布式锁保证单一线程处理数据，而如果是为了防止缓存击穿（热点数据定时失效），那么使用JVM本地锁也没有太大关系。比如某个服务有10个节点，在使用JVM锁的情况下，即使某一时刻每个节点<strong>各自</strong>涌入1000个请求，虽然总共有1w个请求，但最终打到数据库的也只有10个，数据库层面是完全可以抗住这点请求量的，又由于本身是查询，所以不会造成线程安全问题。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络概述</title>
    <link href="/2020/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h2><h3 id="1-1-基本术语"><a href="#1-1-基本术语" class="headerlink" title="1.1. 基本术语"></a>1.1. 基本术语</h3><ol><li><strong>结点 （node）</strong> ：网络中的结点可以是计算机，集线器，交换机或路由器等。</li><li><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</li><li><strong>主机（host）</strong> ：连接在因特网上的计算机。</li><li><strong>ISP（Internet Service Provider）</strong> ：因特网服务提供者（提供商）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135211.png" alt="ISP (Internet Service Provider) Definition"></p><ol start="5"><li><strong>IXP（Internet eXchange Point）</strong> ： 互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135226.png" alt="IXP Traffic Levels During the Stratos Skydive — RIPE Labs"></p><p style="text-align:center;font-size:13px;color:gray">https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive</p><ol start="6"><li><strong>RFC(Request For Comments)</strong> ：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</li><li><strong>广域网 WAN（Wide Area Network）</strong> ：任务是通过长距离运送主机发送的数据。</li><li><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</li><li><strong>局域网 LAN（Local Area Network）</strong> ： 学校或企业大多拥有多个互连的局域网。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135238.png" alt="MAN &amp; WMAN | Red de área metropolitana, Redes informaticas, Par trenzado"></p><p style="text-align:center;font-size:13px;color:gray">http://conexionesmanwman.blogspot.com/</p><ol start="10"><li><strong>个人区域网 PAN（Personal Area Network）</strong> ：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135249.png" alt="Advantages and disadvantages of personal area network (PAN) - IT Release"></p><p style="text-align:center;font-size:13px;color:gray">https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/</p><ol start="12"><li><strong>分组（packet ）</strong> ：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</li><li><strong>存储转发（store and forward ）</strong> ：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135301.gif"></p><ol start="14"><li><strong>带宽（bandwidth）</strong> ：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</li><li><strong>吞吐量（throughput ）</strong> ：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</li></ol><h3 id="1-2-重要知识点总结"><a href="#1-2-重要知识点总结" class="headerlink" title="1.2. 重要知识点总结"></a>1.2. 重要知识点总结</h3><ol><li><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></li><li>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</li><li>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</li><li>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</li><li>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</li><li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li><li>按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN，局域网 LAN，个人区域网 PAN。</li><li><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></li><li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</li><li><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135313.png" alt="s"></p><p>下面的内容会介绍计算机网络的五层体系结构：<strong>物理层+数据链路层+网络层（网际层）+运输层+应用层</strong>。</p><h2 id="2-物理层（Physical-Layer）"><a href="#2-物理层（Physical-Layer）" class="headerlink" title="2. 物理层（Physical Layer）"></a>2. 物理层（Physical Layer）</h2><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135327.png" alt="物理层"></p><h3 id="2-1-基本术语"><a href="#2-1-基本术语" class="headerlink" title="2.1. 基本术语"></a>2.1. 基本术语</h3><ol><li><strong>数据（data）</strong> :运送消息的实体。</li><li><strong>信号（signal）</strong> ：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li><li><strong>码元（ code）</strong> ：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li><li><strong>单工（simplex ）</strong> : 只能有一个方向的通信而没有反方向的交互。</li><li><strong>半双工（half duplex ）</strong> ：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li><strong>全双工（full duplex）</strong> : 通信的双方可以同时发送和接收信息。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135336.png"></p><ol start="7"><li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135349.png"></p><ol start="8"><li><strong>奈氏准则</strong> : 在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li><li><strong>香农定理</strong> ：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li><li><strong>基带信号（baseband signal）</strong> : 来自信源的信号。指没有经过调制的数字信号或模拟信号。</li><li><strong>带通（频带）信号（bandpass signal）</strong> ：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li><li><strong>调制（modulation ）</strong> : 对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li><li><strong>信噪比（signal-to-noise ratio ）</strong> : 指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li><li><strong>信道复用（channel multiplexing ）</strong> ：指多个用户共享同一个信道。（并不一定是同时）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135359.png" alt="信道复用技术"></p><ol start="15"><li><strong>比特率（bit rate ）</strong> ：单位时间（每秒）内传送的比特数。</li><li><strong>波特率（baud rate）</strong> ：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</li><li><strong>复用（multiplexing）</strong> ：共享信道的方法。</li><li><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong> ：非对称数字用户线。</li><li><strong>光纤同轴混合网（HFC 网）</strong> :在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</li></ol><h3 id="2-2-重要知识点总结"><a href="#2-2-重要知识点总结" class="headerlink" title="2.2. 重要知识点总结"></a>2.2. 重要知识点总结</h3><ol><li><strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></li><li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li><li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</strong></li><li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li><li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li><li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li><li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li><li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li><li>了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li></ol><h3 id="2-3-补充"><a href="#2-3-补充" class="headerlink" title="2.3. 补充"></a>2.3. 补充</h3><h4 id="2-3-1-物理层主要做啥？"><a href="#2-3-1-物理层主要做啥？" class="headerlink" title="2.3.1. 物理层主要做啥？"></a>2.3.1. 物理层主要做啥？</h4><p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</p><p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p><h4 id="2-3-2-几种常用的信道复用技术"><a href="#2-3-2-几种常用的信道复用技术" class="headerlink" title="2.3.2. 几种常用的信道复用技术"></a>2.3.2. 几种常用的信道复用技术</h4><ol><li><strong>频分复用(FDM)</strong> ：所有用户在同样的时间占用不同的带宽资源。</li><li><strong>时分复用（TDM）</strong> ：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li><li><strong>统计时分复用 (Statistic TDM)</strong> ：改进的时分复用，能够明显提高信道的利用率。</li><li><strong>码分复用(CDM)</strong> ： 用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li><strong>波分复用( WDM)</strong> ：波分复用就是光的频分复用。</li></ol><h4 id="2-3-3-几种常用的宽带接入技术，主要是-ADSL-和-FTTx"><a href="#2-3-3-几种常用的宽带接入技术，主要是-ADSL-和-FTTx" class="headerlink" title="2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx"></a>2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx</h4><p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p><h2 id="3-数据链路层（Data-Link-Layer）"><a href="#3-数据链路层（Data-Link-Layer）" class="headerlink" title="3. 数据链路层（Data Link Layer）"></a>3. 数据链路层（Data Link Layer）</h2><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135410.png" alt="数据链路层"></p><h3 id="3-1-基本术语"><a href="#3-1-基本术语" class="headerlink" title="3.1. 基本术语"></a>3.1. 基本术语</h3><ol><li><strong>链路（link）</strong> ：一个结点到相邻结点的一段物理链路。</li><li><strong>数据链路（data link）</strong> ：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路。</li><li><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong> ：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</li><li><strong>帧（frame）</strong> ：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</li><li><strong>MTU（Maximum Transfer Uint ）</strong> ：最大传送单元。帧的数据部分的的长度上限。</li><li><strong>误码率 BER（Bit Error Rate ）</strong> ：在一段时间内，传输错误的比特占所传输比特总数的比率。</li><li><strong>PPP（Point-to-Point Protocol ）</strong> ：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路层协议。以下是 PPP 帧的示意图：<br><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135422.png" alt="PPP"></li><li><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong> ：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135436.png" alt="ARP (Address Resolution Protocol) explained"></p><ol start="9"><li><strong>网桥（bridge）</strong> ：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</li><li><strong>交换机（switch ）</strong> ：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</li></ol><h3 id="3-2-重要知识点总结"><a href="#3-2-重要知识点总结" class="headerlink" title="3.2. 重要知识点总结"></a>3.2. 重要知识点总结</h3><ol><li>链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li><li>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li><li>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li><li><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</li><li><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li><li>PPPoE 是为宽带上网的主机使用的链路层协议</li><li><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></li><li>计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</li><li>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li><li>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</li><li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li><li>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li></ol><h3 id="3-3-补充"><a href="#3-3-补充" class="headerlink" title="3.3. 补充"></a>3.3. 补充</h3><ol><li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点</li><li>数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></li><li>以太网的 MAC 层硬件地址</li><li>适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</li></ol><h2 id="4-网络层（Network-Layer）"><a href="#4-网络层（Network-Layer）" class="headerlink" title="4. 网络层（Network Layer）"></a>4. 网络层（Network Layer）</h2><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135448.png" alt="网络层"></p><h3 id="4-1-基本术语"><a href="#4-1-基本术语" class="headerlink" title="4.1. 基本术语"></a>4.1. 基本术语</h3><ol><li><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</li><li><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</li><li><strong>ICMP（Internet Control Message Protocol ）</strong> ：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</li><li><strong>子网掩码（subnet mask ）</strong> ：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</li><li><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</li><li><strong>默认路由（default route）</strong> ：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</li><li><strong>路由选择算法（Virtual Circuit）</strong> ：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</li></ol><h3 id="4-2-重要知识点总结"><a href="#4-2-重要知识点总结" class="headerlink" title="4.2. 重要知识点总结"></a>4.2. 重要知识点总结</h3><ol><li><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</strong></li><li>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li><li>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</li><li>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li><li><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送 ARP 请求分组</strong></li><li>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</li><li>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种 ICMP 差错报告报文和 ICMP 询问报文。</li><li><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</li><li><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></li><li>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li></ol><h2 id="5-传输层（Transport-Layer）"><a href="#5-传输层（Transport-Layer）" class="headerlink" title="5. 传输层（Transport Layer）"></a>5. 传输层（Transport Layer）</h2><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135500.png" alt="传输层"></p><h3 id="5-1-基本术语"><a href="#5-1-基本术语" class="headerlink" title="5.1. 基本术语"></a>5.1. 基本术语</h3><ol><li><strong>进程（process）</strong> ：指计算机中正在运行的程序实体。</li><li><strong>应用进程互相通信</strong> ：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</li><li><strong>传输层的复用与分用</strong> ：复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</li><li><strong>TCP（Transmission Control Protocol）</strong> ：传输控制协议。</li><li><strong>UDP（User Datagram Protocol）</strong> ：用户数据报协议。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135511.png" alt="TCP和UDP"></p><ol start="6"><li><strong>端口（port）</strong> ：端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</li><li><strong>停止等待协议（stop-and-wait）</strong> ：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</li><li><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li><li><strong>拥塞控制</strong> ：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li></ol><h3 id="5-2-重要知识点总结"><a href="#5-2-重要知识点总结" class="headerlink" title="5.2. 重要知识点总结"></a>5.2. 重要知识点总结</h3><ol><li><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></li><li><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></li><li>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</li><li><strong>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</strong></li><li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li><li>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</li><li>运输层的端口号分为服务器端使用的端口号（0<del>1023 指派给熟知端口，1024</del>49151 是登记端口号）和客户端暂时使用的端口号（49152~65535）</li><li><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></li><li><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></li><li><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一被通信两端的两个端点所确定。</strong></li><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li><li>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li><li>TCP 报文段的前 20 个字节是固定的，后面有 4n 字节是根据需要增加的选项。因此，TCP 首部的最小长度是 20 字节。</li><li><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></li><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li><li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li><li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li><li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li><li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li><li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li></ol><h3 id="5-3-补充（重要）"><a href="#5-3-补充（重要）" class="headerlink" title="5.3. 补充（重要）"></a>5.3. 补充（重要）</h3><p>以下知识点需要重点关注：</p><ol><li>端口和套接字的意义</li><li>UDP 和 TCP 的区别以及两者的应用场景</li><li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议</li><li>TCP 的滑动窗口，流量控制，拥塞控制和连接管理</li><li>TCP 的三次握手，四次挥手机制</li></ol><h2 id="6-应用层（Application-Layer）"><a href="#6-应用层（Application-Layer）" class="headerlink" title="6. 应用层（Application Layer）"></a>6. 应用层（Application Layer）</h2><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135525.png" alt="应用层"></p><h3 id="6-1-基本术语"><a href="#6-1-基本术语" class="headerlink" title="6.1. 基本术语"></a>6.1. 基本术语</h3><ol><li><strong>域名系统（DNS）</strong> ：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135535.png"></p><p style="text-align:right;font-size:12px">https://www.seobility.net/en/wiki/HTTP_headers</p><ol start="2"><li><strong>文件传输协议（FTP）</strong> ：FTP 是 File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。 “下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135547.png" alt="FTP工作过程"></p><ol start="3"><li><strong>简单文件传输协议（TFTP）</strong> ：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</li><li><strong>远程终端协议（TELNET）</strong> ：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</li><li><strong>万维网（WWW）</strong> ：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</li><li><strong>万维网的大致工作工程：</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135601.png" alt="万维网的大致工作工程"></p><ol start="7"><li><strong>统一资源定位符（URL）</strong> ：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</li><li><strong>超文本传输协议（HTTP）</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</li></ol><p>HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式。HTTP 的原理如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135627.png"></p><ol start="10"><li><strong>代理服务器（Proxy Server）</strong> ： 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</li><li><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135644.png" alt="一个电子邮件被发送的过程"></p><p style="text-align:right;font-size:12px">https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/<p><ol start="11"><li><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135707.png" alt="搜索引擎"></p><ol start="12"><li><strong>垂直搜索引擎</strong> ：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</li><li><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</li><li><strong>目录索引</strong> ：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</li></ol><h3 id="6-2-重要知识点总结"><a href="#6-2-重要知识点总结" class="headerlink" title="6.2. 重要知识点总结"></a>6.2. 重要知识点总结</h3><ol><li>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</li><li>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</li><li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</li><li>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li></ol><h3 id="6-3-补充（重要）"><a href="#6-3-补充（重要）" class="headerlink" title="6.3. 补充（重要）"></a>6.3. 补充（重要）</h3><p>以下知识点需要重点关注：</p><ol><li>应用层的常见协议（重点关注 HTTP 协议）</li><li>域名系统-从域名解析出 IP 地址</li><li>访问一个网站大致的过程</li><li>系统调用和应用编程接口概念</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化(4)-索引与优化原理(下)</title>
    <link href="/2020/08/19/SQL%E4%BC%98%E5%8C%96(4)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8B)/"/>
    <url>/2020/08/19/SQL%E4%BC%98%E5%8C%96(4)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>继续上一篇，本节重点介绍联合索引。</p><h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><p>之前我们已经接触了一部分索引优化相关的概念，但更多的是我一个人在讲，大家被动地接收。如何验证文章所说的正确性，以及一条SQL是否真的用到了索引呢？</p><p>这个时候就该Explain上场了，使用方式有两种：</p><ul><li>借助Navicat等软件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610247075143-d475fc88-120c-4ca9-a27d-204b7d6ecf45-20210923214500198.png" alt="img"></p><ul><li>直接使用Explain命令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610247009784-07acd78b-aaf8-4cf6-ae50-6a83e381f027-20210923214507859.png" alt="img"></p><p>大家把它当做一个命令即可，是MySQL提供的专门用来分析SQL执行计划的，比如语句是否使用了关联查询、是否使用了索引、扫描行数等。使用场景一般是：</p><ul><li>当你发现某条SQL很慢时，可以借助Explain分析一下是否走索引</li><li>当你修改某条SQL后，借助Explain查看是否达到预期</li></ul><p>Explain有很多指标，重点看type、key、Extra：</p><table><thead><tr><th>列名</th><th>解释</th></tr></thead><tbody><tr><td>id</td><td>查询编号</td></tr><tr><td>select_type</td><td>查询类型：显示本行是简单还是复杂查询</td></tr><tr><td>table</td><td>涉及到的表</td></tr><tr><td>partitions</td><td>匹配的分区：查询将匹配记录所在的分区。仅当使用 partition 关键字时才显示该列。对于非分区表，该值为 NULL。</td></tr><tr><td><strong>type</strong></td><td>本次查询的表连接类型</td></tr><tr><td>possible_keys</td><td>可能选择的索引</td></tr><tr><td><strong>key</strong></td><td>实际选择的索引</td></tr><tr><td>key_len</td><td>被选择的索引长度：一般用于判断联合索引有多少列被选择了</td></tr><tr><td>ref</td><td>与索引比较的列</td></tr><tr><td>rows</td><td>预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确</td></tr><tr><td>filtered</td><td>按条件筛选的行的百分比</td></tr><tr><td><strong>Extra</strong></td><td>附加信息</td></tr></tbody></table><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><table><thead><tr><th>type 的值</th><th>解释</th></tr></thead><tbody><tr><td>system</td><td>查询对象表只有一行数据，且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况</td></tr><tr><td>const</td><td>基于主键或唯一索引查询，最多返回一条结果</td></tr><tr><td>eq_ref</td><td>表连接时基于主键或非 NULL 的唯一索引完成扫描</td></tr><tr><td>ref</td><td>基于普通索引的等值查询，或者表间等值连接</td></tr><tr><td>fulltext</td><td>全文检索</td></tr><tr><td>ref_or_null</td><td>表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值</td></tr><tr><td>index_merge</td><td>利用多个索引</td></tr><tr><td>unique_subquery</td><td>子查询中使用唯一索引</td></tr><tr><td>index_subquery</td><td>子查询中使用普通索引</td></tr><tr><td>range</td><td>利用索引进行范围查询</td></tr><tr><td>index</td><td>全索引扫描</td></tr><tr><td>ALL</td><td>全表扫描</td></tr></tbody></table><h2 id="possible-keys、key、key-len"><a href="#possible-keys、key、key-len" class="headerlink" title="possible_keys、key、key_len"></a>possible_keys、key、key_len</h2><p>possible_keys是MySQL预估会使用的索引（基本不用看），key才是最终实际选择的索引，可以结合key_len来推测联合索引的“使用率”。比如联合索引index(a,b,c)，假设每个索引长度为1，而key_len却是2，那么可以推测联合索引只用了前两个。</p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>Extra是最难的，含义也最多，和索引覆盖、排序等都有关系。</p><table><thead><tr><th>Extra 常见的值</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td>Using filesort</td><td>将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</td><td>explain select * from t1 order by create_time;</td></tr><tr><td>Using temporary</td><td>需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时</td><td>explain select * from t1 group by create_time;</td></tr><tr><td>Using index</td><td>使用覆盖索引</td><td>explain select a from t1 where a=111;</td></tr><tr><td>Using where</td><td>使用 where 语句来处理结果</td><td>explain select * from t1 where create_time=‘2019-06-18 14:38:24’;</td></tr><tr><td>Impossible WHERE</td><td>对 where 子句判断的结果总是 false 而不能选择任何数据</td><td>explain select * from t1 where 1&lt;0;</td></tr><tr><td>Using join buffer (Block Nested Loop)</td><td>关联查询中，被驱动表的关联字段没索引</td><td>explain select * from t1 straight_join t2 on (t1.create_time=t2.create_time);</td></tr><tr><td>Using index condition</td><td>先条件过滤索引，再查数据</td><td>explain select * from t1 where a &gt;900 and a like “%9”;</td></tr><tr><td>Select tables optimized away</td><td>使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</td><td>explain select max(a) from t1;</td></tr></tbody></table><p>Explain更详细的解释可以参考：<a href="https://www.bilibili.com/video/BV1KW411u7vy?p=20">https://www.bilibili.com/video/BV1KW411u7vy?p=20</a></p><h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><p>联合索引其实要比单列索引难很多，很多SQL优化原则都是针对万恶的联合索引搞出来的，比如大名鼎鼎的“最左匹配原则”。</p><p><strong>虽然联合索引容易引发各种问题，看起来不那么容易驯服，但它在提高索引利用率、加快分组、排序等方面却有着很大的作用，</strong>所以实际开发时，联合索引一般来说应该优于单列索引。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589537787486-ed93cbb6-a245-49eb-8e8f-42fe6ce51893-20210923214519728.png" alt="img"></p><p>我不知道大家是否好奇<strong>联合索引到底长啥样</strong>，反正我当初学习SQL优化时，就有很多的疑问：</p><ul><li><p>联合索引到底长啥样？</p></li><li><p>查询时是怎么检索的呢？</p></li><li><p>为什么对于联合索引index(a, b, c)，查询条件WHERE b=1, c=2无法利用索引呢？</p></li></ul><p>我们先回答第一、第二个问题，第三个问题我们分为三小节，专门讨论所谓的“最左匹配原则”。</p><p>联合索引到底长什么样呢？</p><ul><li>还是一棵树，不会因为是联合索引，就变成多棵树</li><li>索引节点会存储多列，比如原先单列索引的节点会存储[name, name, name…]，而多列索引的节点内会存储[[name, age], [name, age], [name, age]…]</li></ul><p>为了帮大家更好地理解联合索引，我们一起探讨一个问题：</p><p>当我们向建有联合索引的表中插入一条数据时，发生了什么？</p><p>假设现在数据库的记录是这样的(最底下是有序链表，即叶子节点的数据)：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610674696496-4561304d-995a-4035-812f-880cbf5f7a77-20210923214527578.png" alt="img"></p><p>除了主键索引，其他都是辅助索引，联合索引也不例外。所以，上图叶子节点的数据应该是id，但为了更直观，我画成name和age。</p><p>现在要往数据库插入一条数据(bravo, 18, “杭州”, “18255555556”)，插入时需要维护索引，所以需要沿着索引找到数据所在的位置并在叶子节点的表数据中插入：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589544348046-f14690a1-2d1a-44b2-a87e-592802d19765-20210923214533926.png" alt="img"></p><p><strong>插入数据的过程其实伴随着索引的维护，</strong>插入后整棵索引树就变成了这样：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589544632849-3010099d-1849-4dea-9817-dbd57d41b7ea-20210923214538925.png" alt="img"></p><p>通过分析上面数据的插入过程，你会发现，在插入时其实会进行索引比较，先比较name再比较age。<strong>换句话说，这样沿着索引比较后插入的数据，本身就是有序的，符合联合索引的顺序。</strong></p><p>比如班级排座位，老师按照两个条件综合排序，先按身高排，身高一样的，成绩好的坐后面。那么放学走出教室时，顺序自然就是先按身高排，矮的先出来，高的后出来，身高相同的成绩差的先出来。</p><p>所以，对于下面这条SQL：</p><p>SELECT 学生 FROM ‘三年二班’ ORDER BY 身高, 成绩</p><p>你认为MySQL还有排序的必要吗？直接把三年二班的学生从头数到尾拎出来即可。</p><p>这就是所谓的“索引能加快排序速度”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1594511066391-5c4d07d0-0020-4fc1-8242-c93bc1603177-20210923214545481.png" alt="img"></p><p>因为本身插入或更新时，都是按照某种规则维护的。当你ORDER BY的规则与维护索引的规则一致时（都是根据身高、成绩），此时索引就能加快排序，<strong>因为这个时候根本不用排序。</strong></p><p>所以记住，最快的排序就是不用排序，也就是利用索引排序。把对顺序的维护<strong>分散到</strong>每一次增删改的过程中，而不是查询时再匆忙从零开始排序。</p><h2 id="最左匹配原则：WHERE条件查询"><a href="#最左匹配原则：WHERE条件查询" class="headerlink" title="最左匹配原则：WHERE条件查询"></a>最左匹配原则：WHERE条件查询</h2><p>接着，让我们思考一下“为什么对于联合索引index(name, age)，条件WHERE age=25无法利用索引”。</p><p>上面分析过，数据总是要经过索引比较后才插入，所以数据天然就是按索引顺序排列的。当我们拿着WHERE子句的条件（age=25）顺着索引树比较时，是得不到正确的结果的。因为当初这棵树排序的第一个条件是name，而不是age。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589545510186-c162bc1b-fe5f-45a0-9a45-72227ee7934a-20210923214551939.png" alt="img"></p><p>由于整棵树的排序规则是“先根据name排列，再根据age排列”，你硬要直接拿age查询，最终结果可能会南辕北辙。还是以学生排座位举例，人家明明是<strong>先按照身高</strong>排序，<strong>再按照成绩</strong>排序，那么注定成绩不会成“递增”或“递减”的趋势（请观察右边分数列），而面对没有相关趋势的数据，我们只能遍历查找：</p><ul><li><p>180cm 98分</p></li><li><p>182cm 96分</p></li><li><p>182cm 97分</p></li><li><p>183cm 99分</p></li><li><p>184cm 93分</p></li><li><p>184cm 95分</p></li></ul><p>分数的相关趋势只有在“身高一致”这个前提下才会显现，是<strong>局部</strong>特征（绿色块、蓝色块的分数确实呈现某种趋势）：</p><ul><li><p>180cm 98分</p></li><li><p>182cm 96分</p></li><li><p>182cm 97分</p></li><li><p>183cm 99分</p></li><li><p>184cm 93分</p></li><li><p>184cm 95分</p></li></ul><p>当然，实际上MySQL在解析SQL时并不会真的像上面一样进行逻辑分析，而是直接进行语法匹配和成本预估，发现WHERE条件不符合联合索引的“最左匹配原则”时，直接放弃走索引，选择全表扫描。</p><p>那么，怎么才能利用index(name, age)这个联合索引呢？</p><p>把查询条件变成 WHERE name=bravo, age=18即可！此时它会先按照name比较，再按照age比较，刚好和联合索引的顺序一致，也就是和排序顺位一致：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589546040377-acd3e6b0-1a78-4d3d-9a0d-8d9cd6e4a17d-20210923214558226.png" alt="img"></p><p>也就是说，此时WHERE子句的条件顺序刚好能满足最左匹配原则。</p><p>假设联合索引是index(a, b, c)，来看几个最左匹配原则的案例：</p><ul><li><p>WHERE a, b, c ✔️</p></li><li><p>WHERE a, b ✔️（只能匹配a,b）</p></li><li><p>WHERE a, c ✔️（只能匹配a）</p></li><li><p>WHERE b, c（❌）</p></li></ul><p>上面WHERE a, c的查询过程是怎么样的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589618860739-a778f594-32c2-4bd0-8575-53788640d3a7-20210923214605529.png" alt="img"></p><p>也就是说，WHERE后条件如果能走索引，就能站在更高的地方判断条件是否符合，否则只能<strong>作为判断条件</strong>深入节点内部的数据逐个比对。</p><p>如果能走全部索引，就可以少几次比较，甚至可能少几次IO：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589557584392-8bb5a6fe-c7b9-4f87-ac48-07465eade3af-20210923214613726.png" alt="img"></p><p>另外，除了不能缺少联合索引中的查询字段外，还要注意尽量不要使用范围查询。</p><p>比如，联合索引是index(a, b, c)：</p><ul><li>WHERE a=1, b&gt;2, c=3 ✔️（只能匹配a, b）</li></ul><p>注意一下即可，毕竟真要做范围查询也不是我们能决定的，无非索引利用率低一些罢了。</p><h2 id="最左匹配原则：ORDER-BY"><a href="#最左匹配原则：ORDER-BY" class="headerlink" title="最左匹配原则：ORDER BY"></a>最左匹配原则：ORDER BY</h2><p>上面说过了，对于index(name, age)的索引树，最底层的数据本身就是先按name，再按age排序的。当ORDER BY的条件刚好是ORDER BY name, age时，直接查询即可，无需排序，因为数据在插入时就按索引顺序排好了。</p><p>现在我们反过来讨论，如果没有利用索引排序，或者无法利用索引排序时，会发生什么呢？</p><p>filesort！</p><p>所谓filesort是EXPLAIN命令中extra一列的某个指标，当extra出现filesort这个指标时，说明我们的SQL没有走索引排序，而是利用内存或磁盘自己重新排序。</p><p>那么，什么情况下会导致ORDER BY无法利用索引排序呢？</p><p>以联合索引index(name, age)为例，以下情况无法利用索引排序：</p><ul><li>ORDER BY age, name（字段顺序不一致）</li><li>ORDER BY name DESC, age ASC（字段排序方式不同步，DESC和ASC混着来）</li></ul><p>第一种情况：</p><p>因为索引里的数据是先按name、后按age排序的，而你想要先按age再按name排序，对不起，你自己对结果集重新排吧，我不管了。</p><p>特别要注意，对于联合索引index(a,b,c)，WHERE条件无论是a,b,c、a,c,b还是b,c,a…都没关系，比如女生找男朋友要身高180以上、长得帅的，如果你“反过来”，长得帅、身高180以上也是可以的。但是排序不同，顺序必须和联合索引一致，否则语义是不同的。比如，先按身高再按分数和先按分数再按身高是两种完全不同的排序策略，结果自然也不同。</p><p>大家不妨做个实验，对于(‘a’, 17),(‘a’, 16), (‘b’, 18), (‘c’, 18)，(‘d’, 15)先按name正序再按age正序的结果是：</p><ul><li><p>(‘a’, 16)</p></li><li><p>(‘a’, 17)</p></li><li><p>(‘b’, 18)</p></li><li><p>(‘c’, 18)</p></li><li><p>(‘d’, 15)</p></li></ul><p>而先按age正序再按name正序的结果是：</p><ul><li><p>(‘d’, 15)</p></li><li><p>(‘a’, 16)</p></li><li><p>(‘a’, 17)</p></li><li><p>(‘b’, 18)</p></li><li><p>(‘c’, 18)</p></li></ul><p>所以对于index(name, age)，ORDER BY age, name排序顺序与索引不一致，是无法利用索引排序的。</p><p>第二种情况：</p><p>维护索引时默认都是name ASC, name ASC排序，如果你需要name DESC，age ASC，对不起，你自己对结果集重新排吧，我不管了。</p><p>理由同上。</p><p>但以下情况仍可以利用索引排序：</p><ul><li>ORDER BY name DESC, age DESC（字段顺序和索引顺序一致即可，全部DESC或ASC都没关系）</li></ul><p>为什么ORDER BY name DESC, address DESC也能利用索引排序呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608985883366-5221f525-a2b1-4d49-a62d-44da6eb92008-20210923214621711.png" alt="img"></p><p>假设右边数据是联合索引自动排序的，而现在查询的排序规则是ORDER BY name DESC, age DESC。我们先尝试一下，如果右边的数据真的按ORDER BY name DESC, age DESC排序，会是什么样呢？</p><p><strong>其实就是左边数据倒过来！</strong></p><p>所以 ORDER BY name DESC, age DESC看起来好像无法利用索引，但其实索引数据反着来刚好符合期望的排序。</p><p>总之，大家应该理解为索引排序是“很消极”的：</p><p>反正索引当初就这么排的，如果你刚好想要这种排序，就直接拿数据即可。但你如果想要的排序不是我现有的这种，对不起，你自己爱咋整咋整，但我明确告诉你，<strong>重新排序会让整个查询变慢。</strong></p><p>说了这么多，我们来验证一下。</p><p>创建表：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589547567889-6a812a41-3b19-4536-a4d6-960327eff327-20210923214629930.png" alt="img"></p><p>给name、address加了联合索引。</p><p>共1000w数据：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548017233-53960dfe-8407-4c37-8f14-a930eb6bfadb-20210923214636772.png" alt="img"></p><p>先介绍两个简单的指标，具体的Explain命令后面介绍：</p><p>Extra列中，如果出现了Using filesort，说明没有走索引排序，也就是说本次查询自己额外做了排序。</p><p>ORDER BY name（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548043565-c2fabb16-a7eb-433b-acb2-bce7842152e2-20210923214645356.png" alt="img"></p><p>ORDER BY name, address（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548082945-066e09ba-8d76-4593-a252-1b20376dcb02-20210923214651758.png" alt="img"></p><p>ORDER BY  <code>name</code> DESC, address DESC（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548127165-ccb2ae5c-8bbe-4861-ba9f-481d263b4664-20210923214656860.png" alt="img"></p><p>Using index指的是索引覆盖，是个好消息，意味着本次查询不会回表。</p><p>索引失效案例：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548196364-2aeee667-a9b3-4f59-8289-f501a6b9b010-20210923214703042.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548223133-3f1b433d-430e-4110-831f-d49b6461481b-20210923214710565.png" alt="img"></p><p>当前叶子节点链表上的数据是按索引排的（先name后address），而SQL希望的排序方式是先address后name。既然不能有效利用索引的排序，只能把结果集取出来重新排序。</p><p><strong>总之，如果想利用索引排序，那么ORDER BY的顺序必须符合最左前缀原则，顺序完全一致，且DESC和ASC不能混用。</strong></p><p>OK，上面讲的都是ORDER BY本身的一些规则，接下来我们把战场扩大些，把WHERE也引进来。</p><p>当WHERE和ORDER BY搭配，就会产生一种“例外情况”：<strong>对于index(a,b,c)，SELECT * FROM table WHERE</strong> <strong>a</strong><strong>=1 ORDER BY</strong> <strong>b,c****也是可以利用索引排序的。</strong></p><p>单独观察ORDER BY后面的字段，由于不符合“最左匹配原则”，理应不能走联合索引才对。</p><p>加入WHERE后怎么就可以了呢？</p><p>道理其实很简单，比如原本学生的排序是身高、体重、分数：</p><ul><li><p>180cm 65kg 98分</p></li><li><p>182cm 65kg 96分</p></li><li><p>182cm 65kg 97分</p></li><li><p>183cm 62kg 99分</p></li><li><p>184cm 63kg 93分</p></li><li><p>184cm 64kg 95分</p></li></ul><p>虽然ORDER BY b, c看起来不完整，但只要我定死身高为182（WHERE a=182），那实际筛选出来的学生其实就是先按体重、再按分数排序的，也就是ORDER BY b, c。</p><p>当没有通过a过滤时，数据整体没有相关性，但被a过滤后，局部数据就呈现相关性。</p><p>但这个“例外”本身还有个例外，就是：WHERE的条件不能是范围查询。</p><p>比如：</p><p>SELECT * FROM table WHERE a&gt;1 ORDER BY b,c;</p><p>这条语句是无法利用联合索引index(a,b,c)排序的，理由同上面讲得一样，a&gt;1筛选出来的结果集并不能保证b,c是预期的顺序。</p><p>上面说过，WHERE height=182 ORDER BY weight, score是可以走索引排序的，因为局部范围内能保证走索引排序，而WHERE height&gt;=182 ORDER BY weight, score，显然就不满足索引排序。</p><ul><li><p>180cm 65kg 98分</p></li><li><p>182cm 65kg 96分</p></li><li><p>182cm 65kg 97分</p></li><li><p>183cm 62kg 99分</p></li><li><p>184cm 63kg 93分</p></li><li><p>184cm 64kg 95分</p></li></ul><h2 id="最左匹配原则：GROUP-BY"><a href="#最左匹配原则：GROUP-BY" class="headerlink" title="最左匹配原则：GROUP BY"></a>最左匹配原则：GROUP BY</h2><p>这个没什么好说的，GROUP BY其实可以看成两步：<strong>先排序，后归并。</strong></p><p>一般对于GROUP BY的优化，就是尽可能让它也走索引排序。当它和联合索引顺序一致时，GROUP BY会跳过排序，直接归并，从而达到优化的目的。</p><p>后面我们专门安排一个章节，汇总一下优化规则，上面的内容理解即可。</p><h1 id="联合索引的使用场景"><a href="#联合索引的使用场景" class="headerlink" title="联合索引的使用场景"></a>联合索引的使用场景</h1><p>GROUP BY没什么好讲的，可以理解为排序的基础上在进行归并，所以学习联合索引时，主要关注WHERE和ORDER BY即可。</p><h2 id="场景一：多条件查询，提高利用率"><a href="#场景一：多条件查询，提高利用率" class="headerlink" title="场景一：多条件查询，提高利用率"></a>场景一：多条件查询，提高利用率</h2><p>如果发现很多SQL的WHERE条件经常是多个相同的字段，比如SELECT xxx WHERE a,b,c、SELECT xxx WHERE a,b、SELECT xxx WHERE a,c等，此时可以考虑创建联合索引index(a,b,c)。</p><p>这里有几条规则需要注意：</p><ul><li><p>WHERE条件的书写顺序并不影响是否走联合索引。比如WHERE a,b,c和WHERE b,c,a都可以走index(a,b,c)</p></li><li><p>但WHERE b,c是不行的，因为缺少a，而WHERE a,c只能利用部分索引</p></li><li><p>创建索引时，最好把区分度高的排在前面（注意，我说的是创建索引的顺序，而不是WHERE条件的顺序）</p></li></ul><p>第三条需要大家再仔细品味一下，比如要给id_card和name建立联合索引，如果你建的是index(name, id_card)，就会浪费无畏的IO在name查找上：先找到全国同名同姓的，再根据id_card匹配。而如果创建index(id_card, name)，那么id_card是唯一的，区分度极高，基本就是一击必中。</p><h2 id="场景二：避免回表"><a href="#场景二：避免回表" class="headerlink" title="场景二：避免回表"></a>场景二：避免回表</h2><p>上一篇已经介绍过了，如果走辅助索引并回表，就会无端多一次对主键索引的扫描。比如对于只有主键索引和name索引的表执行以下SQL：</p><p>SELECT id, name, age FROM table name=’xxxx’，</p><p>由于name索引只包含了id和name，而SELECT的列却是id、name、age，此时MySQL底层不得不回表，拿着id再跑一遍主键索引，把age给捞出来。</p><p>可行的解决办法是：添加联合索引index(name, age)，这样辅助索引上就同时包含id、name、age，可以直接返回。</p><p>当然啦，<strong>并不是只有联合索引才能使用索引覆盖，</strong>只要辅助索引上的字段满足SELECT的列即可，所以即使是单列索引index(name)，也是可以避免回表的，比如SELECT id, name FROM table WHERE name=’xxx’。</p><p><strong>但大家要认识到，实际开发索引覆盖可遇不可求，基本还是回表的情况多一些。</strong>比如，即使你定了联合索引index(name, age)，但实际上却是要查询所有列怎么办？此时还是要乖乖回表（好歹走了辅助索引了，知足吧）。</p><h2 id="场景三：索引排序"><a href="#场景三：索引排序" class="headerlink" title="场景三：索引排序"></a>场景三：索引排序</h2><p>当你建了联合索引index(a,b,c)，那么每次增删改都会按这个顺序维护。如果查询是需要的顺序刚好是a,b,c，就可以直接返回数据，无需排序，美其名约“利用索引排序”。</p><p>有个比较特别的地方是，WHERE和ORDER BY可以“联手”玩转联合索引，比如对于index(a,b,c)，并不是只有WHERE a,b,c或者ORDER BY a,b,c才能利用联合索引，WHERE a=1 ORDER BY b,c也是可以的~</p><p>讲完了这三个场景，再稍微注意一下联合索引失效的问题即可（只说两个最常用的）：</p><ul><li>最左匹配原则</li><li>注意范围查询，比如WHERE a&gt;1 and b=2 and c=3，那么就只能用到a啦</li></ul><h2 id="场景四：COUNT统计"><a href="#场景四：COUNT统计" class="headerlink" title="场景四：COUNT统计"></a>场景四：COUNT统计</h2><p>虽说一般大数据量不推荐直接使用COUNT函数，但绝大部分公司都是小公司，一张表不会很大，所以初期COUNT也无妨，但最好尽量走索引。比如要求统计天猫平台下的店主粉丝数量：</p><p>SELECT COUNT(*) FROM t_user_follow WHERE uid=123 and platform=6 and follow_status=1;</p><p>此时最好建立联合索引index(uid, platform, follow_status)，速度会稍微快一些。</p><p>其实场景四不过是联合索引的一个特例，这里单独提出来，就是为了给大家提个醒：哦？COUNT也能用上联合索引啊！</p><h1 id="MySQL的架构图"><a href="#MySQL的架构图" class="headerlink" title="MySQL的架构图"></a>MySQL的架构图</h1><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589599142582-6d0f9da2-d57b-4816-bf63-707f9337fe9d-20210923214721874.png" alt="img"></p><p>看到那个查询优化器了吗，比如index(a,b,c)联合索引，即使我们写成 WHERE a=1, c=3, b=2也能走全索引，就是因为它帮我们优化了顺序。</p><p>好了，虽然上面的内容不一定全部正确，但个人认为利大于弊，起码能让你快速、清晰地理解SQL优化的底层原理，相信大家对于市面上任意的SQL优化课程都能快速吸收。</p><p>如果要用一句话概括SQL优化，应该是下面这句：</p><p>所谓SQL优化，其实就是让查询优化器<strong>根据程序员的意愿</strong>选择匹配的执行计划，最终减少查询中产生的IO。</p><p>这几篇下来，大家应该对索引是什么、如何进行SQL优化有了整体的认知。</p><h1 id="教程推荐"><a href="#教程推荐" class="headerlink" title="教程推荐"></a>教程推荐</h1><p>SQL优化如果仅仅是想学到能应付日常工作，其实不难。但对于初学者（尤其是非科班），最难的其实是入门，比如索引的概念等。前面的几篇的作用，就是帮大家跨过最开始的不适区，接下来我觉得大家其实已经可以自学了。</p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><a href="https://www.bilibili.com/video/BV1KW411u7vy?from=search&seid=131710834280412195">尚硅谷——MySQL优化</a></p><p><a href="https://www.bilibili.com/video/BV1es411u7we?p=1">https://www.bilibili.com/video/BV1es411u7we?p=1</a></p><p>复习时尽量注意以下知识节点：</p><ol><li><p>MySQL常用数据类型及选择（肯定有人对int(11)和varchar(255)里的数字迷茫吧？）</p></li><li><p>数据库范式与反范式的取舍</p></li><li><p>SQL基础：简单查询、关联查询、子查询、GROUP BY、HAVING、ORDER BY、LIMIT，重点关注GROUP BY和ORDER BY，它俩最常用也最难理解</p></li><li><p>常用函数，比如now()等</p></li><li><p>什么是索引、索引的数据结构是什么（只考虑InnoDB）</p></li><li><p>索引加快查询的原理、聚簇索引和非聚簇索引的概念</p></li><li><p>索引的优缺点</p></li><li><p>如何利用Explain分析执行计划、慢查询日志</p></li><li><p>索引失效的几种场景(最左匹缀、!=、LIKE %…、列函数计算等)</p></li><li><p>SQL改写的几种场景与策略</p></li></ol><p>有了小册几篇文章的铺垫，现在大家再来看上面的视频会轻松很多。</p><p>如果一开始就给大家看上面的视频，会懵。确实不如燕十八老师讲的通俗易懂…</p><h2 id="专栏"><a href="#专栏" class="headerlink" title="专栏"></a>专栏</h2><p>如果希望继续深入，可以继续选择专栏观看。</p><p><a href="https://www.imooc.com/read/43">https://www.imooc.com/read/43</a></p><p><a href="https://time.geekbang.org/column/intro/139">https://time.geekbang.org/column/intro/139</a></p><p>建议先看第一个，虽然第二个确实厉害点，但不如第一个简单易懂。个人认为有些细节确实不知道也没什么，最重要的是有较为系统认识即可。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化(3)-索引与优化原理(上)</title>
    <link href="/2020/08/13/SQL%E4%BC%98%E5%8C%96(3)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8A)/"/>
    <url>/2020/08/13/SQL%E4%BC%98%E5%8C%96(3)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上一篇，我们重走了一遍数据库索引的历史，认识了B+树结构，这一篇我们回归现实中的MySQL数据库，初步学习具体的SQL优化原则，并尝试从索引底层原理出发，分析为什么会有那么多的“规则”。</p><h1 id="为什么要学习SQL优化"><a href="#为什么要学习SQL优化" class="headerlink" title="为什么要学习SQL优化"></a>为什么要学习SQL优化</h1><p>我的前东家是做招聘服务的，所以不可避免地要查询行业分类。通常来说，前端可以采用根据parentId分步加载的方式获取行业类别，但有些场景也需要全量嵌套查询：查询行业分类及其子分类。</p><p>这里我们就假定直接查询所有分类及其子分类：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584876552845-1508cebc-e24b-4812-b5f1-d44df431105b-20210923151052749.png" alt="img"></p><p>我自己设计了一个简单版的表结构，大概如下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584876666317-5f0f97f0-aa23-4be1-a7bf-e1d8fce54587-20210923151044115.png" alt="img"></p><p>表中有1106条数据：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877002375-f8dd6ff0-eff5-485b-a2e7-277a049ffdaa-20210923151103929.png" alt="img"></p><p>经过《实用小算法》的学习，我们很容易写出以下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询行业分类及其子分类</span><br><span class="hljs-comment"> */</span><br>@Test<br>public void test<span class="hljs-constructor">Cascade()</span> &#123;<br><br>    <span class="hljs-comment">// 查询数据库，得到所有行业类别</span><br>    List&lt;SysPosition&gt; sysPositionList = sysPositionMapper.select<span class="hljs-constructor">All()</span>;<br><br>    long start = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br><br>    Map&lt;String, SysPosition&gt; sysPositionMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>    List&lt;SysPosition&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-comment">// 第一步：List转Map</span><br>    <span class="hljs-keyword">for</span> (SysPosition sysPosition : sysPositionList) &#123;<br>        sysPositionMap.put(sysPosition.get<span class="hljs-constructor">Code()</span>, sysPosition);<br>    &#125;<br><br>    <span class="hljs-comment">// 第二步：遍历List，利用Map完成嵌套</span><br>    <span class="hljs-keyword">for</span> (SysPosition sysPosition : sysPositionList) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-1&quot;</span>.equals(sysPosition.get<span class="hljs-constructor">ParentCode()</span>)) &#123;<br>            result.add(sysPosition);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            SysPosition parent = sysPositionMap.get(sysPosition.get<span class="hljs-constructor">ParentCode()</span>);<br>            parent.get<span class="hljs-constructor">Children()</span>.add(sysPosition);<br>        &#125;<br>    &#125;<br><br>    long <span class="hljs-keyword">end</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (<span class="hljs-keyword">end</span> - start));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在《实用小算法》中，我们分析过效率：List转Map这种方式会有2N次循环，也就是会循环2212次。</p><p>大家猜上面程序耗时多少？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877133249-0f113716-f40b-4824-be73-a6fbc5eac808-20210923151113333.png" alt="img"></p><p>只需1<strong>毫秒</strong>。</p><p>对于CPU来说，计算内存中的数据是非常快的，几千次的循环基本可以忽略不计。</p><p>你们想知道之前《实用小算法》的第一版算法耗时多少吗？测一下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877340185-9be080f5-c98b-4ef3-9dbc-6b6e690f36a4-20210923151121192.png" alt="img"></p><p>也<strong>只要</strong>33毫秒。</p><p>要知道，第一版算法在这种情况下可是循环了1106*1106 = 100w+次！！<strong>但是对于CPU来说，不足挂齿。</strong>当然，这是单次调用的差距，想象一下这个接口每天要被几十万、甚至几百万用户调用，累计差距还是很可观的。</p><p>通过上面的案例，我想说的是：绝大多数情况下，内存中数据的处理耗时几乎可以忽略不计。</p><p>大家有没有发现，上面的程序并没有把Mapper查询数据库的操作计入时间？数据库select操作会很耗时吗？</p><p>我在某网站的专栏中看到过关于数据库insert的一段话：</p><p>插入行所需的时间由以下因素决定（参考MySQL 5.7参考手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html">8.2.4.1优化INSERT语句</a>）</p><ul><li><p>连接：30%</p></li><li><p>向服务器发送查询：20%</p></li><li><p>解析查询：20%</p></li><li><p>插入行：10% * 行的大小</p></li><li><p>插入索引：10% * 索引数</p></li><li><p>结束：10%</p></li></ul><p>可发现大部分时间耗费在客户端与服务端通信的时间，因此可以使用 insert 包含多个值来减少客户端和服务器之间的通信。我们通过实验来验证下一次插入多行与一次插入一行的效率对比。</p><p>上面虽然说得是insert，但select的情况其实也差不多。现在我把Mapper查询的时间也包括进来：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877601504-4c6d4ea7-967a-4e78-9d0c-1219fc21c491-20210923151138685.png" alt="img"></p><p><strong>竟然暴增到496毫秒！！</strong></p><p>好了，这个例子告诉我们，网络请求（以及IO操作）是非常耗时的操作，我们应该尽量避免在循环中调用网络请求或进行IO操作，比如：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877845815-757a0f69-eaee-42bc-90b4-d4949e03cb0c-20210923151148208.png" alt="img"></p><p>这是非常差劲的写法。</p><p>OK，到这里大家应该能形成一个认知：一次正常的请求，最可能出现性能瓶颈的地方就是网络请求及IO操作（通常而言性能瓶颈往往出现在数据库）。</p><p>要想优化数据的查询，大方向有两个：</p><ul><li>优化关系型数据库本身，比如增加索引等</li><li>借助大数据和ES，转嫁查询压力（本质已经和关系型数据库无关了）</li></ul><p>对于一般小公司而言，大数据和ES还是稀罕物，所以当我们讨论性能优化时，SQL优化几乎是重点！和SQL的性能提升相比，代码的优化有时是微不足道的。<strong>即使有优化，归根到底其实还是减少、减小对数据库的请求。</strong>大家应该要感到高兴，因为你们终于也将登堂入室，要去探索SQL优化了。</p><p>没有特殊情况的话，本文讨论的内容都是基于InnoDB引擎</p><p>在我看来，对于一般的Java开发而言，SQL优化分为几个层次：</p><ul><li><p>索引优化 70%</p></li><li><p>事务及锁 20%</p></li><li><p>读写分离等 10%</p></li></ul><p>其中，索引优化是最重要、也是一般Java开发人员最常用的手段。</p><h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><p>索引的分类可能有不同维度，这里不追求特别准确的分类，毕竟不是做学术，只要感性认识几种即可。</p><p>打开Navicat，尝试创建索引时会发现有4种索引类型可以选择：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589520399248-9a8373e7-567f-4ab5-9d74-f39ac0bb3332-20210923151215022.png" alt="img"></p><ul><li><p>全文索引</p></li><li><p>普通索引</p></li><li><p>空间索引</p></li><li><p>唯一索引</p></li></ul><p>普通索引就可以组织树结构了，而唯一索引在普通索引的基础上还要求索引列不能重复。比如，假设我们给student表的name列加了唯一索引，如果表中已经存在”张三”，那么再次插入”张三”将会报错。</p><p>MySQL这种关系型数据库并不适合进行全文检索（考虑Elastic Search），所以全文索引一般很少使用。</p><p>至于空间索引，我也不知道是什么。</p><p>实际开发常用的索引只有<strong>普通索引</strong>和<strong>唯一索引</strong>，其他的可以不用理会（主键索引其实相当于唯一索引+非NULL）。</p><h1 id="索引的实现方式"><a href="#索引的实现方式" class="headerlink" title="索引的实现方式"></a>索引的实现方式</h1><p>常见的索引实现方式有两种，通过B+树结构或hash算法实现。</p><p><strong>特别注意，这里虽然写的是”BTREE”，但MySQL确实使用的是B+Tree。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589533482892-ea6a7e77-c129-45e3-8519-827ae57c69c7-20210923151221445.png" alt="img"></p><p>这个概念，其实和上面“索引的类型”并不冲突。</p><p>比如，对于普通索引，我们可以使用B+树的结构组织索引，也可以使用hash算法实现。经过上一篇的学习，我们对B+树结构已经比较了解，所以这里单独聊一下hash索引。</p><p>所谓hash索引，其实就是利用<strong>哈希算法为索引列计算得到唯一的存储地址</strong>，一般来说这个地址是不会重复的（重复的情况被称为哈希冲突）。</p><p>举个燕十八老师说的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589533947057-755cdba3-b196-44cd-88c4-813dc6397463-20210923151227170.png" alt="img"></p><p>在墙上装一根弹性永不衰变的弹簧，每次拿不同的物件把弹簧压到极限后放开，不同的物件最终落点会不同。比如你上回存了一本书，那么下次想要找到这本书时，只需要拿一本<strong>一模一样的书</strong>重新弹一下，即可在本次落点处找到上次那本书。</p><p>数据库hash索引的设计也类似，假设你要存入id=10086的数据，就需要通过hash算法对id进行计算，得到一个存储位置后写入数据。下次拿着id=10086查询时，只要按同样的算法再次计算，就能马上找到对应的数据，是不是很快呢~</p><p>需要注意的是，弹簧的例子用来比喻hash算法虽然挺形象的，但可能会让人误以为越重的物品落点越近，越轻的物品落点越远，进而得出结论：hash索引可以进行范围查找。</p><p>其实并不是如此。</p><p>hash算法有个比较显著的特征：即使源数据具备一定的相关性，经过hash映射后得到的结果也会变得“很散”，没有规律可循。回到之前的例子中，你可以理解为重量并不是影响书本最终落点的唯一因素，书的材质、形状等都占有一定比例，最终体现到空气阻力上导致落点的不规则。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608951320970-75bcceba-6e55-4737-9e29-8a7da83502b6-20210923151233076.png" alt="img"></p><p>不知道大家还是否记得，在JavaSE阶段接触HashMap时，很多人会发现put的顺序和get的顺序并不一定相同。比如put的顺序是1000克、500克、300克，而get的顺序却是500克、300克、1000克。也就是说，经过hash计算后，数据的相关性会大大减弱。</p><p>所以，当你希望查找500g~1000g的书本时，就无法利用边界值进行范围查找。而B+树<strong>叶子节点是有序链表</strong>，范围查询非常方便。</p><p><strong>hash索引除了无法进行范围查找外，还不能进行模糊搜索。</strong></p><p>hash算法本身代表着精确定位，依赖于计算的入参得出“唯一”的值，所以无法进行模糊匹配。比如，你给我”bravo”，我可以计算唯一的hash值，你给我”bra%”，我会以为这人就叫”bra%”，也计算一个值，<strong>而****这个值代表着”bra%”计算得到的落点，而不是”所有以bra开头的数据”的落点</strong>，显然是不对的。</p><p>但B+树可以进行模糊搜索，你可以姑且认为因为它会顺着树查找，并在装有数据的节点内调用类似Java的String#startWith()方法进行比较。</p><p>hash索引的优劣势</p><ul><li>优势：速度非常快，只需一次计算即可得到地址，时间复杂度O(1)，而B+树是O(logn)</li><li>劣势：不支持模糊查询、范围查询、索引排序（本身就是不规则的，如何利用索引排序呢）</li></ul><p>最后，《实用小算法》中List转HashMap的操作其实就是借鉴了hash索引！</p><h1 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h1><p>索引的创建时机一般有两处：</p><ul><li>起初，建表时顺便建立索引</li><li>后期，修改表结构创建索引（一般都是这样，因为很难未卜先知，提前优化等于瞎优化）</li></ul><p>比如，一开始就创建索引：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589520661369-1d8b2328-8dca-4f08-8fb4-94df84b770b5-20210923151242400.png" alt="img"></p><p>这张表有两个索引：主键索引、auditor_id普通索引。</p><p>主键索引并不属于上面介绍的4种索引类型之一，但所谓的Primary Key可以看做 唯一索引 + NOT NULL约束。</p><p>后期如果需要添加索引，可以通过两种方式：</p><ul><li>SQL语句</li><li>Navicat图形界面</li></ul><p>利用SQL语句添加索引：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 1.添加PRIMARY KEY（主键索引） </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span> (`<span class="hljs-keyword">column</span>`) ;<br><span class="hljs-comment">-- 2.添加UNIQUE(唯一索引) </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> (`<span class="hljs-keyword">column</span>`);<br><span class="hljs-comment">-- 3.添加INDEX(普通索引) </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (`<span class="hljs-keyword">column</span>`);<br><span class="hljs-comment">-- 4.添加FULLTEXT(全文索引) </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> FULLTEXT (`<span class="hljs-keyword">column</span>`);<br><span class="hljs-comment">-- 5.添加联合索引 </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (`column1`, `column2`, `column3`);<br></code></pre></div></td></tr></table></figure><p>在本案例中，可以写：</p><figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">ALTER TABLE `moneywithdraw` ADD INDEX idx_auditor_id (`auditor_id`)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>利用Navicat图形界面创建<strong>单列索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589521376561-1c62b92e-60ae-4d06-ad73-6cfa4c69101b-20210923151251589.png" alt="img"></p><p>利用Navicat图形界面创建<strong>联合索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589521546600-37ba8127-ad31-4f94-a137-e1986de9354f-20210923151256752.png" alt="img"></p><p>哦，对了，数据量太大的表，不要自己随便加索引，搞不好会锁表哦…后面有机会再说。总之，你可以“懂索引”，但要“动索引”前，最好三思。</p><h1 id="索引的好与坏"><a href="#索引的好与坏" class="headerlink" title="索引的好与坏"></a>索引的好与坏</h1><p>提到索引，很多人就会说：哦，索引能提高查询速度。一般这么说的人，可能学得还不错，但绝对还没有完全掌握索引的底层原理。</p><p>如果你认为索引的优势只是加快查询，那就太小看索引了。</p><p>索引的优势是：</p><ul><li><p>加快查询速度（包括关联查询）</p></li><li><p>加快排序速度（ORDER BY）</p></li><li><p>加快分组速度（GROUP BY）</p></li></ul><p>虽然加快排序、加快分组最终还是体现在加快查询速度上，但能主动意识到这一点算是一种突破。只有当你意识到索引能加快排序和分组，你才会在写ORDER BY和GROUP BY时有意识地利用索引分组和排序（最左匹配原则），从而写出更优的SQL。</p><p>索引的劣势：</p><ul><li><p>创建索引是需要付出代价的，主要体现在维护成本、空间成本和回表成本。也就是说<strong>索引能提高查询效率，但往往会降低增删改的速度</strong>（字典新增几百个字，需要额外编排目录吧，要多占几页纸吧）</p></li><li><p>如果使用了联合索引，还需要考虑索引失效问题（下篇介绍联合索引）</p></li><li><p>太多的索引会增加查询优化器的选择时间（选择太多也麻烦）</p></li></ul><h1 id="建索引的原则"><a href="#建索引的原则" class="headerlink" title="建索引的原则"></a>建索引的原则</h1><p>很多人觉得SQL优化才是重中之重，创建索引只需要一行代码即可，没什么大不了的。但现在你已经知道了索引的优势与劣势，你会明白“在合适的时候、合适的字段建立索引”是多么空泛的口号。创建索引的判断依据究竟是什么呢？</p><p>创建索引有4个大原则：</p><ul><li><p>索引并不是越多越好，联合索引应该优于多个单列索引</p></li><li><p>索引应该建立在区分度高的字段上</p></li><li><p>尽量给查询频繁的字段创建索引，避免为修改频繁的字段创建索引</p></li><li><p>避免重复索引</p></li></ul><p>第一个原则背后的原因是，实际上数据库一次查询只会选择<strong>一棵索引树</strong>（不包括回表），更专业的说法是每次查询只会选择一个执行计划。即使你给a,b,c,d,e,f,g…所有列都加了索引，SELECT xx, xxx FROM table WHERE …时，数据库也只会<strong>择优****选择</strong>一个执行计划进行查询。</p><p>需要注意的是，<strong>每建一个索引，就需要维护一棵索引树，</strong>所以索引绝对不是越多越好，不合适的索引会增加数据库的负担。比如，你已经搞了一个根据拼音查找汉字的目录，又想根据偏旁部首来，那没辙了，只能劳烦您自己再搞一个目录了。</p><p>看到这，你可能会反问：我靠，那MySQL也太笨了吧，为什么这么死心眼一次只利用一个索引？</p><p>比较粗浅的理由是：你根据拼音查完汉字以后，还会根据偏旁部首再查一遍吗？</p><p>比较正经的理由是：按我个人的理解，索引本身的出发点是“走完一遍索引后，数据库应该返回<strong>精确的结果</strong>或<strong>很小的结果集</strong>”，从成本上考虑，此时再走一遍索引还不如直接遍历结果集来得快。当然，要想一次索引就得到精确的结果集，着实需要下一番苦功夫。给哪个字段加索引好呢？我建议，应该尽可能给区分度高的字段添加索引。</p><p>什么是区分度很高？这就是建索引的第二个原则啦。比如，表中有100w学生数据，你如果在sex列加索引，那么根据sex大概只能过滤掉50w数据，剩下的结果集仍然很大，说明这个索引建得不太合适，区分度太低了。</p><p>第三个原则就是字面意思。比如一本字典根据内容编好目录以后，隔三差五地就有新词汇要往里面加，或者经常要修改汉字读音，一顿操作后必然要连累目录，只能重新编排啦。也就是说，为了保证目录能正确指向对应的汉字，每次增删改后都要额外多一个操作：重新修订目录。</p><p>总之要意识到索引在加快查询的同时几乎必然会对修改产生负担，所以创建索引并没有那么简单，它绝对是一门“平衡的艺术”。</p><p>第四个原则是，比如已经建立a索引，又建立index(a,b,c)联合索引，此时单列索引a就是冗余的，因为联合索引已经可以保证符合条件时会利用a索引。<strong>在物理存储上，a单列索引和index(a, b, c)是两个独立的B+树，</strong>重复的索引会增加维护成本。</p><p>以上四个原则，后面的内容还会重新提到。</p><h1 id="MySQL常用引擎"><a href="#MySQL常用引擎" class="headerlink" title="MySQL常用引擎"></a>MySQL常用引擎</h1><p>MySQL的引擎有很多种，但最常听到的就MyISAM和InnoDB，而实际开发几乎99%选择使用InnoDB，而且MySQL5.6还是哪个版本以后默认引擎就从MyISAM变成了InnoDB，所以这里着重介绍InnoDB，简略介绍MyISAM。</p><p>对于两种引擎的介绍，可以看：<a href="https://www.bilibili.com/video/BV1RE41187Yo?p=9">存储引擎简介</a></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589527342910-49ca1484-7ba5-4924-944f-d1008cd46e85-20210923151312836.png" alt="img"></p><p>这里主要想和大家讨论MyISAM和InnoDB在索引组织上的区别。大家应该都已经知道，MyISAM和InnoDB存储数据的方式是不同的。</p><p>MyISAM的每张表在存储时会分为3个文件：</p><ul><li><p>表结构</p></li><li><p>表数据</p></li><li><p>索引</p></li></ul><p>也就是说，表数据和索引是分别独立存储的。</p><p>而InnoDB的表数据在存储时只分为2个文件：</p><ul><li>表结构</li><li>表数据+索引</li></ul><p>需要注意的是，InnoDB所有表的数据和索引都在同一个文件里（见下一个小节）。</p><h1 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h1><p>对于BTREE索引而言，从数据的组织形式来看，索引又可以分为两大类：</p><ul><li>聚簇索引</li><li>非聚簇索引</li></ul><p>所谓聚簇索引，可以简单理解为索引和数据是“聚合”在一起的，而非聚簇索引的数据和索引是分开的。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589532501128-7bf641bd-946e-446b-9a0f-a581b3f13887-20210923151325454.png" alt="img"></p><p>根据InnoDB引擎的<strong>主键索引</strong>查询时无需回表，每一行完整的数据都直接挂在叶子节点下，可以直接返回。也就是说，对于InnoDB的<strong>主键索引</strong>而言，数据即索引，索引即数据。<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589586538060-89e3781c-22ed-4b16-a734-d5466af2d6aa-20210923151335790.png" alt="img"></p><p>MyISAM不是很重要，不提了。</p><p>InnoDB的索引也并不是都不需要回表，根据是否需要回表其实可以分为两类：主键索引、辅助索引（或者叫二级索引、普通索引）。</p><p>会什么要做这种区分呢？</p><p>假设一个场景：</p><p>新建一张表后，自然会产生主键索引。但后期发现name字段查询很频繁，于是加了name索引。</p><p><strong>如果name索引也和主键索引一样挂着数据，那么两个索引数据就会重复。想象一下，现在磁盘中有一颗叫name的树和一棵叫id的树，一个以name为节点，一个以id为节点，相同的是最底层叶子节点都挂着完整的表数据。也就是说，磁盘中存了两份一模一样的student数据。且不说数据冗余，更新时还可能产生数据不一致（要同步数据，确保多张表的数据一致性）。</strong></p><p>所以InnoDB的做法是，辅助索引只存储索引列+主键，必要时进行“回表”操作：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589536446002-5fddd16a-59f2-4928-b10e-088aaa01f927-20210923151343933.png" alt="img"></p><p>由于SELECT * FROM stu WHERE name=’bravo’中，查询的数据是*，也就是整行数据。而上面的辅助索引只存了主键+name，所以必须回表：拿着主键再去跑一遍主键索引，最终返回整行数据。</p><p>现在，我们可以给MyISAM和InnoDB的索引分类做个简单的总结：</p><ul><li><p>MyISAM：非聚簇索引，需要回表</p></li><li><p>InnoDB：</p></li><li><ul><li>聚簇索引：主键索引，叶子节点是表数据，不需要回表</li><li>非聚簇索引：辅助索引（唯一索引、普通索引），叶子节点是主键，必要时需要根据主键回表查询</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608956710604-75cdbc20-a59e-473f-9e98-b963ac3cd49d-20210923151351478.png" alt="img"></p><p>InnoDB每张表只能有一个主键索引，辅助索引则可以有多个。表数据只有一份，挂在主键索引下面。</p><p>需要注意的是，如有可能，应该尽量避免回表。<strong>SQL优化的本质其实就是减少/减小磁盘IO</strong>，而回表必然会增加磁盘IO次数。</p><p>举个例子，假设某张表总共就两棵索引树：主键索引+name辅助索引，两棵树高度都是3。由于只有主键索引下才挂着表数据，所以对于SELECT * FROM table WHERE name=’xxx’来说，需要先走辅助索引取得id，再根据id走一遍主键索引。假设两棵树需要的数据都在第三层，那么这条SQL需要进行6次逻辑IO访问。而如果直接根据id查询，就可以直接走主键索引，IO次数为3。</p><p>所以，<strong>通常情况下</strong>辅助索引查询都是需要回表的，比主键索引查询多扫描一棵索引树（自身+主键索引），实际编写SQL时，应该尽量走主键索引。</p><p>那么，<strong>什么情况下</strong>辅助索引可以避免回表吗？</p><h1 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h1><p>索引覆盖这个名字，咋一听不知所云，所以很多初学者一直搞不明白什么意思，其实它最大的作用就是：避免回表。</p><p>下面通过一个案例来说明。</p><p>假设有个需求：前端需要支持<strong>根据用户名模糊搜索订单，</strong>而页面需要的字段如下。</p><table><thead><tr><th><strong>id</strong></th><th><strong>productName</strong></th><th><strong>price</strong></th><th><strong>userName</strong></th><th><strong>userAge</strong></th></tr></thead><tbody><tr><td>1</td><td>iphone12</td><td>5999</td><td>bravo1988</td><td>18</td></tr></tbody></table><p>一个可行的方案是：</p><ol><li><p>在t_user表中根据name搜索用户，得到user_id、user_name、user_age</p></li><li><p>在t_order表中根据user_id查询订单</p></li><li><p>在内存中根据user_id匹配order和user数据后返回</p></li></ol><p>由于t_user表此时的查询条件是user_name，为了加快t_user表的查询速度，可以给user_name加普通索引。但，这样真的好吗？我劝！不要犯这样的聪明，小聪明啊。</p><p>你要知道，此时我们从t_user表查询的可不止user_name，还有user_age和id。如果只是给user_name加了索引，那么此时磁盘中产生的索引树是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610162572296-97295d9c-ab7c-444b-a99a-6c8ea8f106eb-20210923151400366.png" alt="img"></p><p>这棵树的非叶子节点是user_name，叶子节点是id，<strong>也就是说从这棵树上我们只能得到user_name和user_id</strong>，至于user_age，MySQL底层只能跳出name索引树，然后跑到隔壁主键索引获取。整个过程被称为回表，而回表意味着多跑一趟。</p><p>此时我们可以给user_name和user_age加一个联合索引，这样就能产生所谓的“索引覆盖”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610162521710-d2586c99-f888-4db1-b713-3a69dc59028d-20210923151409810.png" alt="img"></p><p>当辅助索引上的字段完全满足本次查询的列时，就是所谓的索引覆盖，这是一个好消息，意味着不需要回表，查询效率将会大大提高。这也是为什么SQL优化原则中经常会强调：尽量只取必要的字段，避免SELECT *（提高索引覆盖的几率，查询的字段越多，几率越低）。</p><p>即使目前表中只有两个字段且已经索引覆盖，也不要写SELECT *。因为后期随着业务扩展，这张表会新增其他字段，此时SELECT *将不再覆盖索引！</p><p>为了方便记忆，大家可以把索引覆盖理解为 索引的字段 &gt;= 查询需要的字段。比如联合索引的字段是index(a,b,c)，那么此时SELCT a, b就会发生索引覆盖，索引覆盖最大的好处是避免回表。</p><p>需要强调的是，覆盖索引和联合索引没有必然关系。比如我只给user_name加单索引，而我查询语句是</p><p>SELECT id, user_name FROM t_user WHERE name=’bravo’;</p><p>此时也是索引覆盖。所以，<strong>能否索引覆盖不取决于索引单方面，需要查询配合。</strong></p><p>关于联合索引，我们放在下一篇介绍。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化(2)-索引与B+树</title>
    <link href="/2020/08/11/SQL%E4%BC%98%E5%8C%96-%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/"/>
    <url>/2020/08/11/SQL%E4%BC%98%E5%8C%96-%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于60%的程序员而言，Java的三层架构Controller、Service、Dao可以说是“越往后走天越黑”，特别是到了Dao层，提着灯笼也只能看到脚边一米开外的河边小石子，只闻对岸风啸马嘶却不知到底是人是鬼，只能借着MyBatis或JPA这些ORM框架隔着宽宽的河举行一场又一场的刺刀战，你砍我一刀，我刺你一剑。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589374354625-30b6de0f-8337-4db5-964b-6c6df7ae09ad-20210923150111295.png" alt="img"></p><p>诚然，很多人对MySQL数据库的印象就是一个模糊的大铁柜，闭上眼睛深吸一口气仿佛还能嗅到一股铁锈味。只知柜子里藏着很多张表，表里面存着很多行数据，再详细一点的呢？不知道。</p><p>MySQL有太多太多细节，根本无法用四、五篇文章说透，但我仍希望这个系列的文章能成为非常好的入门教程，让从来没接触过SQL优化的同学也能快速建立较为系统的知识框架，方便日后学习其他专栏时进一步拓展。</p><hr><h1 id="柏青哥"><a href="#柏青哥" class="headerlink" title="柏青哥"></a>柏青哥</h1><p>大家小时候在游戏厅看过下面这种机器吗：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589354675837-5eaba89f-fb57-4fdf-aa7e-80573ada61a6-20210923150439959.png" alt="img"></p><p>日本人管它叫柏青哥（パチンコ），玩法是：</p><p>从机器最上方的唯一入口投入一颗钢珠，由于重力的作用，钢珠会往下落。机器是直立的，面板上有很多突出的圆柱，它们的作用是随机改变钢珠的落点。最终，钢珠掉落在下方的某个槽中。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589355808319-788e3454-19ae-4c57-9707-b68edc99f05c-20210923150137448.png" alt="img"></p><p>这里提柏青哥，是为后面的B+树及分析B+树搜索过程做铺垫。到时你会发现，沿着索引树搜索的过程和柏青哥小钢珠的下落过程是多么相似！</p><p>很多人都听过数据库索引，但是很少人会去思考下面几个问题：</p><ul><li><p>索引是什么</p></li><li><p>为什么需要索引</p></li><li><p>索引怎么起作用</p></li></ul><p>在历史的长河中，索引的出现几乎是必然的。不信？那就跟我重走一遍历史吧。</p><p>请大家先忘了MySQL、Oracle等乱七八糟的玩意儿，就假设你是上世纪第一批程序员，此时连正儿八经的数据库都没有，需要由你来开天辟地。目前摆在你面前的最大难题是：如何较为<strong>高效地</strong>存取数据？</p><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p>最直观的想法就是存“格子”里，也就是将数据存在线性结构的容器中，比如数组或链表。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589356217794-f7c00e60-53e2-447d-a2b5-2c97d4726d0c-20210923150143937.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589357468320-10555c9b-b1f5-41a7-922d-73ea4f70c03c-20210923150149784.png" alt="img"></p><p>用线性结构存储数据<strong>短期</strong>看是没问题的，但是一家名为SUN的公司发现，随着公司业务增长，平台要经手的用户数据越来越多，特别是今年，他们收到了很多客户的信件投诉，说网页数据的加载越来越慢了！</p><p>SUN的工程师做了个实验，一个线性表如果存了42亿条数据，想要找到id=100的数据，游标只需爬99格即可返回，但如果id=10000000，就要爬将近1000w个格子才能返回。对于这42亿条数据，平均查询次数是21亿次！！</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>作为改进，有人提出用树结构来存储数据。比如，如果要找id=6的数据，那么只要比较3次，小于爬格子次数（5次）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358245965-f357a5d0-90fc-49e7-affe-8cfa11a2243d-20210923150156142.png" alt="img"></p><p>如果要找id=9的数据，只要比较4次，小于爬格子次数（8次）。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358394072-a5d5f642-25e5-4d01-ba52-ba7251609d4a-20210923150201825.png" alt="img"></p><p>结合两次实验，SUN的工程师发现：</p><p>在一棵树中找到目标数据所需的比较次数 = 目标数据所在的层级</p><p>如果用一棵树来存储42亿条数据，即232=42亿，树的层级是32，最差的情况也只要查32次（需要是二叉平衡树），远远小于线性结构的平均21亿次，这是非常夸张的。</p><p>注意，在线性结构的案例中，不是我故意不用二分查找，而是不能使用二分查找。一般来说，<strong>对于线性结构的数据集合，如果要使用二分查找，那么整个数据都要事先在内存中，</strong>但显然没人会这样做！相比在内存中对线性结构进行二分查找，树在逻辑上天然支持二分查找。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608365614192-1f7e343b-f3fc-4dd6-b4c7-90d64f7569d9-20210923150207584.png" alt="img"></p><p>然而，树结构也分好几种：</p><ul><li><p>Binary Search Tree（二叉查找树）</p></li><li><p>AVL Tree（二叉平衡树）</p></li><li><p>B Tree（平衡树）</p></li><li><p>B+ Tree（大名鼎鼎的B+树，对B Tree的改进）</p></li><li><p>…</p></li></ul><p>大家可以访问<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a>这个网站动手玩一下，特别注意上面的4种树：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589360823134-4c779906-c5d8-4ea4-ab72-47af54d8af3c-20210923150214447.png" alt="img"></p><p>如果你听我的建议，打开上面的网站选择Binary Search Tree并按1,2,3,4…的顺序插入数据时，<strong>它其实变成了线性结构：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358856443-e8032dc1-b241-4f23-9c43-883c36b3b25e-20210923150222903.png" alt="img"></p><p>显然，这不是我们想要的结果，因为刚才已经讨论过，线性结构不适合存储大数据，等后期数据量大了以后要爬很多“格子”。</p><h1 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h1><p>相比来说，AVL Tree更符合SUN工程师的需求：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358993173-e6bd2cc0-279a-4d98-8fdc-68abf82b2744-20210923150229048.png" alt="img"></p><p>二叉平衡树会在数据插入完毕后<strong>自动调整节点，好让“树的层级”不至于太深。（赶紧去动手玩一下）</strong></p><p>按理来说，如果我们按二叉平衡树组织表数据的话，应该是非常完美的。你想啊，42亿数据中找一条记录最多只需比较32次，尤其是对于CPU来说，<strong>别说32次比较，哪怕32w次简单数据的比较都不会超过0.1秒。</strong>但是！问题在于这里所谓的“32w次简单数据的比较不会超过0.1秒”有个前提条件：<strong>数据必须全部在内存中。</strong></p><p>而我们的表数据因为数据量很大，而且需要持久化，所以一般来说是存在磁盘中，等需要使用时再从磁盘载入内存，也就是涉及磁盘-内存的IO操作。</p><p>通常情况下，没有人会直接把500w行数据一次性加载到内存中进行二分查找，内存极有可能顶不住（同时访问多张表，全部加载）。所以，最终我们组织数据库的方式只能是：</p><ul><li><p>把数据存在磁盘中</p></li><li><p>数据按树结构组织</p></li><li><p>查询时分块读取数据并比较，持续进行磁盘IO读取节点，直到找到目标数据</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608365864685-03842132-d684-4a5b-9ca8-42ceb43181f7-20210923150235370.png" alt="img"></p><p>每一个节点存储“一小块数据”，分多次IO读取每一块数据到内存判断，直到找到匹配的数据。</p><h1 id="二叉平衡树与磁盘IO"><a href="#二叉平衡树与磁盘IO" class="headerlink" title="二叉平衡树与磁盘IO"></a>二叉平衡树与磁盘IO</h1><p>数据存在磁盘中，没问题。</p><p>数据桉树结构组织，没问题。</p><p><strong>查询时分块读取数据，有一点点问题。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589361951577-71cfd4b1-bfd8-44cc-a968-5de2d821fe2b-20210923150241680.png" alt="img"></p><p>磁盘IO是非常耗时的操作，耗时到什么程度呢？大家可能都听过各个语言的执行效率：</p><p>C &gt; C++ &gt; Java &gt;&gt; Python</p><p>但这些都是在内存层面谈论语言自身的执行效率，而实际上开发一个Web应用，无论用上述哪个语言，对于普通应用而言，都是可以满足用户需求的，真正的瓶颈是IO（网络IO和磁盘IO）。就好比F1赛车、奥迪A4和拖拉机一起跑在北京4环的路上，限制它们的不是引擎，而是堵车。</p><p>所以，二叉平衡树虽然查找42亿数据最多只需32次，但是32次磁盘IO还是不能接受的。</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>基于上面的分析，如果考虑磁盘IO，那么原本优秀的二叉平衡树将显得不再那么优秀。错的不是二叉平衡树，而是我们没有那么大的内存，也不方便把数据都放内存（考虑数据丢失与持久化）。</p><p>但现在不是考虑谁对谁错的时候，要想优化当前数据库，关键是减少磁盘IO次数，<strong>而影响IO次数的关键因素就是树的层级（深度）！</strong>举个例子，如果目标数据在第二层，那么只要比较到第二层，就找到目标数据直接返回，不用再继续磁盘IO读取下一个节点。而如果数据在32层，那么就需要进行32次磁盘IO，比较到最后一层的节点。</p><p>那么，如何减少树的层级呢（让树变矮）？</p><p>请大家思考一下232中的“2”指的是什么？</p><p>其实就是“二叉平衡树”的“二”，而指数32代表树的层级。也就是说，如果以二叉平衡树的结构组织42亿行数据，那么树的深度是32。如果是“三叉平衡树”呢？</p><p>3?? = 232 </p><p>3的指数大概为21。也就是说，如果用“三叉树”组织数据，那么层级将会减少到21，也就意味着磁盘IO次数最多为21次。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589362752238-4daa5676-b2c3-419f-9016-a3cf84bb057f-20210923150255800.png" alt="img"></p><p>所以，到这里我们已经有答案了：要想减少二叉平衡树的磁盘IO次数，需要增加它的“叉”，变成“N叉平衡树”，从而减少树的深度。</p><p>此时有位长者说了一句：你们心里没点B树吗。</p><p>听到这，SUN的工程师颇受启发：对哦，直接用B树就好了。</p><p>B树有个“阶”的概念，比如“三叉平衡”的B树其实叫“3阶B树”。</p><p>通过上面的图，我们会发现“N阶B树”<strong>每个节点可以存N-1个数据</strong>（二叉平衡树每个节点只存1个数据），且每个节点至多可以连接N个子节点。</p><p>这样组织的好处是，<strong>每次加载一个节点时都可以从磁盘带出更多条数据，从而减少磁盘IO的次数。</strong>比如原先比完id=3，接下来要和id=5比较，需要再从磁盘中把id=5的数据读出来。而现在当前节点已经有id=3,id=5的数据了，直接比较即可，无需做磁盘IO。</p><p>这是典型的“空间换时间”。</p><p>但B树最难的地方不是结构本身，而是如何实现这种结构，尤其是如何通过B树组织数据库的表数据？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589370021227-2ce244b2-e5de-4aeb-8a57-5cfb81109d80-20210923150305159.png" alt="img"></p><p>举个例子，当我要找id=7的数据时，需要先找到根节点，和id=4的节点比较，由于7&gt;4，所以选择右侧那一支，接着因为6&lt;7&lt;8，所以这个节点中三个addr选择中间的addr，顺着这个地址找到7的节点，然后取出数据。</p><p>需要注意的是，当一个节点被加载到内存后，这个节点内部的数据就可以通过二分查找得到啦，所以那么id=7去上图右边节点查找正确的addr是很快的。</p><p>上面只是演示了3阶B树，实际上1个节点可以存更多数据，做成N阶B树：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589370580691-8b9a4589-4f48-42cb-9daf-918ad3183d99-20210923150314176.png" alt="img"></p><p>分析到这里，历史的话剧就告一个段落，让我们看看MySQL索引的真正实现方式吧。</p><h1 id="B-树与索引"><a href="#B-树与索引" class="headerlink" title="B+树与索引"></a>B+树与索引</h1><p>实际上MySQL索引采用的是B+树，而不是B树。</p><p>为什么不用B树呢？</p><p>在操作系统中有个叫“页”的概念，是用来存储数据的一种单位，大小为4k。MySQL中也有“页”的概念，但大小为16k，你可以理解为MySQL中的“页”就是上面B树的一个个节点。</p><p>那么问题来了：你知道日常开发中，表中的一行数据大概占多少字节吗？</p><p>让我们来计算一下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589371147835-6bf74fd5-b52c-4abc-869a-88fd74c96e0a-20210923150326037.png" alt="img"></p><p>在上面这张表中，按每列数据类型推算，一行数据大概 8+150+150+150+150+9+2+9+750+5+5+8+8=1404字节，就算1k好了，因为节点最大size是16k，所以每个节点最多只能存16行数据。</p><p>我们之前之所以从二叉平衡树转为B树，是因为B树的每个节点可以存更多数据。但上面的计算告诉我们，其实也就是比二叉平衡树多了15条数据而已。</p><p>但原则是对的，为了尽可能使树“变矮”从而减少磁盘IO，最好的做法是让<strong>一个节点尽可能地塞入更多的数据。</strong></p><p>不过把整行数据塞到节点中，有点太浪费了，我们其实可以<strong>把每一行数据的主键存进去。</strong>即使用bigint类型做主键，一个主键也就8个字节。假设每个主键对应一个addr（指针），MySQL中一个指针为6个字节，那么节点内每个主键-地址这样形式的数据能存16*1024/14=1170个。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589376951699-3f01f932-8684-414e-8dcb-2c0573837744-20210923150332743.png" alt="img"></p><p>这其实就是B+树对B树的改造。</p><p><strong>所谓的B+树，就是把原先B树中分散在各个节点的数据都“赶到”最底层的叶子节点，非叶子节点只存储主键-addr形式的数据：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589372895183-3540a1e5-82ba-4d3d-9dca-252f95007eee-20210923150338523.png" alt="img"></p><p>最终，一棵3层的B+树，最底下的叶子节点总共能存2000w条数据。</p><p>有部分同学可能还是不明白B+树为什么比B树能存储更多数据，这里再举个最极端的例子，假设一行表数据8k，而一个节点容量是16k，如果是B Tree，那么一个节点只能存两行数据，最终每个节点只能“夹带”3个addr，只能指向3个子节点：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589377482590-ca616c4f-89de-4de2-b459-1b7ef408a5ff-20210923150345350.png" alt="img"></p><p>但如果是B+ Tree，只存主键：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589377712338-9f1bfde7-bce8-4ecb-a9a0-27d1a5670b67-20210923150352723.png" alt="img"></p><p>那么最上面的节点可以存更多的主键，指向更多的下级节点，就有更多的“16k数据”。上面还只是分析单个节点的情况，如果放眼整棵索引树，最终叶子节点会多很多很多的“16k数据”。</p><p>从MySQL学习者的角度而言，我们只需要知道B+树2个很重要的特征：</p><ul><li>非叶子节点不存数据</li><li>叶子节点数据用链表相连</li></ul><p>所以更详细的版本是：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589448311743-b494fa66-02d0-43b8-ab9f-f920caec8af2-20210923150358426.png" alt="img"></p><p>叶子节点是有序链表，可以帮助做范围查询。</p><p>最后，还有个问题，如果我不提估计很少有人会考虑：B+树如何查找数据。</p><p>为什么会有这个疑问呢？</p><p>之前说过，B数的节点存了完整的数据，假设数据总共3层，而你要找的数据在第2层的某个节点，当你找到后便可以直接返回整行数据。而B+树为了一个节点能存入更多的addr，节点内部只存了主键id，所以即使你在第二层找到匹配的id，还是不能直接返回，必须继续往下，直到在叶子节点读取完整数据。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589421184838-106cccdb-a84e-448f-8806-58e9dfa9b76e-20210923150406906.gif" alt="img"></p><p>讨论到这，我们来对比一下B树和B+树：</p><ul><li><p>B树的节点都会存储整行数据，占用空间大存储addr少，而B+树的非叶子节点只存储主键，能容纳更多addr</p></li><li><p>由于非叶子节点能容纳更多addr，那么同一个节点能指向更多下级节点，所以相同数据量时，B+树通常更加“矮”，IO更少</p></li><li><p>B树的查询效率是不稳定的，最好情况是根节点，最差情况是叶子节点，而B+树是稳定的，每次都要查询到叶子节点</p></li><li><p>B+树的叶子节点是有序列表，非常便于范围查询</p></li></ul><p>对于第三点，很多人可能觉得B+树每次都是稳定地查询叶子节点，还不如B树（最好情况根节点就返回了）。其实上面分析过了，B+树每个节点能存储的数据是B树的1170/16≈73倍，意味着B+树每个节点可以连接的分支更多，相同数据量的情况下，B+树远远矮于B树。比如B树的查询IO次数是1~100，而B+树恒定为3，你觉得哪个效率高？</p><p>回头看看柏青哥，钢珠掉落的过程是不是很像沿着索引查找数据呢~</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589373836878-c32bc126-fc73-48e4-ae95-d7e23ccf77c8-20210923150420395.png" alt="img"></p><p>学到这里，相信Dao层的对岸到底是什么，大家心里已经有B+树了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589374780467-c8dbebf7-eb2e-418b-8536-cc90aea27b37-20210923150427648.png" alt="img"></p><p>至此，我们回过头来给索引下个定义：</p><p><strong>索引是一种数据结构，</strong>用于高效搜索目标数据，在MySQL中具体实现为B+树（InnoDB引擎）。</p><p>最后说一句，没有所谓的“B减树”，很多人可能看到B树的英文表示法是”B-Tree”，误读为“B减树”。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊下Spring Cloud Netflix</title>
    <link href="/2020/08/04/spring-cloud/"/>
    <url>/2020/08/04/spring-cloud/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文基于 Spring Cloud Netflix 。Spring Cloud Alibaba 也是非常不错的选择哦！</p><p>授权转载自：<a href="https://juejin.im/post/5de2553e5188256e885f4fa3">https://juejin.im/post/5de2553e5188256e885f4fa3</a></p></blockquote><p>首先我给大家看一张图，如果大家对这张图有些地方不太理解的话，我希望你们看完我这篇文章会恍然大悟。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348675.jpg" alt="Spring Cloud 总体架构"></p><h2 id="什么是Spring-cloud"><a href="#什么是Spring-cloud" class="headerlink" title="什么是Spring cloud"></a>什么是Spring cloud</h2><blockquote><p>构建分布式系统不需要复杂和容易出错。Spring Cloud 为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。Spring Cloud 构建于 Spring Boot 之上，使得开发者很容易入手并快速应用于生产中。</p></blockquote><p>官方果然官方，介绍都这么有板有眼的。</p><p>我所理解的 <code>Spring Cloud</code> 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 <strong>服务发现注册</strong> 、<strong>配置中心</strong> 、<strong>消息总线</strong> 、<strong>负载均衡</strong> 、<strong>断路器</strong> 、<strong>数据监控</strong> 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p><h2 id="Spring-Cloud-的版本"><a href="#Spring-Cloud-的版本" class="headerlink" title="Spring Cloud 的版本"></a>Spring Cloud 的版本</h2><p>当然这个只是个题外话。</p><p><code>Spring Cloud</code> 的版本号并不是我们通常见的数字版本号，而是一些很奇怪的单词。这些单词均为英国伦敦地铁站的站名。同时根据字母表的顺序来对应版本时间顺序，比如：最早 的 <code>Release</code> 版本 <code>Angel</code>，第二个 <code>Release</code> 版本 <code>Brixton</code>（英国地名），然后是 <code>Camden</code>、 <code>Dalston</code>、<code>Edgware</code>、<code>Finchley</code>、<code>Greenwich</code>、<code>Hoxton</code>。</p><h2 id="Spring-Cloud-的服务发现框架——Eureka"><a href="#Spring-Cloud-的服务发现框架——Eureka" class="headerlink" title="Spring Cloud 的服务发现框架——Eureka"></a>Spring Cloud 的服务发现框架——Eureka</h2><blockquote><p><code>Eureka</code>是基于<code>REST</code>（代表性状态转移）的服务，主要在 <code>AWS</code> 云中用于定位服务，以实现负载均衡和中间层服务器的故障转移。我们称此服务为<code>Eureka</code>服务器。Eureka还带有一个基于 <code>Java</code> 的客户端组件 <code>Eureka Client</code>，它使与服务的交互变得更加容易。客户端还具有一个内置的负载平衡器，可以执行基本的循环负载平衡。在 <code>Netflix</code>，更复杂的负载均衡器将 <code>Eureka</code> 包装起来，以基于流量，资源使用，错误条件等多种因素提供加权负载均衡，以提供出色的弹性。</p></blockquote><p>总的来说，<code>Eureka</code> 就是一个服务发现框架。何为服务，何又为发现呢？</p><p>举一个生活中的例子，就比如我们平时租房子找中介的事情。</p><p>在没有中介的时候我们需要一个一个去寻找是否有房屋要出租的房东，这显然会非常的费力，一你找凭一个人的能力是找不到很多房源供你选择，再者你也懒得这么找下去(找了这么久，没有合适的只能将就)。<strong>这里的我们就相当于微服务中的 <code>Consumer</code> ，而那些房东就相当于微服务中的 <code>Provider</code> 。消费者 <code>Consumer</code> 需要调用提供者 <code>Provider</code> 提供的一些服务，就像我们现在需要租他们的房子一样。</strong></p><p>但是如果只是租客和房东之间进行寻找的话，他们的效率是很低的，房东找不到租客赚不到钱，租客找不到房东住不了房。所以，后来房东肯定就想到了广播自己的房源信息(比如在街边贴贴小广告)，这样对于房东来说已经完成他的任务(将房源公布出去)，但是有两个问题就出现了。第一、其他不是租客的都能收到这种租房消息，这在现实世界没什么，但是在计算机的世界中就会出现 <strong>资源消耗</strong> 的问题了。第二、租客这样还是很难找到你，试想一下我需要租房，我还需要东一个西一个地去找街边小广告，麻不麻烦？</p><p>那怎么办呢？我们当然不会那么傻乎乎的，第一时间就是去找 <strong>中介</strong> 呀，它为我们提供了统一房源的地方，我们消费者只需要跑到它那里去找就行了。而对于房东来说，他们也只需要把房源在中介那里发布就行了。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348705.png"></p><p>那么现在，我们的模式就是这样的了。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348841.png"></p><p>但是，这个时候还会出现一些问题。</p><ol><li>房东注册之后如果不想卖房子了怎么办？我们是不是需要让房东 <strong>定期续约</strong> ？如果房东不进行续约是不是要将他们从中介那里的注册列表中 <strong>移除</strong> 。</li><li>租客是不是也要进行 <strong>注册</strong> 呢？不然合同乙方怎么来呢？</li><li>中介可不可以做 <strong>连锁店</strong> 呢？如果这一个店因为某些不可抗力因素而无法使用，那么我们是否可以换一个连锁店呢？</li></ol><p>针对上面的问题我们来重新构建一下上面的模式图</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348029.jpg" alt="租房-中介模式图"></p><p>好了，举完这个:chestnut:我们就可以来看关于 <code>Eureka</code> 的一些基础概念了，你会发现这东西理解起来怎么这么简单。:punch::punch::punch:</p><p><strong>服务发现</strong>：其实就是一个“中介”，整个过程中有三个角色：**服务提供者(出租房子的)、服务消费者(租客)、服务中介(房屋中介)**。</p><p><strong>服务提供者</strong>： 就是提供一些自己能够执行的一些服务给外界。</p><p><strong>服务消费者</strong>： 就是需要使用一些服务的“用户”。</p><p><strong>服务中介</strong>： 其实就是服务提供者和服务消费者之间的“桥梁”，服务提供者可以把自己注册到服务中介那里，而服务消费者如需要消费一些服务(使用一些功能)就可以在服务中介中寻找注册在服务中介的服务提供者。</p><p><strong>服务注册 Register</strong>：</p><p>官方解释：当 <code>Eureka</code> 客户端向 <code>Eureka Server</code> 注册时，它提供自身的<strong>元数据</strong>，比如IP地址、端口，运行状况指示符URL，主页等。</p><p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>)在中介 (服务器 <code>Eureka Server</code>) 那里登记房屋的信息，比如面积，价格，地段等等(元数据 <code>metaData</code>)。</p><p><strong>服务续约 Renew</strong>：</p><p>官方解释：**<code>Eureka</code> 客户会每隔30秒(默认情况下)发送一次心跳来续约**。 通过续约来告知 <code>Eureka Server</code> 该 <code>Eureka</code> 客户仍然存在，没有出现问题。 正常情况下，如果 <code>Eureka Server</code> 在90秒没有收到 <code>Eureka</code> 客户的续约，它会将实例从其注册表中删除。</p><p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>) 定期告诉中介 (服务器 <code>Eureka Server</code>) 我的房子还租(续约) ，中介 (服务器<code>Eureka Server</code>) 收到之后继续保留房屋的信息。</p><p><strong>获取注册列表信息 Fetch Registries</strong>： </p><p>官方解释：<code>Eureka</code> 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 <code>Eureka</code> 客户端的缓存信息不同, <code>Eureka</code> 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，<code>Eureka</code> 客户端则会重新获取整个注册表信息。 <code>Eureka</code> 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。<code>Eureka</code> 客户端和 <code>Eureka</code> 服务器可以使用JSON / XML格式进行通讯。在默认的情况下 <code>Eureka</code> 客户端使用压缩 <code>JSON</code> 格式来获取注册列表的信息。</p><p>结合中介理解：租客(消费者 <code>Eureka Client Consumer</code>) 去中介 (服务器 <code>Eureka Server</code>) 那里获取所有的房屋信息列表 (客户端列表 <code>Eureka Client List</code>) ，而且租客为了获取最新的信息会定期向中介 (服务器 <code>Eureka Server</code>) 那里获取并更新本地列表。</p><p><strong>服务下线 Cancel</strong>：</p><p>官方解释：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<code>DiscoveryManager.getInstance().shutdownComponent();</code></p><p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>) 告诉中介  (服务器 <code>Eureka Server</code>) 我的房子不租了，中介之后就将注册的房屋信息从列表中剔除。</p><p><strong>服务剔除 Eviction</strong>：</p><p>官方解释：在默认的情况下，<strong>当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除</strong>，即服务剔除。</p><p>结合中介理解：房东(提供者 <code>Eureka Client Provider</code>) 会定期联系 中介  (服务器 <code>Eureka Server</code>) 告诉他我的房子还租(续约)，如果中介  (服务器 <code>Eureka Server</code>) 长时间没收到提供者的信息，那么中介会将他的房屋信息给下架(服务剔除)。</p><p>下面就是 <code>Netflix</code> 官方给出的 <code>Eureka</code> 架构图，你会发现和我们前面画的中介图别无二致。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348074.png" alt="Eureka架构图"></p><p>当然，可以充当服务发现的组件有很多：<code>Zookeeper</code> ，<code>Consul</code> ， <code>Eureka</code> 等。</p><p>更多关于 <code>Eureka</code> 的知识(自我保护，初始注册策略等等)可以自己去官网查看，或者查看我的另一篇文章 <a href="https://juejin.im/post/5dd497e3f265da0ba7718018">深入理解 Eureka</a>。</p><h2 id="负载均衡之-Ribbon"><a href="#负载均衡之-Ribbon" class="headerlink" title="负载均衡之 Ribbon"></a>负载均衡之 Ribbon</h2><h3 id="什么是-RestTemplate"><a href="#什么是-RestTemplate" class="headerlink" title="什么是 RestTemplate?"></a>什么是 <code>RestTemplate</code>?</h3><p>不是讲 <code>Ribbon</code> 么？怎么扯到了 <code>RestTemplate</code> 了？你先别急，听我慢慢道来。</p><p>我不听我不听我不听:hear_no_evil::hear_no_evil::hear_no_evil:。</p><p>我就说一句！**<code>RestTemplate</code>是<code>Spring</code>提供的一个访问Http服务的客户端类**，怎么说呢？就是微服务之间的调用是使用的 <code>RestTemplate</code> 。比如这个时候我们 消费者B 需要调用 提供者A 所提供的服务我们就需要这么写。如我下面的伪代码。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><span class="hljs-comment">// 这里是提供者A的ip地址，但是如果使用了 Eureka 那么就应该是提供者A的名称</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVICE_PROVIDER_A = <span class="hljs-string">&quot;http://localhost:8081&quot;</span>;<br><br><span class="hljs-meta">@PostMapping(&quot;/judge&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Request request)</span> </span>&#123;<br>    String url = SERVICE_PROVIDER_A + <span class="hljs-string">&quot;/service1&quot;</span>;<br>    <span class="hljs-keyword">return</span> restTemplate.postForObject(url, request, Boolean.class);<br>&#125;<br></code></pre></div></td></tr></table></figure><p> 如果你对源码感兴趣的话，你会发现上面我们所讲的 <code>Eureka</code> 框架中的 <strong>注册</strong>、<strong>续约</strong> 等，底层都是使用的 <code>RestTemplate</code> 。</p><h3 id="为什么需要-Ribbon？"><a href="#为什么需要-Ribbon？" class="headerlink" title="为什么需要 Ribbon？"></a>为什么需要 Ribbon？</h3><p><code>Ribbon</code>  是 <code>Netflix</code> 公司的一个开源的负载均衡 项目，是一个客户端/进程内负载均衡器，<strong>运行在消费者端</strong>。</p><p>我们再举个:chestnut:，比如我们设计了一个秒杀系统，但是为了整个系统的 <strong>高可用</strong> ，我们需要将这个系统做一个集群，而这个时候我们消费者就可以拥有多个秒杀系统的调用途径了，如下图。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348206.jpg" style="zoom:50%;" /><p>如果这个时候我们没有进行一些 <strong>均衡操作</strong> ，如果我们对 <code>秒杀系统1</code> 进行大量的调用，而另外两个基本不请求，就会导致 <code>秒杀系统1</code> 崩溃，而另外两个就变成了傀儡，那么我们为什么还要做集群，我们高可用体现的意义又在哪呢？</p><p>所以 <code>Ribbon</code> 出现了，注意我们上面加粗的几个字——<strong>运行在消费者端</strong>。指的是，<code>Ribbon</code> 是运行在消费者端的负载均衡器，如下图。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348411.jpg" style="zoom:50%;" /><p>其工作原理就是 <code>Consumer</code> 端获取到了所有的服务列表之后，在其<strong>内部</strong>使用<strong>负载均衡算法</strong>，进行对多个系统的调用。</p><h3 id="Nginx-和-Ribbon-的对比"><a href="#Nginx-和-Ribbon-的对比" class="headerlink" title="Nginx 和 Ribbon 的对比"></a>Nginx 和 Ribbon 的对比</h3><p>提到 <strong>负载均衡</strong> 就不得不提到大名鼎鼎的 <code>Nignx</code> 了，而和 <code>Ribbon</code> 不同的是，它是一种<strong>集中式</strong>的负载均衡器。</p><p>何为集中式呢？简单理解就是 <strong>将所有请求都集中起来，然后再进行负载均衡</strong>。如下图。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348438.jpg" style="zoom:50%;" /><p>我们可以看到 <code>Nginx</code> 是接收了所有的请求进行负载均衡的，而对于 <code>Ribbon</code> 来说它是在消费者端进行的负载均衡。如下图。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348837.jpg" style="zoom:50%;" /><blockquote><p>请注意 <code>Request</code> 的位置，在 <code>Nginx</code> 中请求是先进入负载均衡器，而在 <code>Ribbon</code> 中是先在客户端进行负载均衡才进行请求的。</p></blockquote><h3 id="Ribbon-的几种负载均衡算法"><a href="#Ribbon-的几种负载均衡算法" class="headerlink" title="Ribbon 的几种负载均衡算法"></a>Ribbon 的几种负载均衡算法</h3><p>负载均衡，不管 <code>Nginx</code> 还是 <code>Ribbon</code> 都需要其算法的支持，如果我没记错的话 <code>Nginx</code> 使用的是 轮询和加权轮询算法。而在 <code>Ribbon</code> 中有更多的负载均衡调度算法，其默认是使用的 <code>RoundRobinRule</code> 轮询策略。</p><ul><li>**<code>RoundRobinRule</code>**：轮询策略。<code>Ribbon</code> 默认采用的策略。若经过一轮轮询没有找到可用的 <code>provider</code>，其最多轮询 10 轮。若最终还没有找到，则返回 <code>null</code>。</li><li><strong><code>RandomRule</code></strong>: 随机策略，从所有可用的 <code>provider</code> 中随机选择一个。</li><li><strong><code>RetryRule</code></strong>: 重试策略。先按照 <code>RoundRobinRule</code> 策略获取 <code>provider</code>，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。</li></ul><p>🐦🐦🐦 还有很多，这里不一一举:chestnut:了，你最需要知道的是默认轮询算法，并且可以更换默认的负载均衡算法，只需要在配置文件中做出修改就行。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">providerName:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span><br></code></pre></div></td></tr></table></figure><p>当然，在 <code>Ribbon</code> 中你还可以<strong>自定义负载均衡算法</strong>，你只需要实现 <code>IRule</code> 接口，然后修改配置文件或者自定义 <code>Java Config</code> 类。</p><h2 id="什么是-Open-Feign"><a href="#什么是-Open-Feign" class="headerlink" title="什么是 Open Feign"></a>什么是 Open Feign</h2><p>有了 <code>Eureka</code>  ，<code>RestTemplate</code> ，<code>Ribbon</code>，  我们就可以愉快地进行服务间的调用了，但是使用 <code>RestTemplate</code> 还是不方便，我们每次都要进行这样的调用。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><span class="hljs-comment">// 这里是提供者A的ip地址，但是如果使用了 Eureka 那么就应该是提供者A的名称</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVICE_PROVIDER_A = <span class="hljs-string">&quot;http://localhost:8081&quot;</span>;<br><br><span class="hljs-meta">@PostMapping(&quot;/judge&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Request request)</span> </span>&#123;<br>    String url = SERVICE_PROVIDER_A + <span class="hljs-string">&quot;/service1&quot;</span>;<br>    <span class="hljs-comment">// 是不是太麻烦了？？？每次都要 url、请求、返回类型的 </span><br>    <span class="hljs-keyword">return</span> restTemplate.postForObject(url, request, Boolean.class);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样每次都调用 <code>RestRemplate</code> 的 <code>API</code> 是否太麻烦，我能不能像<strong>调用原来代码一样进行各个服务间的调用呢？</strong></p><p>:bulb::bulb::bulb:聪明的小朋友肯定想到了，那就用 <strong>映射</strong> 呀，就像域名和IP地址的映射。我们可以将被调用的服务代码映射到消费者端，这样我们就可以 **“无缝开发” **啦。</p><blockquote><p> <code>OpenFeign</code> 也是运行在消费者端的，使用 <code>Ribbon</code> 进行负载均衡，所以 <code>OpenFeign</code> 直接内置了 <code>Ribbon</code>。</p></blockquote><p>在导入了 <code>Open Feign</code> 之后我们就可以进行愉快编写  <code>Consumer</code> 端代码了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 使用 @FeignClient 注解来指定提供者的名字</span><br><span class="hljs-meta">@FeignClient(value = &quot;eureka-client-provider&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestClient</span> </span>&#123;<br>    <span class="hljs-comment">// 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/provider/xxx&quot;,</span><br><span class="hljs-meta">    method = RequestMethod.POST)</span><br>    CommonResponse&lt;List&lt;Plan&gt;&gt; getPlans(<span class="hljs-meta">@RequestBody</span> planGetRequest request);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后我们在 <code>Controller</code> 就可以像原来调用 <code>Service</code> 层代码一样调用它了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br>    <span class="hljs-comment">// 这里就相当于原来自动注入的 Service</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TestClient testClient;<br>    <span class="hljs-comment">// controller 调用 service 层代码</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.POST)</span><br>    <span class="hljs-keyword">public</span> CommonResponse&lt;List&lt;Plan&gt;&gt; get(<span class="hljs-meta">@RequestBody</span> planGetRequest request) &#123;<br>        <span class="hljs-keyword">return</span> testClient.getPlans(request);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="必不可少的-Hystrix"><a href="#必不可少的-Hystrix" class="headerlink" title="必不可少的 Hystrix"></a>必不可少的 Hystrix</h2><h3 id="什么是-Hystrix之熔断和降级"><a href="#什么是-Hystrix之熔断和降级" class="headerlink" title="什么是 Hystrix之熔断和降级"></a>什么是 Hystrix之熔断和降级</h3><blockquote><p>在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。</p></blockquote><p>总体来说 <code>Hystrix</code> 就是一个能进行 <strong>熔断</strong> 和 <strong>降级</strong> 的库，通过使用它能提高整个系统的弹性。</p><p>那么什么是 熔断和降级 呢？再举个:chestnut:，此时我们整个微服务系统是这样的。服务A调用了服务B，服务B再调用了服务C，但是因为某些原因，服务C顶不住了，这个时候大量请求会在服务C阻塞。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348032.jpg" style="zoom:50%;" /><p>服务C阻塞了还好，毕竟只是一个系统崩溃了。但是请注意这个时候因为服务C不能返回响应，那么服务B调用服务C的的请求就会阻塞，同理服务B阻塞了，那么服务A也会阻塞崩溃。</p><blockquote><p>请注意，为什么阻塞会崩溃。因为这些请求会消耗占用系统的线程、IO 等资源，消耗完你这个系统服务器不就崩了么。</p></blockquote><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348243.jpg" style="zoom:50%;" /><p>这就叫 <strong>服务雪崩</strong>。妈耶，上面两个 <strong>熔断</strong> 和 <strong>降级</strong> 你都没给我解释清楚，你现在又给我扯什么 <strong>服务雪崩</strong> ？:tired_face::tired_face::tired_face:</p><p>别急，听我慢慢道来。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348317.png"></p><p>不听我也得讲下去！</p><p>所谓 <strong>熔断</strong> 就是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过 <strong>断路器</strong> 直接将此请求链路断开。</p><p>也就是我们上面服务B调用服务C在指定时间窗内，调用的失败率到达了一定的值，那么 <code>Hystrix</code> 则会自动将 服务B与C 之间的请求都断了，以免导致服务雪崩现象。</p><p>其实这里所讲的 <strong>熔断</strong> 就是指的 <code>Hystrix</code> 中的 <strong>断路器模式</strong> ，你可以使用简单的 <code>@HystrixCommand</code> 注解来标注某个方法，这样 <code>Hystrix</code> 就会使用 <strong>断路器</strong> 来“包装”这个方法，每当调用时间超过指定时间时(默认为1000ms)，断路器将会中断对这个方法的调用。</p><p>当然你可以对这个注解的很多属性进行设置，比如设置超时时间，像这样。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand(</span><br><span class="hljs-meta">    commandProperties = &#123;@HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1200&quot;)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Xxx&gt; <span class="hljs-title">getXxxx</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...省略代码逻辑</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是，我查阅了一些博客，发现他们都将 <strong>熔断</strong> 和 <strong>降级</strong> 的概念混淆了，以我的理解，<strong>降级是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户友好的回复</strong>。这也就对应着 <code>Hystrix</code> 的 <strong>后备处理</strong> 模式。你可以通过设置 <code>fallbackMethod</code> 来给一个方法设置备用的代码逻辑。比如这个时候有一个热点新闻出现了，我们会推荐给用户查看详情，然后用户会通过id去查询新闻的详情，但是因为这条新闻太火了(比如最近什么*易对吧)，大量用户同时访问可能会导致系统崩溃，那么我们就进行 <strong>服务降级</strong> ，一些请求会做一些降级处理比如当前人数太多请稍后查看等等。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 指定了后备方法调用</span><br><span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;getHystrixNews&quot;)</span><br><span class="hljs-meta">@GetMapping(&quot;/get/news&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> News <span class="hljs-title">getNews</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用新闻系统的获取新闻api 代码逻辑省略</span><br>&#125;<br><span class="hljs-comment">// </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> News <span class="hljs-title">getHystrixNews</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    <span class="hljs-comment">// 做服务降级</span><br>    <span class="hljs-comment">// 返回当前人数太多，请稍后查看</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="什么是Hystrix之其他"><a href="#什么是Hystrix之其他" class="headerlink" title="什么是Hystrix之其他"></a>什么是Hystrix之其他</h3><p>我在阅读 《Spring微服务实战》这本书的时候还接触到了一个 <strong>舱壁模式</strong> 的概念。在不使用舱壁模式的情况下，服务A调用服务B，这种调用默认的是 <strong>使用同一批线程来执行</strong> 的，而在一个服务出现性能问题的时候，就会出现所有线程被刷爆并等待处理工作，同时阻塞新请求，最终导致程序崩溃。而舱壁模式会将远程资源调用隔离在他们自己的线程池中，以便可以控制单个表现不佳的服务，而不会使该程序崩溃。</p><p>具体其原理我推荐大家自己去了解一下，本篇文章中对 <strong>舱壁模式</strong> 不做过多解释。当然还有 <strong><code>Hystrix</code> 仪表盘</strong>，它是<strong>用来实时监控 <code>Hystrix</code> 的各项指标信息的</strong>，这里我将这个问题也抛出去，希望有不了解的可以自己去搜索一下。</p><h2 id="微服务网关——Zuul"><a href="#微服务网关——Zuul" class="headerlink" title="微服务网关——Zuul"></a>微服务网关——Zuul</h2><blockquote><p>ZUUL 是从设备和 web 站点到 Netflix 流应用后端的所有请求的前门。作为边界服务应用，ZUUL 是为了实现动态路由、监视、弹性和安全性而构建的。它还具有根据情况将请求路由到多个 Amazon Auto Scaling Groups（亚马逊自动缩放组，亚马逊的一种云计算方式） 的能力</p></blockquote><p>在上面我们学习了 <code>Eureka</code> 之后我们知道了 <em>服务提供者</em>  是 <em>消费者</em> 通过 <code>Eureka Server</code> 进行访问的，即 <code>Eureka Server</code> 是 <em>服务提供者</em> 的统一入口。那么整个应用中存在那么多 <em>消费者</em> 需要用户进行调用，这个时候用户该怎样访问这些 <em>消费者工程</em> 呢？当然可以像之前那样直接访问这些工程。但这种方式没有统一的消费者工程调用入口，不便于访问与管理，而 Zuul 就是这样的一个对于 <em>消费者</em> 的统一入口。</p><blockquote><p>如果学过前端的肯定都知道 Router 吧，比如 Flutter 中的路由，Vue，React中的路由，用了 Zuul 你会发现在路由功能方面和前端配置路由基本是一个理。:smile: 我偶尔撸撸 Flutter。</p></blockquote><p>大家对网关应该很熟吧，简单来讲网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行<strong>鉴权</strong>、<strong>限流</strong>、 <strong>路由</strong>、<strong>监控</strong>等功能。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348558.jpg" style="zoom:50%;" /><p>没错，网关有的功能，<code>Zuul</code> 基本都有。而 <code>Zuul</code> 中最关键的就是 <strong>路由和过滤器</strong> 了，在官方文档中 <code>Zuul</code> 的标题就是</p><blockquote><p>Router and Filter : Zuul</p></blockquote><h3 id="Zuul-的路由功能"><a href="#Zuul-的路由功能" class="headerlink" title="Zuul 的路由功能"></a>Zuul 的路由功能</h3><h4 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h4><p>本来想给你们复制一些代码，但是想了想，因为各个代码配置比较零散，看起来也比较零散，我决定还是给你们画个图来解释吧。</p><blockquote><p>请不要因为我这么好就给我点赞 :thumbsup: 。 疯狂暗示。</p></blockquote><p>比如这个时候我们已经向 <code>Eureka Server</code> 注册了两个 <code>Consumer</code> 、三个 <code>Provicer</code> ，这个时候我们再加个 <code>Zuul</code> 网关应该变成这样子了。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348954.jpg" style="zoom:50%;" /><p>emmm，信息量有点大，我来解释一下。关于前面的知识我就不解释了:neutral_face:。</p><p>首先，<code>Zuul</code> 需要向 <code>Eureka</code> 进行注册，注册有啥好处呢？</p><p>你傻呀，<code>Consumer</code> 都向 <code>Eureka Server</code> 进行注册了，我网关是不是只要注册就能拿到所有 <code>Consumer</code> 的信息了？</p><p>拿到信息有什么好处呢？</p><p>我拿到信息我是不是可以获取所有的 <code>Consumer</code> 的元数据(名称，ip，端口)？</p><p>拿到这些元数据有什么好处呢？拿到了我们是不是直接可以做<strong>路由映射</strong>？比如原来用户调用 <code>Consumer1</code> 的接口 <code>localhost:8001/studentInfo/update</code> 这个请求，我们是不是可以这样进行调用了呢？<code>localhost:9000/consumer1/studentInfo/update</code> 呢？你这样是不是恍然大悟了？</p><blockquote><p>这里的url为了让更多人看懂所以没有使用 restful 风格。</p></blockquote><p>上面的你理解了，那么就能理解关于 <code>Zuul</code> 最基本的配置了，看下面。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9000</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># 这里只要注册 Eureka 就行了</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:9997/eureka</span><br></code></pre></div></td></tr></table></figure><p>然后在启动类上加入 <code>@EnableZuulProxy</code> 注解就行了。没错，就是那么简单:smiley:。</p><h4 id="统一前缀"><a href="#统一前缀" class="headerlink" title="统一前缀"></a>统一前缀</h4><p>这个很简单，就是我们可以在前面加一个统一的前缀，比如我们刚刚调用的是 <code>localhost:9000/consumer1/studentInfo/update</code>，这个时候我们在 <code>yaml</code> 配置文件中添加如下。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">prefix:</span> <span class="hljs-string">/zuul</span><br></code></pre></div></td></tr></table></figure><p>这样我们就需要通过 <code>localhost:9000/zuul/consumer1/studentInfo/update</code> 来进行访问了。</p><h4 id="路由策略配置"><a href="#路由策略配置" class="headerlink" title="路由策略配置"></a>路由策略配置</h4><p>你会发现前面的访问方式(直接使用服务名)，需要将微服务名称暴露给用户，会存在安全性问题。所以，可以自定义路径来替代微服务名称，即自定义路由策略。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-attr">consumer1:</span> <span class="hljs-string">/FrancisQ1/**</span><br>    <span class="hljs-attr">consumer2:</span> <span class="hljs-string">/FrancisQ2/**</span><br></code></pre></div></td></tr></table></figure><p>这个时候你就可以使用 <code> </code>localhost:9000/zuul/FrancisQ1/studentInfo/update` 进行访问了。</p><h4 id="服务名屏蔽"><a href="#服务名屏蔽" class="headerlink" title="服务名屏蔽"></a>服务名屏蔽</h4><p>这个时候你别以为你好了，你可以试试，在你配置完路由策略之后使用微服务名称还是可以访问的，这个时候你需要将服务名屏蔽。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">ignore-services:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></div></td></tr></table></figure><h4 id="路径屏蔽"><a href="#路径屏蔽" class="headerlink" title="路径屏蔽"></a>路径屏蔽</h4><p><code>Zuul</code> 还可以指定屏蔽掉的路径 URI，即只要用户请求中包含指定的 URI 路径，那么该请求将无法访问到指定的服务。通过该方式可以限制用户的权限。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">ignore-patterns:</span> <span class="hljs-string">**/auto/**</span><br></code></pre></div></td></tr></table></figure><p>这样关于 auto 的请求我们就可以过滤掉了。</p><blockquote><p>** 代表匹配多级任意路径</p><p>*代表匹配一级任意路径</p></blockquote><h4 id="敏感请求头屏蔽"><a href="#敏感请求头屏蔽" class="headerlink" title="敏感请求头屏蔽"></a>敏感请求头屏蔽</h4><p>默认情况下，像 <code>Cookie</code>、<code>Set-Cookie</code> 等敏感请求头信息会被 <code>zuul</code> 屏蔽掉，我们可以将这些默认屏蔽去掉，当然，也可以添加要屏蔽的请求头。</p><h3 id="Zuul-的过滤功能"><a href="#Zuul-的过滤功能" class="headerlink" title="Zuul 的过滤功能"></a>Zuul 的过滤功能</h3><p>如果说，路由功能是 <code>Zuul</code> 的基操的话，那么<strong>过滤器</strong>就是 <code>Zuul</code>的利器了。毕竟所有请求都经过网关(Zuul)，那么我们可以进行各种过滤，这样我们就能实现 <strong>限流</strong>，<strong>灰度发布</strong>，<strong>权限控制</strong> 等等。</p><h4 id="简单实现一个请求时间日志打印"><a href="#简单实现一个请求时间日志打印" class="headerlink" title="简单实现一个请求时间日志打印"></a>简单实现一个请求时间日志打印</h4><p>要实现自己定义的 <code>Filter</code> 我们只需要继承 <code>ZuulFilter</code> 然后将这个过滤器类以 <code>@Component</code> 注解加入 Spring 容器中就行了。</p><p>在给你们看代码之前我先给你们解释一下关于过滤器的一些注意点。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348400.jpg" style="zoom:50%;" /><p>过滤器类型：<code>Pre</code>、<code>Routing</code>、<code>Post</code>。前置<code>Pre</code>就是在请求之前进行过滤，<code>Routing</code>路由过滤器就是我们上面所讲的路由策略，而<code>Post</code>后置过滤器就是在 <code>Response</code> 之前进行过滤的过滤器。你可以观察上图结合着理解，并且下面我会给出相应的注释。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 加入Spring容器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreRequestFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;<br>    <span class="hljs-comment">// 返回过滤器类型 这里是前置过滤器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> FilterConstants.PRE_TYPE;<br>    &#125;<br>    <span class="hljs-comment">// 指定过滤顺序 越小越先执行，这里第一个执行</span><br>    <span class="hljs-comment">// 当然不是只真正第一个 在Zuul内置中有其他过滤器会先执行</span><br>    <span class="hljs-comment">// 那是写死的 比如 SERVLET_DETECTION_FILTER_ORDER = -3</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 什么时候该进行过滤</span><br>    <span class="hljs-comment">// 这里我们可以进行一些判断，这样我们就可以过滤掉一些不符合规定的请求等等</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果过滤器允许通过则怎么进行处理</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;<br>        <span class="hljs-comment">// 这里我设置了全局的RequestContext并记录了请求开始时间</span><br>        RequestContext ctx = RequestContext.getCurrentContext();<br>        ctx.set(<span class="hljs-string">&quot;startTime&quot;</span>, System.currentTimeMillis());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// lombok的日志</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-comment">// 加入 Spring 容器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessLogFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;<br>    <span class="hljs-comment">// 指定该过滤器的过滤类型</span><br>    <span class="hljs-comment">// 此时是后置过滤器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> FilterConstants.POST_TYPE;<br>    &#125;<br>    <span class="hljs-comment">// SEND_RESPONSE_FILTER_ORDER 是最后一个过滤器</span><br>    <span class="hljs-comment">// 我们此过滤器在它之前执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> FilterConstants.SEND_RESPONSE_FILTER_ORDER - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 过滤时执行的策略</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;<br>        RequestContext context = RequestContext.getCurrentContext();<br>        HttpServletRequest request = context.getRequest();<br>        <span class="hljs-comment">// 从RequestContext获取原先的开始时间 并通过它计算整个时间间隔</span><br>        Long startTime = (Long) context.get(<span class="hljs-string">&quot;startTime&quot;</span>);<br>        <span class="hljs-comment">// 这里我可以获取HttpServletRequest来获取URI并且打印出来</span><br>        String uri = request.getRequestURI();<br>        <span class="hljs-keyword">long</span> duration = System.currentTimeMillis() - startTime;<br>        log.info(<span class="hljs-string">&quot;uri: &quot;</span> + uri + <span class="hljs-string">&quot;, duration: &quot;</span> + duration / <span class="hljs-number">100</span> + <span class="hljs-string">&quot;ms&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面就简单实现了请求时间日志打印功能，你有没有感受到 <code>Zuul</code> 过滤功能的强大了呢？</p><p>没有？好的、那我们再来。</p><h4 id="令牌桶限流"><a href="#令牌桶限流" class="headerlink" title="令牌桶限流"></a>令牌桶限流</h4><p>当然不仅仅是令牌桶限流方式，<code>Zuul</code> 只要是限流的活它都能干，这里我只是简单举个:chestnut:。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348632.jpg" alt="令牌桶限流" style="zoom:50%;" /><p>我先来解释一下什么是 <strong>令牌桶限流</strong> 吧。</p><p>首先我们会有个桶，如果里面没有满那么就会以一定 <strong>固定的速率</strong> 会往里面放令牌，一个请求过来首先要从桶中获取令牌，如果没有获取到，那么这个请求就拒绝，如果获取到那么就放行。很简单吧，啊哈哈、</p><p>下面我们就通过 <code>Zuul</code> 的前置过滤器来实现一下令牌桶限流。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lgq.zuul.filter;<br><br><span class="hljs-keyword">import</span> com.google.common.util.concurrent.RateLimiter;<br><span class="hljs-keyword">import</span> com.netflix.zuul.ZuulFilter;<br><span class="hljs-keyword">import</span> com.netflix.zuul.context.RequestContext;<br><span class="hljs-keyword">import</span> com.netflix.zuul.exception.ZuulException;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;<br>    <span class="hljs-comment">// 定义一个令牌桶，每秒产生2个令牌，即每秒最多处理2个请求</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RateLimiter RATE_LIMITER = RateLimiter.create(<span class="hljs-number">2</span>);<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> FilterConstants.PRE_TYPE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">5</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;<br>        log.info(<span class="hljs-string">&quot;放行&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        RequestContext context = RequestContext.getCurrentContext();<br>        <span class="hljs-keyword">if</span>(!RATE_LIMITER.tryAcquire()) &#123;<br>            log.warn(<span class="hljs-string">&quot;访问量超载&quot;</span>);<br>            <span class="hljs-comment">// 指定当前请求未通过过滤</span><br>            context.setSendZuulResponse(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 向客户端返回响应码429，请求数量过多</span><br>            context.setResponseStatusCode(<span class="hljs-number">429</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样我们就能将请求数量控制在一秒两个，有没有觉得很酷？</p><h3 id="关于-Zuul-的其他"><a href="#关于-Zuul-的其他" class="headerlink" title="关于 Zuul  的其他"></a>关于 Zuul  的其他</h3><p><code>Zuul</code> 的过滤器的功能肯定不止上面我所实现的两种，它还可以实现 <strong>权限校验</strong>，包括我上面提到的 <strong>灰度发布</strong> 等等。</p><p>当然，<code>Zuul</code> 作为网关肯定也存在 <strong>单点问题</strong> ，如果我们要保证 <code>Zuul</code> 的高可用，我们就需要进行 <code>Zuul</code> 的集群配置，这个时候可以借助额外的一些负载均衡器比如 <code>Nginx</code> 。</p><p>##Spring Cloud配置管理——Config</p><h3 id="为什么要使用进行配置管理？"><a href="#为什么要使用进行配置管理？" class="headerlink" title="为什么要使用进行配置管理？"></a>为什么要使用进行配置管理？</h3><p>当我们的微服务系统开始慢慢地庞大起来，那么多 <code>Consumer</code> 、<code>Provider</code> 、<code>Eureka Server</code> 、<code>Zuul</code> 系统都会持有自己的配置，这个时候我们在项目运行的时候可能需要更改某些应用的配置，如果我们不进行配置的统一管理，我们只能<strong>去每个应用下一个一个寻找配置文件然后修改配置文件再重启应用</strong>。</p><p>首先对于分布式系统而言我们就不应该去每个应用下去分别修改配置文件，再者对于重启应用来说，服务无法访问所以直接抛弃了可用性，这是我们更不愿见到的。</p><p>那么有没有一种方法<strong>既能对配置文件统一地进行管理，又能在项目运行时动态修改配置文件呢？</strong></p><p>那就是我今天所要介绍的 <code>Spring Cloud Config</code> 。</p><blockquote><p>能进行配置管理的框架不止 <code>Spring Cloud Config</code> 一种，大家可以根据需求自己选择（<code>disconf</code>，阿波罗等等）。而且对于 <code>Config</code> 来说有些地方实现的不是那么尽人意。</p></blockquote><h3 id="Config-是什么"><a href="#Config-是什么" class="headerlink" title="Config 是什么"></a>Config 是什么</h3><blockquote><p><code>Spring Cloud Config</code> 为分布式系统中的外部化配置提供服务器和客户端支持。使用 <code>Config</code> 服务器，可以在中心位置管理所有环境中应用程序的外部属性。</p></blockquote><p>简单来说，<code>Spring Cloud Config</code> 就是能将各个 应用/系统/模块 的配置文件存放到 <strong>统一的地方然后进行管理</strong>(Git 或者 SVN)。</p><p>你想一下，我们的应用是不是只有启动的时候才会进行配置文件的加载，那么我们的 <code>Spring Cloud Config</code> 就暴露出一个接口给启动应用来获取它所想要的配置文件，应用获取到配置文件然后再进行它的初始化工作。就如下图。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348766.jpg" style="zoom:50%;" /><p>当然这里你肯定还会有一个疑问，如果我在应用运行时去更改远程配置仓库(Git)中的对应配置文件，那么依赖于这个配置文件的已启动的应用会不会进行其相应配置的更改呢？</p><p>答案是不会的。</p><p>什么？那怎么进行动态修改配置文件呢？这不是出现了 <strong>配置漂移</strong> 吗？你个渣男:rage:，你又骗我！</p><p>别急嘛，你可以使用 <code>Webhooks</code> ，这是  <code>github</code> 提供的功能，它能确保远程库的配置文件更新后客户端中的配置信息也得到更新。</p><p>噢噢，这还差不多。我去查查怎么用。</p><p>慢着，听我说完，<code>Webhooks</code> 虽然能解决，但是你了解一下会发现它根本不适合用于生产环境，所以基本不会使用它的。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348821.png"></p><p>而一般我们会使用 <code>Bus</code> 消息总线 + <code>Spring Cloud Config</code> 进行配置的动态刷新。</p><h2 id="引出-Spring-Cloud-Bus"><a href="#引出-Spring-Cloud-Bus" class="headerlink" title="引出 Spring Cloud Bus"></a>引出 Spring Cloud Bus</h2><blockquote><p>用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。</p></blockquote><p>你可以简单理解为 <code>Spring Cloud Bus</code> 的作用就是<strong>管理和广播分布式系统中的消息</strong>，也就是消息引擎系统中的广播模式。当然作为 <strong>消息总线</strong> 的 <code>Spring Cloud Bus</code> 可以做很多事而不仅仅是客户端的配置刷新功能。</p><p>而拥有了 <code>Spring Cloud Bus</code> 之后，我们只需要创建一个简单的请求，并且加上 <code>@ResfreshScope</code> 注解就能进行配置的动态修改了，下面我画了张图供你理解。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348224.jpg" style="zoom:50%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章中我带大家初步了解了 <code>Spring Cloud</code> 的各个组件，他们有</p><ul><li><code>Eureka</code> 服务发现框架</li><li><code>Ribbon</code> 进程内负载均衡器</li><li><code>Open Feign</code> 服务调用映射</li><li><code>Hystrix</code> 服务降级熔断器</li><li><code>Zuul</code> 微服务网关</li><li><code>Config</code> 微服务统一配置中心</li><li><code>Bus</code> 消息总线</li></ul><p>如果你能这个时候能看懂文首那张图，也就说明了你已经对 <code>Spring Cloud</code> 微服务有了一定的架构认识。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UDP&amp;TCP</title>
    <link href="/2020/07/29/UDP%20&amp;%20TCP%20/"/>
    <url>/2020/07/29/UDP%20&amp;%20TCP%20/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>讲解 TCP 三次握手和四次握手之前，我们先了解一下 TCP 和 UDP 这两个重量级的传输层协议。</p><p>💦 <strong>用户数据报协议 UDP</strong>（User Datagram Protocol）：</p><ul><li><strong>UDP 在传送数据之前不需要先建立连接</strong>，远程主机在收到 UDP 报文后，不需要给出任何确认。</li><li>虽然 UDP <strong>不提供可靠交付</strong>，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等</li></ul><p>💦 <strong>传输控制协议 TCP</strong>（Transmission Control Protocol）：</p><ul><li>TCP 提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 不提供广播或多播服务。由于 TCP 要提供<strong>可靠</strong>的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</li><li>TCP <strong>一般用于文件传输、发送和接收邮件、远程登录等场景</strong>。</li></ul><h2 id="2-TCP-报文段首部格式"><a href="#2-TCP-报文段首部格式" class="headerlink" title="2. TCP 报文段首部格式"></a>2. TCP 报文段首部格式</h2><p>TCP 报文段的具体格式大家可以不必都记住，但是其中的几个<strong>控制位</strong>与我们接下来要讲的三次握手和四次挥手息息相关，大家一定要牢记。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144029349" alt="图片"></p><p>首部固定部分各字段意义如下：</p><ul><li><p>1 - <strong>源端口和目的端口</strong>：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址</p></li><li><p>2 - <strong>序号/序列号</strong>（Sequense Number，SN）：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。<strong>初始序号称为 Init Sequense Number, ISN</strong>（序号/序列号这个字段很重要，大家留个印象，下文会详细讲解）</p><p>例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。</p></li><li><p>3 - <strong>确认号 ack</strong>：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。</p></li><li><p>4 - <strong>数据偏移</strong>（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。</p></li><li><p>5 - <strong>保留</strong>：占 6 位，应置为 0，保留为今后使用。</p></li></ul><p>⭐ 大家看上图，保留位的右边还有 6 个控制位（重要），这是TCP 用来说明该报文段性质的：</p><ul><li><p><strong>紧急位 URG</strong>：当 URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。该控制位需配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）</p><p>举个例子：我们需要取消一个已经发送了很长程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这个指令将存储在接收 TCP 的缓存末尾，只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程，这样做就无法实现立即中断。</p></li><li><p><strong>确认 ACK</strong>：仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</p></li><li><p><strong>推送 PSH</strong>：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。</p></li><li><p><strong>复位 RST</strong>：当 RST = 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。</p></li><li><p><strong>同步 SYN</strong>：SYN = 1 表示这是一个连接请求或连接接受报文。</p><p>当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 且 ACK = 1。</p></li><li><p><strong>终止 FIN</strong>：用来释放一个连接。当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p></li></ul><h2 id="3-TCP-三次握手建立连接"><a href="#3-TCP-三次握手建立连接" class="headerlink" title="3. TCP 三次握手建立连接"></a>3. TCP 三次握手建立连接</h2><h3 id="①-三次握手过程详解"><a href="#①-三次握手过程详解" class="headerlink" title="① 三次握手过程详解"></a>① 三次握手过程详解</h3><p>三次握手的原文是 <code>three-way handshake</code>，整个名词的可以翻译为：<strong>需要三个步骤才能建立握手/连接的机制</strong>。当然，三次握手也可以叫 <code>three-message handshake</code>，通过三条消息来建立的握手/连接。</p><p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的 <strong>初始化序列号(Init Sequense Number,  <code>ISN</code>)</strong> 为后面的可靠性传输做准备。</p><p>三次握手过程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144034490" alt="图片"></p><p>回顾一下图中字符的含义：</p><ul><li><code>SYN</code>：连接请求/接收 报文段</li><li><code>seq</code>：发送的第一个字节的序号</li><li><code>ACK</code>：确认报文段</li><li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p><strong>刚开始客户端处于 <code>Closed</code> 的状态，而服务端处于 <code>Listen</code> 状态</strong>：</p><blockquote><p><code>CLOSED</code>：没有任何连接状态</p><p><code>LISTEN</code>：侦听来自远方 TCP 端口的连接请求</p></blockquote><p><strong>1）第一次握手</strong>：客户端向服务端发送一个 SYN 报文（SYN = 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq = x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 <code>SYN_Send</code> 状态。</p><blockquote><p><code>SYN-SENT</code> ：在发送连接请求后等待匹配的连接请求</p></blockquote><p><strong>2）第二次握手</strong>：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN = 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq = y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 <code>SYN_REVD</code> 的状态。</p><blockquote><p><code>SYN-RECEIVED</code>：在收到和发送一个连接请求后等待对连接请求的确认</p></blockquote><p><strong>3）第三次握手</strong>：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 <code>Establised</code> 状态。</p><p>服务器收到 ACK 报文之后，也处于 <code>Establised 状态</code>，至此，双方建立起了 TCP 连接。</p><blockquote><p><code>ESTABLISHED</code>：代表一个打开的连接，数据可以传送给用户</p></blockquote><h3 id="②-为什么要三次握手"><a href="#②-为什么要三次握手" class="headerlink" title="② 为什么要三次握手"></a>② 为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的</strong>。</p><p>只有经过三次握手才能确认双发的收发功能都正常，缺一不可：</p><ul><li><p>第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常</p></li><li><p>第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：</p><p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p><p>服务器确认了：对方发送正常，自己接收正常</p></li><li><p>第三次握手（客户端发送 ACK 报文给服务器）：</p><p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p><p>服务器确认了：自己发送、接收正常，对方发送、接收正常</p></li></ul><h3 id="③-ISN-Initial-Sequence-Number-是固定的吗"><a href="#③-ISN-Initial-Sequence-Number-是固定的吗" class="headerlink" title="③ ISN (Initial Sequence Number) 是固定的吗"></a>③ ISN (Initial Sequence Number) 是固定的吗</h3><p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据</strong>。</p><p>当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。<strong>如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的</strong>。</p><h3 id="④-三次握手过程中可以携带数据吗"><a href="#④-三次握手过程中可以携带数据吗" class="headerlink" title="④ 三次握手过程中可以携带数据吗"></a>④ 三次握手过程中可以携带数据吗</h3><p>第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手绝对不可以携带数据</strong></p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>⭐ <strong>简单的记忆就是，请求连接/接收 即 <code>SYN = 1</code> 的时候不能携带数据</strong></p><p>而对于第三次的话，此时客户端已经处于 <code>ESTABLISHED</code> 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。</p><h3 id="⑤-半连接队列"><a href="#⑤-半连接队列" class="headerlink" title="⑤ 半连接队列"></a>⑤ 半连接队列</h3><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code> 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>当然还有一个<strong>全连接队列</strong>，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><h3 id="⑥-SYN-洪泛攻击"><a href="#⑥-SYN-洪泛攻击" class="headerlink" title="⑥ SYN 洪泛攻击"></a>⑥ SYN 洪泛攻击</h3><p>SYN 攻击就是 <strong>Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包</strong>，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</p><h3 id="⑦-如果第三次握手丢失了，客户端服务端会如何处理"><a href="#⑦-如果第三次握手丢失了，客户端服务端会如何处理" class="headerlink" title="⑦ 如果第三次握手丢失了，客户端服务端会如何处理"></a>⑦ 如果第三次握手丢失了，客户端服务端会如何处理</h3><p>服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><h2 id="4-TCP-四次挥手释放连接"><a href="#4-TCP-四次挥手释放连接" class="headerlink" title="4. TCP 四次挥手释放连接"></a>4. TCP 四次挥手释放连接</h2><h3 id="①-四次挥手过程详解"><a href="#①-四次挥手过程详解" class="headerlink" title="① 四次挥手过程详解"></a>① 四次挥手过程详解</h3><p>建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的<strong>半关闭</strong>（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 连接的释放需要发送四个包（执行四个步骤），因此称为四次挥手(<code>Four-way handshake</code>)，<strong>客户端或服务端均可主动发起挥手动作</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144040116" alt="图片"></p><p>回顾一下上图中符号的意思：</p><ul><li><code>FIN</code> ：连接终止位</li><li><code>seq</code>：发送的第一个字节的序号</li><li><code>ACK</code>：确认报文段</li><li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p>刚开始双方都处于<code>ESTABLISHED</code> 状态，假设是客户端先发起关闭请求。四次挥手的过程如下：</p><p><strong>1）第一次挥手</strong>：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并<strong>停止再发送数据，主动关闭 TCP 连接</strong>。此时客户端处于 <code>FIN_WAIT1</code> 状态，等待服务端的确认。</p><blockquote><p><code>FIN-WAIT-1</code> - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></blockquote><p><strong>2）第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。</p><blockquote><p><code>CLOSE-WAIT</code> - 等待从本地用户发来的连接中断请求；</p></blockquote><p><strong>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放</strong>。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待 2）状态，等待服务端发出的连接释放报文段。</p><blockquote><p><code>FIN-WAIT-2</code> - 从远程TCP等待连接中断请求；</p></blockquote><p><strong>3）第三次挥手</strong>：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态，等待客户端的确认。</p><blockquote><p><code>LAST-ACK</code> - 等待原来发向远程TCP的连接中断请求的确认；</p></blockquote><p><strong>4）第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 <strong><code>TIME_WAIT</code> （时间等待）状态</strong>。</p><blockquote><p><code>TIME-WAIT</code> - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></blockquote><p>🚨 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，<strong>需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 <code>CLOSED</code> 状态</strong>（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 <code>CLOSED</code> 状态。</p><h3 id="②-为什么要四次挥手"><a href="#②-为什么要四次挥手" class="headerlink" title="② 为什么要四次挥手"></a>② 为什么要四次挥手</h3><p>由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就<strong>完全关闭</strong>了TCP连接。</p><p><strong>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手</strong>。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Communication protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式都在这了</title>
    <link href="/2020/07/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/07/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java中单例(Singleton)模式是一种广泛使用的设计模式。单例模式的主要作用是保证在Java程序中，某个类只有一个实例存在。</p><p>它的核心在于，<strong>单例模式可以保证一个类仅创建一个实例，并提供一个访问它的全局访问点</strong>。</p><p><strong>一些管理器和控制器常被设计成单例模式</strong> 。</p><h3 id="单例模式好处"><a href="#单例模式好处" class="headerlink" title="单例模式好处"></a>单例模式好处</h3><ul><li>它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间；</li><li>能够避免由于操作多个实例导致的逻辑错误。</li><li>如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。</li></ul><p>单例模式有很多种写法，大部分写法都或多或少有一些不足。下面将分别对这几种写法进行介绍。</p><p><strong>该模式有三个基本要点</strong>：</p><p><strong>一是这个类只能有一个实例；</strong><br><strong>二是它必须自行创建这个实例；</strong><br><strong>三是它必须自行向整个系统提供这个实例</strong>。</p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance=<span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 自行创建实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// 通过该函数向整个系统提供实例</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从代码中我们看到，类的构造函数定义为private的，保证其他类不能实例化此类，然后提供了一个静态实例并返回给调用者。饿汉模式是最简单的一种实现方式，<strong>饿汉模式在类加载的时候就对实例进行创建，实例在整个程序周期都存在。</strong></p><p>它的好处是只在类加载的时候创建一次实例，不会存在多个线程创建多个实例的情况，避免了多线程同步的问题。<br>它的缺点也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。<br> 这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况。但是，如果单例占用的内存比较大，或单例只是在某个特定场景下才会用到，使用饿汉模式就不合适了，这时候就需要用到懒汉模式进行延迟加载。</p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 懒汉模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance= <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 不实例化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// 通过该函数向整个系统提供实例</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<span class="hljs-comment">// 当 instance 为 null 时，则实例化对象，否则直接返回对象</span><br>            instance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 实例化对象</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<span class="hljs-comment">// 返回已存在的对象</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>好处：懒汉模式中单例是在需要的时候才去创建的，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。</li><li>适用于：如果某个单例使用的次数少，并且创建单例消耗的资源较多，那么就需要实现单例的按需创建，这个时候使用懒汉模式就是一个不错的选择。</li><li>缺点：但是这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的getInstance()方法，导致创建多个实例，因此需要加锁解决线程同步问题，实现如下:</li></ul><p>以上代码在单线程下运行是没有问题的，但要运行在多线程下，就会出现实例化多个类对象的情况。这是怎么回事呢？</p><p>当线程 A 进入到 if 判断条件后，开始实例化对象，此时 instance 依然为 null；又有线程 B 进入到 if 判断条件中，之后也会通过条件判断，进入到方法里面创建一个实例对象。</p><p>所以我们需要对该方法进行加锁，保证多线程情况下仅创建一个实例。这里我们使用 Synchronized 同步锁来修饰 getInstance 方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 懒汉模式 + synchronized 同步锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance= <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 不实例化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// 加同步锁，通过该函数向整个系统提供实例</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<span class="hljs-comment">// 当 instance 为 null 时，则实例化对象，否则直接返回对象</span><br>            instance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 实例化对象</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<span class="hljs-comment">// 返回已存在的对象</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但同步锁会增加锁竞争，带来系统性能开销，从而导致系统性能下降，因此这种方式也会降低单例模式的性能。</p><p>还有，<strong>每次请求获取类对象时，都会通过 getInstance() 方法获取，除了第一次为 null，其它每次请求基本都是不为 null 的。在没有加同步锁之前，是因为 if 判断条件为 null 时，才导致创建了多个实例。基于以上两点，我们可以考虑将同步锁放在 if 条件里面，这样就可以减少同步锁资源竞争</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 懒汉模式 + synchronized 同步锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance= <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 不实例化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// 加同步锁，通过该函数向整个系统提供实例</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<span class="hljs-comment">// 当 instance 为 null 时，则实例化对象，否则直接返回对象</span><br>          <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<br>              instance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 实例化对象</span><br>          &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<span class="hljs-comment">// 返回已存在的对象</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p> 你是不是觉得这样就可以了呢？答案是依然会创建多个实例。<strong>这是因为当多个线程进入到 if 判断条件里，虽然有同步锁，但是进入到判断条件里面的线程依然会依次获取到锁创建对象，然后再释放同步锁</strong>。所以我们还需要在同步锁里面再加一个判断条件</p><h3 id="双重校验锁【推荐】"><a href="#双重校验锁【推荐】" class="headerlink" title="双重校验锁【推荐】"></a>双重校验锁【推荐】</h3><ol><li>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。</li><li>一半的人写不出双检锁，还有一半的人说不出它的隐患和Java1.5是如何对它修正的。</li><li>它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，</li><li>但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。</li></ol><ul><li><strong>加锁的懒汉模式看起来即解决了线程并发问题，又实现了延迟加载，然而它存在着性能问题，依然不够完美。</strong></li><li><strong>synchronized修饰的同步方法比一般方法要慢很多，如果多次调用getInstance()，累积的性能损耗就比较大了。</strong></li><li><strong>因此就有了双重校验锁，先看下它的实现代码。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 懒汉模式 + synchronized 同步锁 + double-check</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance= <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 不实例化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// 加同步锁，通过该函数向整个系统提供实例</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<span class="hljs-comment">// 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象</span><br>          <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<span class="hljs-comment">// 同步锁</span><br>             <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<span class="hljs-comment">// 第二次判断</span><br>                instance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 实例化对象</span><br>             &#125;<br>          &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<span class="hljs-comment">// 返回已存在的对象</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到上面在同步代码块内多了一层instance为空的判断。由于单例对象只需要创建一次，如果后面再次调用getInstance()只需要直接返回单例对象。</p><ul><li>因此，大部分情况下，调用getInstance()都不会执行到同步代码块，从而提高了程序性能。</li><li>不过还需要考虑一种情况，假如两个线程A、B，A执行了if (instance == null)语句，它会认为单例对象没有创建，此时线程切到B也执行了同样的语句，B也认为单例对象没有创建，然后两个线程依次执行同步代码块，并分别创建了一个单例对象。为了解决这个问题，还需要在同步代码块中增加if (instance == null)语句，也就是上面看到的代码中的校验2。</li><li>双检锁隐患：<br><strong>我们看到双重校验锁即实现了延迟加载，又解决了线程并发问题，同时还解决了执行效率问题，是否真的就万无一失了呢？</strong></li></ul><ul><li>这里要提到Java中的指令重排优化和 Happens-Before 规则。所谓指令重排优化是指在不改变原语义的情况下，通过调整指令的执行顺序让程序运行的更快。</li><li>JVM中并没有规定编译器优化相关的内容，也就是说JVM可以自由的进行指令重排序的优化。</li><li>这个问题的关键就在于由于指令重排优化的存在，导致初始化Singleton和将对象地址赋给instance字段的顺序是不确定的。</li><li>在某个线程创建单例对象时，在构造方法被调用之前，就为该对象分配了内存空间并将对象的字段设置为默认值。</li><li>此时就可以将分配的内存地址赋值给instance字段了，然而该对象可能还没有初始化。若紧接着另外一个线程来调用getInstance，取到的就是状态不正确的对象，程序就会出错。</li></ul><h4 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h4><p><strong>通过字面意思，你可能会误以为是前一个操作发生在后一个操作之前。然而真正的意思是，前一个操作的结果可以被后续的操作获取。这条规则规范了编译器对程序的重排序优化。</strong></p><ul><li><strong>JDK5的修正</strong>：以上就是双重校验锁会失效的原因，不过还好在JDK1.5及之后版本增加了volatile关键字。<ul><li>volatile的一个语义是禁止指令重排序优化，也就保证了instance变量被赋值的时候对象已经是初始化过的，从而避免了上面说到的问题。</li><li>Java中的volatile 变量是什么？</li></ul></li></ul><p>理解volatile关键字的作用的前提是要理解Java内存模型，volatile关键字的作用主要有两个：</p><ol><li>多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</li><li>代码底层执行不像我们看到的高级语言—-Java程序这么简单，<br>它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。<strong>使用volatile则会对禁止语义重排序</strong>，当然这也一定程度上降低了代码执行效率</li></ol><ul><li>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</li><li>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。 </li><li>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生。</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 懒汉模式 + synchronized 同步锁 + double-check</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance= <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 不实例化</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; list = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//list 属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;<br>      list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    &#125;<span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// 加同步锁，通过该函数向整个系统提供实例</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<span class="hljs-comment">// 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象</span><br>          <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<span class="hljs-comment">// 同步锁</span><br>             <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<span class="hljs-comment">// 第二次判断</span><br>                instance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 实例化对象</span><br>             &#125;<br>          &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<span class="hljs-comment">// 返回已存在的对象</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="静态内部类【推荐】"><a href="#静态内部类【推荐】" class="headerlink" title="静态内部类【推荐】"></a>静态内部类【推荐】</h3><p>除了上面的三种方式，还有另外一种实现单例的方式，通过静态内部类来实现。<br>首先看一下它的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 懒汉模式 内部类实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-keyword">public</span> List&lt;String&gt; list = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// list 属性</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 构造函数</span><br>list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>&#125;<br> <br><span class="hljs-comment">// 内部类实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerSingleton</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance=<span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 自行创建实例</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> InnerSingleton.instance;<span class="hljs-comment">// 返回内部类中的静态变量</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li> 这种方式同样利用了类加载机制来保证只创建一个instance实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。</li><li>不一样的是，它是在内部类里面去创建对象实例。</li><li>这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举模式最安全，反射和序列化都是单例。</p><p>《Effective Java》作者也是强烈推荐枚举方式实现单例。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Resource</span><span class="hljs-params">()</span></span>&#123;&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 枚举类型是线程安全的，并且只会装载一次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    INSTANCE;<br> <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Resource instance;<br> <br>    Singleton()&#123;<br>        instance = <span class="hljs-keyword">new</span> Resource();<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Resource <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Resource <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-keyword">return</span> Singleton.INSTANCE.getInstance();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>上面的类Resource是我们要应用单例模式的资源，具体可以表现为网络连接，数据库连接，线程池等等。 </li><li>获取资源的方式很简单，只要 Singleton.INSTANCE.getInstance() 即可获得所要实例。</li></ul><p><strong>下面我们来看看单例是如何被保证的：</strong> </p><ol><li>首先，在枚举中我们<strong>明确了构造方法限制为私有</strong>，在我们访问枚举实例时会执行构造方法。</li><li>同时每个<strong>枚举实例都是static final类型的</strong>，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。 </li><li>也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的INSTANCE也被保证实例化一次。 </li></ol><ul><li>可以看到，枚举实现单例还是比较简单的，除此之外我们再来看一下Enum这个类的声明：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">E</span>&gt;&gt;<span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Serializable</span></span><br></code></pre></div></td></tr></table></figure><ul><li>可以看到，枚举也提供了序列化机制。某些情况，比如我们要通过网络传输一个数据库连接的句柄，会提供很多帮助。 </li><li>最后借用 《Effective Java》一书中的话， 单元素的枚举类型已经成为实现Singleton的最佳方法。</li></ul><p>或者使用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DataSourceEnum</span> </span>&#123;<br>    DATASOURCE;<br>    <span class="hljs-keyword">private</span> DBConnection connection = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DataSourceEnum</span><span class="hljs-params">()</span> </span>&#123;<br>        connection = <span class="hljs-keyword">new</span> DBConnection();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DBConnection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> connection;<br>    &#125;<br>&#125;  <br></code></pre></div></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Title</span>: java单例之enum实现方式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: EnumSingleton.java</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Copyright</span> 2016-2018 - Powered By 研发中心</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 王延飞</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>:  2018-02-07 20:02</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> V1.0</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnumSingleton</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">EnumSingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EnumSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> Singleton.INSTANCE.getInstance();<br>   &#125;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span></span>&#123;<br>       INSTANCE;<br>       <span class="hljs-keyword">private</span> EnumSingleton singleton;<br>       <span class="hljs-comment">//JVM会保证此方法绝对只调用一次</span><br>       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;<br>           singleton = <span class="hljs-keyword">new</span> EnumSingleton();<br>       &#125;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> EnumSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>           <span class="hljs-keyword">return</span> singleton;<br>       &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       EnumSingleton obj1 = EnumSingleton.getInstance();<br>       EnumSingleton obj2 = EnumSingleton.getInstance();<br>       <span class="hljs-comment">//输出结果：obj1==obj2?true</span><br>       System.out.println(<span class="hljs-string">&quot;obj1==obj2?&quot;</span> + (obj1==obj2));<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面提到的四种实现单例的方式都有共同的缺点：</p><ol><li>需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例。</li><li>可以使用反射强行调用私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）。</li></ol><p>而枚举类很好的解决了这两个问题，使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。</p><h3 id="单例模式的线程安全性"><a href="#单例模式的线程安全性" class="headerlink" title="单例模式的线程安全性"></a>单例模式的线程安全性</h3><p>首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p><p>（1）饿汉式：线程安全</p><p>（2）懒汉式：非线程安全</p><p>（3）双检锁：线程安全</p><p>（4）静态内部类：线程安全</p><p>（5）枚举：线程安全</p><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；</p><p>如果我们是写一些工具类，则优先考虑使用懒汉模式，因为很多项目可能会引用到 jar 包，但未必会使用到这个工具类，懒汉模式实现的单例可以避免提前被加载到内存中，占用系统资源。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发注意事项</title>
    <link href="/2020/06/16/%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2020/06/16/%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="1-1-正确使用-equals-方法"><a href="#1-1-正确使用-equals-方法" class="headerlink" title="1.1. 正确使用 equals 方法"></a>1.1. 正确使用 equals 方法</h2><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 </p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span><br>String str = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">&quot;SnailClimb&quot;</span>)) &#123;<br>  ...<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  ..<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-string">&quot;SnailClimb&quot;</span>.equals(str);<span class="hljs-comment">// false </span><br></code></pre></div></td></tr></table></figure><p>不过更推荐使用 <code>java.util.Objects#equals</code>(JDK7 引入的工具类)。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Objects.equals(<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;SnailClimb&quot;</span>);<span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><p>我们看一下<code>java.util.Objects#equals</code>的源码就知道原因了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;<br>    <span class="hljs-comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span><br>    <span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-keyword">null</span> &amp;&amp; a.equals(b));<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong></p><p>Reference:<a href="https://blog.csdn.net/tick_tock97/article/details/72824894">Java中equals方法造成空指针异常的原因及解决方案</a></p><ul><li>每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。</li><li>可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中<code>null == null</code>将返回true。</li><li>不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</li></ul><h2 id="1-2-整型包装类值的比较"><a href="#1-2-整型包装类值的比较" class="headerlink" title="1.2. 整型包装类值的比较"></a>1.2. 整型包装类值的比较</h2><p>所有整型包装类对象值的比较必须使用equals方法。</p><p>先看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer i1 = <span class="hljs-number">40</span>;<br>Integer i2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">40</span>);<br>System.out.println(i1==i2);<span class="hljs-comment">//false</span><br></code></pre></div></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生拆箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而<code>Integer i1 = new Integer(40)</code> 会直接创建新的对象。因此，输出 false 。</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 <code>equals()</code>  方法比较</strong>。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281141849.png"></p><p><strong>注意：</strong> 如果你的IDE(IDEA/Eclipse)上安装了阿里巴巴的p3c插件，这个插件如果检测到你用 ==的话会报错提示，推荐安装一个这个插件，很不错。</p><h2 id="1-3-BigDecimal"><a href="#1-3-BigDecimal" class="headerlink" title="1.3. BigDecimal"></a>1.3. BigDecimal</h2><h3 id="1-3-1-BigDecimal-的用处"><a href="#1-3-1-BigDecimal-的用处" class="headerlink" title="1.3.1. BigDecimal 的用处"></a>1.3.1. BigDecimal 的用处</h3><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">float</span> a = <span class="hljs-number">1.0f</span> - <span class="hljs-number">0.9f</span>;<br><span class="hljs-keyword">float</span> b = <span class="hljs-number">0.9f</span> - <span class="hljs-number">0.8f</span>;<br>System.out.println(a);<span class="hljs-comment">// 0.100000024</span><br>System.out.println(b);<span class="hljs-comment">// 0.099999964</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BigDecimal a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;1.0&quot;</span>);<br>BigDecimal b = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.9&quot;</span>);<br>BigDecimal c = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.8&quot;</span>);<br><br>BigDecimal x = a.subtract(b); <br>BigDecimal y = b.subtract(c); <br><br>System.out.println(x); <span class="hljs-comment">/* 0.1 */</span><br>System.out.println(y); <span class="hljs-comment">/* 0.1 */</span><br>System.out.println(Objects.equals(x, y)); <span class="hljs-comment">/* true */</span><br></code></pre></div></td></tr></table></figure><h3 id="1-3-2-BigDecimal-的大小比较"><a href="#1-3-2-BigDecimal-的大小比较" class="headerlink" title="1.3.2. BigDecimal 的大小比较"></a>1.3.2. BigDecimal 的大小比较</h3><p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1表示 <code>a</code> 大于 <code>b</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BigDecimal a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;1.0&quot;</span>);<br>BigDecimal b = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.9&quot;</span>);<br>System.out.println(a.compareTo(b));<span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure><h3 id="1-3-3-BigDecimal-保留几位小数"><a href="#1-3-3-BigDecimal-保留几位小数" class="headerlink" title="1.3.3. BigDecimal 保留几位小数"></a>1.3.3. BigDecimal 保留几位小数</h3><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BigDecimal m = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;1.255433&quot;</span>);<br>BigDecimal n = m.setScale(<span class="hljs-number">3</span>,BigDecimal.ROUND_HALF_DOWN);<br>System.out.println(n);<span class="hljs-comment">// 1.255</span><br></code></pre></div></td></tr></table></figure><h3 id="1-3-4-BigDecimal-的使用注意事项"><a href="#1-3-4-BigDecimal-的使用注意事项" class="headerlink" title="1.3.4. BigDecimal 的使用注意事项"></a>1.3.4. BigDecimal 的使用注意事项</h3><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210928104528.png" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></p><h3 id="1-3-5-总结"><a href="#1-3-5-总结" class="headerlink" title="1.3.5. 总结"></a>1.3.5. 总结</h3><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p><p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p><h2 id="1-4-基本数据类型与包装数据类型的使用标准"><a href="#1-4-基本数据类型与包装数据类型的使用标准" class="headerlink" title="1.4. 基本数据类型与包装数据类型的使用标准"></a>1.4. 基本数据类型与包装数据类型的使用标准</h2><p>Reference:《阿里巴巴Java开发手册》</p><ul><li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li><li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul><p>比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.</p><p><strong>说明</strong> :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p><p><strong>正例</strong> : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p><p><strong>反例</strong> : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p><h1 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h1><h2 id="2-1-Arrays-asList-使用指南"><a href="#2-1-Arrays-asList-使用指南" class="headerlink" title="2.1. Arrays.asList()使用指南"></a>2.1. Arrays.asList()使用指南</h2><p>最近使用<code>Arrays.asList()</code>遇到了一些坑，然后在网上看到这篇文章：<a href="http://javadevnotes.com/java-array-to-list-examples">Java Array to List Examples</a> 感觉挺不错的，但是还不是特别全面。所以，自己对于这块小知识点进行了简单的总结。</p><h3 id="2-1-1-简介"><a href="#2-1-1-简介" class="headerlink" title="2.1.1. 简介"></a>2.1.1. 简介</h3><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String[] myArray = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>&#125;;<br>List&lt;String&gt; myList = Arrays.asList(myArray);<br><span class="hljs-comment">//上面两个语句等价于下面一条语句</span><br>List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>JDK 源码对于这个方法的说明：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，</span><br><span class="hljs-comment">  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-1-2-《阿里巴巴Java-开发手册》对其的描述"><a href="#2-1-2-《阿里巴巴Java-开发手册》对其的描述" class="headerlink" title="2.1.2. 《阿里巴巴Java 开发手册》对其的描述"></a>2.1.2. 《阿里巴巴Java 开发手册》对其的描述</h3><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210928104537.png" alt="阿里巴巴Java开发手-Arrays.asList()方法"></p><h3 id="2-1-3-使用时的注意事项总结"><a href="#2-1-3-使用时的注意事项总结" class="headerlink" title="2.1.3. 使用时的注意事项总结"></a>2.1.3. 使用时的注意事项总结</h3><p><strong>传递的数组必须是对象数组，而不是基本类型。</strong> </p><p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] myArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>List myList = Arrays.asList(myArray);<br>System.out.println(myList.size());<span class="hljs-comment">//1</span><br>System.out.println(myList.get(<span class="hljs-number">0</span>));<span class="hljs-comment">//数组地址值</span><br>System.out.println(myList.get(<span class="hljs-number">1</span>));<span class="hljs-comment">//报错：ArrayIndexOutOfBoundsException</span><br><span class="hljs-keyword">int</span>[] array = (<span class="hljs-keyword">int</span>[]) myList.get(<span class="hljs-number">0</span>);<br>System.out.println(array[<span class="hljs-number">0</span>]);<span class="hljs-comment">//1</span><br></code></pre></div></td></tr></table></figure><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>我们使用包装类型数组就可以解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer[] myArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>使用集合的修改方法:<code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List myList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>myList.add(<span class="hljs-number">4</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.clear();<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br></code></pre></div></td></tr></table></figure><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List myList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>System.out.println(myList.getClass());<span class="hljs-comment">//class java.util.Arrays$ArrayList</span><br></code></pre></div></td></tr></table></figure><p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">      <span class="hljs-keyword">implements</span> <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class">  </span>&#123;<br>      ...<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>         ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; c)</span> </span>&#123;<br>        ...<br>      &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-1-4-如何正确的将数组转换为ArrayList"><a href="#2-1-4-如何正确的将数组转换为ArrayList" class="headerlink" title="2.1.4. 如何正确的将数组转换为ArrayList?"></a>2.1.4. 如何正确的将数组转换为ArrayList?</h3><p>stackoverflow：<a href="https://dwz.cn/vcBkTiTW">https://dwz.cn/vcBkTiTW</a></p><p><strong>1. 自己动手实现（教育目的）</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.5+</span><br><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">arrayToList</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T[] array)</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> List&lt;T&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;(array.length);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> T s : array) &#123;<br>    l.add(s);<br>  &#125;<br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>System.out.println(arrayToList(myArray).getClass());<span class="hljs-comment">//class java.util.ArrayList</span><br></code></pre></div></td></tr></table></figure><p><strong>2. 最简便的方法(推荐)</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>))<br></code></pre></div></td></tr></table></figure><p><strong>3. 使用 Java8 的Stream(推荐)</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List myList = Arrays.stream(myArray).collect(Collectors.toList());<br><span class="hljs-comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><br><span class="hljs-keyword">int</span> [] myArray2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());<br></code></pre></div></td></tr></table></figure><p><strong>4. 使用 Guava(推荐)</strong></p><p>对于不可变集合，你可以使用[<code>ImmutableList</code>]类及其[<code>of()</code>]与[<code>copyOf()</code>]工厂方法：（参数不能为空）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; il = ImmutableList.of(<span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;elements&quot;</span>);  <span class="hljs-comment">// from varargs</span><br>List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="hljs-comment">// from array</span><br></code></pre></div></td></tr></table></figure><p>对于可变集合，你可以使用[<code>Lists</code>]类及其[<code>newArrayList()</code>]工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="hljs-comment">// from collection</span><br>List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="hljs-comment">// from array</span><br>List&lt;String&gt; l3 = Lists.newArrayList(<span class="hljs-string">&quot;or&quot;</span>, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;elements&quot;</span>); <span class="hljs-comment">// from varargs</span><br></code></pre></div></td></tr></table></figure><p><strong>5. 使用 Apache Commons Collections</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>CollectionUtils.addAll(list, str);<br></code></pre></div></td></tr></table></figure><p><strong>6. 使用 Java9 的 <code>List.of()</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>List&lt;Integer&gt; list = List.of(array);<br>System.out.println(list); <span class="hljs-comment">/* [1, 2, 3] */</span><br><span class="hljs-comment">/* 不支持基本数据类型 */</span><br></code></pre></div></td></tr></table></figure><h2 id="2-2-Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#2-2-Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="2.2. Collection.toArray()方法使用的坑&amp;如何反转数组"></a>2.2. Collection.toArray()方法使用的坑&amp;如何反转数组</h2><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String [] s= <span class="hljs-keyword">new</span> String[]&#123;<br>    <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;over&quot;</span>, <span class="hljs-string">&quot;jumps&quot;</span>, <span class="hljs-string">&quot;fox&quot;</span>, <span class="hljs-string">&quot;brown&quot;</span>, <span class="hljs-string">&quot;quick&quot;</span>, <span class="hljs-string">&quot;A&quot;</span><br>&#125;;<br>List&lt;String&gt; list = Arrays.asList(s);<br>Collections.reverse(list);<br>s=list.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);<span class="hljs-comment">//没有指定类型的话会报错</span><br></code></pre></div></td></tr></table></figure><p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p><h2 id="2-3-不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#2-3-不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="2.3. 不要在 foreach 循环里进行元素的 remove/add 操作"></a>2.3. 不要在 foreach 循环里进行元素的 remove/add 操作</h2><p>如果要进行<code>remove</code>操作，可以调用迭代器的 <code>remove </code>方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p></blockquote><p>Java8开始，可以使用<code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>    list.add(i);<br>&#125;<br>list.removeIf(filter -&gt; filter % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">/* 删除list中的所有偶数 */</span><br>System.out.println(list); <span class="hljs-comment">/* [1, 3, 5, 7, 9] */</span><br></code></pre></div></td></tr></table></figure><p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210928104803.png" alt="不要在 foreach 循环里进行元素的 remove/add 操作"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双亲委派机制</title>
    <link href="/2020/06/15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/06/15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在介绍双亲委派机制的时候，不得不提ClassLoader（类加载器）。说ClassLoader之前，我们得先了解下Java的基本知识。<br>  Java是运行在Java的虚拟机(JVM)中的，但是它是如何运行在JVM中了呢？我们在IDE中编写的Java源代码被编译器编译成.class的字节码文件。然后由我们得ClassLoader负责将这些class文件给加载到JVM中去执行。<br>  JVM中提供了三层的ClassLoader：</p><p>Bootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader。</p><p>ExtClassLoader：主要负责加载jre/lib/ext目录下的一些扩展的jar。</p><p>AppClassLoader：主要负责加载应用程序的主函数类</p><p>那如果有一个我们写的Hello.java编译成的Hello.class文件，它是如何被加载到JVM中的呢？别着急，请继续往下看。</p><p>双亲委派机制</p><p>我打开了我的AndroidStudio，搜索了下“ClassLoader”,然后打开“java.lang”包下的ClassLoader类。然后将代码翻到loadClass方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-keyword">false</span>);<br>&#125;<br><span class="hljs-comment">//              -----??-----</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>        <span class="hljs-comment">// 首先，检查是否已经被类加载器加载过</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 存在父加载器，递归的交由父加载器</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 直到最上面的Bootstrap类加载器</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br> <br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其实这段代码已经很好的解释了双亲委派机制，为了大家更容易理解，我做了一张图来描述一下上面这段代码的流程：  </p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70.png"></p><p>从上图中我们就更容易理解了，当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。那么有人就有下面这种疑问了？</p><p>为什么要设计这种机制</p><p>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。</p><p>总结了一张脑图如下：</p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70-20210719110251508.png" style="zoom:200%;" />]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis哨兵模式</title>
    <link href="/2020/05/22/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/22/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p><h3 id="一、哨兵模式概述"><a href="#一、哨兵模式概述" class="headerlink" title="一、哨兵模式概述"></a>一、哨兵模式概述</h3><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/sen1.png"></p><p>这里的哨兵有两个作用</p><ul><li><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</p></li><li><p>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</p></li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p>用文字描述一下<strong>故障切换（failover）</strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><hr><h3 id="二、Redis配置哨兵模式"><a href="#二、Redis配置哨兵模式" class="headerlink" title="二、Redis配置哨兵模式"></a>二、Redis配置哨兵模式</h3><p>配置3个哨兵和1主2从的Redis服务器来演示这个过程。</p><p>| 服务类型  |是否是主服务器 |ip地址| 端口|<br>| :——— | :———— | :———— | :———— | :———— |<br>|redis|是|192.168.11.128|6379|<br>|redis|否|192.168.11.129|6379|<br>|redis|否|192.168.11.130|6379|<br>|sentinel|-|192.168.11.128|26379|<br>|sentinel|-|192.168.11.129|26379|<br>|sentinel|-|192.168.11.130|26379|</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/sen2.png"></p><p>首先配置Redis的主从服务器，修改redis.conf文件如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"># 使得Redis服务器可以跨网络访问<br>bind 0.0.0.0<br># 设置密码<br>requirepass &quot;123456&quot;<br># 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置<br>slaveof 192.168.11.128 6379<br># 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置<br>masterauth 123456<br></code></pre></div></td></tr></table></figure><p>上述内容主要是配置Redis服务器，从服务器比主服务器多一个slaveof的配置和密码。</p><p>配置3个哨兵，每个哨兵的配置都是一样的。在Redis安装目录下有一个sentinel.conf文件，copy一份进行修改</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"># 禁止保护模式<br>protected-mode no<br># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。<br>sentinel monitor mymaster 192.168.11.128 6379 2<br># sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码<br># sentinel auth-pass <span class="hljs-tag">&lt;<span class="hljs-name">master-name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br>sentinel auth-pass mymaster 123456<br></code></pre></div></td></tr></table></figure><p>上述关闭了保护模式，便于测试。</p><p>有了上述的修改，我们可以进入Redis的安装目录的src目录，通过下面的命令启动服务器和哨兵</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"># 启动Redis服务器进程<br>./redis-server ../redis.conf<br># 启动哨兵进程<br>./redis-sentinel ../sentinel.conf<br></code></pre></div></td></tr></table></figure><p>注意启动的顺序。首先是主机（192.168.11.128）的Redis服务进程，然后启动从机的服务进程，最后启动3个哨兵的服务进程。</p><hr><h3 id="三、Java中使用哨兵模式"><a href="#三、Java中使用哨兵模式" class="headerlink" title="三、Java中使用哨兵模式"></a>三、Java中使用哨兵模式</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试Redis哨兵模式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSentinels</span> </span>&#123;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;resource&quot;)</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSentinel</span><span class="hljs-params">()</span> </span>&#123;<br>        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>);<br>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>);<br>        jedisPoolConfig.setMinIdle(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 哨兵信息</span><br>        Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;192.168.11.128:26379&quot;</span>,<br>                <span class="hljs-string">&quot;192.168.11.129:26379&quot;</span>,<span class="hljs-string">&quot;192.168.11.130:26379&quot;</span>));<br>        <span class="hljs-comment">// 创建连接池</span><br>        JedisSentinelPool pool = <span class="hljs-keyword">new</span> JedisSentinelPool(<span class="hljs-string">&quot;mymaster&quot;</span>, sentinels,jedisPoolConfig,<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">// 获取客户端</span><br>        Jedis jedis = pool.getResource();<br>        <span class="hljs-comment">// 执行两个命令</span><br>        jedis.set(<span class="hljs-string">&quot;mykey&quot;</span>, <span class="hljs-string">&quot;myvalue&quot;</span>);<br>        String value = jedis.get(<span class="hljs-string">&quot;mykey&quot;</span>);<br>        System.out.println(value);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面是通过Jedis进行使用的，同样也可以使用Spring进行配置RedisTemplate使用。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;poolConfig&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 最大空闲数 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 最大连接数 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxTotal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 最大等待时间 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxWaitMillis&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;connectionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolConfig&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;poolConfig&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sentinelConfig&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sentinelConfig&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-comment">&lt;!-- JDK序列化器 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdkSerializationRedisSerializer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-comment">&lt;!-- String序列化器 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stringRedisSerializer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;redisTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connectionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;connectionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keySerializer&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stringRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultSerializer&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stringRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;valueSerializer&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jdkSerializationRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-comment">&lt;!-- 哨兵配置 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sentinelConfig&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisSentinelConfiguration&quot;</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 服务名称 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;master&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mymaster&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 哨兵服务IP和端口 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sentinels&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;192.168.11.128&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26379&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;192.168.11.129&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26379&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;192.168.11.130&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26379&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="四、哨兵模式的其他配置项"><a href="#四、哨兵模式的其他配置项" class="headerlink" title="四、哨兵模式的其他配置项"></a>四、哨兵模式的其他配置项</h3><table><thead><tr><th align="left">配置项</th><th align="left">参数类型</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">port</td><td align="left">整数</td><td align="left">启动哨兵进程端口</td></tr><tr><td align="left">dir</td><td align="left">文件夹目录</td><td align="left">哨兵进程服务临时文件夹，默认为/tmp，要保证有可写入的权限</td></tr><tr><td align="left">sentinel down-after-milliseconds</td><td align="left">&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td align="left">指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）</td></tr><tr><td align="left">sentinel parallel-syncs</td><td align="left">&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td><td align="left">指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高</td></tr><tr><td align="left">sentinel failover-timeout</td><td align="left">&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td align="left">指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟</td></tr><tr><td align="left">sentinel notification-script</td><td align="left">&lt;服务名称&gt;&lt;脚本路径&gt;</td><td align="left">指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，比较常用</td></tr></tbody></table><p>sentinel down-after-milliseconds配置项只是一个哨兵在超过规定时间依旧没有得到响应后，会自己认为主机不可用。对于其他哨兵而言，并不是这样认为。哨兵会记录这个消息，当拥有认为主观下线的哨兵达到sentinel monitor所配置的数量时，就会发起一次投票，进行failover，此时哨兵会重写Redis的哨兵配置文件，以适应新场景的需要。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis常用命令</title>
    <link href="/2020/05/21/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/05/21/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://1drv.ms/u/s!AuIKtprkDa8kjCfpQcXgXISfDleN?e=jKW0qf">课件地址</a>      <a href="http://redisdoc.com/">redis命令大全</a></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">redis-server /配置文件位置     #启动redis <br>redis-cli -p 6379     #切换到redis控制台 redis默认端口 6379<br>redis-cli shutdown   #单实例关闭<br>redis-cli -p 6379 shutdown    #多实例关闭，指定端口关闭<br>select db #切换到该数据库 0 - 15 <br>dbsize #查看当前库key的数量<br>flushdb #清空当当前库<br>flushall #清空16个库 慎用！<br></code></pre></div></td></tr></table></figure><h2 id="Redis-键（key）"><a href="#Redis-键（key）" class="headerlink" title="Redis 键（key）"></a><strong>Redis 键（key）</strong></h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">keys *  #查看所有keys <br>exists key  #判断key是否存在<br>move key db  #将key移动到db  当前库就没有了<br>expire key second  # 为key设置过期时间 单位秒<br>ttl key  #查看该key 还有多少秒过期  -1表示永不过期   -2表示已过期（过期后该key被移除）<br>type key #查看该key类型<br>del key #删除该key<br></code></pre></div></td></tr></table></figure><h2 id="Redis-String"><a href="#Redis-String" class="headerlink" title="Redis String"></a><strong>Redis String</strong></h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">set key #设置该key的value<br>get key #获取该key的value<br>del key #删除该key<br>append key value #在该key后面添加value<br>strlen key #获取该key长度<br>incr key  #该key的值 加1  该key的值必须是数字 <br>decr key  #该key的值 减1  该key的值必须是数字 <br>incrby key num # 该key的值加 num 该key的值必须是数字 <br>decrby key num # 该key的值减 num 该key的值必须是数字 <br>getrange key start end # 获取start和end区间的值， 0  -1 为获取全部<br>setrange key offset value  # 设置该key从offset开始的值为value <br>setex key second value # set with expire 设置该key的值为value 存活时间为second <br>setnx key value # set if not exist 如果该key不存在，设置该key的值为value<br>mset key value key value ...  #一次存入多个键值对<br>mget key key key ... #一次取出多个key的value<br>msetnx key value key value # 一次存入多个键值对  key必须是未存在#个key已存在，则整个命令失败<br></code></pre></div></td></tr></table></figure><h2 id="Redis-List-列表-有序可重"><a href="#Redis-List-列表-有序可重" class="headerlink" title="Redis List(列表  有序可重)"></a><strong>Redis List</strong>(列表  有序可重)</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">lpush key value value value  # 存入一个list value之间用空格分开 往左端加 若key已存在 则添加元素<br>rpush key value value value  # 存入一个list value之间用空格分开 往右端加 若key已存在 则添加元素<br>lrange key statr stop  # 取出key中value 从start开始 stop结束  0 -1 表示取出全部<br>lpop key  # 从该key的list左边 单次出栈<br>rpop key  # 从该key的lits右边 单次出栈<br>lindex key index # 按index获取list中的值 从0开始 <br>llen key  # 获取该key的list的长度<br>lrem key count value  #删除该key的list中count个值为value的元素<br>ltrim key start stop  #截取key的list中 从start 到 stop的元素 ，重新赋值给key<br>rpoplpush source destination  # 获取source最右端元素，移动到destination最左端 <br>lset key index value  # 将该key的list的第index位元素的值设置为value<br>linsert key before|after pivot value #在key对应的list的  pivot元素前(befroe)或后(after)  插入值为value的元素<br><span class="hljs-meta"> </span><br><span class="hljs-meta">#</span><span class="bash"> REDIS LIST是一个字符串了链表，left、right都可以插入添加</span><br><span class="hljs-meta">#</span><span class="bash"> 如果键不存在，创建新的链表</span> <br><span class="hljs-meta">#</span><span class="bash"> 如果键已存在，新增内容 lpush往左端加 rpush往右端加</span><br><span class="hljs-meta">#</span><span class="bash"> 如果值全部移除，对应的键也就消失了</span><br><span class="hljs-meta">#</span><span class="bash"> 链表的操作 头尾效率都极高 ，但是对中间元素操作的效率很惨淡</span><br><br></code></pre></div></td></tr></table></figure><h2 id="Redis-Set-集合-无序不可重"><a href="#Redis-Set-集合-无序不可重" class="headerlink" title="Redis Set(集合  无序不可重)"></a><strong>Redis Set(集合  无序不可重)</strong></h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sadd key member member .. # 添加键为key 值为member 的set  若key已存在 则添加元素  元素不能重复 <br>smembers key # 查看该key的所有元素<br>sismember key member # 产看该key中是否有member元素 有返回 1 无返回 0<br>scard key #获取集合里的元素个数<br>srem key value #删除key对应的集合中值为value的元素<br>srandmember key count #从key集合中随机获取count个元素<br>spop key  #从key集合中随机出栈1个元素<br>smove key1 key2 key1中某个值    # 将key1中的某个值赋给key2<br>sdiff key1 key2   # 已key1为全集 求key2相对key1的差集<br>sinter key1 key2  # 求key1 key2的交集 <br>sunion key1 key2  # 求key1 key2的并集 （自动去重）<br></code></pre></div></td></tr></table></figure><h2 id="Redis-Hash-hash的value是以键值对的形式存储的-key-value-key-value"><a href="#Redis-Hash-hash的value是以键值对的形式存储的-key-value-key-value" class="headerlink" title="Redis Hash(hash的value是以键值对的形式存储的    key  value(key  value)  )"></a><strong>Redis Hash</strong>(hash的value是以键值对的形式存储的    key  value(key  value)  )</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">hset key Vkey Vvalue   #添加键为key 值为Vkey Vvalue 的hash （ hash的格式为 key value(key value) ）<br>hget key Vkey  #获取键为key的hash的 value key 为Vkey的 value<br>hmset key Vkey Vvalue Vkey Vvalue ...  # 添加键为key的hash的 多个value <br>hmget key Vkey Vkey Vkey ...  #获取键为key的hash的多个value的 valueKey为Vkey的 value<br>hgetall key  #获取键为key的hash的所有value （键值对形式）<br>hdel key Vkey  #删除键为key的hash的value的 键为Vkey的 value <br>hlen key  #获取键为key的hash的长度 <br>hexists key Vkey  #判断键为key的hash中是否存在 键为Vkey的 value 存在返回1 不存在返回0<br>hkeys key  #获取键为key的 hash中 所有value的 key<br>hvals key #获取键为key的hash中 所有value 的value<br>hincrby key Vkey num   # 给key对应的value的 value key所对应的 value value 加num（整数）（Vkey对应的value必须数integer）<br>hincrbyfloat key Vkey float   # 给key对应的value的 value key所对应的 value value 加float （小数）<br>hsetnx key Vkey Vvalue   #给key对应的hash数据添加新的value键值对 （Vkey Vvalue） Vkey不能已存在<br></code></pre></div></td></tr></table></figure><h2 id="Redis-Zset-sorted-set-有序不可重集合"><a href="#Redis-Zset-sorted-set-有序不可重集合" class="headerlink" title="Redis Zset (sorted set) 有序不可重集合"></a><strong>Redis Zset (sorted set)</strong> 有序不可重集合</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在<span class="hljs-built_in">set</span>基础上，加一个score值。<span class="hljs-built_in">set</span>是k1 v1 v2 v3， zset是k1 score1 v1 score2 v2</span><br>zadd key score value score value ....  #添加键为key 索引为score 值为value的Zset数据 <br>zrange key min max  #获取min max闭区间内该key对应的所有value (min 和 max 为value对应的下标 从0开始) 0 -1表示全部<br>zrangebyscore key startScore stopScore  #获取 startScore stopScore闭区间内该key对应的所有value<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 在命令最后加上 withscores可以显示每个vvalue对应的score</span></span> <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 在startScore 或是 stopScore前加 &quot;(&quot; 表示开区间  如 startScore (stopScore 等于 [startScore stopScore) ，&quot;(&quot;后的索引对应的value将被排除在结果中</span></span> <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># stopScore为 &quot;+inf&quot; 表示获取 startScore到 end 闭区间内的所有value</span></span><br>zrangebyscore key startScore stopScore limit start step #分页显示[startScope stopScore]内结果集，start为开始索引 step为步进 <br>zrem key value  #删除该key对应的zset集合中的对应value<br>zcard key #获取该集合中的元素个数<br>zcount key startScore stopScore #获取 [startScope stopScore] 闭区间内元素个数<br>zrank key value #获取该value在该集合中的下标 (0开始)<br>zscore key value #获取该value在该集合下对应的score<br>zrevrank key value #获取该value在该集合中的逆下标 <br>zrevrange key min max # #逆序获取min max闭区间内该key对应的所有value(min 和 max 为value对应的下标 从0开始)  0 -1表示全部<br>zrevrangebyscore key stopScore startScore #获取  stopScore startScore 闭区间内的所有value <br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis笔记</title>
    <link href="/2020/05/21/Redis/"/>
    <url>/2020/05/21/Redis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>##<strong>Redis基本数据类型</strong></p><ol><li>字符串：redis没有直接使用C语言传统的字符串表示，而是自己实现的叫做简单动态字符串SDS的抽象类型。C语言的字符串不记录自身的长度信息，而SDS则保存了长度信息，这样将获取字符串长度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串长度时所需的内存重分配次数。</li><li>链表linkedlist：redis链表是一个双向无环链表结构，很多发布订阅、慢查询、监视器功能都是使用到了链表来实现，每个链表的节点由一个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。</li><li>字典hashtable：用于保存键值对的抽象数据结构。redis使用hash表作为底层实现，每个字典带有两个hash表，供平时使用和rehash时使用，hash表使用链地址法来解决键冲突，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对hash表进行扩容或者缩容的时候，为了服务的可用性，rehash的过程不是一次性完成的，而是渐进式的。</li><li>跳跃表skiplist：跳跃表是有序集合的底层实现之一，redis中在实现有序集合键和集群节点的内部结构中都是用到了跳跃表。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表信息（表头、表尾节点、长度等），zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1-32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。</li><li>整数集合intset：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</li><li>压缩列表ziplist：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li></ol><p>基于这些基础的数据结构，redis封装了自己的对象系统，包含字符串对象string、列表对象list、哈希对象hash、集合对象set、有序集合对象zset，每种对象都用到了至少一种基础的数据结构。</p><p>redis通过encoding属性设置对象的编码形式来提升灵活性和效率，基于不同的场景redis会自动做出优化。不同对象的编码如下：</p><ol><li>字符串对象string：int整数、embstr编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：ziplist、linkedlist</li><li>哈希对象hash：ziplist、hashtable</li><li>集合对象set：intset、hashtable</li><li>有序集合对象zset：ziplist、skiplist</li></ol><h2 id="Redis为什么快呢？"><a href="#Redis为什么快呢？" class="headerlink" title="Redis为什么快呢？"></a><strong>Redis为什么快呢？</strong></h2><p>redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几十倍。速度快的原因主要有几点：</p><ol><li>完全基于内存操作</li><li>C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高</li><li>使用单线程，无上下文的切换成本</li><li>基于非阻塞的IO多路复用机制</li></ol><h2 id="那为什么Redis6-0之后又改用多线程呢"><a href="#那为什么Redis6-0之后又改用多线程呢" class="headerlink" title="那为什么Redis6.0之后又改用多线程呢?"></a><strong>那为什么Redis6.0之后又改用多线程呢?</strong></h2><p>redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。</p><p>这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。</p><h2 id="什么是热key吗？热key问题怎么解决？"><a href="#什么是热key吗？热key问题怎么解决？" class="headerlink" title="什么是热key吗？热key问题怎么解决？"></a><strong>什么是热key吗？热key问题怎么解决？</strong></h2><p>所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/1.jpg"></p><p>针对热key的解决方案：</p><ol><li>提前把热key打散到不同的服务器，降低压力</li><li>加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询</li></ol><h2 id="什么是缓存击穿、缓存穿透、缓存雪崩？"><a href="#什么是缓存击穿、缓存穿透、缓存雪崩？" class="headerlink" title="什么是缓存击穿、缓存穿透、缓存雪崩？"></a><strong>什么是缓存击穿、缓存穿透、缓存雪崩？</strong></h2><p>###<strong>缓存击穿</strong></p><p>缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上，这个和热key的问题比较类似，只是说的点在于过期导致请求全部打到DB上而已。</p><p>解决方案：</p><ol><li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了。</li><li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/2.jpg"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h3><p>缓存穿透是指查询不存在缓存中的数据，每次请求都会打到DB，就像缓存不存在一样。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/3.jpg"></p><p>针对这个问题，加一层布隆过滤器。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。</p><p>这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。</p><p>显然，使用布隆过滤器之后会有一个问题就是误判，因为它本身是一个数组，可能会有多个值落到同一个位置，那么理论上来说只要我们的数组长度够长，误判的概率就会越低，这种问题就根据实际情况来就好了。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/4.jpg"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃，称为雪崩。雪崩和击穿、热key的问题不太一样的是，他是指大规模的缓存都过期失效了。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/5.jpg"></p><p>针对雪崩几个解决方案：</p><ol><li>针对不同key设置不同的过期时间，避免同时过期</li><li>限流，如果redis宕机，可以限流，避免同时刻大量请求打崩DB</li><li>二级缓存，同热key的方案。</li></ol><h2 id="Redis的过期策略有哪些？"><a href="#Redis的过期策略有哪些？" class="headerlink" title="Redis的过期策略有哪些？"></a><strong>Redis的过期策略有哪些？</strong></h2><p>redis主要有2种过期删除策略</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><strong>惰性删除</strong></h3><p>惰性删除指的是当我们查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/6.jpg"></p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a><strong>定期删除</strong></h3><p>定期删除指的是redis每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。</p><p>###<strong>那么定期+惰性都没有删除过期的key怎么办？</strong></p><p>假设redis每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存在redis里面无法被删除，这时候就会走到redis的内存淘汰机制。</p><ol><li>volatile-lru：从已设置过期时间的key中，移出最近最少使用的key进行淘汰</li><li>volatile-ttl：从已设置过期时间的key中，移出将要过期的key</li><li>volatile-random：从已设置过期时间的key中随机选择key淘汰</li><li>allkeys-lru：从key中选择最近最少使用的进行淘汰</li><li>allkeys-random：从key中随机选择key进行淘汰</li><li>noeviction：当内存达到阈值的时候，新写入操作报错</li></ol><p>##<strong>持久化方式有哪些？有什么区别？</strong></p><p>redis持久化方案分为RDB和AOF两种。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h3><p>RDB持久化可以手动执行也可以根据配置定期执行，它的作用是将某个时间点上的数据库状态保存到RDB文件中，RDB文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态。由于RDB文件是保存在硬盘上的，所以即使redis崩溃或者退出，只要RDB文件存在，就可以用它来恢复还原数据库的状态。</p><p>可以通过SAVE或者BGSAVE来生成RDB文件。</p><p>SAVE命令会阻塞redis进程，直到RDB文件生成完毕，在进程阻塞期间，redis不能处理任何命令请求，这显然是不合适的。</p><p>BGSAVE则是会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h3><p>AOF和RDB不同，AOF是通过保存redis服务器所执行的写命令来记录数据库状态的。</p><p>AOF通过追加、写入、同步三个步骤来实现持久化机制。</p><ol><li>当AOF持久化处于激活状态，服务器执行完写命令之后，写命令将会被追加append到aof_buf缓冲区的末尾</li><li>在服务器每结束一个事件循环之前，将会调用flushAppendOnlyFile函数决定是否要将aof_buf的内容保存到AOF文件中，可以通过配置appendfsync来决定。</li></ol><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">always</span> <span class="hljs-string">##aof_buf内容写入并同步到AOF文件</span><br><span class="hljs-attr">everysec</span> <span class="hljs-string">##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步</span><br><span class="hljs-attr">no</span> <span class="hljs-string">##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定</span><br></code></pre></div></td></tr></table></figure><p>如果不设置，默认选项将会是everysec，因为always来说虽然最安全（只会丢失一次事件循环的写命令），但是性能较差，而everysec模式只不过会可能丢失1秒钟的数据，而no模式的效率和everysec相仿，但是会丢失上次同步AOF文件之后的所有写命令数据。</p><p>##<strong>怎么实现Redis的高可用？</strong></p><p>要想实现高可用，一台机器肯定是不够的，而redis要保证高可用，有2个可选方案。</p><p>###<strong>主从架构</strong></p><p>主从模式是最简单的实现高可用的方案，核心就是主从同步。主从同步的原理如下：</p><ol><li>slave发送sync命令到master</li><li>master收到sync之后，执行bgsave，生成RDB全量文件</li><li>master把slave的写命令记录到缓存</li><li>bgsave执行完毕之后，发送RDB文件到slave，slave执行</li><li>master发送缓存中的写命令到slave，slave执行</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/7.jpg"></p><p>这里我写的这个命令是sync，但是在redis2.8版本之后已经使用psync来替代sync了，原因是sync命令非常消耗系统资源，而psync的效率更高。</p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a><strong>哨兵</strong></h3><p>基于主从方案的缺点还是很明显的，假设master宕机，那么就不能写入数据，那么slave也就失去了作用，整个架构就不可用了，除非你手动切换，主要原因就是因为没有自动故障转移机制。而哨兵(sentinel)的功能比单纯的主从架构全面的多了，它具备自动故障转移、集群监控、消息通知等功能。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/8.jpg"></p><p>哨兵可以同时监视多个主从服务器，并且在被监视的master下线时，自动将某个slave提升为master，然后由新的master继续接收命令。整个过程如下：</p><ol><li>初始化sentinel，将普通的redis代码替换成sentinel专用代码</li><li>初始化masters字典和服务器信息，服务器信息主要保存ip:port，并记录实例的地址和ID</li><li>创建和master的两个连接，命令连接和订阅连接，并且订阅sentinel:hello频道</li><li>每隔10秒向master发送info命令，获取master和它下面所有slave的当前信息</li><li>当发现master有新的slave之后，sentinel和新的slave同样建立两个连接，同时每个10秒发送info命令，更新master信息</li><li>sentinel每隔1秒向所有服务器发送ping命令，如果某台服务器在配置的响应时间内连续返回无效回复，将会被标记为下线状态</li><li>选举出领头sentinel，领头sentinel需要半数以上的sentinel同意</li><li>领头sentinel从已下线的的master所有slave中挑选一个，将其转换为master</li><li>让所有的slave改为从新的master复制数据</li><li>将原来的master设置为新的master的从服务器，当原来master重新回复连接时，就变成了新master的从服务器</li></ol><p>sentinel会每隔1秒向所有实例（包括主从服务器和其他sentinel）发送ping命令，并且根据回复判断是否已经下线，这种方式叫做主观下线。当判断为主观下线时，就会向其他监视的sentinel询问，如果超过半数的投票认为已经是下线状态，则会标记为客观下线状态，同时触发故障转移。</p><h2 id="redis集群的原理"><a href="#redis集群的原理" class="headerlink" title="redis集群的原理"></a><strong>redis集群的原理</strong></h2><p>如果说依靠哨兵可以实现redis的高可用，如果还想在支持高并发同时容纳海量的数据，那就需要redis集群。redis集群是redis提供的分布式数据存储方案，集群通过数据分片sharding来进行数据的共享，同时提供复制和故障转移的功能。</p><p>###<strong>节点</strong></p><p>一个redis集群由多个节点node组成，而多个node之间通过cluster meet命令来进行连接，节点的握手过程：</p><ol><li>节点A收到客户端的cluster meet命令</li><li>A根据收到的IP地址和端口号，向B发送一条meet消息</li><li>节点B收到meet消息返回pong</li><li>A知道B收到了meet消息，返回一条ping消息，握手成功</li><li>最后，节点A将会通过gossip协议把节点B的信息传播给集群中的其他节点，其他节点也将和B进行握手</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/9.jpg"></p><h3 id="槽slot"><a href="#槽slot" class="headerlink" title="槽slot"></a><strong>槽slot</strong></h3><p>redis通过集群分片的形式来保存数据，整个集群数据库被分为16384个slot，集群中的每个节点可以处理0-16384个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有一个slot没有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。</p><p>slot是一个位数组，数组的长度是16384/8=2048，而数组的每一位用1表示被节点处理，0表示不处理，如图所示的话表示A节点处理0-7的slot。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/10.jpg"></p><p>当客户端向节点发送命令，如果刚好找到slot属于当前节点，那么节点就执行命令，反之，则会返回一个MOVED命令到客户端指引客户端转向正确的节点。（MOVED过程是自动的）</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/11.jpg"></p><p>如果增加或者移出节点，对于slot的重新分配也是非常方便的，redis提供了工具帮助实现slot的迁移，整个过程是完全在线的，不需要停止服务。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a><strong>故障转移</strong></h3><p>如果节点A向节点B发送ping消息，节点B没有在规定的时间内响应pong，那么节点A会标记节点B为pfail疑似下线状态，同时把B的状态通过消息的形式发送给其他节点，如果超过半数以上的节点都标记B为pfail状态，B就会被标记为fail下线状态，此时将会发生故障转移，优先从复制数据较多的从节点选择一个成为主节点，并且接管下线节点的slot，整个过程和哨兵非常类似，都是基于Raft协议做选举。</p><p>##<strong>Redis事务机制</strong></p><p>redis通过MULTI、EXEC、WATCH等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，并且在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。事务的执行过程如下：</p><ol><li>服务端收到客户端请求，事务以MULTI开始</li><li>如果客户端正处于事务状态，则会把事务放入队列同时返回给客户端QUEUED，反之则直接执行这个命令</li><li>当收到客户端EXEC命令时，WATCH命令监视整个事务中的key是否有被修改，如果有则返回空回复到客户端表示失败，否则redis会遍历整个事务队列，执行队列中保存的所有命令，最后返回结果给客户端</li></ol><p>WATCH的机制本身是一个CAS的机制，被监视的key会被保存到一个链表中，如果某个key被修改，那么REDIS_DIRTY_CAS标志将会被打开，这时服务器会拒绝执行事务。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO 模型</title>
    <link href="/2020/05/12/IO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/05/12/IO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>I/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。</p><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="何为-I-O"><a href="#何为-I-O" class="headerlink" title="何为 I/O?"></a>何为 I/O?</h3><p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p><p><strong>我们先从计算机结构的角度来解读一下 I/O。</strong></p><p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281328176.jpeg" alt="冯诺依曼体系结构"></p><p>输入设备（比如键盘）和输出设备（比如鼠标）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p><p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p><p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p><p><strong>我们再先从应用程序的角度来解读一下 I/O。</strong></p><p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p><p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p><p>并且，用户空间的程序不能直接访问内核空间。</p><p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p><p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p><p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和相应）</strong>。</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol><h3 id="有哪些常见的-IO-模型"><a href="#有哪些常见的-IO-模型" class="headerlink" title="有哪些常见的 IO 模型?"></a>有哪些常见的 IO 模型?</h3><p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p><p>这也是我们经常提到的 5 种 IO 模型。</p><h2 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281330319.png" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>跟着我的思路往下看看，相信你会得到答案！</p><p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281331302.png"></p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281331701.png"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持</p><ul><li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281332591.png"></p><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281332503.png"></p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281328071.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入拆解 Tomcat &amp; Jetty》</li><li>如何完成一次 IO：<a href="https://llc687.top/post/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E6%AC%A1-io/">https://llc687.top/post/如何完成一次-io/</a></li><li>程序员应该这样理解 IO：<a href="https://www.jianshu.com/p/fa7bdc4f3de7">https://www.jianshu.com/p/fa7bdc4f3de7</a></li><li>10 分钟看懂， Java NIO 底层原理：<a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html">https://www.cnblogs.com/crazymakercircle/p/10225159.html</a></li><li>IO 模型知多少 | 理论篇：<a href="https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html">https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html</a></li><li>《UNIX 网络编程 卷 1；套接字联网 API 》6.2 节 IO 模型</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过滤器和拦截器</title>
    <link href="/2020/04/29/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2020/04/29/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>我们在项目中同时配置 <code>拦截器</code> 和 <code>过滤器</code>。</p><h4 id="1、过滤器-Filter"><a href="#1、过滤器-Filter" class="headerlink" title="1、过滤器 (Filter)"></a>1、过滤器 (Filter)</h4><p>过滤器的配置比较简单，直接实现<code>Filter</code> 接口即可，也可以通过<code>@WebFilter</code>注解实现对特定<code>URL</code>拦截，看到<code>Filter</code> 接口中定义了三个方法。</p><ul><li><code>init()</code> ：该方法在容器启动初始化过滤器时被调用，它在 <code>Filter</code> 的整个生命周期只会被调用一次。<strong>注意</strong>：这个方法必须执行成功，否则过滤器会不起作用。</li><li><code>doFilter()</code> ：容器中的每一次请求都会调用该方法， <code>FilterChain</code> 用来调用下一个过滤器 <code>Filter</code>。</li><li><code>destroy()</code>： 当容器销毁 过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器 <code>Filter</code> 的整个生命周期也只会被调用一次</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Filter 前置&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Filter 处理中&quot;</span>);<br>        filterChain.doFilter(servletRequest, servletResponse);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Filter 后置&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2、拦截器-Interceptor"><a href="#2、拦截器-Interceptor" class="headerlink" title="2、拦截器 (Interceptor)"></a>2、拦截器 (Interceptor)</h4><p>拦截器它是链式调用，一个应用中可以同时存在多个拦截器<code>Interceptor</code>， 一个请求也可以触发多个拦截器 ，而每个拦截器的调用会依据它的声明顺序依次执行。</p><p>首先编写一个简单的拦截器处理类，请求的拦截是通过<code>HandlerInterceptor</code> 来实现，看到<code>HandlerInterceptor</code> 接口中也定义了三个方法。</p><ul><li><code>preHandle()</code> ：这个方法将在请求处理之前进行调用。<strong>注意</strong>：如果该方法的返回值为<code>false</code> ，将视为当前请求结束，不仅自身的拦截器会失效，还会导致其他的拦截器也不再执行。</li><li><code>postHandle()</code>：只有在 <code>preHandle()</code> 方法返回值为<code>true</code> 时才会执行。会在Controller 中的方法调用之后，DispatcherServlet 返回渲染视图之前被调用。 <strong>有意思的是</strong>：<code>postHandle()</code> 方法被调用的顺序跟 <code>preHandle()</code> 是相反的，先声明的拦截器 <code>preHandle()</code> 方法先执行，而<code>postHandle()</code>方法反而会后执行。</li><li><code>afterCompletion()</code>：只有在 <code>preHandle()</code> 方法返回值为<code>true</code> 时才会执行。在整个请求结束之后， DispatcherServlet 渲染了对应的视图之后执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Interceptor 前置&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Interceptor 处理中&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Interceptor 后置&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将自定义好的拦截器处理类进行注册，并通过<code>addPathPatterns</code>、<code>excludePathPatterns</code>等属性设置需要拦截或需要排除的 <code>URL</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> MyInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> MyInterceptor1()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="我们不一样"><a href="#我们不一样" class="headerlink" title="我们不一样"></a>我们不一样</h3><p>过滤器 和 拦截器 均体现了<code>AOP</code>的编程思想，都可以实现诸如日志记录、登录鉴权等功能，但二者的不同点也是比较多的，接下来一一说明。</p><h4 id="1、实现原理不同"><a href="#1、实现原理不同" class="headerlink" title="1、实现原理不同"></a>1、实现原理不同</h4><p>过滤器和拦截器 底层实现方式大不相同，<code>过滤器</code> 是基于函数回调的，<code>拦截器</code> 则是基于Java的反射机制（动态代理）实现的。</p><p>这里重点说下过滤器！</p><p>在我们自定义的过滤器中都会实现一个 <code>doFilter()</code>方法，这个方法有一个<code>FilterChain</code> 参数，而实际上它是一个回调接口。<code>ApplicationFilterChain</code>是它的实现类， 这个实现类内部也有一个 <code>doFilter()</code> 方法就是回调方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FilterChain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest var1, ServletResponse var2)</span> <span class="hljs-keyword">throws</span> IOException, ServletException</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/202110220941441.png" alt="在这里插入图片描述"><br><code>ApplicationFilterChain</code>里面能拿到我们自定义的<code>xxxFilter</code>类，在其内部回调方法<code>doFilter()</code>里调用各个自定义<code>xxxFilter</code>过滤器，并执行 <code>doFilter()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterChain</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> </span>&#123;<br>            ...<span class="hljs-comment">//省略</span><br>            internalDoFilter(request,response);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">internalDoFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (pos &lt; n) &#123;<br>            <span class="hljs-comment">//获取第pos个filter    </span><br>            ApplicationFilterConfig filterConfig = filters[pos++];        <br>            Filter filter = filterConfig.getFilter();<br>            ...<br>            filter.doFilter(request, response, <span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br> <br>&#125;<br></code></pre></div></td></tr></table></figure><p>而每个<code>xxxFilter</code> 会先执行自身的 <code>doFilter()</code> 过滤逻辑，最后在执行结束前会执行<code>filterChain.doFilter(servletRequest, servletResponse)</code>，也就是回调<code>ApplicationFilterChain</code>的<code>doFilter()</code> 方法，以此循环执行实现函数回调。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br><br>    filterChain.doFilter(servletRequest, servletResponse);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2、使用范围不同"><a href="#2、使用范围不同" class="headerlink" title="2、使用范围不同"></a>2、使用范围不同</h4><p>我们看到过滤器 实现的是 <code>javax.servlet.Filter</code> 接口，而这个接口是在<code>Servlet</code>规范中定义的，也就是说过滤器<code>Filter</code> 的使用要依赖于<code>Tomcat</code>等容器，导致它只能在<code>web</code>程序中使用。<br><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/202110220942135.png" alt="在这里插入图片描述"><br>而拦截器(<code>Interceptor</code>) 它是一个<code>Spring</code>组件，并由<code>Spring</code>容器管理，并不依赖<code>Tomcat</code>等容器，是可以单独使用的。不仅能应用在<code>web</code>程序中，也可以用于<code>Application</code>、<code>Swing</code>等程序中。<br><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/202110220942414.png" alt="在这里插入图片描述"></p><h4 id="3、触发时机不同"><a href="#3、触发时机不同" class="headerlink" title="3、触发时机不同"></a>3、触发时机不同</h4><p><code>过滤器</code> 和 <code>拦截器</code>的触发时机也不同，我们看下边这张图。<br><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/202110220942973.png" alt="在这里插入图片描述"></p><p>过滤器<code>Filter</code>是在请求进入容器后，但在进入<code>servlet</code>之前进行预处理，请求结束是在<code>servlet</code>处理完以后。</p><p>拦截器 <code>Interceptor</code> 是在请求进入<code>servlet</code>后，在进入<code>Controller</code>之前进行预处理的，<code>Controller</code> 中渲染了对应的视图之后请求结束。</p><h4 id="4、拦截的请求范围不同"><a href="#4、拦截的请求范围不同" class="headerlink" title="4、拦截的请求范围不同"></a>4、拦截的请求范围不同</h4><p>在上边我们已经同时配置了过滤器和拦截器，再建一个<code>Controller</code>接收请求测试一下。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/test1&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test1</span><span class="hljs-params">(String a)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是controller&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>项目启动过程中发现，过滤器的<code>init()</code>方法，随着容器的启动进行了初始化。<br><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/202110220941027.png" alt="在这里插入图片描述"><br>此时浏览器发送请求，F12 看到居然有两个请求，一个是我们自定义的 <code>Controller</code> 请求，另一个是访问静态图标资源的请求。<br><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/202110220941087.png" alt="在这里插入图片描述"><br>看到控制台的打印日志如下：</p><p>执行顺序 ：<code>Filter 处理中</code> -&gt; <code>Interceptor 前置</code> -&gt; <code>我是controller</code> -&gt; <code>Interceptor 处理中</code> -&gt; <code>Interceptor 处理后</code></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Filter 处理中<br>Interceptor 前置<br>Interceptor 处理中<br>Interceptor 后置<br>Filter 处理中<br></code></pre></div></td></tr></table></figure><p>过滤器<code>Filter</code>执行了两次，拦截器<code>Interceptor</code>只执行了一次。这是因为过滤器几乎可以对所有进入容器的请求起作用，而拦截器只会对<code>Controller</code>中请求或访问<code>static</code>目录下的资源请求起作用。</p><h4 id="5、注入Bean情况不同"><a href="#5、注入Bean情况不同" class="headerlink" title="5、注入Bean情况不同"></a>5、注入Bean情况不同</h4><p>在实际的业务场景中，应用到过滤器或拦截器，为处理业务逻辑难免会引入一些<code>service</code>服务。</p><p>下边我们分别在过滤器和拦截器中都注入<code>service</code>，看看有什么不同？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TestService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是方法A&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>过滤器中注入<code>service</code>，发起请求测试一下 ，日志正常打印出<code>“我是方法A”</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TestService testService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Filter 处理中&quot;</span>);<br>        testService.a();<br>        filterChain.doFilter(servletRequest, servletResponse);<br>    &#125;<br>Filter 处理中<br>我是方法A<br>Interceptor 前置<br>我是controller<br>Interceptor 处理中<br>Interceptor 后置<br></code></pre></div></td></tr></table></figure><p>在拦截器中注入<code>service</code>，发起请求测试一下 ，竟然TM的报错了，<code>debug</code>跟一下发现注入的<code>service</code>怎么是<code>Null</code>啊？<br><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/202110220942479.png" alt="在这里插入图片描述"><br>这是因为加载顺序导致的问题，<code>拦截器</code>加载的时间点在<code>springcontext</code>之前，而<code>Bean</code>又是由<code>spring</code>进行管理。</p><blockquote><p>拦截器：老子今天要进洞房；<br>Spring：兄弟别闹，你媳妇我还没生出来呢！</p></blockquote><p>解决方案也很简单，我们在注册拦截器之前，先将<code>Interceptor</code> 手动进行注入。<strong>注意</strong>：在<code>registry.addInterceptor()</code>注册的是<code>getMyInterceptor()</code> 实例。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MyInterceptor <span class="hljs-title">getMyInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;注入了MyInterceptor&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyInterceptor();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br><br>        registry.addInterceptor(getMyInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="6、控制执行顺序不同"><a href="#6、控制执行顺序不同" class="headerlink" title="6、控制执行顺序不同"></a>6、控制执行顺序不同</h4><p>实际开发过程中，会出现多个过滤器或拦截器同时存在的情况，不过，有时我们希望某个过滤器或拦截器能优先执行，就涉及到它们的执行顺序。</p><p>过滤器用<code>@Order</code>注解控制执行顺序，通过<code>@Order</code>控制过滤器的级别，值越小级别越高越先执行。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br></code></pre></div></td></tr></table></figure><p>拦截器默认的执行顺序，就是它的注册顺序，也可以通过<code>Order</code>手动设置控制，值越小越先执行。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>       registry.addInterceptor(<span class="hljs-keyword">new</span> MyInterceptor2()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">2</span>);<br>       registry.addInterceptor(<span class="hljs-keyword">new</span> MyInterceptor1()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">1</span>);<br>       registry.addInterceptor(<span class="hljs-keyword">new</span> MyInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">3</span>);<br>   &#125;<br></code></pre></div></td></tr></table></figure><p>看到输出结果发现，先声明的拦截器 <code>preHandle()</code> 方法先执行，而<code>postHandle()</code>方法反而会后执行。</p><p><code>postHandle()</code> 方法被调用的顺序跟 <code>preHandle()</code> 居然是相反的！如果实际开发中严格要求执行顺序，那就需要特别注意这一点。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Interceptor1 前置<br>Interceptor2 前置<br>Interceptor 前置<br>我是controller<br>Interceptor 处理中<br>Interceptor2 处理中<br>Interceptor1 处理中<br>Interceptor 后置<br>Interceptor2 处理后<br>Interceptor1 处理后<br></code></pre></div></td></tr></table></figure><p><strong>那为什么会这样呢？</strong> 得到答案就只能看源码了，我们要知道<code>controller</code> 中所有的请求都要经过核心组件<code>DispatcherServlet</code>路由，都会执行它的 <code>doDispatch()</code> 方法，而拦截器<code>postHandle()</code>、<code>preHandle()</code>方法便是在其中调用的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <br>        <span class="hljs-keyword">try</span> &#123;<br>         ...........<br>            <span class="hljs-keyword">try</span> &#123;<br>           <br>                <span class="hljs-comment">// 获取可以执行当前Handler的适配器</span><br>                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());<br><br>                <span class="hljs-comment">// Process last-modified header, if supported by the handler.</span><br>                String method = request.getMethod();<br>                <span class="hljs-keyword">boolean</span> isGet = <span class="hljs-string">&quot;GET&quot;</span>.equals(method);<br>                <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">&quot;HEAD&quot;</span>.equals(method)) &#123;<br>                    <span class="hljs-keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());<br>                    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                        logger.debug(<span class="hljs-string">&quot;Last-Modified value for [&quot;</span> + getRequestUri(request) + <span class="hljs-string">&quot;] is: &quot;</span> + lastModified);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 注意： 执行Interceptor中PreHandle()方法</span><br>                <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 注意：执行Handle【包括我们的业务逻辑，当抛出异常时会被Try、catch到】</span><br>                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br><br>                <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                applyDefaultViewName(processedRequest, mv);<br><br>                <span class="hljs-comment">// 注意：执行Interceptor中PostHandle 方法【抛出异常时无法执行】</span><br>                mappedHandler.applyPostHandle(processedRequest, response, mv);<br>            &#125;<br>        &#125;<br>        ...........<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>看看两个方法<code>applyPreHandle(）</code>、<code>applyPostHandle(）</code>具体是如何被调用的，就明白为什么<code>postHandle()</code>、<code>preHandle()</code> 执行顺序是相反的了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">applyPreHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        HandlerInterceptor[] interceptors = <span class="hljs-keyword">this</span>.getInterceptors();<br>        <span class="hljs-keyword">if</span>(!ObjectUtils.isEmpty(interceptors)) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; interceptors.length; <span class="hljs-keyword">this</span>.interceptorIndex = i++) &#123;<br>                HandlerInterceptor interceptor = interceptors[i];<br>                <span class="hljs-keyword">if</span>(!interceptor.preHandle(request, response, <span class="hljs-keyword">this</span>.handler)) &#123;<br>                    <span class="hljs-keyword">this</span>.triggerAfterCompletion(request, response, (Exception)<span class="hljs-keyword">null</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">applyPostHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, <span class="hljs-meta">@Nullable</span> ModelAndView mv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        HandlerInterceptor[] interceptors = <span class="hljs-keyword">this</span>.getInterceptors();<br>        <span class="hljs-keyword">if</span>(!ObjectUtils.isEmpty(interceptors)) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = interceptors.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                HandlerInterceptor interceptor = interceptors[i];<br>                interceptor.postHandle(request, response, <span class="hljs-keyword">this</span>.handler, mv);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>发现两个方法中在调用拦截器数组 <code>HandlerInterceptor[]</code> 时，循环的顺序竟然是相反的。。。，导致<code>postHandle()</code>、<code>preHandle()</code> 方法执行的顺序相反。<br><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/202110220941032.png" alt="在这里插入图片描述"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我相信大部分人都能熟练使用滤器和拦截器，但两者的差别还是需要多了解下，不然开发中使用不当，时不时就会出现奇奇怪怪的问题，以上内容比较简单，新手学习老鸟复习，有遗漏的地方还望大家积极补充，如有理解错误之处，还望不吝赐教。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Filter</tag>
      
      <tag>Interceptor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化(1)-SQL基础</title>
    <link href="/2020/03/22/SQL%E4%BC%98%E5%8C%96(1)-SQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/03/22/SQL%E4%BC%98%E5%8C%96(1)-SQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h1><p>实际上数据库范式不止3种，但大家熟知的就三种。</p><p>第一范式</p><p>所有列应该不可再分</p><p>比如，往contact列存储”18257500000,杭州,<a href="mailto:&#x35;&#x32;&#51;&#x38;&#51;&#57;&#x30;&#48;&#48;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;">&#x35;&#x32;&#51;&#x38;&#51;&#57;&#x30;&#48;&#48;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;</a>“是比较糟糕的做法，因为此时该列包含了phone、address、email三个维度的数据，应该拆成phone、address、email三个字段分别存储，这样对更新和查询都有好处。</p><p>第二范式</p><p>必须存在业务主键，且非主键字段应该依赖于全部业务主键（之所以写“全部”，因为可能存在复合主键）</p><p>说人话就是：每张表最好都设定主键。虽然某些列可能具备主键的特质（比如user表的id_card），但个人认为主键最好与业务无关，比如自增id。</p><table><thead><tr><th>id</th><th>xxx</th><th>yyy</th><th>zzz</th><th>…</th></tr></thead><tbody><tr><td>1</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>第三范式：</p><p>非主键列不能依赖除主键列以外的其他列</p><p>听起来很抽象，举个例子就明白了：</p><table><thead><tr><th><strong>t_student</strong></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>stu_name</td><td>stu_age</td><td>teacher_name</td><td>teacher_age</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>李四</td><td>40</td></tr></tbody></table><p>上面这张t_student表就违反了第三范式：非主键列teacher_name、teacher_age并不依赖id（学生的）。这种做法被称为“冗余”，它的弊端是<strong>有可能导致数据不一致。</strong>比如t_teacher表数据更新了，李四的age变成41，而代码里却没有及时维护t_student表的数据，就会导致从t_student表查出来的数据中，李四还是40岁。</p><p>改写成符合第三范式的设计：</p><table><thead><tr><th><strong>t_student</strong></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>stu_name</td><td>stu_age</td><td><strong>teacher_id</strong></td></tr><tr><td>1</td><td>张三</td><td>18</td><td><strong>10086</strong></td></tr></tbody></table><table><thead><tr><th><strong>t_teacher</strong></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>teacher_name</td><td>teacher_age</td><td>address</td></tr><tr><td>10086</td><td>李四</td><td>40</td><td>hangzhou</td></tr></tbody></table><p>总结一下三范式：</p><ul><li><p>每一列字段应该不可再分，职责单一</p></li><li><p>要有主键，最好是与业务无关的自增id</p></li><li><p>不要有冗余字段，为了避免数据更新不一致，应该拆成两张表，用（逻辑）外键关联</p></li></ul><p>一般来说，前两个范式大家都会遵守，但第三范式有时会被打破（就像上面的t_student一样）。<strong>因为实际工作中，越遵从范式化设计，表的拆分越细致，查询时需要关联的表就越多。</strong></p><p>比如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">SELECT <span class="hljs-built_in">t1</span>.aaa, <span class="hljs-built_in">t2</span>.<span class="hljs-keyword">bbb, </span><span class="hljs-built_in">t3</span>.ccc<br>FROM <span class="hljs-built_in">t1</span> <br>LEFT <span class="hljs-keyword">JOIN </span><span class="hljs-built_in">t2</span> ON xxxx<br>LEFT <span class="hljs-keyword">JOIN </span><span class="hljs-built_in">t3</span> ON xxxx;<br></code></pre></div></td></tr></table></figure><p>此时我们可以<strong>适当反范式化设计</strong>（反第三范式），目的是减少查询时需要关联的表的数量从而提升查询性能：</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">SELECT <span class="hljs-built_in">t1</span>.aaa, <span class="hljs-built_in">t1</span>.<span class="hljs-keyword">bbb, </span><span class="hljs-built_in">t1</span>.ccc<br>FROM <span class="hljs-built_in">t1</span>;<br></code></pre></div></td></tr></table></figure><p>所以才会出现上面t_student表里冗余teacher_name和teacher_age的设计。</p><p>但不论范式化设计还是反范式化设计，都不能过度：</p><ul><li>遵守第三范式，有时会让查询变得非常麻烦，要么JOIN关联，要么内存中匹配，甚至干脆无法满足需求</li><li>不遵守第三范式，则需要主动维护冗余数据，避免造成数据更新不一致</li></ul><p>但有些场景下，冗余数据百利而无一害。举个例子，比如订单表中的商品价格。商品价格会随着时间发生改变（促销等），而订单表只需记录当前下单的价格即可，不需要更新，否则你双11花了2999买的手机，过几天查询订单发现价格变成了3200，会怀疑自己是不是多付了。</p><h1 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h1><p>分类的方法很多，但这里只按自己的理解及使用频率分为4大类：</p><ul><li><p>整数类型</p></li><li><p>字符类型</p></li><li><p>小数类型</p></li><li><p>时间类型</p></li></ul><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>数值类型唯一需要注意的3点：</p><ul><li><p>如果业务允许，尽量设置unsigned</p></li><li><p>int(11)里的11和占用字节大小无关</p></li><li><p>注意各个类型的选取标准</p></li></ul><p>所谓unsigned，即无符号。比如tinyint，正常取值范围是-128<del>127。但实际业务中很少需要用到负数，比如年龄、身高等都是整数，最小为0。此时使用unsigned可以让正向范围翻倍：0</del>255。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589609778497-d64e7ece-7979-4baa-83d7-15555882f163-20210923213840093.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605039821-daa06c46-0aad-482a-a2e3-5935f95ca480-20210923213848199.png" alt="img"></p><p>如果业务需要，可以为当前字段设置默认值，比如文章状态status默认0，表示“待审核”。</p><p>另外，关于int(11)里的11，很多人都不是很清楚。其实括号里的数字和占用字节大小无关，哪怕你写成int(1)也不代表它比int(11)省空间，这只是列宽表示，比如位数不够就前面补零啥的，但对实际数值大小没有影响。<strong>总之，对于数值类型来说，每种类型占用空间大小是固定的。</strong></p><p>来看一下各种数值类型的占用空间：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占据空间</strong></th><th><strong>范围（有符号）</strong></th><th><strong>范围（无符号）</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>tinyint</td><td>1 个字节</td><td>-2^7 ~ 2^7-1</td><td>0 - 255</td><td>小整数值</td></tr><tr><td>smallint</td><td>2 个字节</td><td>-2^15 ~ 2^15-1</td><td>0 - 65535</td><td>大整数值</td></tr><tr><td>mediumint</td><td>3 个字节</td><td>-2^23 ~ 2^23-1</td><td>0 - 16777215</td><td>大整数值</td></tr><tr><td>int</td><td>4 个字节</td><td>-2^31 ~ 2^31-1</td><td>0 - 4294967295</td><td>大整数值</td></tr><tr><td>bigint</td><td>8 个字节</td><td>-2^63 ~ 2^63-1</td><td>0 - 18446744073709551615</td><td>极大整数值</td></tr></tbody></table><p>选择数值类型时，最重要的规则是“够用就好”。比如对于“性别”或“年龄”，用tinyint足够了，毕竟还没听过有人活过250岁的。这里并不是为了省磁盘空间而去扣这些细节，毕竟磁盘是最不值钱的，主要关系到索引。后面会解释，总之记住“够用就好”。</p><p>通常来说：</p><ul><li><p>主键id用bigint</p></li><li><p>age、height等普通数据用int</p></li><li><p>deleted、status、type用tinyint</p></li></ul><p>之前听说有些公司对于只有0、1两种状态的字段使用bit，也…行吧，按公司的约定来吧。隐约听过有坑，但我自己试了下没发现。大家没啥事可以自己去试试各种类型，做做实验：</p><p>此处为语雀视频卡片，点击链接查看：<a href="https://www.yuque.com/books/share/2b434c74-ed3a-470e-b148-b4c94ba14535/ghl3hi#JEUdS">Kapture 2020-12-29 at 23.26.36.mp4</a></p><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>平时大家会经常看到char(8)或者varchar(255)这样的形式对吧？经过上面的学习，你可能会觉得：哦，这也是显示作用，和实际大小无关。</p><p><strong>那你就错了。</strong></p><p><strong>字符类型的数字和实际大小有关，</strong>准确地说这里的数值和实际存储大小的<strong>上限</strong>有关。比如char(3)，表示会<strong>固定</strong>占用3个字符空间，即使存储的值不够3个字符，照样会占着那块空间，但不能超过3个字符：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605677558-0fa1e912-abbd-4568-a151-ed0d93b2130b-20210923213856943.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605713308-618696b9-23f5-45a4-8cdd-afa9f91a9803-20210923213903139.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605740485-d2756bfc-bbbd-4c72-88ef-c29657f80faa-20210923213907419.png" alt="img"></p><p>实际开发中，一不小心就会出现上面的报错信息，此时你应该要意识到这是字符超过规定长度了。</p><p>至于varchar(255)，表示最多存储255个字符。看起来好像和char(255)没区别？实际上，char和varchar分别代表着两种类型：定长与变长。</p><p>比如int、bigint这些都是定长，而varchar是变长。</p><p>varchar作为“变长字符”，它的占用空间是可伸缩的。 varchar(255)表示最多能存储255个字符，但最终占用空间以实际存储的值为准，可能实际占用M个字符（M&lt;=255），而char(255)则一定会占用255个字符的控件。</p><p>看起来好像varchar是百利而无一害，完爆char对吧？</p><p>char VS varchar</p><ul><li><p>char长度固定，不需要考虑边界问题，读写效率高于varchar，适合存储长度固定、频繁读写的数据</p></li><li><p>varchar长度不固定，但可以通过varchar(10)的方式指定上限，适合存储长度波动、更新不频繁的数据</p></li><li><p>char的存储长度不够灵活，而varchar则需要浪费1~2个字节来存储当前值的实际长度，且更新会导致重新计算</p></li></ul><p>关于第一点，你可以简单理解为：</p><p>char是定长，说了一个字段用3个格子存储就一定是3个格子，所以当你要找第3个数据时，只需要往右数6个格子，那么7~9就存着你要找的数据。而varchar(3)的“3”只代表上限，实际不一定占用3个格子，所以不能直接计算得到位置。</p><p>没有最完美的类型，只有最合适的类型。比如，当你需要存储手机号码或者身份证号时，用char(11)、char(18)显然更合适。但存储“个人介绍”时，用varchar更好，因为个人介绍的长度是可变的。</p><h2 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h2><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占据空间</strong></th><th><strong>是够精确</strong></th></tr></thead><tbody><tr><td>float</td><td>4个字节</td><td>非精确</td></tr><tr><td>double</td><td>8 个字节</td><td>非精确</td></tr><tr><td>decimal</td><td>每4个字节存9个数字，小数点占一个字节</td><td>精确</td></tr></tbody></table><p>对于decimal的大小，比如123456789.987654321，用decimal(18,9)存储，占9个字节，前后各4个字节，小数点一个字节。decimal的效率不如float和double。</p><p>当然，很多电商公司其实都是直接存最小单位“分”，也就没有精度问题了。</p><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占据空间</strong></th><th><strong>取值范围</strong></th></tr></thead><tbody><tr><td>date</td><td>3个字节</td><td>1000-01-01 ~ 9999-12-31</td></tr><tr><td>time</td><td>3~6个字节</td><td>-838:59:59 ~ 838:59:59</td></tr><tr><td>datetime</td><td>5~8个字节</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td></tr><tr><td>timestamp</td><td>4~7个字节</td><td>1970-01-01 00:00:01 ~ 2038-01-19 03:14:07</td></tr></tbody></table><p>DATETIME 和 TIMESTAMP的区别：</p><ul><li>时间范围不同，DATETIME更大，内存稍微大一点</li><li>TIMESTAMP的时间会根据时区变化。比如 SET time_zone=’+10:00’，那么查询后会自动增加10小时</li></ul><p>具体跟着公司走就好了，比如我们公司甚至没用时间类型，直接用Long存秒数。</p><h1 id="类型选择小结"><a href="#类型选择小结" class="headerlink" title="类型选择小结"></a>类型选择小结</h1><ul><li><p>更小的通常更好</p></li><li><p>简单合适就好</p></li><li><p>尽量避免null（设置NOT NULL，除非业务要求可能NULL）</p></li><li><p>如果确定不会出现负数，可以使用unsigned</p></li></ul><p>NOT NULL：一定要传递值，且不能为NULL，否则报错</p><p>DEFAULT ‘xx’：传不传都可以，不传就使用默认值xx，<strong>可以传NULL</strong></p><p>NOT NULL DEFAULT ‘xx’：传不传都可以，不传就使用默认值xx，<strong>不能传NULL</strong></p><p>可以做个实验：</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`test`</span> (<br>  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-symbol">`age_not_null_default`</span> int(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> DEFAULT <span class="hljs-string">&#x27;0&#x27;</span>,<br>  <span class="hljs-symbol">`age_not_null`</span> int(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`age_default`</span> int(<span class="hljs-number">10</span>) DEFAULT <span class="hljs-string">&#x27;0&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;<br></code></pre></div></td></tr></table></figure><p>测试：</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"># age_not_null_default 要么不传，要么传非NULL值，这里选择不传，则插入默认值0<br># age_not_null 一定要传值，且不能为NULL<br># age_default 传不传都可以，可以传NULL<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`test`</span> (<span class="hljs-symbol">`age_not_null`</span>, <span class="hljs-symbol">`age_default`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>);<br></code></pre></div></td></tr></table></figure><h1 id="语句书写顺序"><a href="#语句书写顺序" class="headerlink" title="语句书写顺序"></a>语句书写顺序</h1><p>SELECT … FROM table WHERE … GROUP BY … HAVING … ORDER BY … LIMIT …</p><p>除了SELECT，后面几个顺序可以记忆为：温哥华OL，意思是温哥华白领。</p><h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><h2 id="隐式连接"><a href="#隐式连接" class="headerlink" title="隐式连接"></a>隐式连接</h2><p>什么是隐式连接？不用写JOIN关键字的连接。</p><p>格式是：</p><p>FROM t_a, t_b WHERE或ON 等值连接条件</p><p>隐式连接属于内连接，效果等同于：</p><p>FROM t_a [INNER] JOIN t_b ON 连接条件</p><h2 id="显式连接"><a href="#显式连接" class="headerlink" title="显式连接"></a>显式连接</h2><p><strong>内连接</strong></p><p>格式：</p><p>FROM t_a [INNER] JOIN t_b ON 连接条件</p><p>INNER写不写都可以，查询效果和隐式连接一样，连接条件写在ON后面。</p><p>如果两个表做等值判断的字段相同，比如 ON t1.id = t2.id 可以改写为 USING(id)，但没什么卵用，我要不是这次复习，都不知道这是啥意思。所以尽量别用这种乱七八糟的写法，给同事添堵。</p><p><strong>外连接</strong></p><ul><li>LEFT JOIN</li><li>RIGHT JOIN </li></ul><p>本质是一样的，换个位置而已。</p><p><strong>自连接</strong></p><p>格式：</p><p>FROM t_a child, t_a parent ON 连接条件</p><p>自连接不是一种新的连接形式，它可以用上面的任意一种连接方式，只不过是把同一张表当做两张表，自己和自己关联。</p><p>其他的什么自然连接(NATURAL JOIN)、交叉连接(CROSS JOIN)不提了，我反正从来没用过，大家有兴趣自行了解，不徒增大家的记忆负担。</p><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询指的就是在一个查询之中嵌套了其他若干个查询。</p><p>子查询通常出现在</p><ul><li><p>WHERE后面：SELECT name FROM table_a WHERE id IN (SELECT id FROM table_b)</p></li><li><p>FROM后面：SELECT name FROM (SELECT name, age FROM table_a) temp LEFT JOIN….</p></li><li><p>EXISTST后面：没用过，大家自己可以了解一下（很真实）</p></li></ul><p>放在FROM后的子查询可以看做一张临时表，WHERE后面的子查询就是动态的查询条件而已。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis分布式锁</title>
    <link href="/2020/03/04/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2020/03/04/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇文章我想和你聊一聊，关于 Redis 分布式锁的「安全性」问题。</p><p>Redis 分布式锁的话题，很多文章已经写烂了，我为什么还要写这篇文章呢？</p><p>因为我发现网上 99% 的文章，并没有把这个问题真正讲清楚。导致很多读者看了很多文章，依旧云里雾里。例如下面这些问题，你能清晰地回答上来吗？</p><ul><li>基于 Redis 如何实现一个分布式锁？</li><li>Redis 分布式锁真的安全吗？</li><li>Redis 的 Redlock 有什么问题？一定安全吗？</li><li>业界争论 Redlock，到底在争论什么？哪种观点是对的？</li><li>分布式锁到底用 Redis 还是 Zookeeper？</li><li>实现一个有「容错性」的分布式锁，都需要考虑哪些问题？</li></ul><p>这篇文章，我就来把这些问题彻底讲清楚。</p><p>读完这篇文章，你不仅可以彻底了解分布式锁，还会对「分布式系统」有更加深刻的理解。</p><p><strong>文章有点长，但干货很多，希望你可以耐心读完。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101801037.png" alt="图片"></strong></p><h1 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h1><p>在开始讲分布式锁之前，有必要简单介绍一下，为什么需要分布式锁？</p><p>与分布式锁相对应的是「单机锁」，我们在写多线程程序时，避免同时操作一个共享变量产生数据问题，通常会使用一把锁来「互斥」，以保证共享变量的正确性，其使用范围是在「同一个进程」中。</p><p>如果换做是多个进程，需要同时操作一个共享资源，如何互斥呢？</p><p>例如，现在的业务应用通常都是微服务架构，这也意味着一个应用会部署多个进程，那这多个进程如果需要修改 MySQL 中的同一行记录时，为了避免操作乱序导致数据错误，此时，我们就需要引入「分布式锁」来解决这个问题了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101752919.png" alt="图片"></p><p>想要实现分布式锁，必须借助一个外部系统，所有进程都去这个系统上申请「加锁」。</p><p>而这个外部系统，必须要实现「互斥」的能力，即两个请求同时进来，只会给一个进程返回成功，另一个返回失败（或等待）。</p><p>这个外部系统，可以是 MySQL，也可以是 Redis 或 Zookeeper。但为了追求更好的性能，我们通常会选择使用 Redis 或 Zookeeper 来做。</p><p>下面我就以 Redis 为主线，由浅入深，带你深度剖析一下，分布式锁的各种「安全性」问题，帮你彻底理解分布式锁。</p><h1 id="分布式锁怎么实现？"><a href="#分布式锁怎么实现？" class="headerlink" title="分布式锁怎么实现？"></a>分布式锁怎么实现？</h1><p>我们从最简单的开始讲起。</p><p>想要实现分布式锁，必须要求 Redis 有「互斥」的能力，我们可以使用 SETNX 命令，这个命令表示<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists，即如果 key 不存在，才会设置它的值，否则什么也不做。</p><p>两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p><p>客户端 1 申请加锁，加锁成功：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; SETNX lock 1<br>(integer) 1     // 客户端1，加锁成功<br></code></pre></div></td></tr></table></figure><p>客户端 2 申请加锁，因为它后到达，加锁失败：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; SETNX lock 1<br>(integer) 0     // 客户端2，加锁失败<br></code></pre></div></td></tr></table></figure><p>此时，加锁成功的客户端，就可以去操作「共享资源」，例如，修改 MySQL 的某一行数据，或者调用一个 API 请求。</p><p>操作完成后，还要及时释放锁，给后来者让出操作共享资源的机会。如何释放锁呢？</p><p>也很简单，直接使用 DEL 命令删除这个 key 即可：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; DEL lock // 释放锁<br>(integer) 1<br></code></pre></div></td></tr></table></figure><p>这个逻辑非常简单，整体的路程就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101730050.png" alt="图片"></p><p>但是，它存在一个很大的问题，当客户端 1 拿到锁后，如果发生下面的场景，就会造成「死锁」：</p><ol><li>程序处理业务逻辑异常，没及时释放锁</li><li>进程挂了，没机会释放锁</li></ol><p>这时，这个客户端就会一直占用这个锁，而其它客户端就「永远」拿不到这把锁了。</p><p>怎么解决这个问题呢？</p><h1 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h1><p>我们很容易想到的方案是，在申请锁时，给这把锁设置一个「租期」。</p><p>在 Redis 中实现时，就是给这个 key 设置一个「过期时间」。这里我们假设，操作共享资源的时间不会超过 10s，那么在加锁时，给这个 key 设置 10s 过期即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">127.0.0.1:6379&gt; SETNX lock 1    // 加锁<br>(integer) 1<br>127.0.0.1:6379&gt; EXPIRE lock 10  // 10s后自动过期<br>(integer) 1<br></code></pre></div></td></tr></table></figure><p>这样一来，无论客户端是否异常，这个锁都可以在 10s 后被「自动释放」，其它客户端依旧可以拿到锁。</p><p>但这样真的没问题吗？</p><p>还是有问题。</p><p>现在的操作，加锁、设置过期是 2 条命令，有没有可能只执行了第一条，第二条却「来不及」执行的情况发生呢？例如：</p><ol><li>SETNX 执行成功，执行 EXPIRE 时由于网络问题，执行失败</li><li>SETNX 执行成功，Redis 异常宕机，EXPIRE 没有机会执行</li><li>SETNX 执行成功，客户端异常崩溃，EXPIRE 也没有机会执行</li></ol><p>总之，这两条命令不能保证是原子操作（一起成功），就有潜在的风险导致过期时间设置失败，依旧发生「死锁」问题。</p><p>怎么办？</p><p>在 Redis 2.6.12 版本之前，我们需要想尽办法，保证 SETNX 和 EXPIRE 原子性执行，还要考虑各种异常情况如何处理。</p><p>但在 Redis 2.6.12 之后，Redis 扩展了 SET 命令的参数，用这一条命令就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">// 一条命令保证原子性执行<br>127.0.0.1:6379&gt; SET lock 1 EX 10 NX<br>OK<br></code></pre></div></td></tr></table></figure><p>这样就解决了死锁问题，也比较简单。</p><p>我们再来看分析下，它还有什么问题？</p><p>试想这样一种场景：</p><ol><li>客户端 1 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源的时间，「超过」了锁的过期时间，锁被「自动释放」</li><li>客户端 2 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源完成，释放锁（但释放的是客户端 2 的锁）</li></ol><p>看到了么，这里存在两个严重的问题：</p><ol><li><strong>锁过期</strong>：客户端 1 操作共享资源耗时太久，导致锁被自动释放，之后被客户端 2 持有</li><li><strong>释放别人的锁</strong>：客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁</li></ol><p>导致这两个问题的原因是什么？我们一个个来看。</p><p><strong>第一个问题，可能是我们评估操作共享资源的时间不准确导致的。</strong></p><p>例如，操作共享资源的时间「最慢」可能需要 15s，而我们却只设置了 10s 过期，那这就存在锁提前过期的风险。</p><p>过期时间太短，那增大冗余时间，例如设置过期时间为 20s，这样总可以了吧？</p><p>这样确实可以「缓解」这个问题，降低出问题的概率，但依旧无法「彻底解决」问题。</p><p>为什么？</p><p>原因在于，客户端在拿到锁之后，在操作共享资源时，遇到的场景有可能是很复杂的，例如，程序内部发生异常、网络请求超时等等。</p><p>既然是「预估」时间，也只能是大致计算，除非你能预料并覆盖到所有导致耗时变长的场景，但这其实很难。</p><p>有什么更好的解决方案吗？</p><p>别急，关于这个问题，我会在后面详细来讲对应的解决方案。</p><p>我们继续来看第二个问题。</p><p><strong>第二个问题在于，一个客户端释放了其它客户端持有的锁。</strong></p><p>想一下，导致这个问题的关键点在哪？</p><p>重点在于，每个客户端在释放锁时，都是「无脑」操作，并没有检查这把锁是否还「归自己持有」，所以就会发生释放别人锁的风险，这样的解锁流程，很不「严谨」！</p><p>如何解决这个问题呢？</p><h1 id="锁被别人释放怎么办"><a href="#锁被别人释放怎么办" class="headerlink" title="锁被别人释放怎么办?"></a>锁被别人释放怎么办?</h1><p>解决办法是：客户端在加锁时，设置一个只有自己知道的「唯一标识」进去。</p><p>例如，可以是自己的线程 ID，也可以是一个 UUID（随机且唯一），这里我们以 UUID 举例：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// 锁的VALUE设置为UUID<br>127.0.0.1:6379&gt; SET lock $uuid EX 20 NX<br>OK<br></code></pre></div></td></tr></table></figure><blockquote><p>这里假设 20s 操作共享时间完全足够，先不考虑锁自动过期的问题。</p></blockquote><p>之后，在释放锁时，要先判断这把锁是否还归自己持有，伪代码可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 锁是自己的，才释放</span><br><span class="hljs-keyword">if</span> redis.get(<span class="hljs-string">&quot;lock&quot;</span>) == $uuid:<br>    redis.del(<span class="hljs-string">&quot;lock&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>这里释放锁使用的是 GET + DEL 两条命令，这时，又会遇到我们前面讲的原子性问题了。</p><ol><li>客户端 1 执行 GET，判断锁是自己的</li><li>客户端 2 执行了 SET 命令，强制获取到锁（虽然发生概率比较低，但我们需要严谨地考虑锁的安全性模型）</li><li>客户端 1 执行 DEL，却释放了客户端 2 的锁</li></ol><p>由此可见，这两个命令还是必须要原子执行才行。</p><p>怎样原子执行呢？Lua 脚本。</p><p>我们可以把这个逻辑，写成 Lua 脚本，让 Redis 来执行。</p><p>因为 Redis 处理每一个请求是「单线程」执行的，在执行一个 Lua 脚本时，其它请求必须等待，直到这个 Lua 脚本处理完成，这样一来，GET + DEL 之间就不会插入其它命令了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101642484.png" alt="图片"></p><p>安全释放锁的 Lua 脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">// 判断锁是自己的，才释放<br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;GET&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;DEL&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>好了，这样一路优化，整个的加锁、解锁的流程就更「严谨」了。</p><p>这里我们先小结一下，基于 Redis 实现的分布式锁，一个严谨的的流程如下：</p><ol><li>加锁：SET lock_key $unique_id EX $expire_time NX</li><li>操作共享资源</li><li>释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101626176.png" alt="图片"></p><p>好，有了这个完整的锁模型，让我们重新回到前面提到的第一个问题。</p><p>锁过期时间不好评估怎么办？</p><h1 id="锁过期时间不好评估怎么办？"><a href="#锁过期时间不好评估怎么办？" class="headerlink" title="锁过期时间不好评估怎么办？"></a>锁过期时间不好评估怎么办？</h1><p>前面我们提到，锁的过期时间如果评估不好，这个锁就会有「提前」过期的风险。</p><p>当时给的妥协方案是，尽量「冗余」过期时间，降低锁提前过期的概率。</p><p>这个方案其实也不能完美解决问题，那怎么办呢？</p><p>是否可以设计这样的方案：<strong>加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。</strong></p><p>这确实一种比较好的方案。</p><p>如果你是 Java 技术栈，幸运的是，已经有一个库把这些工作都封装好了：<strong>Redisson</strong>。</p><p>Redisson 是一个 Java 语言实现的 Redis SDK 客户端，在使用分布式锁时，它就采用了「自动续期」的方案来避免锁过期，这个守护线程我们一般也把它叫做「看门狗」线程。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101618896.png" alt="图片"></p><p>除此之外，这个 SDK 还封装了很多易用的功能：</p><ul><li>可重入锁</li><li>乐观锁</li><li>公平锁</li><li>读写锁</li><li>Redlock（红锁，下面会详细讲）</li></ul><p>这个 SDK 提供的 API 非常友好，它可以像操作本地锁的方式，操作分布式锁。如果你是 Java 技术栈，可以直接把它用起来。</p><blockquote><p>这里不重点介绍 Redisson 的使用，大家可以看官方 Github 学习如何使用，比较简单。</p></blockquote><p>到这里我们再小结一下，基于 Redis 的实现分布式锁，前面遇到的问题，以及对应的解决方案：</p><ul><li><strong>死锁</strong>：设置过期时间</li><li><strong>过期时间评估不好，锁提前过期</strong>：守护线程，自动续期</li><li><strong>锁被别人释放</strong>：锁写入唯一标识，释放锁先检查标识，再释放</li></ul><p>还有哪些问题场景，会危害 Redis 锁的安全性呢？</p><p>之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 的部署架构细节。</p><p>而我们在使用 Redis 时，一般会采用<strong>主从集群 + 哨兵</strong>的模式部署，这样做的好处在于，当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p><p><strong>那当「主从发生切换」时，这个分布锁会依旧安全吗？</strong></p><p>试想这样的场景：</p><ol><li>客户端 1 在主库上执行 SET 命令，加锁成功</li><li>此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）</li><li>从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101604473.png" alt="图片"></p><p>可见，当引入 Redis 副本后，分布锁还是可能会受到影响。</p><p>怎么解决这个问题？</p><p>为此，Redis 的作者提出一种解决方案，就是我们经常听到的 <strong>Redlock（红锁）</strong>。</p><p>它真的可以解决上面这个问题吗？</p><h1 id="Redlock-真的安全吗？"><a href="#Redlock-真的安全吗？" class="headerlink" title="Redlock 真的安全吗？"></a>Redlock 真的安全吗？</h1><p>好，终于到了这篇文章的重头戏。啊？上面讲的那么多问题，难道只是基础？</p><p>是的，那些只是开胃菜，真正的硬菜，从这里刚刚开始。</p><p>如果上面讲的内容，你还没有理解，我建议你重新阅读一遍，先理清整个加锁、解锁的基本流程。</p><p>如果你已经对 Redlock 有所了解，这里可以跟着我再复习一遍，如果你不了解 Redlock，没关系，我会带你重新认识它。</p><p>值得提醒你的是，<strong>后面我不仅仅是讲 Redlock 的原理，还会引出有关「分布式系统」中的很多问题，你最好跟紧我的思路，在脑中一起分析问题的答案。</strong></p><p>现在我们来看，Redis 作者提出的 Redlock 方案，是如何解决主从切换后，锁失效问题的。</p><p>Redlock 的方案基于 2 个前提：</p><ol><li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong></li><li>但主库要部署多个，官方推荐至少 5 个实例</li></ol><p>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><blockquote><p><strong>注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101557341.png" alt="图片"></p><p>Redlock 具体如何使用呢？</p><p>整体的流程是这样的，一共分为 5 步：</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 &gt;=3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p>我简单帮你总结一下，有 4 个重点：</p><ol><li>客户端在多个 Redis 实例上申请加锁</li><li>必须保证大多数节点加锁成功</li><li>大多数节点加锁的总耗时，要小于锁设置的过期时间</li><li>释放锁，要向全部节点发起释放锁请求</li></ol><blockquote><p>第一次看可能不太容易理解，建议你把上面的文字多看几遍，加深记忆。</p><p>然后，记住这 5 步，非常重要，下面会根据这个流程，剖析各种可能导致锁失效的问题假设。</p></blockquote><p>好，明白了 Redlock 的流程，我们来看 Redlock 为什么要这么做。</p><p><strong>1) 为什么要在多个实例上加锁？</strong></p><p>本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用。</p><p><strong>2) 为什么大多数加锁成功，才算成功？</strong></p><p>多个 Redis 实例一起来用，其实就组成了一个「分布式系统」。</p><p>在分布式系统中，总会出现「异常节点」，所以，在谈论分布式系统问题时，需要考虑异常节点达到多少个，也依旧不会影响整个系统的「正确性」。</p><p>这是一个分布式系统「容错」问题，这个问题的结论是：<strong>如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的。</strong></p><blockquote><p>这个问题的模型，就是我们经常听到的「拜占庭将军」问题，感兴趣可以去看算法的推演过程。</p></blockquote><p><strong>3) 为什么步骤 3 加锁成功后，还要计算加锁的累计耗时？</strong></p><p>因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久，而且，因为是网络请求，网络情况是复杂的，有可能存在<strong>延迟、丢包、超时</strong>等情况发生，网络请求越多，异常发生的概率就越大。</p><p>所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经「超过」了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。</p><p><strong>4) 为什么释放锁，要操作所有节点？</strong></p><p>在某一个 Redis 节点加锁时，可能因为「网络原因」导致加锁失败。</p><p>例如，客户端在一个 Redis 实例上加锁成功，但在读取响应结果时，网络问题导致<strong>读取失败</strong>，那这把锁其实已经在 Redis 上加锁成功了。</p><p>所以，释放锁时，不管之前有没有加锁成功，需要释放「所有节点」的锁，以保证清理节点上「残留」的锁。</p><p>好了，明白了 Redlock 的流程和相关问题，看似 Redlock 确实解决了 Redis 节点异常宕机锁失效的问题，保证了锁的「安全性」。</p><p>但事实真的如此吗？</p><h1 id="Redlock-的争论谁对谁错？"><a href="#Redlock-的争论谁对谁错？" class="headerlink" title="Redlock 的争论谁对谁错？"></a>Redlock 的争论谁对谁错？</h1><p>Redis 作者把这个方案一经提出，就马上受到业界著名的分布式系统专家的<strong>质疑</strong>！</p><p>这个专家叫 <strong>Martin</strong>，是英国剑桥大学的一名分布式系统研究员。在此之前他曾是软件工程师和企业家，从事大规模数据基础设施相关的工作。它还经常在大会做演讲，写博客，写书，也是开源贡献者。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101545963.png" alt="图片"></p><p>他马上写了篇文章，质疑这个 Redlock 的算法模型是有问题的，并对分布式锁的设计，提出了自己的看法。</p><p>之后，Redis 作者 Antirez 面对质疑，不甘示弱，也写了一篇文章，反驳了对方的观点，并详细剖析了 Redlock 算法模型的更多设计细节。</p><p>而且，关于这个问题的争论，在当时互联网上也引起了非常激烈的讨论。</p><p><strong>二人思路清晰，论据充分，这是一场高手过招，也是分布式系统领域非常好的一次思想的碰撞！双方都是分布式系统领域的专家，却对同一个问题提出很多相反的论断，究竟是怎么回事？</strong></p><p>下面我会从他们的争论文章中，提取重要的观点，整理呈现给你。</p><blockquote><p>提醒：后面的信息量极大，可能不宜理解，最好放慢速度阅读。</p></blockquote><h2 id="分布式专家-Martin-对于-Relock-的质疑"><a href="#分布式专家-Martin-对于-Relock-的质疑" class="headerlink" title="分布式专家 Martin 对于 Relock 的质疑"></a>分布式专家 Martin 对于 Relock 的质疑</h2><p>在他的文章中，主要阐述了 4 个论点：</p><p><strong>1) 分布式锁的目的是什么？</strong></p><p>Martin 表示，你必须先清楚你在使用分布式锁的目的是什么？</p><p>他认为有两个目的。</p><p><strong>第一，效率。</strong></p><p>使用分布式锁的互斥能力，是避免不必要地做同样的两次工作（例如一些昂贵的计算任务）。如果锁失效，并不会带来「恶性」的后果，例如发了 2 次邮件等，无伤大雅。</p><p><strong>第二，正确性。</strong></p><p>使用锁用来防止并发进程互相干扰。如果锁失效，会造成多个进程同时操作同一条数据，产生的后果是<strong>数据严重错误、永久性不一致、数据丢失</strong>等恶性问题，就像给患者服用了重复剂量的药物，后果很严重。</p><p>他认为，如果你是为了前者——效率，那么使用单机版 Redis 就可以了，即使偶尔发生锁失效（宕机、主从切换），都不会产生严重的后果。而使用 Redlock 太重了，没必要。</p><p><strong>而如果是为了正确性，Martin 认为 Redlock 根本达不到安全性的要求，也依旧存在锁失效的问题！</strong></p><p><strong>2) 锁在分布式系统中会遇到的问题</strong></p><p>Martin 表示，一个分布式系统，更像一个复杂的「野兽」，存在着你想不到的各种异常情况。</p><p>这些异常场景主要包括三大块，这也是分布式系统会遇到的三座大山：<strong>NPC</strong>。</p><ul><li>N：Network Delay，网络延迟</li><li>P：Process Pause，进程暂停（GC）</li><li>C：Clock Drift，时钟漂移</li></ul><p>Martin 用一个进程暂停（GC）的例子，指出了 Redlock 安全性问题：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC（时间比较久）</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取到了 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到了锁，发生「冲突」</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101536288.png" alt="图片"></p><p>Martin 认为，GC 可能发生在程序的任意时刻，而且执行时间是不可控的。</p><blockquote><p>注：当然，即使是使用没有 GC 的编程语言，在发生网络延迟、时钟漂移时，也都有可能导致 Redlock 出现问题，这里 Martin 只是拿 GC 举例。</p></blockquote><p><strong>3) 假设时钟正确的是不合理的</strong></p><p>又或者，当多个 Redis 节点「时钟」发生问题时，也会导致 Redlock <strong>锁失效</strong>。</p><ol><li>客户端 1 获取节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E</li><li>节点 C 上的时钟「向前跳跃」，导致锁到期</li><li>客户端 2 获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B</li><li>客户端 1 和 2 现在都相信它们持有了锁（冲突）</li></ol><p>Martin 觉得，Redlock 必须「强依赖」多个节点的时钟是保持同步的，一旦有节点时钟发生错误，那这个算法模型就失效了。</p><blockquote><p>即使 C 不是时钟跳跃，而是「崩溃后立即重启」，也会发生类似的问题。</p></blockquote><p>Martin 继续阐述，机器的时钟发生错误，是很有可能发生的：</p><ul><li>系统管理员「手动修改」了机器时钟</li><li>机器时钟在同步 NTP 时间时，发生了大的「跳跃」</li></ul><p>总之，Martin 认为，Redlock 的算法是建立在「同步模型」基础上的，有大量资料研究表明，同步模型的假设，在分布式系统中是有问题的。</p><p>在混乱的分布式系统的中，你不能假设系统时钟就是对的，所以，你必须非常小心你的假设。</p><p><strong>4) 提出 fecing token 的方案，保证正确性</strong></p><p>相对应的，Martin 提出一种被叫作 fecing token 的方案，保证分布式锁的正确性。</p><p>这个模型流程如下：</p><ol><li>客户端在获取锁时，锁服务可以提供一个「递增」的 token</li><li>客户端拿着这个 token 去操作共享资源</li><li>共享资源可以根据 token 拒绝「后来者」的请求</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101529458.png" alt="图片"></p><p>这样一来，无论 NPC 哪种异常情况发生，都可以保证分布式锁的安全性，因为它是建立在「异步模型」上的。</p><p>而 Redlock 无法提供类似 fecing token 的方案，所以它无法保证安全性。</p><p>他还表示，<strong>一个好的分布式锁，无论 NPC 怎么发生，可以不在规定时间内给出结果，但并不会给出一个错误的结果。也就是只会影响到锁的「性能」（或称之为活性），而不会影响它的「正确性」。</strong></p><p>Martin 的结论：</p><p><strong>1、Redlock 不伦不类</strong>：它对于效率来讲，Redlock 比较重，没必要这么做，而对于正确性来说，Redlock 是不够安全的。</p><p><strong>2、时钟假设不合理</strong>：该算法对系统时钟做出了危险的假设（假设多个节点机器时钟都是一致的），如果不满足这些假设，锁就会失效。</p><p><strong>3、无法保证正确性</strong>：Redlock 不能提供类似 fencing token 的方案，所以解决不了正确性的问题。为了正确性，请使用有「共识系统」的软件，例如 Zookeeper。</p><p>好了，以上就是 Martin 反对使用 Redlock 的观点，看起来有理有据。</p><p>下面我们来看 Redis 作者 Antirez 是如何反驳的。</p><h2 id="Redis-作者-Antirez-的反驳"><a href="#Redis-作者-Antirez-的反驳" class="headerlink" title="Redis 作者 Antirez 的反驳"></a>Redis 作者 Antirez 的反驳</h2><p>在 Redis 作者的文章中，重点有 3 个：</p><p><strong>1) 解释时钟问题</strong></p><p>首先，Redis 作者一眼就看穿了对方提出的最为核心的问题：<strong>时钟问题</strong>。</p><p>Redis 作者表示，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了，允许有「误差」。</p><p>例如要计时 5s，但实际可能记了 4.5s，之后又记了 5.5s，有一定误差，但只要不超过「误差范围」锁失效时间即可，这种对于时钟的精度要求并不是很高，而且这也符合现实环境。</p><p>对于对方提到的「时钟修改」问题，Redis 作者反驳到：</p><ol><li><strong>手动修改时钟</strong>：不要这么做就好了，否则你直接修改 Raft 日志，那 Raft 也会无法工作…</li><li><strong>时钟跳跃</strong>：通过「恰当的运维」，保证机器时钟不会大幅度跳跃（每次通过微小的调整来完成），实际上这是可以做到的</li></ol><blockquote><p>为什么 Redis 作者优先解释时钟问题？因为在后面的反驳过程中，需要依赖这个基础做进一步解释。</p></blockquote><p><strong>2) 解释网络延迟、GC 问题</strong></p><p>之后，Redis 作者对于对方提出的，网络延迟、进程 GC 可能导致 Redlock 失效的问题，也做了反驳：</p><p>我们重新回顾一下，Martin 提出的问题假设：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取节点 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到锁，发生「冲突」</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101522843.png" alt="图片"></p><p>Redis 作者反驳到，这个假设其实是有问题的，Redlock 是可以保证锁安全的。</p><p>这是怎么回事呢？</p><p>还记得前面介绍 Redlock 流程的那 5 步吗？这里我再拿过来让你复习一下。</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p><strong>注意，重点是 1-3，在步骤 3，加锁成功后为什么要重新获取「当前时间戳T2」？还用 T2 - T1 的时间，与锁的过期时间做比较？</strong></p><p>Redis 作者强调：如果在 1-3 发生了网络延迟、进程 GC 等耗时长的异常情况，那在第 3 步 T2 - T1，是可以检测出来的，如果超出了锁设置的过期时间，那这时就认为加锁会失败，之后释放所有节点的锁就好了！</p><p>Redis 作者继续论述，如果对方认为，发生网络延迟、进程 GC 是在步骤 3 之后，也就是客户端确认拿到了锁，去操作共享资源的途中发生了问题，导致锁失效，那这<strong>不止是 Redlock 的问题，任何其它锁服务例如 Zookeeper，都有类似的问题，这不在讨论范畴内。</strong></p><p>这里我举个例子解释一下这个问题：</p><ol><li>客户端通过 Redlock 成功获取到锁（通过了大多数节点加锁成功、加锁耗时检查逻辑）</li><li>客户端开始操作共享资源，此时发生网络延迟、进程 GC 等耗时很长的情况</li><li>此时，锁过期自动释放</li><li>客户端开始操作 MySQL（此时的锁可能会被别人拿到，锁失效）</li></ol><p>Redis 作者这里的结论就是：</p><ul><li>客户端在拿到锁之前，无论经历什么耗时长问题，Redlock 都能够在第 3 步检测出来</li><li>客户端在拿到锁之后，发生 NPC，那 Redlock、Zookeeper 都无能为力</li></ul><p>所以，Redis 作者认为 Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p><p><strong>3) 质疑 fencing token 机制</strong></p><p>Redis 作者对于对方提出的 fecing token 机制，也提出了质疑，主要分为 2 个问题，这里最不宜理解，请跟紧我的思路。</p><p><strong>第一</strong>，这个方案必须要求要操作的「共享资源服务器」有拒绝「旧 token」的能力。</p><p>例如，要操作 MySQL，从锁服务拿到一个递增数字的 token，然后客户端要带着这个 token 去改 MySQL 的某一行，这就需要利用 MySQL 的「事物隔离性」来做。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 两个客户端必须利用事物和隔离性达到目的<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 注意 token 的判断条件<br>UPDATE <span class="hljs-keyword">table</span> T <span class="hljs-keyword">SET</span> val <span class="hljs-operator">=</span> $new_val <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> $id <span class="hljs-keyword">AND</span> current_token <span class="hljs-operator">&lt;</span> $token<br></code></pre></div></td></tr></table></figure><p>但如果操作的不是 MySQL 呢？例如向磁盘上写一个文件，或发起一个 HTTP 请求，那这个方案就无能为力了，这对要操作的资源服务器，提出了更高的要求。</p><p>也就是说，大部分要操作的资源服务器，都是没有这种互斥能力的。</p><p><strong>再者，既然资源服务器都有了「互斥」能力，那还要分布式锁干什么？</strong></p><p>所以，Redis 作者认为这个方案是站不住脚的。</p><p><strong>第二</strong>，退一步讲，即使 Redlock 没有提供 fecing token 的能力，但 Redlock 已经提供了随机值（就是前面讲的 UUID），利用这个随机值，也可以达到与 fecing token 同样的效果。</p><p>如何做呢？</p><blockquote><p>Redis 作者只是提到了可以完成 fecing token 类似的功能，但却没有展开相关细节，根据我查阅的资料，大概流程应该如下，如有错误，欢迎交流~</p></blockquote><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端在操作共享资源之前，先把这个锁的 VALUE，在要操作的共享资源上做标记</li><li>客户端处理业务逻辑，最后，在修改共享资源时，判断这个标记是否与之前一样，一样才修改（类似 CAS 的思路）</li></ol><p>还是以 MySQL 为例，举个例子就是这样的：</p><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端要修改 MySQL 表中的某一行数据之前，先把锁的 VALUE 更新到这一行的某个字段中（这里假设为 current_token 字段)</li><li>客户端处理业务逻辑</li><li>客户端修改 MySQL 的这一行数据，把 VALUE 当做 WHERE 条件，再修改</li></ol><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">UPDATE <span class="hljs-keyword">table</span> T <span class="hljs-keyword">SET</span> val <span class="hljs-operator">=</span> $new_val <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> $id <span class="hljs-keyword">AND</span> current_token <span class="hljs-operator">=</span> $redlock_value<br></code></pre></div></td></tr></table></figure><p>可见，这种方案依赖 MySQL 的事物机制，也达到对方提到的 fecing token 一样的效果。</p><p>但这里还有个小问题，是网友参与问题讨论时提出的：<strong>两个客户端通过这种方案，先「标记」再「检查+修改」共享资源，那这两个客户端的操作顺序无法保证啊？</strong></p><p>而用 Martin 提到的 fecing token，因为这个 token 是单调递增的数字，资源服务器可以拒绝小的 token 请求，保证了操作的「顺序性」！</p><p>Redis 作者对这问题做了不同的解释，我觉得很有道理，他解释道：<strong>分布式锁的本质，是为了「互斥」，只要能保证两个客户端在并发时，一个成功，一个失败就好了，不需要关心「顺序性」。</strong></p><blockquote><p>前面 Martin 的质疑中，一直很关心这个顺序性问题，但 Redis 的作者的看法却不同。</p></blockquote><p>综上，Redis 作者的结论：</p><p><strong>1、作者同意对方关于「时钟跳跃」对 Redlock 的影响，但认为时钟跳跃是可以避免的，取决于基础设施和运维。</strong></p><p><strong>2、Redlock 在设计时，充分考虑了 NPC 问题，在 Redlock 步骤 3 之前出现 NPC，可以保证锁的正确性，但在步骤 3 之后发生 NPC，不止是 Redlock 有问题，其它分布式锁服务同样也有问题，所以不在讨论范畴内。</strong></p><p>是不是觉得很有意思？</p><p>在分布式系统中，一个小小的锁，居然可能会遇到这么多问题场景，影响它的安全性！</p><p>不知道你看完双方的观点，更赞同哪一方的说法呢？</p><p>别急，后面我还会综合以上论点，谈谈自己的理解。</p><p>好，讲完了双方对于 Redis 分布锁的争论，你可能也注意到了，Martin 在他的文章中，推荐使用 Zookeeper 实现分布式锁，认为它更安全，确实如此吗？</p><h1 id="基于-Zookeeper-的锁安全吗？"><a href="#基于-Zookeeper-的锁安全吗？" class="headerlink" title="基于 Zookeeper 的锁安全吗？"></a>基于 Zookeeper 的锁安全吗？</h1><p>如果你有了解过 Zookeeper，基于它实现的分布式锁是这样的：</p><ol><li>客户端 1 和 2 都尝试创建「临时节点」，例如 /lock</li><li>假设客户端 1 先到达，则加锁成功，客户端 2 加锁失败</li><li>客户端 1 操作共享资源</li><li>客户端 1 删除 /lock 节点，释放锁</li></ol><p>你应该也看到了，Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端 1 拿到锁后，只要连接不断，就可以一直持有锁。</p><p>而且，如果客户端 1 异常崩溃了，那么这个临时节点会自动删除，保证了锁一定会被释放。</p><p><strong>不错，没有锁过期的烦恼，还能在异常时自动释放锁，是不是觉得很完美？</strong></p><p>其实不然。</p><p>思考一下，客户端 1 创建临时节点后，Zookeeper 是如何保证让这个客户端一直持有锁呢？</p><p>原因就在于，<strong>客户端 1 此时会与 Zookeeper 服务器维护一个 Session，这个 Session 会依赖客户端「定时心跳」来维持连接。</strong></p><p>如果 Zookeeper 长时间收不到客户端的心跳，就认为这个 Session 过期了，也会把这个临时节点删除。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101445733.png" alt="图片"></p><p>同样地，基于此问题，我们也讨论一下 GC 问题对 Zookeeper 的锁有何影响：</p><ol><li>客户端 1 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 发生长时间 GC</li><li>客户端 1 无法给 Zookeeper 发送心跳，Zookeeper 把临时节点「删除」</li><li>客户端 2 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 GC 结束，它仍然认为自己持有锁（冲突）</li></ol><p>可见，即使是使用 Zookeeper，也无法保证进程 GC、网络延迟异常场景下的安全性。</p><p><strong>这就是前面 Redis 作者在反驳的文章中提到的：如果客户端已经拿到了锁，但客户端与锁服务器发生「失联」（例如 GC），那不止 Redlock 有问题，其它锁服务都有类似的问题，Zookeeper 也是一样！</strong></p><p>所以，这里我们就能得出结论了：<strong>一个分布式锁，在极端情况下，不一定是安全的。</strong></p><p>如果你的业务数据非常敏感，在使用分布式锁时，一定要注意这个问题，不能假设分布式锁 100% 安全。</p><p>好，现在我们来总结一下 Zookeeper 在使用分布式锁时优劣：</p><p>Zookeeper 的优点：</p><ol><li>不需要考虑锁的过期时间</li><li>watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁</li></ol><p>但它的劣势是：</p><ol><li>性能不如 Redis</li><li>部署和运维成本高</li><li>客户端与 Zookeeper 的长时间失联，锁被释放问题</li></ol><h1 id="我对分布式锁的理解"><a href="#我对分布式锁的理解" class="headerlink" title="我对分布式锁的理解"></a>我对分布式锁的理解</h1><p>好了，前面详细介绍了基于 Redis 的 Redlock 和 Zookeeper 实现的分布锁，在各种异常情况下的安全性问题，下面我想和你聊一聊我的看法，仅供参考，不喜勿喷。</p><p><strong>1) 到底要不要用 Redlock？</strong></p><p>前面也分析了，Redlock 只有建立在「时钟正确」的前提下，才能正常工作，如果你可以保证这个前提，那么可以拿来使用。</p><p>但保证时钟正确，我认为并不是你想的那么简单就能做到的。</p><p><strong>第一，从硬件角度来说</strong>，时钟发生偏移是时有发生，无法避免。</p><p>例如，CPU 温度、机器负载、芯片材料都是有可能导致时钟发生偏移的。</p><p><strong>第二，从我的工作经历来说</strong>，曾经就遇到过时钟错误、运维暴力修改时钟的情况发生，进而影响了系统的正确性，所以，人为错误也是很难完全避免的。</p><p>所以，我对 Redlock 的个人看法是，尽量不用它，而且它的性能不如单机版 Redis，部署成本也高，我还是会优先考虑使用主从+ 哨兵的模式 实现分布式锁。</p><p>那正确性如何保证呢？第二点给你答案。</p><p><strong>2) 如何正确使用分布式锁？</strong></p><p>在分析 Martin 观点时，它提到了 fecing token 的方案，给我了很大的启发，虽然这种方案有很大的局限性，但对于保证「正确性」的场景，是一个非常好的思路。</p><p>所以，我们可以把这两者结合起来用：</p><p><strong>1、使用分布式锁，在上层完成「互斥」目的，虽然极端情况下锁会失效，但它可以最大程度把并发请求阻挡在最上层，减轻操作资源层的压力。</strong></p><p><strong>2、但对于要求数据绝对正确的业务，在资源层一定要做好「兜底」，设计思路可以借鉴 fecing token 的方案来做。</strong></p><p>两种思路结合，我认为对于大多数业务场景，已经可以满足要求了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，总结一下。</p><p>这篇文章，我们主要探讨了基于 Redis 实现的分布式锁，究竟是否安全这个问题。</p><p>从最简单分布式锁的实现，到处理各种异常场景，再到引出 Redlock，以及两个分布式专家的辩论，得出了 Redlock 的适用场景。</p><p>最后，我们还对比了 Zookeeper 在做分布式锁时，可能会遇到的问题，以及与 Redis 的差异。</p><p>这里我把这些内容总结成了思维导图，方便你理解。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640.png" alt="图片"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇文章的信息量其实是非常大的，我觉得应该把分布锁的问题，彻底讲清楚了。</p><p>如果你没有理解，我建议你多读几遍，并在脑海中构建各种假定的场景，反复思辨。</p><p>在写这篇文章时，我又重新研读了两位大神关于 Redlock 争辩的这两篇文章，可谓是是收获满满，在这里也分享一些心得给你。</p><p>1、在分布式系统环境下，看似完美的设计方案，可能并不是那么「严丝合缝」，如果稍加推敲，就会发现各种问题。所以，在思考分布式系统问题时，一定要<strong>谨慎再谨慎</strong>。</p><p>2、从 Redlock 的争辩中，我们不要过多关注对错，而是要多学习大神的思考方式，以及对一个问题严格审查的严谨精神。</p><p>最后，用 Martin 在对于 Redlock 争论过后，写下的感悟来结尾：</p><p>“<strong>前人已经为我们创造出了许多伟大的成果：站在巨人的肩膀上，我们可以才得以构建更好的软件。无论如何，通过争论和检查它们是否经得起别人的详细审查，这是学习过程的一部分。但目标应该是获取知识，而不是为了说服别人，让别人相信你是对的。有时候，那只是意味着停下来，好好地想一想。</strong>”</p><p>共勉。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie&amp;session&amp;token</title>
    <link href="/2020/03/02/Cookie&amp;Session&amp;Token/"/>
    <url>/2020/03/02/Cookie&amp;Session&amp;Token/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>1991 年 HTTP 0.9 诞生了，当时只是为了满足大家浏览 web 文档的要求 ，所以只有 GET 请求，浏览完了就走了，两个连接之间是没有任何联系的，这也是 HTTP 为无状态的原因，因为它诞生之初就没有这个需求。</p><p>但随着交互式 Web 的兴起（所谓交互式就是你不光可以浏览，还可以登录，发评论，购物等用户操作的行为），单纯地浏览 web 已经无法满足人们的要求，比如随着网上购物的兴起，需要记录用户的购物车记录，就需要有一个机制记录每个连接的关系，这样我们就知道加入购物车的商品到底属于谁了，于是 Cookie 就诞生了。</p><blockquote><p>Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行 Session 跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。</p></blockquote><p>工作机制如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101127316" alt="图片">img</p><p>以加入购物车为例，每次浏览器请求后 server 都会将本次商品 id 存储在 Cookie 中返回给客户端，客户端会将 Cookie 保存在本地，下一次再将上次保存在本地的 Cookie 传给 server 就行了，这样每个 Cookie 都保存着用户的商品 id，购买记录也就不会丢失了</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101133075" alt="图片">img</p><p>仔细观察上图相信你不难发现随着购物车内的商品越来越多，每次请求的 cookie 也越来越大，这对每个请求来说是一个很大的负担，我只是想将一个商品加入购买车，为何要将历史的商品记录也一起返回给 server ？购物车信息其实已经记录在 server 了，浏览器这样的操作岂不是多此一举？怎么改进呢</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>仔细考虑下，由于用户的购物车信息都会保存在 Server 中，所以在 Cookie 里只要保存能识别用户身份的信息，知道是谁发起了加入购物车操作即可，这样每次请求后只要在 Cookie 里带上用户的身份信息，请求体里也只要带上本次加入购物车的商品 id，大大减少了 cookie 的体积大小，我们把这种能识别哪个请求由哪个用户发起的机制称为 Session（会话机制），生成的能识别用户身份信息的字符串称为 sessionId，它的工作机制如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101138792" alt="图片"></p><ol><li>首先用户登录，server 会为用户生成一个 session，为其分配唯一的 sessionId，这个 sessionId 是与某个用户绑定的，也就是说根据此 sessionid（假设为 abc） 可以查询到它到底是哪个用户，然后将此 sessionid 通过 cookie 传给浏览器</li><li>之后浏览器的每次添加购物车请求中只要在 cookie 里带上 sessionId=abc 这一个键值对即可，server 根据 sessionId 找到它对应的用户后，把传过来的商品 id 保存到 server 中对应用户的购物车即可</li></ol><p>可以看到通过这种方式再也不需要在 cookie 里传所有的购物车的商品 id 了，大大减轻了请求的负担！</p><p>另外通过上文不难观察出 <strong>cookie 是存储在 client 的，而 session 保存在 server</strong>，sessionId 需要借助 cookie 的传递才有意义。</p><h3 id="session-的痛点"><a href="#session-的痛点" class="headerlink" title="session 的痛点"></a>session 的痛点</h3><p>看起来通过  cookie + session 的方式是解决了问题， 但是我们忽略了一个问题，上述情况能正常工作是因为我们假设 server 是单机工作的，但实际在生产上，为了保障高可用，一般服务器至少需要两台机器，通过负载均衡的方式来决定到底请求该打到哪台机器上。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101154301" alt="图片">balance</p><p><strong>如图示：客户端请求后，由负载均衡器（如 Nginx）来决定到底打到哪台机器</strong></p><p>假设登录请求打到了 A 机器，A 机器生成了 session 并在 cookie 里添加 sessionId 返回给了浏览器，那么问题来了：下次添加购物车时如果请求打到了 B 或者 C，由于 session 是在 A 机器生成的，此时的 B,C 是找不到 session 的，那么就会发生无法添加购物车的错误，就得重新登录了，此时请问该怎么办。主要有以下三种方式</p><blockquote><p>1、session 复制</p></blockquote><p>A 生成 session 后复制到 B, C，这样每台机器都有一份 session，无论添加购物车的请求打到哪台机器，由于 session 都能找到，故不会有问题</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101201725" alt="图片">balance (1)</p><p>这种方式虽然可行，但缺点也很明显：</p><ol><li>同一样的一份 session 保存了多份，数据冗余</li><li>如果节点少还好，但如果节点多的话，特别是像阿里，微信这种由于 DAU 上亿，可能需要部署成千上万台机器，这样节点增多复制造成的性能消耗也会很大。</li></ol><blockquote><p>2、session 粘连</p></blockquote><p>这种方式是让每个客户端请求只打到固定的一台机器上，比如浏览器登录请求打到 A 机器后，后续所有的添加购物车请求也都打到 A 机器上，Nginx 的 sticky 模块可以支持这种方式，支持按 ip 或 cookie 粘连等等，如按 ip 粘连方式如下</p><figure class="highlight roboconf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs roboconf">upstream tomcats &#123;<br>  <span class="hljs-attribute">ip_hash;</span><br><span class="hljs-attribute">  server 10.1.1.107</span>:88;<br>  <span class="hljs-attribute">server 10.1.1.132</span>:80;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101207746" alt="图片">img</p><p>这样的话每个 client 请求到达 Nginx 后，只要它的 ip 不变，根据 ip hash 算出来的值会打到固定的机器上，也就不存在 session 找不到的问题了，当然不难看出这种方式缺点也是很明显，对应的机器挂了怎么办？</p><blockquote><p>3、session 共享</p></blockquote><p>这种方式也是目前各大公司普遍采用的方案，将 session 保存在 redis，memcached 等中间件中，请求到来时，各个机器去这些中间件取一下 session 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101212174" alt="图片">img</p><p>缺点其实也不难发现，就是每个请求都要去 redis 取一下 session，多了一次内部连接，消耗了一点性能，另外为了保证 redis 的高可用，必须做集群，当然了对于大公司来说, redis 集群基本都会部署，所以这方案可以说是大公司的首选了。</p><h3 id="Token：no-session"><a href="#Token：no-session" class="headerlink" title="Token：no session!"></a>Token：no session!</h3><p>通过上文分析我们知道通过在服务端共享 session 的方式可以完成用户的身份定位，但是不难发现也有一个小小的瑕疵：搞个校验机制我还得搭个 redis 集群？大厂确实 redis 用得比较普遍，但对于小厂来说可能它的业务量还未达到用 redis 的程度，所以有没有其他不用 server 存储 session 的用户身份校验机制呢，这就是我们今天要介绍的主角：token。</p><p>首先请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地，之后向 server 请求时在请求头带上此 token 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101217167" alt="图片">img</p><p>相信大家看了上图会发现存在两个问题</p><p>1、 token 只存储在浏览器中，服务端却没有存储，这样的话我随便搞个 token 传给 server 也行？</p><p>答：server 会有一套校验机制，校验这个 token 是否合法。</p><p>2、怎么不像 session 那样根据 sessionId 找到 userid 呢，这样的话怎么知道是哪个用户？</p><p>答：token 本身携带 uid 信息</p><p>第一个问题，如何校验 token 呢？我们可以借鉴 HTTPS 的签名机制来校验。先来看 jwt token 的组成部分</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101223022" alt="图片">img</p><p>可以看到 token 主要由三部分组成</p><ol><li>header：指定了签名算法</li><li>payload：可以指定用户 id，过期时间等非敏感数据</li><li>Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。</li></ol><p>当 server 收到浏览器传过来的 token 时，它会首先取出 token 中的 header + payload，根据密钥生成签名，然后再与 token 中的签名比对，如果成功则说明签名是合法的，即 token 是合法的。而且你会发现 payload 中存有我们的 userId，所以拿到 token 后直接在 payload 中就可获取 userid，避免了像 session 那样要从 redis 去取的开销</p><p><strong>画外音：header, payload 实际上是以 base64 的形式存在的，文中为了描述方便，省去了这一步。</strong></p><p>你会发现这种方式确实很妙，只要 server 保证密钥不泄露，那么生成的 token 就是安全的，因为如果伪造 token 的话在签名验证环节是无法通过的，就此即可判定 token 非法。</p><p>可以看到通过这种方式有效地避免了 token 必须保存在 server 的弊端，实现了分布式存储，不过需要注意的是，token 一旦由 server 生成，它就是有效的，直到过期，无法让 token 失效，除非在 server 为 token 设立一个黑名单，在校验 token 前先过一遍此黑名单，如果在黑名单里则此  token 失效，但一旦这样做的话，那就意味着黑名单就必须保存在 server，这又回到了 session 的模式，那直接用 session 不香吗。所以一般的做法是当客户端登出要让 token 失效时，直接在本地移除 token 即可，下次登录重新生成 token 就好。</p><p>另外需要注意的是 token 一般是放在 header 的 Authorization 自定义头里，不是放在 Cookie 里的，这主要是为了解决跨域不能共享 Cookie 的问题 （下文详述）</p><h3 id="Cookie-与-Token-的简单总结"><a href="#Cookie-与-Token-的简单总结" class="headerlink" title="Cookie 与 Token 的简单总结"></a>Cookie 与 Token 的简单总结</h3><blockquote><p>Cookie 有哪些局限性？</p></blockquote><p>1、 Cookie 跨站是不能共享的，这样的话如果你要实现多应用（多系统）的单点登录（SSO），使用 Cookie 来做需要的话就很困难了（要用比较复杂的 trick 来实现，有兴趣的话可以看文末参考链接）</p><p><strong>画外音: 所谓单点登录，是指在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</strong></p><p>但如果用 token 来实现 SSO 会非常简单，如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101228882" alt="图片">img</p><p>只要在 header 中的 authorize 字段（或其他自定义）加上 token 即可完成所有跨域站点的认证。</p><p>2、 在移动端原生请求是没有 cookie 之说的，而 sessionid 依赖于 cookie，sessionid 就不能用 cookie 来传了，如果用 token 的话，由于它是随着 header 的 authoriize 传过来的，也就不存在此问题，换句话说token 天生支持移动平台，可扩展性好</p><p>综上所述，token 具有存储实现简单，扩展性好这些特点。</p><blockquote><p>token 有哪些缺点</p></blockquote><p>那有人就问了，既然 token 这么好，那为什么各个大公司几乎都采用共享 session 的方式呢，可能很多人是第一次听到 token，token 不香吗? token 有以下两点劣势：</p><p>1、 token 太长了</p><p>token 是 header, payload 编码后的样式，所以一般要比 sessionId 长很多，很有可能超出 cookie 的大小限制（cookie 一般有大小限制的，如 4kb），如果你在 token 中存储的信息越长，那么 token 本身也会越长，这样的话由于你每次请求都会带上 token，对请求来是个不小的负担</p><p>2、 不太安全</p><p>网上很多文章说 token 更安全，其实不然，细心的你可能发现了，我们说 token 是存在浏览器的，再细问，存在浏览器的哪里？既然它太长放在 cookie 里可能导致 cookie 超限，那就只好放在 local storage 里，这样会造成安全隐患，因为 local storage 这类的本地存储是可以被 JS 直接读取的，另外由上文也提到，token 一旦生成无法让其失效，必须等到其过期才行，这样的话如果服务端检测到了一个安全威胁，也无法使相关的 token 失效。</p><p><strong>所以 token 更适合一次性的命令认证，设置一个比较短的有效期</strong></p><h3 id="误解-Cookie-相比-token-更不安全，比如-CSRF-攻击"><a href="#误解-Cookie-相比-token-更不安全，比如-CSRF-攻击" class="headerlink" title="误解: Cookie 相比 token 更不安全，比如 CSRF 攻击"></a>误解: Cookie 相比 token 更不安全，比如 CSRF 攻击</h3><p>首先我们需要解释下 CSRF 攻击是怎么回事</p><p>攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过（cookie 里带来 sessionId 等身份认证的信息），所以被访问的网站会认为是真正的用户操作而去运行。</p><p>比如用户登录了某银行网站（假设为 **<a href="http://www.examplebank.com/**%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BD%AC%E8%B4%A6%E5%9C%B0%E5%9D%80%E4%B8%BA">http://www.examplebank.com/**，并且转账地址为</a> <strong><a href="http://www.examplebank.com/withdraw?amount=1000&amp;transferTo=PayeeName">http://www.examplebank.com/withdraw?amount=1000&amp;transferTo=PayeeName</a></strong>），登录后 cookie 里会包含登录用户的 sessionid，攻击者可以在另一个网站上放置如下代码</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-params">&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice<span class="hljs-variable">&amp;amount</span>=<span class="hljs-number">1000</span><span class="hljs-variable">&amp;for</span>=Badman&quot;&gt;</span><br></code></pre></div></td></tr></table></figure><p>那么如果正常的用户误点了上面这张图片，由于相同域名的请求会自动带上 cookie，而 cookie 里带有正常登录用户的 sessionid，类似上面这样的转账操作在 server 就会成功，会造成极大的安全风险</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101238289" alt="图片">csrf 示意图</p><p>CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 cookie 都会被自动带上，这个是浏览器的机制决定的，所以很多人据此认定 cookie 不安全。</p><p>使用 token 确实避免了CSRF 的问题，但正如上文所述，由于 token 保存在 local storage，它会被 JS 读取，<strong>从存储角度来看</strong>也不安全（实际上防护 CSRF 攻击的正确方式是用 CSRF token）</p><p>所以不管是 cookie 还是 token，从存储角度来看其实都不安全，都有暴露的风险，我们所说的安全更多的是强调传输中的安全，可以用 HTTPS 协议来传输， 这样的话请求头都能被加密，也就保证了传输中的安全。</p><p>其实我们把 cookie 和 token 比较本身就不合理，一个是存储方式，一个是验证方式，正确的比较应该是 session vs token。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>session 和 token 本质上是没有区别的，都是对用户身份的认证机制，只是他们实现的校验机制不一样而已（一个保存在 server，通过在 redis 等中间件获取来校验，一个保存在 client，通过签名校验的方式来校验），多数场景上使用 session 会更合理，但如果在单点登录，一次性命令认证上使用 token 会更合适，最好在不同的业务场景中合理选型，才能达到事半功倍的效果。</p><p>巨人的肩膀</p><ul><li>Cookie Session跨站无法共享问题(单点登录解决方案)：<a href="https://blog.csdn.net/wtopps/article/details/75040224">https://blog.csdn.net/wtopps/article/details/75040224</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Communication protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程基础(下)</title>
    <link href="/2019/12/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%8B)/"/>
    <url>/2019/12/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很多博客或者视频每次都会说“实现”多线程的方式有3种：Thread、Runnable和Callable，其实我个人是不太认同这种说法的，Thread是<strong>线程类</strong>，另外两个是<strong>任务类</strong>，不是一类事物啊！</p><p>也即是说，JDK看似提供了很多和多线程相关的类，实际上<strong>有且仅有Thread类能通过start0()方法向操作系统申请线程资源（本地方法）。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1597586134875-8b46bb15-50a0-488c-b703-61f1b02d0909-20210923215627617.png" alt="img"></p><p>并且，在JVM的设定中Java的线程和操作系统的线程是<strong>一一对应</strong>的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1597563841354-7196fcb8-683e-42fd-88d9-eb1cf5ee0f08-20210923215636217.png" alt="img"></p><p><strong>而Runnable和Callable如果没有线程或线程池去执行它们，就什么也不是，只是一坨普通的代码。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608708324821-680b47cf-1db5-45e9-a0cf-a59ef3023880-20210923215642589.png" alt="img"></p><p>注意，当Thread#start()向操作系统申请线程后，线程的执行入口始终是Thread#run()，而不是Runnable/Callable的run()</p><p>到这里，我们帮大家扫清了一些繁杂的概念，<strong>只需记住Java创建多线程只有一种方式：Thread！</strong>无论是直接通过new Thread().start()，或是通过线程池，底层都是Thread在向操作系统申请资源，而且新线程启动后，会找到原来的Thread，从它的run()方法开始执行。</p><h1 id="如何让多线程执行我们的任务？"><a href="#如何让多线程执行我们的任务？" class="headerlink" title="如何让多线程执行我们的任务？"></a>如何让多线程执行我们的任务？</h1><p>线程创建以后，如何让它帮我们执行任务呢？一般来说，可以把待执行任务“塞到”3个地方：</p><ul><li>重写Thread的run()，把任务直接塞到Thread内部，执行路径是：JVM线程–&gt;Thread#run()</li><li>实现Runnable，然后通过Thread构造器传入Runnable实例，执行路径是：JVM线程–&gt;Thread#run()–&gt;target.run()</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1622955712025-8f779783-f665-447f-a87a-38a18345b6c4-20210923215648295.png" alt="img"></p><ul><li>把任务塞到Runnable/Callable，丢到线程池里，屏蔽内部细节，省心省力</li></ul><p><strong>为什么要塞到这3个地方呢？因为当初在设计这些类时，其实就规划好了线程的执行路径，我们只要把待执行任务埋伏到指定位置就一定能碰上啦！</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncAndWaitTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 方式1：重写Thread#run()</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;========&gt;正在执行&quot;</span>);<br>            &#125;<br>        &#125;;<br>        thread.start();<br><br>        <span class="hljs-comment">// 方式2：构造方法传入Runnable实例</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;========&gt;正在执行&quot;</span>);<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 方式3：线程池 + Callable/Runnable，这里以Callble为例</span><br>        ExecutorService executorService = Executors.newSingleThreadExecutor();<br>        Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;========&gt;正在执行&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">3</span> * <span class="hljs-number">1000L</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>        &#125;);<br>        String result = submit.get();<br>        System.out.println(<span class="hljs-string">&quot;result=======&gt;&quot;</span> + result);<br>        <span class="hljs-comment">// 关闭线程池</span><br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1597564427871-eb185e43-a08a-4a98-a13e-e2a70bcf6bbd-20210923215705510.gif" alt="img"></p><p>上面介绍了多线程执行任务的3种方式（Runnable/Callable/线程池），我们再另外介绍一种初学者可能觉得有点绕，但源码里经常会见到的写法，算是Runnable的变种写法<strong>：</strong></p><p>把new Thread().start()隐藏到某个类的内部</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1598166618379-8f8944e7-225d-4517-9c62-78d513a9c38d-20210923215714201.png" alt="img"></p><p>重点关注Worker到底是什么，以及begin()内部做了什么。不熟悉的同学不妨自己写一下，琢磨一下。<strong>我们马上会在JDK的某个类中看到类似的写法！</strong></p><p>总之，在我心里Thread的Level要比Runnbale、Callable高一级。看到很多人把它们混在一起，不禁想起一句话：</p><p>萧某大好男儿，竟和你这种人齐名！ — 《天龙八部》乔峰</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1631540140685-22fcba24-f53a-4ec9-bafd-bc2ab3776471-20210923215722765.jpeg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态代理&amp;动态代理</title>
    <link href="/2019/12/08/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&amp;%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2019/12/08/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&amp;%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a><strong>静态代理</strong></h2><p>假设现在项目经理有一个需求：在项目现有所有类的方法前后打印日志。</p><p>你如何在<strong>不修改已有代码的前提下</strong>，完成这个需求？</p><p>我首先想到的是静态代理。具体做法是：</p><p>1.为现有的每一个类都编写一个<strong>对应的</strong>代理类，并且让它实现和目标类相同的接口（假设都有）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-001c5db900d8785d47c1a5a0c6f32762_1440w-20210902214027681.jpg" alt="img"></p><p>2.在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是说，<strong>代理对象 = 增强代码 + 目标对象（原对象）</strong>。有了代理对象后，就不用原对象了</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-e302487f952bdf8e284afc0d8d6a770b_1440w-20210902214033494.jpg" alt="img"></p><p><strong>静态代理的缺陷</strong></p><p>程序员要手动为每一个目标类编写对应的代理类。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？</p><p><strong>复习对象的创建</strong></p><p>很多初学Java的朋友眼中创建对象的过程</p><p>;<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-9cd31ab516bd967e1b8e68736931f8ba_1440w-20210903091359016.jpg" alt="img"></p><p>实际上可以换个角度，也说得通</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-eddc430b991c58039dfc79dd6f3139cc_1440w-20210903091410216.jpg" alt="img"></p><p>所谓的Class对象，是Class类的实例，而Class类是描述所有类的，比如Person类，Student类</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-c9bf695b1b9d2a0ae01cf92501492159_1440w-20210903091424896.jpg" alt="img"></p><p>可以看出，要创建一个实例，最关键的就是<strong>得到对应的Class对象。</strong>只不过对于初学者来说，new这个关键字配合构造方法，实在太好用了，底层隐藏了太多细节，一句 Person p = new Person();直接把对象返回给你了。我自己刚开始学Java时，也没意识到Class对象的存在。</p><p>分析到这里，貌似有了思路：</p><p><strong>能否不写代理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。</strong></p><p>Class对象包含了一个类的所有信息，比如构造器、方法、字段等。如果我们不写代理类，这些信息从哪获取呢？苦思冥想，突然灵光一现：代理类和目标类理应实现同一组接口。<strong>之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。</strong>还是上面这幅图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-e302487f952bdf8e284afc0d8d6a770b_1440w-20210903091438566.jpg" alt="img"></p><p>所以，可以这样说：接口拥有代理对象和目标对象共同的类信息。所以，我们可以从接口那得到理应由代理类提供的信息。但是别忘了，接口是无法创建对象的，怎么办？</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy，所以我们先聊它。</p><p>Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象。</p><p>用通俗的话说，getProxyClass()这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。打个比方，一个大内太监（接口Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小DD（构造器）…（这到底是道德の沦丧，还是人性的扭曲，欢迎走进动态代理）</p><p>所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-d187a82b1eb9c088fe60327828ee63aa_1440w-20210903091450435.jpg" alt="img"></p><p>大体思路</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-28223a1c03c1800052a5dfe4e6cb8c53_1440w-20210903091507755.jpg" alt="img"></p><p>静态代理</p><p><img src="https://pica.zhimg.com/80/v2-ba3d9206f341be466f18afbdd938a3b3_1440w.jpg?source=1940ef5c" alt="img"></p><p>动态代理</p><p>所以，按我理解，Proxy.getProxyClass()这个方法的本质就是：<strong>以Class造Class。</strong></p><p>有了Class对象，就很好办了，具体看代码：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-6b091b6d41bae1f88ba74a510acb24b1_1440w-20210903091542536.jpg" alt="img"></p><p>完美。</p><p>根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代理对象的方法，最终都会调用InvocationHandler的invoke()方法：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-92610586e77cf71ba5ce89087de52ff1_1440w-20210903091554306.jpg" alt="img"></p><p>怎么做到的呢？</p><p>上面不是说了吗，根据代理Class的构造器创建对象时，需要传入InvocationHandler。<strong>通过构造器传入一个引用，那么必然有个成员变量去接收。</strong>没错，代理对象的内部确实有个成员变量invocationHandler，而且代理对象的每个方法内部都会调用handler.invoke()！InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代理这么直接。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-b5fc8b279a6152889afdfedbb0f611cc_1440w-20210903091605600.jpg" alt="img"></p><p>大家仔细看上图右侧的动态代理，我在invocationHandler的invoke()方法中并没有写目标对象。因为一开始invocationHandler的invoke()里确实没有目标对象，需要我们手动new。<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-88147b81ee9342015374159b2671320b_1440w-20210903091623203.jpg" alt="img"></p><p>但这种写法不够优雅，属于硬编码。我这次代理A对象，下次想代理B对象还要进来改invoke()方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>CalculatorImpl target = <span class="hljs-keyword">new</span> CalculatorImpl();<br>                <span class="hljs-comment">//传入目标对象</span><br>                <span class="hljs-comment">//目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法</span><br>Calculator calculatorProxy = (Calculator) getProxy(target);<br>calculatorProxy.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>calculatorProxy.subtract(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object target)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">//参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口</span><br>Class proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());<br>Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);<br>Object proxy = constructor.newInstance(<span class="hljs-keyword">new</span> InvocationHandler() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法开始执行...&quot;</span>);<br>Object result = method.invoke(target, args);<br>System.out.println(result);<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法执行结束...&quot;</span>);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;);<br><span class="hljs-keyword">return</span> proxy;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你把实例传进来，getProxy()都能给你返回对应的代理对象。就这样，我们完美地跳过了代理类，直接创建了代理对象！</p><p>不过实际编程中，一般不用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理Class对象的过程都帮你隐藏：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>CalculatorImpl target = <span class="hljs-keyword">new</span> CalculatorImpl();<br>Calculator calculatorProxy = (Calculator) getProxy(target);<br>calculatorProxy.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>calculatorProxy.subtract(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object target)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Object proxy = Proxy.newProxyInstance(<br>target.getClass().getClassLoader(),<span class="hljs-comment">/*类加载器*/</span><br>target.getClass().getInterfaces(),<span class="hljs-comment">/*让代理对象和目标对象实现相同接口*/</span><br><span class="hljs-keyword">new</span> InvocationHandler()&#123;<span class="hljs-comment">/*代理对象的方法最终都会被JVM导向它的invoke方法*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法开始执行...&quot;</span>);<br>Object result = method.invoke(target, args);<br>System.out.println(result);<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法执行结束...&quot;</span>);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br>);<br><span class="hljs-keyword">return</span> proxy;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在，我想应该能看懂动态代理了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-6aacbe1e9df4fe982a68fe142401952e_1440w-20210903091644194.jpg" alt="img"></p><p>最后讨论一下代理对象是什么类型。</p><p>首先，请区分两个概念：代理Class对象和代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-bb82bd129d63f77265f51b2209159269_1440w-20210903091702198.jpg" alt="img"></p><p>单从名字看，代理Class和Calculator的接口确实相去甚远，但是我们却能将代理对象赋值给接口类型：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-e869e67fc4fbc708b793ff6ea6e2c012_1440w-20210903091722724.jpg" alt="img"></p><p>千万别觉得名字奇怪，就怀疑它不能用接口接收，只要实现该接口就是该类型。</p><blockquote><p>代理对象的本质就是：和目标对象实现相同接口的实例。代理Class可以叫任何名字，whatever，只要它实现某个接口，就能成为该接口类型。</p></blockquote><p>;<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-91d716b1a95099ad364233de91fca7a3_1440w-20210903091736091.jpg" alt="img"></p><p>我写了一个MyProxy类，那么它的Class名字必然叫MyProxy。<strong>但这和能否赋值给接口没有任何关系。</strong>由于它实现了Serializable和Collection，所以myProxy（代理实例）<strong>同时</strong>是这两个接口的类型。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>我想了个很骚的比喻，希望能解释清楚：</p><p>接口Class对象是大内太监，里面的方法和字段比做他的一身武艺，但是他没有小DD（构造器），所以不能new实例。一身武艺后继无人。</p><p>那怎么办呢？</p><p>正常途径（implements）：</p><p>写一个类，实现该接口。这个就相当于大街上拉了一个人，认他做干爹。一身武艺传给他，只是比他干爹多了小DD，可以new实例。</p><p>非正常途径（动态代理）：</p><p>通过妙手圣医Proxy的克隆大法（Proxy.getProxyClass()），克隆一个Class，但是有小DD。所以这个克隆人Class可以创建实例，也就是代理对象。</p><p>代理Class其实就是附有构造器的接口Class，一样的类结构信息，却能创建实例。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-33094b28321ab388bb0db46608eae74a_1440w-20210903091759099.jpg" alt="img">JDK动态代理生成的实例</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-b99009ee292273a56ab483170b2e20aa_1440w-20210903091819161.jpg" alt="img">CGLib动态代理生成的实例</p><p>如果说继承的父类是亲爹（只有一个），那么实现的接口是干爹（可以有多个）。</p><p>实现接口是一个类认干爹的过程。接口无法创建对象，但实现该接口的类可以。</p><p>比如 </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">class Student extends Person implements A, B<br></code></pre></div></td></tr></table></figure><p>这个类new一个实例出来，你问它：你爸爸是谁啊？它会告诉你：我只有一个爸爸Person。</p><p>但是student instanceof A interface，或者student instanceof B interface，它会告诉你两个都是它干爹（true），都可以用来接收它。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-1c36d27a6a2a49a266a7fc2ed457e532_1440w-20210903091835896.jpg" alt="img"></p><p>然而，凡是有利必有弊。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-991ea99b9038d52875ff6ba57e9032de_1440w-20210903091849332.jpg" alt="img"></p><p>也就是说，动态代理生成的代理对象，最终都可以用接口接收，和目标对象一起形成了多态，可以随意切换展示不同的功能。但是切换的同时，只能使用该接口定义的方法。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java动态代理之InvocationHandler</title>
    <link href="/2019/12/08/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BInvocationHandler/"/>
    <url>/2019/12/08/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BInvocationHandler/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网上关于Java的动态代理，Proxy和InvocationHandler这些概念有讲解得非常高深的文章。其实这些概念没有那么复杂。现在咱们通过一个最简单的例子认识什么是InvocationHandler。值得一提的是，InvocationHandler在Spring框架实现中被广泛使用，这意味着我们吃透了InvocationHandler，就为将来的Spring源码学习打下一个坚实的基础。</p><p>开发一个接口，包含两个方法，可以向指定的人问候“你好”或者“再见”。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHello</span> </span>&#123;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span></span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>创建一个简单的类，实现这个IHello接口。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helloimplements</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHello</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot; GoodBye!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>消费这个实现类，迄今为止没什么特别的。</p><p>现在假设我们接到了这个需求：老板要求在该实现类每次问候某人时，必须把问候的细节记录到日志文件里。为了简单起见，我们在问候前打印下面的一行语句来模拟日志记录的动作。</p><p>System.out.println(“问候之前的日志记录…”);</p><p>您也许会说，这还不简单？直接修改Helloimplements的对应方法，把这行日志插入到对应方法即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183109.png"></p><p>然而，老板的要求是：不允许你修改原来的Helloimplements类。在现实场景中，Helloimplements可能是第三方的jar包提供的，我们没有办法修改代码。</p><p>您也许会说，我们可以用设计模式里的代理模式，即创建一个新的Java类作为代理类，同样实现IHello接口，然后将Helloimplements类的实例传入代理类。我们虽然被要求不允许修改Helloimplements的代码，但是可以把日志记录代码写在代理类里。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHello</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> IHello iHello;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImpl</span><span class="hljs-params">(IHello impl)</span></span>&#123;<br><br>  <span class="hljs-keyword">this</span>.iHello = impl;<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>    System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br><br>    iHello.sayHello(name);<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>     System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br><br>     iHello.sayGoogBye(name);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br><br>     Helloimplements hello = <span class="hljs-keyword">new</span> Helloimplements();<br><br>     StaticProxy proxy = <span class="hljs-keyword">new</span> StaticProxy();<br><br>     proxy.setImpl(hello);<br><br>     proxy.sayHello(<span class="hljs-string">&quot;Jerry&quot;</span>);<br><br>  &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种做法能够实现需求：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183127.png"></p><p>下面我们再看如何用InvocationHandler实现同样的效果。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">InvocationHandler是一个JDK提供的标准接口。看下面的代码：<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynaProxyHello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object delegate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">bind</span><span class="hljs-params">(Object delegate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.delegate = delegate;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>        <span class="hljs-keyword">this</span>.delegate.getClass().getClassLoader(), <span class="hljs-keyword">this</span>.delegate<br>        .getClass().getInterfaces(), <span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br>            <span class="hljs-comment">// JVM通过这条语句执行原来的方法(反射机制)</span><br>            result = method.invoke(<span class="hljs-keyword">this</span>.delegate, args);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>上面代码里的bind方法很想我之前代理类StaticProxy的setImpl方法，只不过这个bind方法的输入参数类型更加通用。日志记录的代码写在方法invoke里。</p><p>看看如何使用：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>    DynaProxyHello helloproxy = <span class="hljs-keyword">new</span> DynaProxyHello();<br>    Helloimplements hello = <span class="hljs-keyword">new</span> Helloimplements();<br>    IHello ihello = (IHello) helloproxy.bind(hello);<br>    ihello.sayHello(<span class="hljs-string">&quot;Jerry&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行效果和StaticProxy那种解决方案完全一致。</p><p>咱们先来调试一下。当bind方法执行时，方法Proxy.newProxyInstance被调用，Helloimplements类的实例被传入。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183142.png"></p><p>我们在调试器里观察IHello ihello = (IHello) helloproxy.bind(hello)这行语句返回的ihello变量。虽然它的静态类型是IHello，但请注意，在调试器里观察它的实际类型，并不是Helloimplements的实例，而是JVM给我们加过工的，包含了我们在invoke方法里手写的那行日志记录代码。这个ihello类型为$Proxy0。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183155.png"></p><p>当这个被JVM加过工的变量的sayHello方法被调用时，JVM自动将调用转交到DynaProxyHello.invoke去：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183208.png"></p><p>于是，在invoke方法里，我们手写的日志记录代码被执行，然后通过Java反射执行原始的sayHello代码。</p><p>有的朋友可能会问，你这个InvocationHandler看起来比静态代理StaticProxy还复杂啊？有什么好处？</p><p>假设老板的需求又变了，在调用问候和说再见的方法里，要使用不同的日志记录策略。</p><p>看看用InvocationHandler如何优雅实现吧：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183221.png"></p><p>希望这个例子能让大家对Java的动态代理之InvocationHandler有了最基本的了解。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程基础(上)</title>
    <link href="/2019/12/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%8A)/"/>
    <url>/2019/12/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="线程、进程概念与区别"><a href="#线程、进程概念与区别" class="headerlink" title="线程、进程概念与区别"></a><strong>线程、进程概念与区别</strong></h2><p><strong>进程</strong></p><p>当我们双击桌面的图标时，系统会将对应的程序加载进内存，程序将会占用一部分内存用以执行操作。进入到内存的程序即为进程（一个应用程序可以同时运行多个进程）。当使用任务管理器关闭程序时（比如QQ），系统又会将程序从内存中清除，此时进程结束。</p><p>可以理解为：<strong>进程指的是占用一定内存的程序。</strong>当内存中的程序被清除，进程即结束。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-fd0f10c0230ac832152cdbd3026721a7_1440w-20210923215102481.jpg" alt="img">程序要运行，必须先加载到内存中</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-b0b5c7d2ceb5594cd407b6619beca690_1440w-20210923215109312.jpg" alt="img">一个应用程序可以同时运行多个进程</p><p><strong>线程</strong></p><p>线程是进程中的一个执行单元，<strong>负责当前进程中程序的执行。</strong>一个进程中至少有一个线程。</p><p><strong>区别</strong></p><p>进程是资源分配的单位，线程是执行单位。早期操作系统没有线程，只有进程。但是进程非常“重”，进程间切换成本高。为了降低并发导致的进程切换成本，提出了线程。一个进程可以拥有多个线程。尽量让线程间进行切换，线程不拥有资源(或者说是很少的必要的资源)。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-81da4d74c8ec012de45ef78790cb9d12_1440w-20210923215115067.jpg" alt="img">多个线程抢占CPU执行权</p><p>需要注意的是，Java本身并不能创造线程，因为线程其实是操作系统的一种资源，它由操作系统管理。我们一般说“Java支持多线程”，指的就是Java可以调用系统资源创建多线程。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-cb16cb8f32cd9e1e47915dade7be2a79_1440w-20210923215119482.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-5e61f736b3c64331a5ca5971bfae3f20_1440w-20210923215125815.jpg" alt="img">单线程方法调用链（main)</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-89c30148f90d4713dcb5fa657b769a35_1440w-20210923215129635.jpg" alt="img">开启多线程</p><hr><p><strong>创建多线程的2种常见方式</strong></p><p>Java中有两种创建多线程的方式：</p><ul><li>方式1：继承Thread类，重写run()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// ThreadDemo1继承了Thread类，并重写run()</span><br>        ThreadDemo1 t = <span class="hljs-keyword">new</span> ThreadDemo1();<br>        <span class="hljs-comment">// 开启线程：t线程得到CPU执行权后会执行run()中的代码</span><br>        t.start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread is running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>方式2：实现Runnable接口，实现run()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// ThreadDemo2实现Runnable接口，并实现run()</span><br>        ThreadDemo2 target = <span class="hljs-keyword">new</span> ThreadDemo2();<br>        <span class="hljs-comment">// 调用Thread构造方法，传入TreadDemo2的实例对象，创建线程对象</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(target);<br>        <span class="hljs-comment">// 开启线程：t线程得到CPU执行权后会执行run()中的代码</span><br>        t.start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread is running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-86814ca28633bf2ce18b4ec6dcae40ff_1440w-20210923215136005.jpg" alt="img"></p><p>上面两段代码，相信大家早已烂熟于心，就不再赘述。这里要提一点：很多初学者，在学习多线程时被反复强调“实际编程往往只用实现Runnable接口的方式”，久而久之，便觉得Thread类干脆没啥用了，只要有Runnable接口就行。</p><p>本末倒置，实在糊涂！</p><p>Runnable里面仅定义了一个抽象方法run()</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-815dff8c5844fb04a8e88c610d5afd53_1440w-20210923215143575.jpg" alt="img"></p><p>从程序运行上来看，这个接口基本没什么卵用。之所以搞出Runnable接口，目的有两个：</p><ol><li>限定Thread构造方法的形参类型（针对方式2说的）</li><li>将run()向上抽取，做成抽象方法，让实现类去重写（为什么？）</li></ol><hr><h2 id="Thread源码浅析"><a href="#Thread源码浅析" class="headerlink" title="Thread源码浅析"></a><strong>Thread源码浅析</strong></h2><p>为了更好地理解上面两句话，先来观察Thread类的源码（截取部分）：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-comment">/* What will be run. */</span><br>    <span class="hljs-keyword">private</span> Runnable target;<br>   <br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span> </span>&#123;<br>        init(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span> </span>&#123;<br>        init(<span class="hljs-keyword">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>            target.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在理解上面源码后，我们开个上帝视角重新看一下Java创建多线程的2种方式：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-8afe4d73801e732abbc19637e1ae7919_1440w-20210923215151585.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-003e14c30d2f9b587179bf226203a990_1440w-20210923215155862.jpg" alt="img">你以为方式2中t.start()开启线程后直接调用本类的run()？NO！它要曲线救国</p><p>现在，大家应该对平时习以为常的这两段代码有了更深刻的理解。但还是不够。我们还没明白上面那两句话到底是什么意思：</p><ul><li>“限定Thread构造方法的形参类型”</li></ul><p>其实这句话，是针对创建多线程的方式2说的。方式2需要我们在创建Thread实例时传入Runnable的实现类对象：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ThreadDemo2实现Runnable接口，并实现run()</span><br>ThreadDemo2 target = <span class="hljs-keyword">new</span> ThreadDemo2();<br><span class="hljs-comment">// 调用Thread构造方法，传入TreadDemo2的实例对象，创建线程对象</span><br>Thread t = <span class="hljs-keyword">new</span> Thread(target);<br></code></pre></div></td></tr></table></figure><p>为什么要传Runnable实现类对象？因为对于方式2而言，要执行的代码并不在Thread线程本身，而是在Runnable的实现类中，所以<strong>必须传入一个对象告诉线程去哪执行。</strong>而Thread的有参构造方法的形参类型是Runnable：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span> </span>&#123;<br>    init(<span class="hljs-keyword">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以方式2要求我们写的类必须implements Runnable，这就是“限定Thread构造方法的形参类型”这句话的背后含义：</p><blockquote><p>Thread的有参构造函数<strong>只允许</strong>接受Runnable的实现类对象（包括Thread子类对象，因为观察源码，我们发现Thread也实现了Runnable）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-9791f7b18e2cfc3e3fb7bd141443a3b7_1440w-20210923215202375.jpg" alt="img">把Thread类看做大水桶，但是入口很严格，由Runnable把持。如果我们的类没有实现Runnable，就无法“塞进”Thread中</p><ul><li>将run()向上抽取，做成抽象方法，强制实现类去重写（为什么？）</li></ul><p>为什么要把run向上抽取做成抽象方法呢？这其实是由Runnable、Thread以及他们各自的实现类及子类的继承体系决定的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-6a18afe8ab8694e6821012767412dc46_1440w-20210923215207618.jpg" alt="img"></p><p>仔细观察，会有以下发现：</p><ul><li>一个线程执行，总是从start()开始，因为它才是开启线程的钥匙。线程开始后会自动调用Thread的run()</li><li>run()的本质，只是为了“包裹”需要线程执行的代码块</li></ul><p>我们实际编码时，工作量只有黄色虚线框内的代码，也就是编写Thread子类或者Runnable实现类。现在请大家专注于这两块代码：</p><p>不难发现，虽然看似有很多run()，但是线程被start()“唤醒”后，只会去调用<strong>Thread的run()<strong>，这个run()可能来自Thread类（方式2），也可能来自Thread的子类对象（方式1）。</strong>换言之，Thread类（及其子类）是线程运行的入口！</strong>没了Thread，Runnable及其实现类就是摆设。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-c681c87c96727c894fc221c0a2eabe46_1440w-20210923215213195.jpg" alt="img">Thread类及其子类永远是入口，方式2写在Runnable实现类中代码之所以能被执行到，仅仅是因为Thread的run()中调用了target.run()</p><hr><h2 id="继承Thread-VS-实现Runnable"><a href="#继承Thread-VS-实现Runnable" class="headerlink" title="继承Thread VS 实现Runnable"></a><strong>继承Thread VS 实现Runnable</strong></h2><p>文章开头已经说了，实际编程往往选择实现Runnable的方式创建多线程。为什么？其实也有点“解耦”的味道的在里面。编程界有句老话：“没有什么问题是引入第三方解决不了的”，而实现Runnable的方式，把原本线程类中的“待执行代码”挪到了Runnable实现类中，硬生生整出了“第三方”。</p><p>实现Runnable的好处恰恰在于“执行者”与“被执行者”被分离了。反观继承Thread这种方式虽然便捷，但是线程和待运行的代码在同一个类中，无法做到资源独立，也就无法共享。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-11e8212648f478b469bac47ebbd44247_1440w-20210923215218446.jpg" alt="img">注意，继承Thread方式并没有做到资源共享，因为每个子类对象都有各自的一份run()，各玩各的</p><hr><p>总结一下：</p><ul><li>Runnable是功能性接口，它的作用是：</li></ul><blockquote><p>为了规范Thread有参构造的传值类型<br>将run()向上抽取，做成抽象方法，让实现类去实现</p></blockquote><ul><li>Thread是多线程的命脉，是入口，没有它多线程无从谈起。不论是方式1还是方式2，切入点都是Thread的run()，然后去执行其中代码，只是方式2更加曲折一些，最终又绕回到Runnable实现类的run()</li><li>实现Runnable的方式更常用，因为它分离了线程与资源。实际编程往往只是把Runnable写成匿名对象，不会去另外写一个类。每New一个Thread就塞一个Runnable，所以也谈不上共享。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">方式<span class="hljs-number">1</span>：<br><span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;The code waiting for Thread1&quot;</span>);<br>            &#125;<br>        &#125;.start();<br>方式<span class="hljs-number">2</span>（只用一次）：<br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;The code waiting for Thread2&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>方式<span class="hljs-number">3</span>（多个线程共享）：<br>        Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            System.out.println(<span class="hljs-string">&quot;The code waiting for Threads&quot;</span>);<br>        &#125;;<br>        Thread t1  = <span class="hljs-keyword">new</span> Thread(r);<br>        Thread t2  = <span class="hljs-keyword">new</span> Thread(r);<br>        Thread t3  = <span class="hljs-keyword">new</span> Thread(r);<br>        Thread t4  = <span class="hljs-keyword">new</span> Thread(r);<br>        Thread t5  = <span class="hljs-keyword">new</span> Thread(r);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        t4.start();<br>        t5.start();<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负数 &gt;&gt;&gt;运算符的计算过程</title>
    <link href="/2019/09/27/%E8%B4%9F%E6%95%B0%3E%3E%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/09/27/%E8%B4%9F%E6%95%B0%3E%3E%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“&gt;&gt;&gt;” 表示无符号右移,正数情况下, a &gt;&gt;&gt; b 等价于 a / Math.pow(2,b)</p><p>以 -16 &gt;&gt;&gt; 2 为例子 负16右移2位</p><ol><li>将-16转为2进制 (用补码表示负数)<ul><li>16 = 00000000 00000000 00000000 00010000</li><li>取反并补码 = 11111111 11111111 11111111 11101111 + 1 = 11111111 11111111 11111111 11110000</li><li>右移2位 = 00111111 11111111 11111111 11111100 = 10进制 1073741820</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
