<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅谈Redis分布式锁(下)</title>
    <link href="/2020/10/25/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8B)/"/>
    <url>/2020/10/25/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自定义Redis分布式锁的弊端"><a href="#自定义Redis分布式锁的弊端" class="headerlink" title="自定义Redis分布式锁的弊端"></a>自定义Redis分布式锁的弊端</h1><p>在上一篇我们自定义了一个Redis分布式锁，用来解决多节点定时任务的拉取问题（避免任务重复执行）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604497239038-11bf2996-86c7-4672-8c14-97003ad03379-20210923224039242.png" alt="img"></p><p>但仍然存在很多问题：</p><ul><li>加锁操作不是原子性的（setnx和expire两步操作不是原子性的，中间宕机会导致死锁）</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String lockKey, String value, <span class="hljs-keyword">long</span> expireTime, TimeUnit timeUnit)</span> </span>&#123;<br>    <span class="hljs-comment">// 1.先setnx</span><br>    Boolean lock = redisTemplate.opsForValue().setIfAbsent(lockKey, value);<br>    <span class="hljs-keyword">if</span> (lock != <span class="hljs-keyword">null</span> &amp;&amp; lock) &#123;<br>        <span class="hljs-comment">// 2.再expire</span><br>        redisTemplate.expire(lockKey, expireTime, timeUnit);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605942078377-4709a4b0-b840-46af-8790-eec570ccc526-20210923224051964.png" alt="img"></p><p>当然啦，高版本的SpringBoot Redis依赖其实提供了加锁的原子性操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 尝试上锁：setNX + expire</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> lockKey    锁</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value      对应的值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> expireTime 过期时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> timeUnit   时间单位</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String lockKey, String value, <span class="hljs-keyword">long</span> expireTime, TimeUnit timeUnit)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 可以设置4个参数，一步到位</span><br>        redisTemplate.opsForValue().set(lockKey, value, expireTime, timeUnit);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从 Redis 2.6.12 版本开始（现在6.x了…）， <a href="http://doc.redisfans.com/string/set.html#set">SET</a> 命令的行为可以通过一系列参数来修改，也因为 <a href="http://doc.redisfans.com/string/set.html#set">SET</a> 命令可以通过参数来实现和 <a href="http://doc.redisfans.com/string/setnx.html#setnx">SETNX</a> 、 <a href="http://doc.redisfans.com/string/setex.html#setex">SETEX</a> 和 <a href="http://doc.redisfans.com/string/psetex.html#psetex">PSETEX</a> 三个命令的效果，所以将来的 Redis 版本可能会废弃并最终移除 <a href="http://doc.redisfans.com/string/setnx.html#setnx">SETNX</a> 、 <a href="http://doc.redisfans.com/string/setex.html#setex">SETEX</a> 和 <a href="http://doc.redisfans.com/string/psetex.html#psetex">PSETEX</a> 这三个命令。</p><ul><li>解锁操作不是原子性的（可能造成不同节点之间互相删锁）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605944419389-2d72efb4-3f0d-4082-9836-27729be483ca-20210923224114637.png" alt="img"></p><p>虽然上一篇设计的unLock()不是原子操作，但可以避免不同节点之间互相删锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLock</span><span class="hljs-params">(String lockKey, String value)</span> </span>&#123;<br>    <span class="hljs-comment">// 1.获取锁的value，存的是MACHINE_ID</span><br>    String machineId = (String) redisTemplate.opsForValue().get(lockKey);<br>    <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(machineId) &amp;&amp; machineId.equals(value)) &#123;<br>        <span class="hljs-comment">// 2.只能删除当前节点设置的锁</span><br>        redisTemplate.delete(lockKey);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>畏难情绪作祟，不想考虑锁续期的问题，企图采用队列的方式缩减定时任务执行时间，直接把任务丢到队列中。但实际上可能存在任务堆积，个别情况下会出现：上次已经拉取某个任务并丢到Redis队列中，但由于队列比较繁忙，该任务还未被执行，数据库状态也尚未更改为status=1（已执行），结果下次又拉取一遍，重复执行（简单的解决策略是：虽然无法阻止入队，但是出队消费时可以判断where status=0后执行）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606004955240-09b70762-48c9-48db-b5ce-594f57f8037d-20210923224127881.png" alt="img"></p><p>引入Redis Message Queue会让系统变得更加复杂，我之前就因为使用了上面的模型导致各种偶发性的BUG，非常不好排查。一般来说，定时任务应该设计得简单点：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605943038778-2e521c6d-d2eb-4bf8-bfee-85386d52683f-20210923224137688.png" alt="img"></p><p>也就是说，绕来绕去，想要设计一个较完备的Redis分布式锁，必须至少解决3个问题：</p><ul><li><p>加锁原子性（setnx和expire要保证原子性，否则会容易发生死锁）</p></li><li><p>解锁原子性（不能误删别人的锁）</p></li><li><p>需要考虑业务/定时任务执行的时间，并为锁续期</p></li></ul><p>如果不考虑性能啥的，加解锁原子性都可以通过lua脚本实现（利用Redis单线程的特性）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605945261112-585bd28f-7670-4518-af85-8440d044153b-20210923224146607.png" alt="img"></p><p>一次执行一个脚本，要么成功要么失败，不会和其他指令交错执行。</p><p>最难的是如何根据实际业务的执行时间给锁续期！虽然我们已经通过判断MACHINE_ID避免了不同节点互相删除锁：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605945347715-e77ca098-bd7a-4dee-beda-1e325c6247fa-20210923224152657.png" alt="img"></p><p>但本质上我们需要的是：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606005458029-94f26b64-780d-4324-910c-f36f7dd7ccaf-20210923224200340.png" alt="img"></p><p>本文我们的主要目标就是实现锁续期！</p><p>好在Redisson已经实现了，所以目标又变成：了解Redisson的锁续期机制。</p><h1 id="Redisson案例"><a href="#Redisson案例" class="headerlink" title="Redisson案例"></a>Redisson案例</h1><h2 id="Redisson环境搭建"><a href="#Redisson环境搭建" class="headerlink" title="Redisson环境搭建"></a>Redisson环境搭建</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">server:<br>  port: 8080<br><br>spring:<br>  redis:<br>    host: # 见小册开头《阿里云服务账号》<br>    password: # 见小册开头《阿里云服务账号》<br>    database: 1<br>    <br># 调整控制台日志格式，稍微精简一些（非必要操作）<br>logging:<br>  pattern:<br>    console: &quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %thread - %msg%n&quot;<br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--大家也可以单独引入Redisson依赖，然后通过@Configuration自己配置RedissonClient--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>然后就可以在test包下测试了~</p><h2 id="lock-方法初探"><a href="#lock-方法初探" class="headerlink" title="lock()方法初探"></a>lock()方法初探</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RLockTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRLock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>::testLockOne).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>::testLockTwo).start();<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">200</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLockOne</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;bravo1988_distributed_lock&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;testLockOne尝试加锁...&quot;</span>);<br>            lock.lock();<br>            log.info(<span class="hljs-string">&quot;testLockOne加锁成功...&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;testLockOne业务开始...&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">50</span>);<br>            log.info(<span class="hljs-string">&quot;testLockOne业务结束...&quot;</span>);<br>            lock.unlock();<br>            log.info(<span class="hljs-string">&quot;testLockOne解锁成功...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLockTwo</span><span class="hljs-params">()</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;bravo1988_distributed_lock&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;testLockTwo尝试加锁...&quot;</span>);<br>            lock.lock();<br>            log.info(<span class="hljs-string">&quot;testLockTwo加锁成功...&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;testLockTwo业务开始...&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">50</span>);<br>            log.info(<span class="hljs-string">&quot;testLockTwo业务结束...&quot;</span>);<br>            lock.unlock();<br>            log.info(<span class="hljs-string">&quot;testLockTwo解锁成功...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果</p><p>2020-11-21 14:24:33 - Thread-3 - testLockTwo尝试加锁…</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne尝试加锁…</p><p>=====&gt; testLockOne()执行过程中，testLockTwo()一直阻塞 &lt;=====</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne加锁成功…</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne业务开始…</p><p>2020-11-21 14:25:23 - Thread-2 - testLockOne业务结束…</p><p>2020-11-21 14:25:23 - Thread-2 - testLockOne解锁成功…</p><p>=====&gt; testLockOne()执行结束释放锁，testLockTwo()抢到锁 &lt;=====</p><p>2020-11-21 14:25:23 - Thread-3 - testLockTwo加锁成功…</p><p>2020-11-21 14:25:23 - Thread-3 - testLockTwo业务开始…</p><p>2020-11-21 14:26:13 - Thread-3 - testLockTwo业务结束…</p><p>2020-11-21 14:26:13 - Thread-3 - testLockTwo解锁成功…</p><p>通过上面的代码，我们有以下疑问：</p><ul><li><p>lock()方法是原子性的吗？</p></li><li><p>lock()有设置过期时间吗？是多少？</p></li><li><p>lock()实现锁续期了吗？</p></li><li><p>lock()方法怎么实现阻塞的？又怎么被唤醒？</p></li></ul><p>先忘了这些，跟着我们走一遍lock()源码就明白了。</p><h1 id="lock-源码解析"><a href="#lock-源码解析" class="headerlink" title="lock()源码解析"></a>lock()源码解析</h1><p>lock()加锁，去除异常的情况，无非加锁成功、加锁失败两种情况，我们先看加锁成功的情况。</p><h2 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h2><p>我们从这段最简单的代码入手：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RLockTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLockSuccess</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;bravo1988_distributed_lock&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;准备加锁...&quot;</span>);<br>        lock.lock();<br>        log.info(<span class="hljs-string">&quot;加锁成功...&quot;</span>);<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">300</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>大家跟着我们先打几个断点（SpringBoot2.3.4）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952885069-f4e16307-9030-4a38-b154-30cd4f7f5a74-20210923224243500.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952773563-dca85b18-f11c-4511-8fdb-a737075fb5fd-20210923224252102.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952860890-484897da-0ee6-45ea-8179-ddf6f357316a-20210923224340729.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952928238-e1dc233d-d877-423f-8561-f121c821d5c8-20210923224347621.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952952657-d35ba600-5996-4a67-adee-0c39535f728c-20210923224354124.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952984223-bf8c4bda-866f-406f-b7f8-c369b6d9b1ea-20210923224359530.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605953023756-2fc503b2-44bb-47c9-baf6-a095fef000e1-20210923224410403.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605953051967-7f6f6fb5-cfba-46a5-80d1-e83f19efb80c-20210923224418693.png" alt="img"></p><p>注意啊，把截图中能看到的断点都打上。</p><p>OK，接着大家自己启动DEBUG，感受一下大致流程，然后看下面的注释：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// redisson.lock()</span><br><span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock(-<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 为了方便辨认，我直接把传进来的参数写在参数列表上</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> leaseTime=-<span class="hljs-number">1</span>, TimeUnit unit=<span class="hljs-keyword">null</span>, <span class="hljs-keyword">boolean</span> interruptibly=<span class="hljs-keyword">false</span>)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 获取当前线程id</span><br>    <span class="hljs-keyword">long</span> threadId = Thread.currentThread().getId();<br>    <span class="hljs-comment">// 尝试上锁。上锁成功返回null，上锁失败返回ttl</span><br>    Long ttl = tryAcquire(-<span class="hljs-number">1</span>, leaseTime=-<span class="hljs-number">1</span>, unit=<span class="hljs-keyword">null</span>, threadId=<span class="hljs-number">666</span>);<br>    <span class="hljs-comment">// 上锁成功，方法结束，回到主线程执行业务啦（后台有个定时任务在给当前锁续期）</span><br>    <span class="hljs-keyword">if</span> (ttl == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 上锁成功就不走下面的流程了，所以这里直接省略</span><br>    <span class="hljs-comment">// 略：加锁失败后续流程...</span><br>&#125;<br><br><span class="hljs-comment">// 尝试上锁。上锁成功返回null，上锁失败返回【当前已经存在的锁】的ttl，方便调用者判断多久之后能重新获取锁</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Long <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=-<span class="hljs-number">1</span>, TimeUnit unit=<span class="hljs-keyword">null</span>, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>)</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 有两次调用：1.tryAcquireAsync()返回Future 2.从Future获取异步结果（异步结果就是ttl）</span><br><span class="hljs-comment">    * 重点是tryAcquireAsync()</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> get(tryAcquireAsync(waitTime=-<span class="hljs-number">1</span>, leaseTime=-<span class="hljs-number">1</span>, unit=<span class="hljs-keyword">null</span>, threadId=<span class="hljs-number">666</span>));<br>&#125;<br><br><span class="hljs-comment">// 获取过期时间（非重点）</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> &lt;V&gt; <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(RFuture&lt;V&gt; future)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> commandExecutor.get(future);<br>&#125;<br><br><span class="hljs-comment">// 重点，加锁后返回RFuture，内部包含ttl。调用本方法可能加锁成功，也可能加锁失败，外界可以通过ttl判断</span><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">RFuture&lt;Long&gt; <span class="hljs-title">tryAcquireAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=-<span class="hljs-number">1</span>, TimeUnit unit=<span class="hljs-keyword">null</span>, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>)</span> </span>&#123;<br><br>    <span class="hljs-comment">// lock()默认leaseTime=-1，所以会跳过if</span><br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行lua脚本，尝试加锁并返回RFuture。这个方法是异步的，其实是把任务提交给线程池</span><br>    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(<br>                                            waitTime=-<span class="hljs-number">1</span>,<br>                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=<span class="hljs-number">30</span>秒,<br>                                            TimeUnit.MILLISECONDS, <br>                                            threadId=<span class="hljs-number">666</span>, <br>                                            RedisCommands.EVAL_LONG);<br><br>    <span class="hljs-comment">// 设置回调方法，异步线程与Redis交互得到结果后会回调BiConsumer#accept()</span><br>    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>        <span class="hljs-comment">// 发生异常时直接return</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 说明加锁成功</span><br>        <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 启动额外的线程，按照一定规则给当前锁续期</span><br>            scheduleExpirationRenewal(threadId);<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-comment">// 返回RFuture，里面有ttlRemaining</span><br>    <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>&#125;<br><br><br><span class="hljs-comment">// 执行lua脚本尝试上锁</span><br>&lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=<span class="hljs-number">30</span>*<span class="hljs-number">1000</span>, TimeUnit unit=毫秒, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;<br>    internalLockLeaseTime = unit.toMillis(leaseTime);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 大家去看一下evalWriteAsync()的参数列表，看看每个参数都代表什么，就能理解KEYS[]和ARGV[]以及整个脚本什么意思了</span><br><span class="hljs-comment">     * 如果你仔细看lua脚本，就会明白：加锁成功时返回ttlRemaining=null，加锁失败时返回ttlRemaining=xxx（上一个锁还剩多少时间）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 另外，我们自定义的Redis分布式锁采用了IdUtil生成节点id，和getLockName(threadId)本质是一样的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, command,<br>            <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,<br>            Collections.singletonList(getName()), internalLockLeaseTime, getLockName(threadId));<br>&#125;<br><br><span class="hljs-comment">// 向Redis服务器发送脚本并返回RFuture，大家可以近似看成：往线程池提交一个任务，然后将异步结果封装到CompletableFuture</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">evalWriteAsync</span><span class="hljs-params">(String key, Codec codec, RedisCommand&lt;T&gt; evalCommandType, String script, List&lt;Object&gt; keys, Object... params)</span> </span>&#123;<br>    CommandBatchService executorService = createCommandBatchService();<br>    RFuture&lt;T&gt; result = executorService.evalWriteAsync(key, codec, evalCommandType, script, keys, params);<br>    <span class="hljs-keyword">if</span> (!(commandExecutor <span class="hljs-keyword">instanceof</span> CommandBatchService)) &#123;<br>        executorService.executeAsync();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605956150610-2ce6fbe0-577a-4ab1-9540-a1d176038d02-20210923224433312.png" alt="img"></p><p>整个流程比较简单，只有两个难点：</p><ul><li>lua脚本写了啥</li><li>ttlRemainingFuture.onComplete()有什么作用</li></ul><h2 id="lua脚本解读"><a href="#lua脚本解读" class="headerlink" title="lua脚本解读"></a>lua脚本解读</h2><p>大家可以通过evalWriteAsync()的参数列表推导出KEYS、ARGV分别是什么：</p><p>KEYS[] =&gt; Collections.singletonList(getName())</p><p>ARGV[] =&gt; internalLockLeaseTime, getLockName(threadId)</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 如果不存在锁：&quot;bravo1988_distributed_lock&quot;</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 使用hincrby设置锁：hincrby bravo1988_distributed_lock a1b2c3d4:666 1</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>); <br>    <span class="hljs-comment">-- 设置过期时间。ARGV[1]==internalLockLeaseTime</span><br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]); <br>    <span class="hljs-comment">-- 返回null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>; <br>    <span class="hljs-keyword">end</span>; <br><br><span class="hljs-comment">-- 如果当前节点已经设置&quot;bravo1988_distributed_lock&quot;（注意，传了ARGV[2]==节点id）</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span> <br>    <span class="hljs-comment">-- 就COUNT++，可重入锁</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>); <br>    <span class="hljs-comment">-- 设置过期时间。ARGV[1]==internalLockLeaseTime</span><br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]); <br>  <span class="hljs-comment">-- 返回null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">end</span>; <br><br><span class="hljs-comment">-- 已经存在锁，且不是当前节点设置的，就返回锁的过期时间ttl</span><br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;pttl&#x27;</span>, KEYS[<span class="hljs-number">1</span>]);<br></code></pre></div></td></tr></table></figure><p>总的来说，Redisson设计的分布式锁是采用hash结构：</p><p><strong>LOCK_NAME</strong>（锁的KEY）+ <strong>CLIENT_ID</strong>（节点ID）+ <strong>COUNT</strong>（重入次数）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605957127624-694aaebe-2293-4641-83e8-8649823ec961-20210923224458173.png" alt="img"></p><h2 id="回调函数的作用"><a href="#回调函数的作用" class="headerlink" title="回调函数的作用"></a>回调函数的作用</h2><p>之前我们已经学过CompletableFuture的回调机制：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605406493819-8575b4ca-57e6-4afc-aba7-4840bee68138-20210923224505808.png" alt="img">RFuture#onComplete()和它很相似：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>        <span class="hljs-comment">// 发生异常时直接return</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 说明加锁成功</span><br>        <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 启动额外的线程，按照一定规则给当前锁续期</span><br>            scheduleExpirationRenewal(threadId);<br>        &#125;<br>    &#125;);<br></code></pre></div></td></tr></table></figure><p>onComplete()应该也是把回调函数推到stack中，方便后面异步线程弹栈执行。</p><p>至此，我们已经解决了之前的两个问题：</p><ul><li>lua脚本是什么意思（见注释）</li><li>ttlRemainingFuture.onComplete()有什么作用（设置回调函数，等会儿会有线程调用）</li></ul><p>虽然在CompletableFuture中已经强调过，这里还是要提一下：<strong>被回调的不是onComplete(BiConsumer)，而是****BiConsumer#accept()。</strong>主线程在调用onComplete(BiConsumer)时把它作为参数传入，然后被推入栈中<strong>：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BiConsumer consumer = (ttlRemaining, e) -&gt; &#123;<br>    <span class="hljs-comment">// 发生异常时直接return</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 说明加锁成功</span><br>    <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 启动额外的线程，按照一定规则给当前锁续期</span><br>        scheduleExpirationRenewal(threadId);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Redisson异步回调机制"><a href="#Redisson异步回调机制" class="headerlink" title="Redisson异步回调机制"></a>Redisson异步回调机制</h2><p>现在已经确定了尝试加锁后会返回RFuture，并且我们可以通过RFuture做两件事：</p><ul><li>通过RFuture获取ttlRemaining，也就是上一个锁的过期时间，如果为null则本次加锁成功，否则加锁失败，需要等待</li><li>通过RFuture设置回调函数</li></ul><p>现在疑问是：</p><ul><li><p>异步线程是谁，哪来的？</p></li><li><p>onComplete()设置的回调函数是干嘛的？</p></li><li><p>回调时的参数(ttlRemaining, e)哪来的？</p></li></ul><p>1、3两个问题非常难，源码比较绕，这里就带大家感性地体验一下，有兴趣可以自己跟源码了解。清除刚才的全部断点，只留下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958482130-e4ac51fd-c7c6-4a1c-9b8d-bc9ce3fab6a6-20210923224532665.png" alt="img"></p><p>再次DEBUG，线程会先到达return ttlRemainingFuture，随后回调BiConsumer#accept()：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958677303-5991020a-4ff9-4399-a71c-cefd1824931c-20210923224542928.png" alt="img"></p><p>回调时线程变了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958821470-c3a87de8-f677-4990-8a52-a42e572696d0-20210923224550800.png" alt="img"></p><p>大家有兴趣可以自己顺着调用栈逆推回去，还是比较复杂的，涉及到NIO、Promise等，源头还是在线程池，但其中又设计了Listeners的收集和循环唤醒：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">evalWriteAsync</span><span class="hljs-params">(String key, Codec codec, RedisCommand&lt;T&gt; evalCommandType, String script, List&lt;Object&gt; keys, Object... params)</span> </span>&#123;<br>    CommandBatchService executorService = createCommandBatchService();<br>    RFuture&lt;T&gt; result = executorService.evalWriteAsync(key, codec, evalCommandType, script, keys, params);<br>    <span class="hljs-keyword">if</span> (!(commandExecutor <span class="hljs-keyword">instanceof</span> CommandBatchService)) &#123;<br>        executorService.executeAsync();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总之，目前为止我们只需要知道：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605959979086-b4d49fc5-a37b-4872-a0d4-3f9c5a560f9d-20210923224610738.png" alt="img"></p><p>我们虽然不知道onComplete()具体如何实现回调（比CompletableFuture复杂得多），但是我们知道锁续期和RFuture的回调机制相关！</p><h2 id="Redisson如何实现锁续期"><a href="#Redisson如何实现锁续期" class="headerlink" title="Redisson如何实现锁续期"></a>Redisson如何实现锁续期</h2><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605960740451-f70e601b-0432-44a1-8e3c-34ff56b3b1c9-20210923224618495.png" alt="img"></p><p>最终会进入：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renewExpiration</span><span class="hljs-params">()</span> </span>&#123;<br>    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>    <span class="hljs-keyword">if</span> (ee == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 启动一个定时器：Timeout newTimeout(TimerTask task, long delay, TimeUnit unit);</span><br><span class="hljs-comment">    * 执行规则是：延迟internalLockLeaseTime/3后执行</span><br><span class="hljs-comment">    * 注意啊，每一个定时任务只执行一遍，而且是延迟执行。</span><br><span class="hljs-comment">    * </span><br><span class="hljs-comment">    * 那么问题就来了：</span><br><span class="hljs-comment">    * 1.internalLockLeaseTime/3是多久呢？</span><br><span class="hljs-comment">    * 2.如果定时任务只执行一遍，似乎解决不了问题啊，本质上和我们手动设置过期时间一样：多久合适呢？</span><br><span class="hljs-comment">    */</span> <br>    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="hljs-keyword">new</span> TimerTask() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>            <span class="hljs-keyword">if</span> (ent == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            Long threadId = ent.getFirstThreadId();<br>            <span class="hljs-keyword">if</span> (threadId == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 定时任务的目的是：重新执行一遍lua脚本，完成锁续期，把锁的ttl拨回到30s</span><br>            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);<br>            <span class="hljs-comment">// 设置了一个回调</span><br>            future.onComplete((res, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>                    log.error(<span class="hljs-string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="hljs-string">&quot; expiration&quot;</span>, e);<br>                    <span class="hljs-comment">// 如果宕机了，就不会续期了</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">// 如果锁还存在（没有unLock，说明业务还没结束），递归调用当前方法，不断续期</span><br>                <span class="hljs-keyword">if</span> (res) &#123;<br>                    <span class="hljs-comment">// reschedule itself</span><br>                    renewExpiration();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;, internalLockLeaseTime / <span class="hljs-number">3</span>, TimeUnit.MILLISECONDS);<br>    <br>    ee.setTimeout(task);<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 重新执行evalWriteAsync()，和加锁时的lua脚本比较类似，但有点不同</span><br><span class="hljs-comment">* 这里设置expire的参数也是internalLockLeaseTime</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 看来我们不得不去调查一下internalLockLeaseTime了！</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> RFuture&lt;Boolean&gt; <span class="hljs-title">renewExpirationAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> threadId)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,<br>            <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return 1; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-string">&quot;return 0;&quot;</span>,<br>            Collections.singletonList(getName()),<br>            internalLockLeaseTime, getLockName(threadId));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果你给renewExpirationAsync()打上断点，会发现每隔10秒，定时任务就会执行一遍：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969467749-64ac2a12-3b6d-4762-abf8-b457be9dc0e5-20210923224633703.png" alt="img"></p><p>联想到定时任务的delay是internalLockLeaseTime/3，所以推测internalLockLeaseTime为30秒。</p><p>点击internalLockLeaseTime，很容易跳转到对应的字段：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969607142-5897d87e-0841-4647-8ad1-02b308a7e66c-20210923224640385.png" alt="img"></p><p>再顺着getLockWatchdogTimeout()跳转，很快就会发现</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969777097-2f955c29-3f28-4ce2-a12a-b76455fb1e1e-20210923224647544.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969804198-7d2b61c3-da1b-4de1-aecd-5777a4994ee5-20210923224657200.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969855073-00958650-adfb-49c5-972e-37e797f5f23d-20210923224708071.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969922018-f5dc76c3-0566-4d14-9018-1ea86f17ff1c-20210923224716263.png" alt="img"></p><p>确实是30秒。</p><p>梳理一下所谓的Watchdog锁续期机制：</p><ul><li>lock()第一次成功加锁时，设置的锁过期时间默认30秒，这个值来自Watchdog变量</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 重点</span><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">RFuture&lt;Long&gt; <span class="hljs-title">tryAcquireAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=-<span class="hljs-number">1</span>, TimeUnit unit=<span class="hljs-keyword">null</span>, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>)</span> </span>&#123;<br><br>    <span class="hljs-comment">// lock()默认leaseTime=-1，所以会跳过if</span><br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行lua脚本加锁，返回RFuture。第二个参数就是leaseTime，来自LockWatchdogTimeout！！！</span><br>    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(<br>                                            waitTime=-<span class="hljs-number">1</span>,<br>                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=<span class="hljs-number">30</span>秒,<br>                                            TimeUnit.MILLISECONDS, <br>                                            threadId=<span class="hljs-number">666</span>, <br>                                            RedisCommands.EVAL_LONG);<br><br>    <span class="hljs-comment">// 设置回调方法</span><br>    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>        <span class="hljs-comment">// 发生异常时直接return</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 说明加锁成功</span><br>        <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 启动额外的线程，按照一定规则给当前锁续期</span><br>            scheduleExpirationRenewal(threadId);<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-comment">// 返回RFuture，里面有ttlRemaining</span><br>    <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>&#125;<br><br><span class="hljs-comment">// 执行lua脚本上锁</span><br>&lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=<span class="hljs-number">30</span>*<span class="hljs-number">1000</span>, TimeUnit unit=毫秒, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;<br>    <span class="hljs-comment">// 略...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>onComplete()设置回调，等Redis调用回来后，异步线程回调BiConsumer#accept()，进入scheduleExpirationRenewal(threadId)，开始<strong>每隔internalLockLeaseTime/3时间就给锁续期</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605961851949-8de820bf-97f6-4330-a580-da4003cc2123-20210923224729646.png" alt="img"></p><p>和加锁一样，执行lua脚本其实很快，所以这里的future.onComplete()虽说是异步，但很快就会被调用，然后就会递归调用renewExpiration()，然后又是一个TimerTask()，<strong>隔****internalLockLeaseTime/3后又给锁续期。</strong></p><p><strong>也就是说，Redisson的Watchdog定时任务虽然只延迟执行一次，但每次调用都会递归，所以相当于：重复延迟执行。</strong></p><p>还记得之前学习CompletableFuture时我写的一行注释吗：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605970707587-a80fb37d-b89e-4742-b675-4bfe03ca8b0c-20210923224741535.png" alt="img"></p><p>也就是说，只要主线程的任务不结束，就会一直给锁续期。</p><p>锁释放有两种情况：</p><ul><li>任务结束，主动unLock()删除锁</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">redisson.lock();<br>task();<br>redisson.unLock();<br></code></pre></div></td></tr></table></figure><ul><li>任务结束，不调用unLock()，但由于守护线程已经结束，不会有后台线程继续给锁续期，过了30秒自动过期</li></ul><p>上面我们探讨的都是加锁成功的流程，直接ttl=null就返回了，后面一大坨都是加锁失败时的判断逻辑，其中涉及到：</p><ul><li><p>while(true)死循环</p></li><li><p>阻塞等待</p></li><li><p>释放锁时Redis的Publish通知（在后面的unLock流程会看到）</p></li><li><p>其他节点收到锁释放的信号后重新争抢锁</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975498344-dd4657b8-5442-4fcd-8693-9f5e81d09531-20210923224753386.png" alt="img"></p><p>整个过程还是非常复杂的，大家有精力可以自行百度了解，后面介绍unLock()时也会涉及一部分加锁失败相关内容。</p><h1 id="unLock-源码解析"><a href="#unLock-源码解析" class="headerlink" title="unLock()源码解析"></a>unLock()源码解析</h1><p>有了lock()的经验，unLock()就简单多了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975635261-dc6265a9-2950-433f-a7f1-d46445d0a01b-20210923224803834.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975844381-fff7bf1c-36e2-4f63-9fc8-f5af8ebc0e0a-20210923224809682.png" alt="img"></p><p>相信大家还是能推断出KEYS[]和ARGV[]，这里就直接给出答案了：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 参数解释：</span><br><span class="hljs-comment">-- KEYS[1] =&gt; &quot;bravo1988_distributed_lock&quot;</span><br><span class="hljs-comment">-- KEYS[2] =&gt; getChannelName()</span><br><span class="hljs-comment">-- ARGV[1] =&gt; LockPubSub.UNLOCK_MESSAGE</span><br><span class="hljs-comment">-- ARGV[2] =&gt; internalLockLeaseTime</span><br><span class="hljs-comment">-- ARGV[3] =&gt; getLockName(threadId)</span><br><br><span class="hljs-comment">-- 锁已经不存在，返回null</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">3</span>]) == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">end</span>;<br><br><span class="hljs-comment">-- 锁还存在，执行COUNT--（重入锁的反向操作）</span><br><span class="hljs-keyword">local</span> counter = redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">3</span>], <span class="hljs-number">-1</span>);<br><br><span class="hljs-comment">-- COUNT--后仍然大于0（之前可能重入了多次）</span><br><span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 设置过期时间</span><br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">-- COUNT--后小于等于0，删除锁，并向对应的Channel发送消息（NIO），消息类型是LockPubSub.UNLOCK_MESSAGE（锁释放啦，快来抢~）</span><br><span class="hljs-keyword">else</span> <br>    redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]);<br>    redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>, KEYS[<span class="hljs-number">2</span>], ARGV[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span>;<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br></code></pre></div></td></tr></table></figure><p>也就是说，当一个锁被释放时，原先持有锁的节点会通过NIO的Channel发送LockPubSub.UNLOCK_MESSAGE，告诉其他订阅的Client：我已经释放锁啦，快来抢啊！此时原本阻塞的其他节点就会重新竞争锁。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606010300656-f21b35bd-bd46-4f02-bf73-e2913664af28-20210923224832043.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606010321812-3803dd5d-3411-4060-84f1-2f797f56946e-20210923224838169.png" alt="img"></p><p>而所谓重入和反重入，简单来说就是：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 加锁三次</span><br>redisson.lock();<br>redisson.lock();<br>redisson.lock();<br><span class="hljs-comment">// 执行业务</span><br>executeTask();<br><span class="hljs-comment">// 相应的，就要解锁三次</span><br>redisson.unLock();<br>redisson.unLock();<br>redisson.unLock();<br></code></pre></div></td></tr></table></figure><p>实际开发不会这样调用，但有时会出现子父类方法调用或者同一个线程反复调用使用同一把锁的多个方法，就会发生锁的重入（COUNT++），而当这些方法执行完毕逐个弹栈的过程中就会逐个unLock()解锁（COUNT–）。</p><h1 id="lock-leaseTime-unit-：自定义过期时间、且不续期"><a href="#lock-leaseTime-unit-：自定义过期时间、且不续期" class="headerlink" title="lock(leaseTime, unit)：自定义过期时间、且不续期"></a>lock(leaseTime, unit)：自定义过期时间、且不续期</h1><p>lock()默认会开启定时任务对锁进行续期，但Redisson还提供了另一个lock方法：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605976920059-cd4945a2-0932-4cc6-a2b5-9beac14475f9-20210923224857619.png" alt="img"></p><p>两个lock()唯一的区别是，内部调用lock()时，一个传了leaseTime=-1，另一个传了我们自己的leaseTime。对于外部调用者来说：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">redisson.lock();<br>redisson.lock(-<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>);<br></code></pre></div></td></tr></table></figure><p>这两种写法其实一样。</p><p>当然了，通常会传入有意义的leaseTime：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605977159145-10176f3a-8e5c-4d34-9f82-d5a9a684c15e-20210923224909434.png" alt="img"></p><p><strong>这种写法除了更改了锁的默认ttl时间外，还阉割了锁续期功能。</strong>也就是说，10秒后如果任务还没执行完，就会和我们手写的Redis分布式锁一样，自动释放锁。</p><p>为什么锁续期的功能失效了呢？留给大家自己解答，这里只给出参考答案：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 重点</span><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">RFuture&lt;Long&gt; <span class="hljs-title">tryAcquireAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=-<span class="hljs-number">1</span>, TimeUnit unit=<span class="hljs-keyword">null</span>, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>)</span> </span>&#123;<br><br>    <span class="hljs-comment">// lock()默认leaseTime=-1，会跳过这个if执行后面的代码。但如果是lock(10, TimeUnit.SECONDS)，会执行if并跳过后面的代码。</span><br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 其实和下面的tryLockInnerAsync()除了时间不一样外，没什么差别</span><br>        <span class="hljs-keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>    &#125;<br><br>    <span class="hljs-comment">// 但由于上面直接return了，所以下面的都不会执行！！</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(</span><br><span class="hljs-comment">                                            waitTime=-1,</span><br><span class="hljs-comment">                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=30秒,</span><br><span class="hljs-comment">                                            TimeUnit.MILLISECONDS, </span><br><span class="hljs-comment">                                            threadId=666, </span><br><span class="hljs-comment">                                            RedisCommands.EVAL_LONG);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 设置回调方法（不会执行！！）</span><br><span class="hljs-comment">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="hljs-comment">        // 发生异常时直接return</span><br><span class="hljs-comment">        if (e != null) &#123;</span><br><span class="hljs-comment">            return;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        // 说明加锁成功</span><br><span class="hljs-comment">        if (ttlRemaining == null) &#123;</span><br><span class="hljs-comment">            // 启动额外的线程，按照一定规则给当前锁续期</span><br><span class="hljs-comment">            scheduleExpirationRenewal(threadId);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 不会执行！！</span><br><span class="hljs-comment">    return ttlRemainingFuture;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>&#125;<br><br><span class="hljs-comment">// 执行lua脚本加锁</span><br>&lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> waitTime=-<span class="hljs-number">1</span>, <span class="hljs-keyword">long</span> leaseTime=<span class="hljs-number">30</span>*<span class="hljs-number">1000</span>, TimeUnit unit=毫秒, <span class="hljs-keyword">long</span> threadId=<span class="hljs-number">666</span>, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;<br>    <span class="hljs-comment">// 略...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>也就是说，直接执行lua加锁就返回了，没有机会启动定时任务和递归…</p><h1 id="tryLock-系列：让调用者自行决定加锁失败后的操作"><a href="#tryLock-系列：让调用者自行决定加锁失败后的操作" class="headerlink" title="tryLock()系列：让调用者自行决定加锁失败后的操作"></a>tryLock()系列：让调用者自行决定加锁失败后的操作</h1><p>之前我们已经观察到，如果多个节点都调用lock()，那么没获取到锁的节点线程会<strong>阻塞</strong>，直到原先持有锁的节点删除锁并publish LockPubSub.UNLOCK_MESSAGE 。</p><p>但如果调用者不希望阻塞呢？他有可能想着：如果加锁失败，我就直接放弃。</p><p>是啊，毕竟尝试加锁的目的可能完全相反：</p><ul><li>在保证线程安全的前提下，尽量让所有线程都执行成功</li><li>在保证线程安全的前提下，只让一个线程执行成功</li></ul><p>前者适用于秒杀、下单等操作，希望尽最大努力达成；后者适用于定时任务，只要让一个节点去执行，没有获取锁的节点应该fast-fail（快速失败）。</p><p>也就是说，节点获锁失败后，理论上可以有各种各样的处理方式：</p><ul><li><p>阻塞等待</p></li><li><p>直接放弃</p></li><li><p>试N次再放弃</p></li><li><p>…</p></li></ul><p><strong>但lock、****lock(leaseTime, timeUnit)替我们写死了：阻塞等待。</strong>即使lock(leaseTime, unit)，其实也是阻塞等待，只不过不会像lock()一样不断续期。</p><p>究其原因，主要是lock()这些方法对于加锁失败的判断是在内部写死的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605978662886-e09f2b51-ccb8-4fdb-b7f2-b2b162d0c57d-20210923224924265.png" alt="img"></p><p>而tryLock()方法则去掉了这层中间判断，<strong>把结果直接呈递到调用者面前，让调用者自己决定加锁失败后如何处理：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605978761456-207d8919-5a9e-451e-9460-3b4498f1b86c-20210923224932016.png" alt="img"></p><p>tryLock()直接返回true（加锁成功）和false（加锁失败），后续如何处理，全凭各个节点自己做出决定。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTryLock</span><span class="hljs-params">()</span> </span>&#123;<br>    RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;bravo1988_distributed_lock&quot;</span>);<br>    <span class="hljs-keyword">boolean</span> b = lock.tryLock();<br>    <span class="hljs-keyword">if</span> (b) &#123;<br>        <span class="hljs-comment">// 业务操作...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用立即结束，不阻塞</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样讲可能有点抽象，大家可以分别点进lock()和tryLock()，自行体会。总之，tryLock()中间少了一大块逻辑，因为它不插手结果的判断。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606181778959-3b05f3f9-ba72-4ada-9d4b-cb17f2871d91-20210923224943457.png" alt="img"></p><p>另外，tryLock()在加锁成功的情况下，其实和lock()是一样的，也会触发锁续期：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979113544-fd5fd678-27b0-4ee8-af1b-bb8e82b6cf5b-20210923224950350.png" alt="img"></p><p>如果你不希望触发锁续期，可以像lock(leaseTime, unit)一样指定过期时间，还可以指定加锁失败后等待多久：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLockSuccess</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;bravo1988_distributed_lock&quot;</span>);<br>    <span class="hljs-comment">// 基本等同于lock()，加锁成功也【会自动锁续期】，但获锁失败【立即返回false】，交给调用者判断是否阻塞或放弃</span><br>    lock.tryLock();<br>    <span class="hljs-comment">// 加锁成功仍然【会自动锁续期】，但获锁失败【会等待10秒】，看看这10秒内当前锁是否释放，如果是否则尝试加锁</span><br>    lock.tryLock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-comment">// 加锁成功【不会锁续期】，加锁失败【会等待10秒】，看看这10秒内当前锁是否释放，如果是否则尝试加锁</span><br>    lock.tryLock(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意哈，只传两个参数时，那个time其实是传给waitTime的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979480581-3f3ecda4-159e-475a-80d3-9854b1affea3-20210923225001508.png" alt="img"></p><p>我们之前操作的都是leaseTime，此时还是-1，也就是说如果加锁成功，还是会锁续期。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979506461-ae56c20c-6a92-44be-ac30-0944c8caaa47-20210923225007411.png" alt="img"></p><p>那waitTime是用来控制什么的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979722684-793f715f-e2ed-498f-98e1-68b8d69519e8-20210923225013679.png" alt="img"></p><p>简而言之：</p><ul><li>tryLock()加锁失败会立即返回false，而加了waitTime可以手动指定阻塞等待的时间（等一等，万一行呢）</li><li>leaseTime的作用没变，控制的是加锁成功后要不要续期</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606183066878-ce4cc7de-8cc1-4dd1-995a-b663df428550-20210923225020644.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612490364124-289ef177-9b03-4cc0-9168-f6270728cff9-20210923225025657.jpeg" alt="img"></p><p>至此，分布式锁章节暂时告一段段落。大家有兴趣的话，可以把上一篇花里胡哨的定时任务用Redisson改写，去掉Redis Message Queue（但定时任务最好还是用xxl-job等）。</p><p>Redisson的具体使用方法可以参考尚硅谷雷丰阳老师的讲解：</p><p><a href="https://www.bilibili.com/video/BV18a4y1L7nv?p=57">https://www.bilibili.com/video/BV18a4y1L7nv?p=57</a></p><h1 id="Redisson分布式锁的缺陷"><a href="#Redisson分布式锁的缺陷" class="headerlink" title="Redisson分布式锁的缺陷"></a>Redisson分布式锁的缺陷</h1><p>在哨兵模式或者主从模式下，如果master实例宕机，可能导致多个节点同时完成加锁。</p><p>以主从模式为例，由于所有的写操作都是先在master上进行，然后再同步给各个slave节点，所以master与各个slave节点之间的数据具有一定的延迟性。对于Redisson分布式锁而言，比如客户端刚对master写入Redisson锁，然后master异步复制给各个slave节点，但这个过程中master节点宕机了，其中一个slave节点经过选举变成了master节点，好巧不巧，这个slave还没同步到Reddison锁，所以其他客户端可能再次加锁。</p><p>具体情况，大家可以百度看看，解决方案也比较多。</p><p>还是那句话，但凡涉及到分布式，都没那么简单。有时引入一个解决方案后，我们不得不面对另一个问题。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Redis分布式锁(中)</title>
    <link href="/2020/10/17/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%AD)/"/>
    <url>/2020/10/17/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%AD)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Demo构思"><a href="#Demo构思" class="headerlink" title="Demo构思"></a>Demo构思</h1><p>在我看来，同样需要使用锁，动机可能完全相反：</p><ul><li>在保证线程安全的前提下，尽量让所有线程都执行成功</li><li>在保证线程安全的前提下，只让一个线程执行成功</li></ul><p>前者适用于秒杀等场景。作为商家，当然希望在不发生线程安全问题的前提下，让每一个订单都生效，直到商品售罄。此时分布式锁的写法可以是<strong>“不断重试”</strong>或<strong>“阻塞等待”</strong>，即：递归或while true循环尝试获取、阻塞等待。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604506622183-fa1bd017-75eb-485a-beed-866826fda0a8-20210923221540849.png" alt="img"></p><p>而后者适用于分布式系统或多节点项目的定时任务，比如同一份代码部署在A、B两台服务器上，而数据库共用同一个。如果不做限制，那么在同一时刻，两台服务器都会去拉取列表执行，会发生任务重复执行的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604217589786-b289e306-b9c9-4109-8dcc-9c444b5d4354-20210923221547128.png" alt="img"></p><p>此时可以考虑使用分布式锁，在cron触发的时刻只允许一个线程去往数据库拉取任务：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604217793953-9468293c-633e-49dc-9020-c69e34cb3b3e-20210923221555357.png" alt="img"></p><p>在实现Redis分布式锁控制定时任务唯一性的同时，我们引入之前的Redis消息队列。注意，这与Redis分布式锁本身无关，就是顺便复习一遍Redis消息队列而已，大家可以只实现Redis分布式锁+定时任务的部分。</p><p>整个Demo的结构大致如图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604218829172-5ce20fc4-99d0-4a26-9b62-053c240660bd-20210923221600743.png" alt="img"></p><p>当然，实际项目中一般是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604489189715-299c40b4-85c2-47c7-9bc4-75aeee053a45-20210923221605971.png" alt="img"></p><h1 id="分布式锁为什么难设计？"><a href="#分布式锁为什么难设计？" class="headerlink" title="分布式锁为什么难设计？"></a>分布式锁为什么难设计？</h1><p>首先，要和大家说一下，但凡牵涉到分布式的处理，没有一个是简单的，上面的Demo设计也不过是玩具，用来启发 大家的思路。</p><p>为什么要把Demo设计得这么复杂呢？哈哈，因为这是我在上一家公司自己设计的，遇到了很多坑…拿出来自嘲一番，与各位共勉。</p><p>我当时的设计思路是：</p><p>由于小公司没有用什么Elastic-Job啥的，就是很普通的多节点部署。为了避免任务重复执行，我想设计一个分布式锁。但因为当时根本不知道Redisson，所以就自己百度了Redis实现分布式锁的方式，然后依葫芦画瓢自己手写了一个 。</p><p>但我写完Redis分布式锁后，在实际测试过程中发现还需要考虑锁的失效时间…</p><p>这里有两个问题：</p><ul><li>为什么要设置锁的过期时间？</li><li>锁的过期时间设置多久合适？</li></ul><p>最简单的实现方案是这样的，一般没问题：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604506681868-7e03eae9-f974-481b-be00-d32180cd2fe2-20210923221614779.png" alt="img"></p><p>但极端的情况下（项目在任务进行时重启或意外宕机），可能当前任务来不及解锁就挂了（死锁），那么下一个任务就会一直被锁在方法外等待。就好比厕所里有人被熏晕了，没法开门，而外面的人又进不去…</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604506732285-dedfe3a9-bbcd-422f-bc35-fe215bbf0035-20210923221619771.png" alt="img"></p><p>此时需要装一个自动解锁的门，到时间自动开门，也就是要给锁设置一个过期时间。但紧接着又会有第二个问题：锁的失效时间设多长合适？</p><p><strong>很难定。</strong></p><p>因为随着项目的发展，<strong>定时任务的执行时间很可能是变化的。</strong></p><p>如果设置时间过长，极端点，定为365天。假设任务正常执行，比如10分钟就结束，那么线程继续往下就会执行unLock()主动解锁。但万一和上面一样宕机了，那么这个锁就要等365天后才解开。注意，宕机可不像JVM异常，它压根不会去执行finally里的unLock()。这种情况好比有个人在厕所里上大号直接掉坑里了，而自动门默认365天打开…所以，锁过期时间设置过长的坏处，本质是一旦发生宕机来不及解锁，那么过期时间越长，影响面越广，会导致其他操作阻滞。</p><p>如果设置时间过短，上一个人还没拉完，门就“咔嚓”一声开了，尴尬不，重复执行了。</p><p>终上所述，我当时之所以设计得这么复杂，就是想尽量缩短任务执行的时间，让它尽可能短（拉取后直接丢给队列，自己不处理），这样锁的时间一般设置30分钟就没啥问题。另外，对于死锁问题，我当时没有考虑宕机的情况，只考虑了意外重启…问题还有很多，文末会再总结。</p><p>请大家阅读下面代码时思考两个问题：</p><ul><li>Demo如何处理锁的过期时间</li><li>Demo如何防止死锁</li></ul><h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><p>新建一个空的SpringBoot项目。</p><p>拷贝下方代码，构建工程：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604495698917-9216d65d-baeb-4c25-8eda-4bc3adc0b593-20210923221627242.png" alt="img"></p><p>构建完以后，拷贝一份，修改端口号为8081，避免和原先的冲突</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604232665683-4d39ad7a-58f0-4bec-b043-d2e67eb68e7b-20210923221633686.png" alt="img"></p><h2 id="统一管理Redis-Key：RedisKeyConst"><a href="#统一管理Redis-Key：RedisKeyConst" class="headerlink" title="统一管理Redis Key：RedisKeyConst"></a>统一管理Redis Key：RedisKeyConst</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 统一管理Redis Key</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qiyu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisKeyConst</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分布式锁的KEY</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESUME_PULL_TASK_LOCK = <span class="hljs-string">&quot;resume_pull_task_lock&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简历异步解析任务队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESUME_PARSE_TASK_QUEUE = <span class="hljs-string">&quot;resume_parse_task_queue&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Redis消息队列：RedisMessageQueueConsumer"><a href="#Redis消息队列：RedisMessageQueueConsumer" class="headerlink" title="Redis消息队列：RedisMessageQueueConsumer"></a>Redis消息队列：RedisMessageQueueConsumer</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消费者，异步获取简历解析结果并存入数据库</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qiyu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisMessageQueueConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ContextRefreshedEvent</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisService redisService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AsyncResumeParser asyncResumeParser;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始监听RedisMessageQueue...&quot;</span>);<br>        CompletableFuture.runAsync(() -&gt; &#123;<br>            <span class="hljs-comment">// 大循环，不断监听队列任务（阻塞式）</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">// 阻塞监听</span><br>                ResumeCollectionDTO resumeCollectionDTO = (ResumeCollectionDTO) redisService.popQueue(RedisKeyConst.RESUME_PARSE_TASK_QUEUE, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>                <span class="hljs-keyword">if</span> (resumeCollectionDTO != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">int</span> rePullCount = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">int</span> retryCount = <span class="hljs-number">0</span>;<br>                    log.info(<span class="hljs-string">&quot;从队列中取出:&#123;&#125;&quot;</span>, resumeCollectionDTO.getName());<br>                    log.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始拉取简历:&#123;&#125;&quot;</span>, resumeCollectionDTO.getName());<br>                    Long asyncPredictId = resumeCollectionDTO.getAsyncPredictId();<br>                    <span class="hljs-comment">// 小循环，针对每一个任务多次调用第三方接口，直到获取最终结果或丢弃任务</span><br>                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            PredictResult result = asyncResumeParser.getResult(asyncPredictId);<br>                            rePullCount++;<br>                            <span class="hljs-comment">// 如果已经解析完毕</span><br>                            <span class="hljs-keyword">if</span> (result.getStatus() == <span class="hljs-number">2</span>) &#123;<br>                                <span class="hljs-comment">// 保存数据库</span><br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    log.info(<span class="hljs-string">&quot;简历:&#123;&#125;解析成功&quot;</span>, resumeCollectionDTO.getName());<br>                                    log.info(<span class="hljs-string">&quot;resultJson:&#123;&#125;&quot;</span>, result.getResultJson());<br>                                    ResumeCollectionDO resumeCollectionDO = objectMapper.readValue(result.getResultJson(), ResumeCollectionDO.class);<br>                                    log.info(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;保存简历:&#123;&#125;到数据库&quot;</span>, resumeCollectionDO);<br>                                    <span class="hljs-comment">// 归零</span><br>                                    rePullCount = <span class="hljs-number">0</span>;<br>                                    retryCount = <span class="hljs-number">0</span>;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                                    discardTask(resumeCollectionDTO);<br>                                    log.info(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;保存简历失败，丢弃任务&quot;</span>);<br>                                    rePullCount = <span class="hljs-number">0</span>;<br>                                    retryCount = <span class="hljs-number">0</span>;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                            &#125;<br>                            <span class="hljs-comment">// 远程服务还未解析完毕，重试</span><br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-keyword">if</span> (rePullCount &lt;= <span class="hljs-number">3</span>) &#123;<br>                                        <span class="hljs-comment">// 前3次重试，时间为1s间隔</span><br>                                        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                                        log.info(<span class="hljs-string">&quot;简历:&#123;&#125;尚未解析完毕, 准备进行第&#123;&#125;次重试, 停顿1s后进行&quot;</span>, resumeCollectionDTO.getName(), rePullCount);<br>                                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rePullCount &gt; <span class="hljs-number">3</span> &amp;&amp; rePullCount &lt;= <span class="hljs-number">6</span>) &#123;<br>                                        <span class="hljs-comment">// 说明任务比较耗时，加长等待时间</span><br>                                        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                                        log.info(<span class="hljs-string">&quot;简历:&#123;&#125;尚未解析完毕, 准备进行第&#123;&#125;次重试, 停顿2s后进行&quot;</span>, resumeCollectionDTO.getName(), rePullCount);<br>                                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rePullCount &gt; <span class="hljs-number">6</span> &amp;&amp; rePullCount &lt;= <span class="hljs-number">8</span>) &#123;<br>                                        <span class="hljs-comment">// 说明任务比较耗时，加长等待时间</span><br>                                        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                                        log.info(<span class="hljs-string">&quot;简历:&#123;&#125;尚未解析完毕, 准备进行第&#123;&#125;次重试, 停顿3s后进行&quot;</span>, resumeCollectionDTO.getName(), rePullCount);<br>                                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                                        discardTask(resumeCollectionDTO);<br>                                        log.info(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;多次拉取仍未得到结果, 丢弃简历:&#123;&#125;&quot;</span>, resumeCollectionDTO.getName());<br>                                        retryCount = <span class="hljs-number">0</span>;<br>                                        rePullCount = <span class="hljs-number">0</span>;<br>                                        <span class="hljs-keyword">break</span>;<br>                                    &#125;<br>                                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                                    discardTask(resumeCollectionDTO);<br>                                    log.info(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;任务中断异常, 简历:&#123;&#125;&quot;</span>, resumeCollectionDTO.getName());<br>                                    rePullCount = <span class="hljs-number">0</span>;<br>                                    retryCount = <span class="hljs-number">0</span>;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                            <span class="hljs-keyword">if</span> (retryCount &gt; <span class="hljs-number">3</span>) &#123;<br>                                discardTask(resumeCollectionDTO);<br>                                log.info(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;简历:&#123;&#125;重试&#123;&#125;次后放弃, rePullCount:&#123;&#125;, retryCount:&#123;&#125;&quot;</span>, resumeCollectionDTO.getName(), retryCount, rePullCount, retryCount);<br>                                rePullCount = <span class="hljs-number">0</span>;<br>                                retryCount = <span class="hljs-number">0</span>;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            retryCount++;<br>                            log.info(<span class="hljs-string">&quot;简历:&#123;&#125;远程调用异常, 准备进行第&#123;&#125;次重试...&quot;</span>, resumeCollectionDTO.getName(), retryCount);<br>                        &#125;<br>                    &#125;<br>                    log.info(<span class="hljs-string">&quot;break......&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discardTask</span><span class="hljs-params">(ResumeCollectionDTO task)</span> </span>&#123;<br>        <span class="hljs-comment">// 根据asyncPredictId删除任务...</span><br>        log.info(<span class="hljs-string">&quot;丢弃任务:&#123;&#125;...&quot;</span>, task.getName());<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="实体类：DO-DTO"><a href="#实体类：DO-DTO" class="headerlink" title="实体类：DO+DTO"></a>实体类：DO+DTO</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResumeCollectionDO</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简历id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简历名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResumeCollectionDTO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简历id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异步解析id，稍后根据id可获取最终解析结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long asyncPredictId;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简历名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="分布式锁：RedisService"><a href="#分布式锁：RedisService" class="headerlink" title="分布式锁：RedisService"></a>分布式锁：RedisService</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RedisService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向队列插入消息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue 自定义队列名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj   要存入的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushQueue</span><span class="hljs-params">(String queue, Object obj)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列取出消息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue    自定义队列名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout  最长阻塞等待时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit 时间单位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">popQueue</span><span class="hljs-params">(String queue, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试上锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String lockKey, String value, <span class="hljs-keyword">long</span> expireTime, TimeUnit timeUnit)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据MACHINE_ID解锁（只能解自己的）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">unLock</span><span class="hljs-params">(String lockKey, String value)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁，不管是不是自己的</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseLock</span><span class="hljs-params">(String lockKey, String value)</span></span>;<br><br>&#125;<br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RedisService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向队列插入消息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue 自定义队列名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj   要存入的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushQueue</span><span class="hljs-params">(String queue, Object obj)</span> </span>&#123;<br>        redisTemplate.opsForList().leftPush(queue, obj);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列取出消息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue    自定义队列名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout  最长阻塞等待时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit 时间单位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">popQueue</span><span class="hljs-params">(String queue, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForList().rightPop(queue, timeout, timeUnit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试上锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String lockKey, String value, <span class="hljs-keyword">long</span> expireTime, TimeUnit timeUnit)</span> </span>&#123;<br>        Boolean lock = redisTemplate.opsForValue().setIfAbsent(lockKey, value);<br>        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(lock)) &#123;<br>            redisTemplate.expire(lockKey, expireTime, timeUnit);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据MACHINE_ID解锁（只能解自己的）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLock</span><span class="hljs-params">(String lockKey, String value)</span> </span>&#123;<br>        String machineId = (String) redisTemplate.opsForValue().get(lockKey);<br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(machineId) &amp;&amp; machineId.equals(value)) &#123;<br>            redisTemplate.delete(lockKey);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁，不管是不是自己的</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseLock</span><span class="hljs-params">(String lockKey, String value)</span> </span>&#123;<br>        Boolean delete = redisTemplate.delete(lockKey);<br>        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(delete)) &#123;<br>            log.info(<span class="hljs-string">&quot;Spring启动，节点:&#123;&#125;成功释放上次简历汇聚定时任务锁&quot;</span>, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="定时任务：ResumeCollectionTask"><a href="#定时任务：ResumeCollectionTask" class="headerlink" title="定时任务：ResumeCollectionTask"></a>定时任务：ResumeCollectionTask</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResumeCollectionTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ContextRefreshedEvent</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当这份代码被部署到不同的服务器，启动时为每台机器分配一个唯一的机器ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MACHINE_ID = IdUtil.randomUUID();<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisService redisService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AsyncResumeParser asyncResumeParser;<br><br>    <span class="hljs-meta">@Scheduled(cron = &quot;0 */1 * * * ?&quot;)</span><br><span class="hljs-comment">//    @Scheduled(fixedDelay = 60 * 1000L)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resumeSchedule</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 尝试上锁，返回true或false，锁的过期时间设置为10分钟（实际要根据项目调整，这也是自己实现Redis分布式锁的难点之一）</span><br>        <span class="hljs-keyword">boolean</span> lock = redisService.tryLock(RedisKeyConst.RESUME_PULL_TASK_LOCK, MACHINE_ID, <span class="hljs-number">10</span>, TimeUnit.MINUTES);<br><br>        <span class="hljs-comment">// 如果当前节点成功获取锁，那么整个系统只允许当前程序去MySQL拉取待执行任务</span><br>        <span class="hljs-keyword">if</span> (lock) &#123;<br>            log.info(<span class="hljs-string">&quot;节点:&#123;&#125;获取锁成功，定时任务启动&quot;</span>, MACHINE_ID);<br>            <span class="hljs-keyword">try</span> &#123;<br>                collectResume();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.info(<span class="hljs-string">&quot;定时任务异常:&quot;</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                redisService.unLock(RedisKeyConst.RESUME_PULL_TASK_LOCK, MACHINE_ID);<br>                log.info(<span class="hljs-string">&quot;节点:&#123;&#125;释放锁，定时任务结束&quot;</span>, MACHINE_ID);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;节点:&#123;&#125;获取锁失败，放弃定时任务&quot;</span>, MACHINE_ID);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务主体：</span><br><span class="hljs-comment">     * 1.从数据库拉取符合条件的HR邮箱</span><br><span class="hljs-comment">     * 2.从HR邮箱拉取附件简历</span><br><span class="hljs-comment">     * 3.调用远程服务异步解析简历</span><br><span class="hljs-comment">     * 4.插入待处理任务到数据库，作为记录留存</span><br><span class="hljs-comment">     * 5.把待处理任务的id丢到Redis Message Queue，让Consumer去异步处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collectResume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 跳过1、2两步，假设已经拉取到简历</span><br>        log.info(<span class="hljs-string">&quot;节点:&#123;&#125;从数据库拉取任务简历&quot;</span>, MACHINE_ID);<br>        List&lt;ResumeCollectionDO&gt; resumeCollectionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        resumeCollectionList.add(<span class="hljs-keyword">new</span> ResumeCollectionDO(<span class="hljs-number">1L</span>, <span class="hljs-string">&quot;张三的简历.pdf&quot;</span>));<br>        resumeCollectionList.add(<span class="hljs-keyword">new</span> ResumeCollectionDO(<span class="hljs-number">2L</span>, <span class="hljs-string">&quot;李四的简历.html&quot;</span>));<br>        resumeCollectionList.add(<span class="hljs-keyword">new</span> ResumeCollectionDO(<span class="hljs-number">3L</span>, <span class="hljs-string">&quot;王五的简历.doc&quot;</span>));<br>        <span class="hljs-comment">// 模拟数据库查询耗时</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br><br>        log.info(<span class="hljs-string">&quot;提交任务到消息队列:&#123;&#125;&quot;</span>, resumeCollectionList.stream().map(ResumeCollectionDO::getName).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>)));<br><br>        <span class="hljs-keyword">for</span> (ResumeCollectionDO resumeCollectionDO : resumeCollectionList) &#123;<br>            <span class="hljs-comment">// 上传简历异步解析，得到异步结果id</span><br>            Long asyncPredictId = asyncResumeParser.asyncParse(resumeCollectionDO);<br><br>            <span class="hljs-comment">// 把任务插入数据库</span><br>            <span class="hljs-comment">// 略...</span><br><br>            <span class="hljs-comment">// 把任务丢到Redis Message Queue</span><br>            ResumeCollectionDTO resumeCollectionDTO = <span class="hljs-keyword">new</span> ResumeCollectionDTO();<br>            BeanUtils.copyProperties(resumeCollectionDO, resumeCollectionDTO);<br>            resumeCollectionDTO.setAsyncPredictId(asyncPredictId);<br>            redisService.pushQueue(RedisKeyConst.RESUME_PARSE_TASK_QUEUE, resumeCollectionDTO);<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 项目重启后先尝试删除之前的锁（如果存在），防止死锁等待</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> event the event to respond to</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;<br>        redisService.releaseLock(RedisKeyConst.RESUME_PULL_TASK_LOCK, MACHINE_ID);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="模拟第三方服务（异步）"><a href="#模拟第三方服务（异步）" class="headerlink" title="模拟第三方服务（异步）"></a>模拟第三方服务（异步）</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第三方提供给的简历解析服务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qiyu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncResumeParser</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟分配异步任务结果id，不用深究，没啥意义，反正每个任务都会得到一个id，稍后根据id返回最终解析结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicLong ASYNC_RESULT_ID = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Long, String&gt; results = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟第三方服务异步解析，返回解析结果</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resumeCollectionDO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">asyncParse</span><span class="hljs-params">(ResumeCollectionDO resumeCollectionDO)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> asyncPredictId = ASYNC_RESULT_ID.getAndIncrement();<br>        <span class="hljs-keyword">try</span> &#123;<br>            String resultJson = objectMapper.writeValueAsString(resumeCollectionDO);<br>            results.put(asyncPredictId, resultJson);<br>            <span class="hljs-keyword">return</span> asyncPredictId;<br>        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1L</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据异步id返回解析结果，但此时未必已经解析成功</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 解析状态</span><br><span class="hljs-comment">     * 0 初始化</span><br><span class="hljs-comment">     * 1 处理中</span><br><span class="hljs-comment">     * 2 调用成功</span><br><span class="hljs-comment">     * 3 调用失败</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> asyncPredictId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PredictResult <span class="hljs-title">getResult</span><span class="hljs-params">(Long asyncPredictId)</span> <span class="hljs-keyword">throws</span> ParseErrorException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 随机模拟异步解析的状态</span><br>        <span class="hljs-keyword">int</span> value = ThreadLocalRandom.current().nextInt(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">85</span>) &#123;<br>            <span class="hljs-comment">// 模拟解析完成</span><br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            String resultJson = results.get(asyncPredictId);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PredictResult(resultJson, <span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt;= <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-comment">// 模拟解析异常</span><br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseErrorException(<span class="hljs-string">&quot;简历解析异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果时间过短，返回status=1，表示解析中</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PredictResult(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解析异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qiyu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParseErrorException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new exception with &#123;<span class="hljs-doctag">@code</span> null&#125; as its detail message.</span><br><span class="hljs-comment">     * The cause is not initialized, and may subsequently be initialized by a</span><br><span class="hljs-comment">     * call to &#123;<span class="hljs-doctag">@link</span> #initCause&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParseErrorException</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new exception with the specified detail message.  The</span><br><span class="hljs-comment">     * cause is not initialized, and may subsequently be initialized by</span><br><span class="hljs-comment">     * a call to &#123;<span class="hljs-doctag">@link</span> #initCause&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message the detail message. The detail message is saved for</span><br><span class="hljs-comment">     *                later retrieval by the &#123;<span class="hljs-doctag">@link</span> #getMessage()&#125; method.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParseErrorException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第三方返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qiyu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PredictResult</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String resultJson;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析状态</span><br><span class="hljs-comment">     * 0 初始化</span><br><span class="hljs-comment">     * 1 处理中</span><br><span class="hljs-comment">     * 2 调用成功</span><br><span class="hljs-comment">     * 3 调用失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer status;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="模拟异常"><a href="#模拟异常" class="headerlink" title="模拟异常"></a>模拟异常</h2><p><strong>在项目运行过程中，</strong>启动这个测试类的方法，即可观察不一样的现象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisDistributedLockApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisService redisService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 作为失败案例（因为不存在777L这个解析任务，AsyncResumeParse.results会返回null）</span><br><span class="hljs-comment">     * 观察RedisMessageQueueConsumer的处理方式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        ResumeCollectionDTO resumeCollectionDTO = <span class="hljs-keyword">new</span> ResumeCollectionDTO();<br>        resumeCollectionDTO.setId(<span class="hljs-number">666L</span>);<br>        resumeCollectionDTO.setAsyncPredictId(<span class="hljs-number">777L</span>);<br>        resumeCollectionDTO.setName(<span class="hljs-string">&quot;测试1号&quot;</span>);<br><br>        redisService.pushQueue(RedisKeyConst.RESUME_PARSE_TASK_QUEUE, resumeCollectionDTO);<br><br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-comment"># </span><br>    <span class="hljs-attr">password:</span> <span class="hljs-comment"># </span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>啥都不说了，都在<del>jiu</del>代码里了。大家自己拷贝到本地，动手玩一下，加深对Redis锁和Redis消息队列的理解。</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://cloud.video.taobao.com/play/u/432628/p/1/d/hd/e/6/t/1/286252615441.mp4?auth_key=YXBwX2tleT04MDAwMDAwMTImYXV0aF9pbmZvPXsidGltZXN0YW1wRW5jcnlwdGVkIjoiMWUyYjkyMTY4NzMzYmMxMDQ2M2QyNDI5MDlhZWRjZDMifSZkdXJhdGlvbj0mdGltZXN0YW1wPTE2MzI0NTA3Mzc="}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604496815462-e6a559e8-27da-492f-b720-cf3f01e62429-20210923221905040.png" alt="img"></p><p>只有一个定时任务能去数据库拉取任务，到时多节点部署大致是下面这样（redis一般是独立部署的，和节点代码无关）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606026519366-b528e8be-3cfc-4a9a-a574-8a6ae401b41f-20210923221915282.png" alt="img"></p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>上面展示的代码其实存在很多问题，我们会在下一篇指出并讨论解决方案。</p><p>本文仅提供思路，开阔大家的眼界，<strong>千万别在自己项目中使用！！！！</strong>我当年被这个坑惨了，花里胡哨的，尤其Consumer里一大堆的sleep()，是非常low的！！</p><p><strong>对于异步调用的结果，不要循环等待，</strong>而应该分为几步：</p><ol><li><p>调用异步接口，得到异步结果唯一id</p></li><li><p>将结果id保存到任务表中，作为一个任务</p></li><li><p>启动定时任务，根据id拉取最终结果（如果还没有结果，跳过当前任务，等下一个定时任务处理）</p></li></ol><p>分布式定时任务可以考虑xxl-job或elastic-job，分布式锁推荐使用<a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">redisson</a>。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Redis分布式锁(上)</title>
    <link href="/2020/10/05/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8A)/"/>
    <url>/2020/10/05/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不论面试还是实际工作中，Redis都是避无可避的技术点。在我心里，MySQL和Redis是衡量一个程序员是否“小有所成”的两把标尺。如果他能熟练使用MySQL和Redis，以小化大，充分利用现有资源出色地完成当下需求，说明他已经成长了。</p><p>本篇文章我们一起来探讨Redis分布式锁相关的内容。</p><p>说到锁，大家第一时间想到的应该是synchronized关键字或ReentrantLock，随即想到偏向锁、自旋锁、重量级锁或者CAS甚至AQS。一般来说，我不喜欢一下子引入这么多概念，可能会把问题弄复杂，但为了方便大家理解Redis分布式锁，这里稍微提一下。</p><h1 id="JVM锁"><a href="#JVM锁" class="headerlink" title="JVM锁"></a>JVM锁</h1><p>所谓JVM锁，其实指的是诸如synchronized关键字或者ReentrantLock实现的锁。之所以统称为JVM锁，是因为我们的项目其实都是跑在JVM上的。理论上每一个项目启动后，就对应一片JVM内存，后续运行时数据的生离死别都在这一片土地上。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1620095054769-ca64b8aa-6bd0-4bdc-a4da-cc7e5d181d24-20210924103005529.png" alt="图片.png"></p><h1 id="什么是锁、怎么锁？"><a href="#什么是锁、怎么锁？" class="headerlink" title="什么是锁、怎么锁？"></a>什么是锁、怎么锁？</h1><p>明白了“JVM锁”名字的由来，我们再来聊什么是“锁”，以及怎么“锁”。</p><p>有时候我们很难阐述清楚某个事物<strong>是什么</strong>，但很容易解释它<strong>能干什么</strong>，JVM锁也是这个道理。JVM锁的出现，就是为了解决线程安全问题。所谓线程安全问题，可以简单地理解为数据不一致（与预期不一致）。</p><p>什么时候可能出现线程安全问题呢？</p><p>当同时满足以下三个条件时，才可能引发线程安全问题：</p><ul><li><p>多线程环境</p></li><li><p>有共享数据</p></li><li><p>有多条语句操作共享数据/单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）</p></li></ul><p>比如线程A、B同时对int count进行+1操作（初始值假设为1），在一定的概率下两次操作最终结果可能为2，而不是3。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604203263605-6b838677-f5b4-48cd-9298-2788c694aa15-20210924103020945.png" alt="image.png"></p><p>那么加锁为什么能解决这个问题呢？</p><p>如果不考虑原子性、内存屏障等晦涩的名词，加锁之所以能保证线程安全，核心就是“互斥”。所谓互斥，就是字面意思上的<strong>互</strong>相排<strong>斥</strong>。这里的“互相”是指谁呢？就是多线程之间！</p><p>怎么实现多线程之间的互斥呢？</p><p>引入“中间人”即可。</p><p>注意，这是个非常简单且伟大的思想。在编程世界中，通过引入“中介”最终解决问题的案例不胜枚举，包括但不限于Spring、MQ。在码农之间，甚至流传着一句话：没有什么问题是引入中间层解决不了的。</p><p>而JVM锁其实就是线程和线程彼此的“中间人”，多个线程在操作加锁数据前都必须征求“中间人”的同意：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612488996804-3ea7c557-98ae-4d76-aa5a-5933c1fe6026-20210924103037552.png" alt="图片.png"></p><p>锁在这里扮演的角色其实就是守门员，是<strong>唯一</strong>的访问入口，所有的线程都要经过它的拷问。在JDK中，锁的实现机制最常见的就是两种，分别是两个派系：</p><ul><li>synchronized关键字</li><li>AQS</li></ul><p>个人觉得synchronized关键字要比AQS难理解，但AQS的源码比较抽象。这里简要介绍一下Java对象内存结构和synchronized关键字的实现原理。</p><h1 id="Java对象内存结构"><a href="#Java对象内存结构" class="headerlink" title="Java对象内存结构"></a>Java对象内存结构</h1><p>要了解synchronized关键字，首先要知道Java对象的内存结构。强调一遍，是Java<strong>对象的内存结构</strong>。</p><p>它的存在仿佛向我们抛出一个疑问：如果有机会解剖一个Java对象，我们能看到什么？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604205724123-0a6ab812-080e-4626-8a35-db6b6a41bd04-20210924103057869.png" alt="image.png"></p><p>右上图画了两个对象，只看其中一个即可。我们可以观察到，Java对象内存结构大致分为几块：</p><ul><li><p>Mark Word（锁相关）</p></li><li><p>元数据指针（class pointer，指向当前实例所属的类）</p></li><li><p>实例数据（instance data，我们平常看到的仅仅是这一块）</p></li><li><p>对齐（padding，和内存对齐有关）</p></li></ul><p>如果此前没有了解过Java对象的内存结构，你可能会感到吃惊：天呐，我还以为Java对象就只有属性和方法！</p><p>是的，我们最熟悉实例数据这一块，而且<strong>以为只有这一块。</strong>也正是这个观念的限制，导致一部分初学者很难理解synchronized。比如初学者经常会疑惑：</p><ul><li><p>为什么任何对象都可以作为锁？</p></li><li><p>Object对象锁和类锁有什么区别？</p></li><li><p>synchronized修饰的普通方法使用的锁是什么？</p></li><li><p>synchronized修饰的静态方法使用的锁是什么？</p></li></ul><p>这一切的一切，其实都可以在Java对象内存结构中的Mark Word找到答案：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604208962907-39530cce-67a1-41ff-9855-13f3297d2c10-20210924103109319.png" alt="image.png"></p><p>很多同学可能是第一次看到这幅图，会感到有点懵，没关系，我也很头大，都一样的。</p><p>Mark Word包含的信息还是蛮多的，但这里我们只需要简单地把它理解为<strong>记录锁信息</strong>的标记即可。上图展示的是32位虚拟机下的Java对象内存，如果你仔细数一数，会发现全部bit加起来刚好是32位。64位虚拟机下的结构大同小异，就不特别介绍。</p><p>Mark Word从有限的32bit中划分出2bit，专门用作锁标志位，通俗地讲就是标记当前锁的状态。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1620095815528-242114c7-277f-4777-ad33-9e38d4c62c27.png" alt="img"></p><p>正因为每个Java对象都有Mark Word，而Mark Word能标记锁状态（把自己当做锁），所以Java中任意对象都可以作为synchronized的锁：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(person)&#123;<br>&#125;<br><span class="hljs-keyword">synchronized</span>(student)&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>所谓的this锁就是当前对象，而Class锁就是当前对象所属类的Class对象，本质也是Java对象。synchronized修饰的普通方法底层使用当前对象作为锁，synchronized修饰的静态方法底层使用Class对象作为锁。</strong></p><p>但如果要保证多个线程互斥，最基本的条件是它们<strong>使用同一把锁：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612489131320-62cceb64-2ba8-431d-985f-03cbe8f42df2-20210923220222012.png" alt="img"></p><p>对同一份数据加两把不同的锁是没有意义的，实际开发时应该注意避免下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(Person.class)&#123;<br>    <span class="hljs-comment">// 操作count</span><br>&#125;<br><br><span class="hljs-keyword">synchronized</span>(person)&#123;<br>    <span class="hljs-comment">// 操作count</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 操作count</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 操作count</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="synchronized与锁升级"><a href="#synchronized与锁升级" class="headerlink" title="synchronized与锁升级"></a>synchronized与锁升级</h1><p>大致介绍完Java对象内存结构后，我们再来解决一个新疑问：</p><p>为什么需要标记锁的状态呢？是否意味着synchronized锁有多种状态呢？</p><p>在JDK早期版本中，synchronized关键字的实现是直接基于重量级锁的。只要我们在代码中使用了synchronized，JVM就会向操作系统申请锁资源（不论当前是否真的是多线程环境），而向操作系统申请锁是比较耗费资源的，其中涉及到用户态和内核态的切换等，总之就是比较费事，且性能不高。</p><p>JDK为了解决JVM锁性能低下的问题，引入了ReentrantLock，它基于CAS+AQS，类似自旋锁。自旋的意思就是，在发生锁竞争的时候，未争取到锁的线程会在门外采取自旋的方式等待锁的释放，谁抢到谁执行。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612489200273-6e3caa00-7625-42b7-9b03-e2a87ba09633-20210923220236604.png" alt="img"></p><p>自旋锁的好处是，不需要兴师动众地切换到内核态申请操作系统的重量级锁，在JVM层面即可实现自旋等待。但世界上并没有百利而无一害的灵丹妙药，CAS自旋虽然避免了状态切换等复杂操作，却要耗费部分CPU资源，尤其当可预计上锁的时间较长且并发较高的情况下，会造成几百上千个线程同时自旋，极大增加CPU的负担。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604463084016-ce0704e8-55d9-4035-9dda-15778b125560-20210923220242536.png" alt="img"></p><p>synchronized毕竟JDK亲儿子，所以大概在JDK1.6或者更早期的版本，官方对synchronized做了优化，提出了“锁升级”的概念，把synchronized的锁划分为多个状态，也就是上图中提到的：</p><ul><li><p>无锁</p></li><li><p>偏向锁</p></li><li><p>轻量级锁（自旋锁）</p></li><li><p>重量级锁</p></li></ul><p>无锁就是一个Java对象刚new出来的状态。当这个对象第一次被一个线程访问时，该线程会把自己的线程id“贴到”它的头上（Mark Word中部分位数被修改），表示“你是我的”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604211050450-4463b6fc-3864-4822-b6a5-e8ed98283b7c-20210924103138330.png" alt="image.png"></p><p>此时是不存在锁竞争的，所以并不会有什么阻塞或等待。</p><p>为什么要设计“偏向锁”这个状态呢？</p><p>大家回忆一下，项目中并发的场景真的这么多吗？并没有吧。大部分项目的大部分时候，某个变量都是单个线程在执行，此时直接向操作系统申请重量级锁显然没有必要，因为根本不会发生线程安全问题。</p><p>而一旦发生锁竞争时，synchronized便会在一定条件下升级为轻量级锁，可以理解为一种自旋锁，具体自旋多少次以及何时放弃自旋，JDK也有一套相关的控制机制，大家可以自行了解。</p><p>同样是自旋，所以synchronized也会遇到ReentrantLock的问题：如果上锁时间长且自旋线程多，又该如何？</p><p>此时就会再次升级，变成传统意义上的重量级锁，本质上操作系统会维护一个队列，用空间换时间，避免多个线程同时自旋等待耗费CPU性能，等到上一个线程结束时唤醒等待的线程参与新一轮的锁竞争即可。</p><p>拓展阅读（没太大必要）：</p><p><a href="https://www.cnblogs.com/kubidemanong/p/9520071.html">线程安全(中)–彻底搞懂synchronized(从偏向锁到重量级锁)</a></p><p><a href="https://www.jianshu.com/p/4758852cbff4">死磕Synchronized底层实现–偏向锁</a></p><h1 id="synchronized案例"><a href="#synchronized案例" class="headerlink" title="synchronized案例"></a>synchronized案例</h1><p>让我们一起来看几个案例，加深对synchronized的理解。</p><ul><li>同一个类中的synchronized method m1和method m2互斥吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290796058-a3bfc5f5-f6be-4543-8796-a2b170d36464-20210923220322058.png" alt="img"></p><p>t1线程执行m1方法时要去读this对象锁，但是t2线程并不需要读锁，两者各管各的，没有交集（不共用一把锁）</p><ul><li>同一个类中synchronized method m1中可以调用synchronized method m2吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290844351-21fa8f5e-80ac-400f-8033-88aad2dd6960-20210923220329432.png" alt="img"></p><p>synchronized是可重入锁，可以粗浅地理解为同一个线程在已经持有该锁的情况下，可以再次获取锁，并且会在某个状态量上做+1操作（ReentrantLock也支持重入）</p><ul><li>子类同步方法synchronized method m可以调用父类的synchronized method m吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290893998-8ba4a1e0-48a4-4789-9856-b5de2539ff7c-20210923220336563.png" alt="img"></p><p>子类对象初始化前，会调用父类构造方法，在结构上相当于包裹了一个父类对象，用的都是this锁对象</p><ul><li>静态同步方法和非静态同步方法互斥吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290932744-f6d63490-b46a-4c0e-b939-c0a54764f6be-20210923220344834.png" alt="img"></p><p>各玩各的，不是同一把锁，谈不上互斥</p><h1 id="Redis分布式锁的概念"><a href="#Redis分布式锁的概念" class="headerlink" title="Redis分布式锁的概念"></a>Redis分布式锁的概念</h1><p>谈到Redis分布式锁，总是会有这样或那样的疑问：</p><ul><li><p>什么是分布式</p></li><li><p>什么是分布式锁</p></li><li><p>为什么需要分布式锁</p></li><li><p>Redis如何实现分布式锁</p></li></ul><p>前3个问题其实可以一起回答，至于Redis如何实现分布式锁，我们放在下一篇。</p><p>什么是分布式？这是个很复杂的概念，我也很难说准确，所以干脆画个图，大家各花入各眼吧：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604211829338-3b84a9f8-b551-41ba-a83e-1428ea401e13-20210923220351203.png" alt="img"></p><p>分布式有个很显著的特点是，Service A和Service B极有可能并不是部署在同一个服务器上，所以它们也不共享同一片JVM内存。<strong>而上面介绍了，要想实现线程互斥，必须保证所有访问的线程使用的是同一把锁（JVM锁此时就无法保证互斥）。</strong></p><p>对于分布式项目，有多少台服务器就有多少片JVM内存，即使每片内存中各设置一把“独一无二”的锁，从整体来看项目中的锁就不是唯一的。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604292366085-77c2f620-9dce-417e-a714-e094c690b934-20210923220359938.png" alt="img"></p><p>此时，<strong>如何保证每一个JVM上的线程共用一把锁呢？</strong></p><p>答案是：把锁抽取出来，让线程们在<strong>同一片内存</strong>相遇。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604292683347-9f095018-1aa9-464d-848e-f26b2ae69a52-20210923220408318.png" alt="img"></p><p>但锁是不能凭空存在的，本质还是要在内存中，此时可以使用Redis缓存作为锁的宿主环境，这就是Redis能构造分布式锁的原因。</p><h1 id="Redis的锁长啥样"><a href="#Redis的锁长啥样" class="headerlink" title="Redis的锁长啥样"></a>Redis的锁长啥样</h1><p>synchronized关键字和ReentrantLock，它们都是实实在在已经实现的锁，而且还有标志位啥的。但Redis就是一个内存…怎么作为锁呢?</p><p>有一点大家要明确，Redis之所以能用来做分布式锁，肯定不只是因为它是一片内存，否则JVM本身也占有内存，为什么无法自己实现分布式锁呢？</p><p>我个人的理解是，要想自定义一个分布式锁，必须至少满足几个条件：</p><ul><li><p>多进程可见（独立于多节点系统之外的一片内存）</p></li><li><p>互斥（可以通过单线程，或者某种顺序机制）</p></li><li><p>可重入</p></li></ul><p>还有个条件，默认要支持：只有持有这把锁的客户端才能解锁</p><p>以上三点Redis都能满足。在上面三个条件下，其实怎么设计锁，完全取决于个人如何定义锁。就好比现实生活中，通常我们理解的锁就是有个钥匙孔、需要插入钥匙的金属小物件。然而锁的形态可不止这么一种，随着科技的发展，什么指纹锁、虹膜锁层出不穷，但归根结底它们之所以被称为“锁”，是因为都保证了“互斥”（我行，你不行）。</p><p>如果我们能设计一种逻辑，它能造成某个场景下的“互斥事件”，那么它就可以被称为“锁”。比如，某家很有名的网红店，一天只接待一位客人。门口没有营业员，就放了一台取号机，里面放了一张票。你如果去迟了，票就没了，你就进不了这家店。这个场景下，没票的顾客进不去，被锁在门外。此时，取票机造成了“互斥事件”，那么它就可以叫做“锁”。</p><p>而Redis提供了setnx指令，如果某个key当前不存在则设置成功并返回true，否则不再重复设置，直接返回false。这不就是编程界的取号机吗？当然，实际用到的命令可不止这一个，具体如何实现，请看下一篇~</p><p>这一篇从JVM锁聊到了Redis分布式锁，还介绍了Java的对象内存结构及synchronized底层的原理，相信大家对“锁”已经有了自己的感性认识。下一篇我们将通过分布式定时任务的案例介绍Redis分布式锁的使用场景。</p><p>下次见。</p><h1 id="思考一个问题：分布式系统是否一定要分布式锁？"><a href="#思考一个问题：分布式系统是否一定要分布式锁？" class="headerlink" title="思考一个问题：分布式系统是否一定要分布式锁？"></a>思考一个问题：分布式系统是否一定要分布式锁？</h1><p>分布式系统如果要加锁是否一定要使用分布式锁呢？</p><p>可能未必。</p><p>如果你需要的是写锁，那么可能确实需要分布式锁保证单一线程处理数据，而如果是为了防止缓存击穿（热点数据定时失效），那么使用JVM本地锁也没有太大关系。比如某个服务有10个节点，在使用JVM锁的情况下，即使某一时刻每个节点<strong>各自</strong>涌入1000个请求，虽然总共有1w个请求，但最终打到数据库的也只有10个，数据库层面是完全可以抗住这点请求量的，又由于本身是查询，所以不会造成线程安全问题。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化(4)-索引与优化原理(下)</title>
    <link href="/2020/08/19/SQL%E4%BC%98%E5%8C%96(4)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8B)/"/>
    <url>/2020/08/19/SQL%E4%BC%98%E5%8C%96(4)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>继续上一篇，本节重点介绍联合索引。</p><h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><p>之前我们已经接触了一部分索引优化相关的概念，但更多的是我一个人在讲，大家被动地接收。如何验证文章所说的正确性，以及一条SQL是否真的用到了索引呢？</p><p>这个时候就该Explain上场了，使用方式有两种：</p><ul><li>借助Navicat等软件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610247075143-d475fc88-120c-4ca9-a27d-204b7d6ecf45-20210923214500198.png" alt="img"></p><ul><li>直接使用Explain命令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610247009784-07acd78b-aaf8-4cf6-ae50-6a83e381f027-20210923214507859.png" alt="img"></p><p>大家把它当做一个命令即可，是MySQL提供的专门用来分析SQL执行计划的，比如语句是否使用了关联查询、是否使用了索引、扫描行数等。使用场景一般是：</p><ul><li>当你发现某条SQL很慢时，可以借助Explain分析一下是否走索引</li><li>当你修改某条SQL后，借助Explain查看是否达到预期</li></ul><p>Explain有很多指标，重点看type、key、Extra：</p><table><thead><tr><th>列名</th><th>解释</th></tr></thead><tbody><tr><td>id</td><td>查询编号</td></tr><tr><td>select_type</td><td>查询类型：显示本行是简单还是复杂查询</td></tr><tr><td>table</td><td>涉及到的表</td></tr><tr><td>partitions</td><td>匹配的分区：查询将匹配记录所在的分区。仅当使用 partition 关键字时才显示该列。对于非分区表，该值为 NULL。</td></tr><tr><td><strong>type</strong></td><td>本次查询的表连接类型</td></tr><tr><td>possible_keys</td><td>可能选择的索引</td></tr><tr><td><strong>key</strong></td><td>实际选择的索引</td></tr><tr><td>key_len</td><td>被选择的索引长度：一般用于判断联合索引有多少列被选择了</td></tr><tr><td>ref</td><td>与索引比较的列</td></tr><tr><td>rows</td><td>预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确</td></tr><tr><td>filtered</td><td>按条件筛选的行的百分比</td></tr><tr><td><strong>Extra</strong></td><td>附加信息</td></tr></tbody></table><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><table><thead><tr><th>type 的值</th><th>解释</th></tr></thead><tbody><tr><td>system</td><td>查询对象表只有一行数据，且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况</td></tr><tr><td>const</td><td>基于主键或唯一索引查询，最多返回一条结果</td></tr><tr><td>eq_ref</td><td>表连接时基于主键或非 NULL 的唯一索引完成扫描</td></tr><tr><td>ref</td><td>基于普通索引的等值查询，或者表间等值连接</td></tr><tr><td>fulltext</td><td>全文检索</td></tr><tr><td>ref_or_null</td><td>表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值</td></tr><tr><td>index_merge</td><td>利用多个索引</td></tr><tr><td>unique_subquery</td><td>子查询中使用唯一索引</td></tr><tr><td>index_subquery</td><td>子查询中使用普通索引</td></tr><tr><td>range</td><td>利用索引进行范围查询</td></tr><tr><td>index</td><td>全索引扫描</td></tr><tr><td>ALL</td><td>全表扫描</td></tr></tbody></table><h2 id="possible-keys、key、key-len"><a href="#possible-keys、key、key-len" class="headerlink" title="possible_keys、key、key_len"></a>possible_keys、key、key_len</h2><p>possible_keys是MySQL预估会使用的索引（基本不用看），key才是最终实际选择的索引，可以结合key_len来推测联合索引的“使用率”。比如联合索引index(a,b,c)，假设每个索引长度为1，而key_len却是2，那么可以推测联合索引只用了前两个。</p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>Extra是最难的，含义也最多，和索引覆盖、排序等都有关系。</p><table><thead><tr><th>Extra 常见的值</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td>Using filesort</td><td>将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</td><td>explain select * from t1 order by create_time;</td></tr><tr><td>Using temporary</td><td>需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时</td><td>explain select * from t1 group by create_time;</td></tr><tr><td>Using index</td><td>使用覆盖索引</td><td>explain select a from t1 where a=111;</td></tr><tr><td>Using where</td><td>使用 where 语句来处理结果</td><td>explain select * from t1 where create_time=‘2019-06-18 14:38:24’;</td></tr><tr><td>Impossible WHERE</td><td>对 where 子句判断的结果总是 false 而不能选择任何数据</td><td>explain select * from t1 where 1&lt;0;</td></tr><tr><td>Using join buffer (Block Nested Loop)</td><td>关联查询中，被驱动表的关联字段没索引</td><td>explain select * from t1 straight_join t2 on (t1.create_time=t2.create_time);</td></tr><tr><td>Using index condition</td><td>先条件过滤索引，再查数据</td><td>explain select * from t1 where a &gt;900 and a like “%9”;</td></tr><tr><td>Select tables optimized away</td><td>使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</td><td>explain select max(a) from t1;</td></tr></tbody></table><p>Explain更详细的解释可以参考：<a href="https://www.bilibili.com/video/BV1KW411u7vy?p=20">https://www.bilibili.com/video/BV1KW411u7vy?p=20</a></p><h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><p>联合索引其实要比单列索引难很多，很多SQL优化原则都是针对万恶的联合索引搞出来的，比如大名鼎鼎的“最左匹配原则”。</p><p><strong>虽然联合索引容易引发各种问题，看起来不那么容易驯服，但它在提高索引利用率、加快分组、排序等方面却有着很大的作用，</strong>所以实际开发时，联合索引一般来说应该优于单列索引。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589537787486-ed93cbb6-a245-49eb-8e8f-42fe6ce51893-20210923214519728.png" alt="img"></p><p>我不知道大家是否好奇<strong>联合索引到底长啥样</strong>，反正我当初学习SQL优化时，就有很多的疑问：</p><ul><li><p>联合索引到底长啥样？</p></li><li><p>查询时是怎么检索的呢？</p></li><li><p>为什么对于联合索引index(a, b, c)，查询条件WHERE b=1, c=2无法利用索引呢？</p></li></ul><p>我们先回答第一、第二个问题，第三个问题我们分为三小节，专门讨论所谓的“最左匹配原则”。</p><p>联合索引到底长什么样呢？</p><ul><li>还是一棵树，不会因为是联合索引，就变成多棵树</li><li>索引节点会存储多列，比如原先单列索引的节点会存储[name, name, name…]，而多列索引的节点内会存储[[name, age], [name, age], [name, age]…]</li></ul><p>为了帮大家更好地理解联合索引，我们一起探讨一个问题：</p><p>当我们向建有联合索引的表中插入一条数据时，发生了什么？</p><p>假设现在数据库的记录是这样的(最底下是有序链表，即叶子节点的数据)：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610674696496-4561304d-995a-4035-812f-880cbf5f7a77-20210923214527578.png" alt="img"></p><p>除了主键索引，其他都是辅助索引，联合索引也不例外。所以，上图叶子节点的数据应该是id，但为了更直观，我画成name和age。</p><p>现在要往数据库插入一条数据(bravo, 18, “杭州”, “18255555556”)，插入时需要维护索引，所以需要沿着索引找到数据所在的位置并在叶子节点的表数据中插入：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589544348046-f14690a1-2d1a-44b2-a87e-592802d19765-20210923214533926.png" alt="img"></p><p><strong>插入数据的过程其实伴随着索引的维护，</strong>插入后整棵索引树就变成了这样：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589544632849-3010099d-1849-4dea-9817-dbd57d41b7ea-20210923214538925.png" alt="img"></p><p>通过分析上面数据的插入过程，你会发现，在插入时其实会进行索引比较，先比较name再比较age。<strong>换句话说，这样沿着索引比较后插入的数据，本身就是有序的，符合联合索引的顺序。</strong></p><p>比如班级排座位，老师按照两个条件综合排序，先按身高排，身高一样的，成绩好的坐后面。那么放学走出教室时，顺序自然就是先按身高排，矮的先出来，高的后出来，身高相同的成绩差的先出来。</p><p>所以，对于下面这条SQL：</p><p>SELECT 学生 FROM ‘三年二班’ ORDER BY 身高, 成绩</p><p>你认为MySQL还有排序的必要吗？直接把三年二班的学生从头数到尾拎出来即可。</p><p>这就是所谓的“索引能加快排序速度”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1594511066391-5c4d07d0-0020-4fc1-8242-c93bc1603177-20210923214545481.png" alt="img"></p><p>因为本身插入或更新时，都是按照某种规则维护的。当你ORDER BY的规则与维护索引的规则一致时（都是根据身高、成绩），此时索引就能加快排序，<strong>因为这个时候根本不用排序。</strong></p><p>所以记住，最快的排序就是不用排序，也就是利用索引排序。把对顺序的维护<strong>分散到</strong>每一次增删改的过程中，而不是查询时再匆忙从零开始排序。</p><h2 id="最左匹配原则：WHERE条件查询"><a href="#最左匹配原则：WHERE条件查询" class="headerlink" title="最左匹配原则：WHERE条件查询"></a>最左匹配原则：WHERE条件查询</h2><p>接着，让我们思考一下“为什么对于联合索引index(name, age)，条件WHERE age=25无法利用索引”。</p><p>上面分析过，数据总是要经过索引比较后才插入，所以数据天然就是按索引顺序排列的。当我们拿着WHERE子句的条件（age=25）顺着索引树比较时，是得不到正确的结果的。因为当初这棵树排序的第一个条件是name，而不是age。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589545510186-c162bc1b-fe5f-45a0-9a45-72227ee7934a-20210923214551939.png" alt="img"></p><p>由于整棵树的排序规则是“先根据name排列，再根据age排列”，你硬要直接拿age查询，最终结果可能会南辕北辙。还是以学生排座位举例，人家明明是<strong>先按照身高</strong>排序，<strong>再按照成绩</strong>排序，那么注定成绩不会成“递增”或“递减”的趋势（请观察右边分数列），而面对没有相关趋势的数据，我们只能遍历查找：</p><ul><li><p>180cm 98分</p></li><li><p>182cm 96分</p></li><li><p>182cm 97分</p></li><li><p>183cm 99分</p></li><li><p>184cm 93分</p></li><li><p>184cm 95分</p></li></ul><p>分数的相关趋势只有在“身高一致”这个前提下才会显现，是<strong>局部</strong>特征（绿色块、蓝色块的分数确实呈现某种趋势）：</p><ul><li><p>180cm 98分</p></li><li><p>182cm 96分</p></li><li><p>182cm 97分</p></li><li><p>183cm 99分</p></li><li><p>184cm 93分</p></li><li><p>184cm 95分</p></li></ul><p>当然，实际上MySQL在解析SQL时并不会真的像上面一样进行逻辑分析，而是直接进行语法匹配和成本预估，发现WHERE条件不符合联合索引的“最左匹配原则”时，直接放弃走索引，选择全表扫描。</p><p>那么，怎么才能利用index(name, age)这个联合索引呢？</p><p>把查询条件变成 WHERE name=bravo, age=18即可！此时它会先按照name比较，再按照age比较，刚好和联合索引的顺序一致，也就是和排序顺位一致：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589546040377-acd3e6b0-1a78-4d3d-9a0d-8d9cd6e4a17d-20210923214558226.png" alt="img"></p><p>也就是说，此时WHERE子句的条件顺序刚好能满足最左匹配原则。</p><p>假设联合索引是index(a, b, c)，来看几个最左匹配原则的案例：</p><ul><li><p>WHERE a, b, c ✔️</p></li><li><p>WHERE a, b ✔️（只能匹配a,b）</p></li><li><p>WHERE a, c ✔️（只能匹配a）</p></li><li><p>WHERE b, c（❌）</p></li></ul><p>上面WHERE a, c的查询过程是怎么样的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589618860739-a778f594-32c2-4bd0-8575-53788640d3a7-20210923214605529.png" alt="img"></p><p>也就是说，WHERE后条件如果能走索引，就能站在更高的地方判断条件是否符合，否则只能<strong>作为判断条件</strong>深入节点内部的数据逐个比对。</p><p>如果能走全部索引，就可以少几次比较，甚至可能少几次IO：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589557584392-8bb5a6fe-c7b9-4f87-ac48-07465eade3af-20210923214613726.png" alt="img"></p><p>另外，除了不能缺少联合索引中的查询字段外，还要注意尽量不要使用范围查询。</p><p>比如，联合索引是index(a, b, c)：</p><ul><li>WHERE a=1, b&gt;2, c=3 ✔️（只能匹配a, b）</li></ul><p>注意一下即可，毕竟真要做范围查询也不是我们能决定的，无非索引利用率低一些罢了。</p><h2 id="最左匹配原则：ORDER-BY"><a href="#最左匹配原则：ORDER-BY" class="headerlink" title="最左匹配原则：ORDER BY"></a>最左匹配原则：ORDER BY</h2><p>上面说过了，对于index(name, age)的索引树，最底层的数据本身就是先按name，再按age排序的。当ORDER BY的条件刚好是ORDER BY name, age时，直接查询即可，无需排序，因为数据在插入时就按索引顺序排好了。</p><p>现在我们反过来讨论，如果没有利用索引排序，或者无法利用索引排序时，会发生什么呢？</p><p>filesort！</p><p>所谓filesort是EXPLAIN命令中extra一列的某个指标，当extra出现filesort这个指标时，说明我们的SQL没有走索引排序，而是利用内存或磁盘自己重新排序。</p><p>那么，什么情况下会导致ORDER BY无法利用索引排序呢？</p><p>以联合索引index(name, age)为例，以下情况无法利用索引排序：</p><ul><li>ORDER BY age, name（字段顺序不一致）</li><li>ORDER BY name DESC, age ASC（字段排序方式不同步，DESC和ASC混着来）</li></ul><p>第一种情况：</p><p>因为索引里的数据是先按name、后按age排序的，而你想要先按age再按name排序，对不起，你自己对结果集重新排吧，我不管了。</p><p>特别要注意，对于联合索引index(a,b,c)，WHERE条件无论是a,b,c、a,c,b还是b,c,a…都没关系，比如女生找男朋友要身高180以上、长得帅的，如果你“反过来”，长得帅、身高180以上也是可以的。但是排序不同，顺序必须和联合索引一致，否则语义是不同的。比如，先按身高再按分数和先按分数再按身高是两种完全不同的排序策略，结果自然也不同。</p><p>大家不妨做个实验，对于(‘a’, 17),(‘a’, 16), (‘b’, 18), (‘c’, 18)，(‘d’, 15)先按name正序再按age正序的结果是：</p><ul><li><p>(‘a’, 16)</p></li><li><p>(‘a’, 17)</p></li><li><p>(‘b’, 18)</p></li><li><p>(‘c’, 18)</p></li><li><p>(‘d’, 15)</p></li></ul><p>而先按age正序再按name正序的结果是：</p><ul><li><p>(‘d’, 15)</p></li><li><p>(‘a’, 16)</p></li><li><p>(‘a’, 17)</p></li><li><p>(‘b’, 18)</p></li><li><p>(‘c’, 18)</p></li></ul><p>所以对于index(name, age)，ORDER BY age, name排序顺序与索引不一致，是无法利用索引排序的。</p><p>第二种情况：</p><p>维护索引时默认都是name ASC, name ASC排序，如果你需要name DESC，age ASC，对不起，你自己对结果集重新排吧，我不管了。</p><p>理由同上。</p><p>但以下情况仍可以利用索引排序：</p><ul><li>ORDER BY name DESC, age DESC（字段顺序和索引顺序一致即可，全部DESC或ASC都没关系）</li></ul><p>为什么ORDER BY name DESC, address DESC也能利用索引排序呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608985883366-5221f525-a2b1-4d49-a62d-44da6eb92008-20210923214621711.png" alt="img"></p><p>假设右边数据是联合索引自动排序的，而现在查询的排序规则是ORDER BY name DESC, age DESC。我们先尝试一下，如果右边的数据真的按ORDER BY name DESC, age DESC排序，会是什么样呢？</p><p><strong>其实就是左边数据倒过来！</strong></p><p>所以 ORDER BY name DESC, age DESC看起来好像无法利用索引，但其实索引数据反着来刚好符合期望的排序。</p><p>总之，大家应该理解为索引排序是“很消极”的：</p><p>反正索引当初就这么排的，如果你刚好想要这种排序，就直接拿数据即可。但你如果想要的排序不是我现有的这种，对不起，你自己爱咋整咋整，但我明确告诉你，<strong>重新排序会让整个查询变慢。</strong></p><p>说了这么多，我们来验证一下。</p><p>创建表：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589547567889-6a812a41-3b19-4536-a4d6-960327eff327-20210923214629930.png" alt="img"></p><p>给name、address加了联合索引。</p><p>共1000w数据：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548017233-53960dfe-8407-4c37-8f14-a930eb6bfadb-20210923214636772.png" alt="img"></p><p>先介绍两个简单的指标，具体的Explain命令后面介绍：</p><p>Extra列中，如果出现了Using filesort，说明没有走索引排序，也就是说本次查询自己额外做了排序。</p><p>ORDER BY name（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548043565-c2fabb16-a7eb-433b-acb2-bce7842152e2-20210923214645356.png" alt="img"></p><p>ORDER BY name, address（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548082945-066e09ba-8d76-4593-a252-1b20376dcb02-20210923214651758.png" alt="img"></p><p>ORDER BY  <code>name</code> DESC, address DESC（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548127165-ccb2ae5c-8bbe-4861-ba9f-481d263b4664-20210923214656860.png" alt="img"></p><p>Using index指的是索引覆盖，是个好消息，意味着本次查询不会回表。</p><p>索引失效案例：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548196364-2aeee667-a9b3-4f59-8289-f501a6b9b010-20210923214703042.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548223133-3f1b433d-430e-4110-831f-d49b6461481b-20210923214710565.png" alt="img"></p><p>当前叶子节点链表上的数据是按索引排的（先name后address），而SQL希望的排序方式是先address后name。既然不能有效利用索引的排序，只能把结果集取出来重新排序。</p><p><strong>总之，如果想利用索引排序，那么ORDER BY的顺序必须符合最左前缀原则，顺序完全一致，且DESC和ASC不能混用。</strong></p><p>OK，上面讲的都是ORDER BY本身的一些规则，接下来我们把战场扩大些，把WHERE也引进来。</p><p>当WHERE和ORDER BY搭配，就会产生一种“例外情况”：<strong>对于index(a,b,c)，SELECT * FROM table WHERE</strong> <strong>a</strong><strong>=1 ORDER BY</strong> <strong>b,c****也是可以利用索引排序的。</strong></p><p>单独观察ORDER BY后面的字段，由于不符合“最左匹配原则”，理应不能走联合索引才对。</p><p>加入WHERE后怎么就可以了呢？</p><p>道理其实很简单，比如原本学生的排序是身高、体重、分数：</p><ul><li><p>180cm 65kg 98分</p></li><li><p>182cm 65kg 96分</p></li><li><p>182cm 65kg 97分</p></li><li><p>183cm 62kg 99分</p></li><li><p>184cm 63kg 93分</p></li><li><p>184cm 64kg 95分</p></li></ul><p>虽然ORDER BY b, c看起来不完整，但只要我定死身高为182（WHERE a=182），那实际筛选出来的学生其实就是先按体重、再按分数排序的，也就是ORDER BY b, c。</p><p>当没有通过a过滤时，数据整体没有相关性，但被a过滤后，局部数据就呈现相关性。</p><p>但这个“例外”本身还有个例外，就是：WHERE的条件不能是范围查询。</p><p>比如：</p><p>SELECT * FROM table WHERE a&gt;1 ORDER BY b,c;</p><p>这条语句是无法利用联合索引index(a,b,c)排序的，理由同上面讲得一样，a&gt;1筛选出来的结果集并不能保证b,c是预期的顺序。</p><p>上面说过，WHERE height=182 ORDER BY weight, score是可以走索引排序的，因为局部范围内能保证走索引排序，而WHERE height&gt;=182 ORDER BY weight, score，显然就不满足索引排序。</p><ul><li><p>180cm 65kg 98分</p></li><li><p>182cm 65kg 96分</p></li><li><p>182cm 65kg 97分</p></li><li><p>183cm 62kg 99分</p></li><li><p>184cm 63kg 93分</p></li><li><p>184cm 64kg 95分</p></li></ul><h2 id="最左匹配原则：GROUP-BY"><a href="#最左匹配原则：GROUP-BY" class="headerlink" title="最左匹配原则：GROUP BY"></a>最左匹配原则：GROUP BY</h2><p>这个没什么好说的，GROUP BY其实可以看成两步：<strong>先排序，后归并。</strong></p><p>一般对于GROUP BY的优化，就是尽可能让它也走索引排序。当它和联合索引顺序一致时，GROUP BY会跳过排序，直接归并，从而达到优化的目的。</p><p>后面我们专门安排一个章节，汇总一下优化规则，上面的内容理解即可。</p><h1 id="联合索引的使用场景"><a href="#联合索引的使用场景" class="headerlink" title="联合索引的使用场景"></a>联合索引的使用场景</h1><p>GROUP BY没什么好讲的，可以理解为排序的基础上在进行归并，所以学习联合索引时，主要关注WHERE和ORDER BY即可。</p><h2 id="场景一：多条件查询，提高利用率"><a href="#场景一：多条件查询，提高利用率" class="headerlink" title="场景一：多条件查询，提高利用率"></a>场景一：多条件查询，提高利用率</h2><p>如果发现很多SQL的WHERE条件经常是多个相同的字段，比如SELECT xxx WHERE a,b,c、SELECT xxx WHERE a,b、SELECT xxx WHERE a,c等，此时可以考虑创建联合索引index(a,b,c)。</p><p>这里有几条规则需要注意：</p><ul><li><p>WHERE条件的书写顺序并不影响是否走联合索引。比如WHERE a,b,c和WHERE b,c,a都可以走index(a,b,c)</p></li><li><p>但WHERE b,c是不行的，因为缺少a，而WHERE a,c只能利用部分索引</p></li><li><p>创建索引时，最好把区分度高的排在前面（注意，我说的是创建索引的顺序，而不是WHERE条件的顺序）</p></li></ul><p>第三条需要大家再仔细品味一下，比如要给id_card和name建立联合索引，如果你建的是index(name, id_card)，就会浪费无畏的IO在name查找上：先找到全国同名同姓的，再根据id_card匹配。而如果创建index(id_card, name)，那么id_card是唯一的，区分度极高，基本就是一击必中。</p><h2 id="场景二：避免回表"><a href="#场景二：避免回表" class="headerlink" title="场景二：避免回表"></a>场景二：避免回表</h2><p>上一篇已经介绍过了，如果走辅助索引并回表，就会无端多一次对主键索引的扫描。比如对于只有主键索引和name索引的表执行以下SQL：</p><p>SELECT id, name, age FROM table name=’xxxx’，</p><p>由于name索引只包含了id和name，而SELECT的列却是id、name、age，此时MySQL底层不得不回表，拿着id再跑一遍主键索引，把age给捞出来。</p><p>可行的解决办法是：添加联合索引index(name, age)，这样辅助索引上就同时包含id、name、age，可以直接返回。</p><p>当然啦，<strong>并不是只有联合索引才能使用索引覆盖，</strong>只要辅助索引上的字段满足SELECT的列即可，所以即使是单列索引index(name)，也是可以避免回表的，比如SELECT id, name FROM table WHERE name=’xxx’。</p><p><strong>但大家要认识到，实际开发索引覆盖可遇不可求，基本还是回表的情况多一些。</strong>比如，即使你定了联合索引index(name, age)，但实际上却是要查询所有列怎么办？此时还是要乖乖回表（好歹走了辅助索引了，知足吧）。</p><h2 id="场景三：索引排序"><a href="#场景三：索引排序" class="headerlink" title="场景三：索引排序"></a>场景三：索引排序</h2><p>当你建了联合索引index(a,b,c)，那么每次增删改都会按这个顺序维护。如果查询是需要的顺序刚好是a,b,c，就可以直接返回数据，无需排序，美其名约“利用索引排序”。</p><p>有个比较特别的地方是，WHERE和ORDER BY可以“联手”玩转联合索引，比如对于index(a,b,c)，并不是只有WHERE a,b,c或者ORDER BY a,b,c才能利用联合索引，WHERE a=1 ORDER BY b,c也是可以的~</p><p>讲完了这三个场景，再稍微注意一下联合索引失效的问题即可（只说两个最常用的）：</p><ul><li>最左匹配原则</li><li>注意范围查询，比如WHERE a&gt;1 and b=2 and c=3，那么就只能用到a啦</li></ul><h2 id="场景四：COUNT统计"><a href="#场景四：COUNT统计" class="headerlink" title="场景四：COUNT统计"></a>场景四：COUNT统计</h2><p>虽说一般大数据量不推荐直接使用COUNT函数，但绝大部分公司都是小公司，一张表不会很大，所以初期COUNT也无妨，但最好尽量走索引。比如要求统计天猫平台下的店主粉丝数量：</p><p>SELECT COUNT(*) FROM t_user_follow WHERE uid=123 and platform=6 and follow_status=1;</p><p>此时最好建立联合索引index(uid, platform, follow_status)，速度会稍微快一些。</p><p>其实场景四不过是联合索引的一个特例，这里单独提出来，就是为了给大家提个醒：哦？COUNT也能用上联合索引啊！</p><h1 id="MySQL的架构图"><a href="#MySQL的架构图" class="headerlink" title="MySQL的架构图"></a>MySQL的架构图</h1><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589599142582-6d0f9da2-d57b-4816-bf63-707f9337fe9d-20210923214721874.png" alt="img"></p><p>看到那个查询优化器了吗，比如index(a,b,c)联合索引，即使我们写成 WHERE a=1, c=3, b=2也能走全索引，就是因为它帮我们优化了顺序。</p><p>好了，虽然上面的内容不一定全部正确，但个人认为利大于弊，起码能让你快速、清晰地理解SQL优化的底层原理，相信大家对于市面上任意的SQL优化课程都能快速吸收。</p><p>如果要用一句话概括SQL优化，应该是下面这句：</p><p>所谓SQL优化，其实就是让查询优化器<strong>根据程序员的意愿</strong>选择匹配的执行计划，最终减少查询中产生的IO。</p><p>这几篇下来，大家应该对索引是什么、如何进行SQL优化有了整体的认知。</p><h1 id="教程推荐"><a href="#教程推荐" class="headerlink" title="教程推荐"></a>教程推荐</h1><p>SQL优化如果仅仅是想学到能应付日常工作，其实不难。但对于初学者（尤其是非科班），最难的其实是入门，比如索引的概念等。前面的几篇的作用，就是帮大家跨过最开始的不适区，接下来我觉得大家其实已经可以自学了。</p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><a href="https://www.bilibili.com/video/BV1KW411u7vy?from=search&seid=131710834280412195">尚硅谷——MySQL优化</a></p><p><a href="https://www.bilibili.com/video/BV1es411u7we?p=1">https://www.bilibili.com/video/BV1es411u7we?p=1</a></p><p>复习时尽量注意以下知识节点：</p><ol><li><p>MySQL常用数据类型及选择（肯定有人对int(11)和varchar(255)里的数字迷茫吧？）</p></li><li><p>数据库范式与反范式的取舍</p></li><li><p>SQL基础：简单查询、关联查询、子查询、GROUP BY、HAVING、ORDER BY、LIMIT，重点关注GROUP BY和ORDER BY，它俩最常用也最难理解</p></li><li><p>常用函数，比如now()等</p></li><li><p>什么是索引、索引的数据结构是什么（只考虑InnoDB）</p></li><li><p>索引加快查询的原理、聚簇索引和非聚簇索引的概念</p></li><li><p>索引的优缺点</p></li><li><p>如何利用Explain分析执行计划、慢查询日志</p></li><li><p>索引失效的几种场景(最左匹缀、!=、LIKE %…、列函数计算等)</p></li><li><p>SQL改写的几种场景与策略</p></li></ol><p>有了小册几篇文章的铺垫，现在大家再来看上面的视频会轻松很多。</p><p>如果一开始就给大家看上面的视频，会懵。确实不如燕十八老师讲的通俗易懂…</p><h2 id="专栏"><a href="#专栏" class="headerlink" title="专栏"></a>专栏</h2><p>如果希望继续深入，可以继续选择专栏观看。</p><p><a href="https://www.imooc.com/read/43">https://www.imooc.com/read/43</a></p><p><a href="https://time.geekbang.org/column/intro/139">https://time.geekbang.org/column/intro/139</a></p><p>建议先看第一个，虽然第二个确实厉害点，但不如第一个简单易懂。个人认为有些细节确实不知道也没什么，最重要的是有较为系统认识即可。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化(3)-索引与优化原理(上)</title>
    <link href="/2020/08/13/SQL%E4%BC%98%E5%8C%96(3)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8A)/"/>
    <url>/2020/08/13/SQL%E4%BC%98%E5%8C%96(3)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上一篇，我们重走了一遍数据库索引的历史，认识了B+树结构，这一篇我们回归现实中的MySQL数据库，初步学习具体的SQL优化原则，并尝试从索引底层原理出发，分析为什么会有那么多的“规则”。</p><h1 id="为什么要学习SQL优化"><a href="#为什么要学习SQL优化" class="headerlink" title="为什么要学习SQL优化"></a>为什么要学习SQL优化</h1><p>我的前东家是做招聘服务的，所以不可避免地要查询行业分类。通常来说，前端可以采用根据parentId分步加载的方式获取行业类别，但有些场景也需要全量嵌套查询：查询行业分类及其子分类。</p><p>这里我们就假定直接查询所有分类及其子分类：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584876552845-1508cebc-e24b-4812-b5f1-d44df431105b-20210923151052749.png" alt="img"></p><p>我自己设计了一个简单版的表结构，大概如下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584876666317-5f0f97f0-aa23-4be1-a7bf-e1d8fce54587-20210923151044115.png" alt="img"></p><p>表中有1106条数据：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877002375-f8dd6ff0-eff5-485b-a2e7-277a049ffdaa-20210923151103929.png" alt="img"></p><p>经过《实用小算法》的学习，我们很容易写出以下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询行业分类及其子分类</span><br><span class="hljs-comment"> */</span><br>@Test<br>public void test<span class="hljs-constructor">Cascade()</span> &#123;<br><br>    <span class="hljs-comment">// 查询数据库，得到所有行业类别</span><br>    List&lt;SysPosition&gt; sysPositionList = sysPositionMapper.select<span class="hljs-constructor">All()</span>;<br><br>    long start = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br><br>    Map&lt;String, SysPosition&gt; sysPositionMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>    List&lt;SysPosition&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-comment">// 第一步：List转Map</span><br>    <span class="hljs-keyword">for</span> (SysPosition sysPosition : sysPositionList) &#123;<br>        sysPositionMap.put(sysPosition.get<span class="hljs-constructor">Code()</span>, sysPosition);<br>    &#125;<br><br>    <span class="hljs-comment">// 第二步：遍历List，利用Map完成嵌套</span><br>    <span class="hljs-keyword">for</span> (SysPosition sysPosition : sysPositionList) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-1&quot;</span>.equals(sysPosition.get<span class="hljs-constructor">ParentCode()</span>)) &#123;<br>            result.add(sysPosition);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            SysPosition parent = sysPositionMap.get(sysPosition.get<span class="hljs-constructor">ParentCode()</span>);<br>            parent.get<span class="hljs-constructor">Children()</span>.add(sysPosition);<br>        &#125;<br>    &#125;<br><br>    long <span class="hljs-keyword">end</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (<span class="hljs-keyword">end</span> - start));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在《实用小算法》中，我们分析过效率：List转Map这种方式会有2N次循环，也就是会循环2212次。</p><p>大家猜上面程序耗时多少？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877133249-0f113716-f40b-4824-be73-a6fbc5eac808-20210923151113333.png" alt="img"></p><p>只需1<strong>毫秒</strong>。</p><p>对于CPU来说，计算内存中的数据是非常快的，几千次的循环基本可以忽略不计。</p><p>你们想知道之前《实用小算法》的第一版算法耗时多少吗？测一下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877340185-9be080f5-c98b-4ef3-9dbc-6b6e690f36a4-20210923151121192.png" alt="img"></p><p>也<strong>只要</strong>33毫秒。</p><p>要知道，第一版算法在这种情况下可是循环了1106*1106 = 100w+次！！<strong>但是对于CPU来说，不足挂齿。</strong>当然，这是单次调用的差距，想象一下这个接口每天要被几十万、甚至几百万用户调用，累计差距还是很可观的。</p><p>通过上面的案例，我想说的是：绝大多数情况下，内存中数据的处理耗时几乎可以忽略不计。</p><p>大家有没有发现，上面的程序并没有把Mapper查询数据库的操作计入时间？数据库select操作会很耗时吗？</p><p>我在某网站的专栏中看到过关于数据库insert的一段话：</p><p>插入行所需的时间由以下因素决定（参考MySQL 5.7参考手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html">8.2.4.1优化INSERT语句</a>）</p><ul><li><p>连接：30%</p></li><li><p>向服务器发送查询：20%</p></li><li><p>解析查询：20%</p></li><li><p>插入行：10% * 行的大小</p></li><li><p>插入索引：10% * 索引数</p></li><li><p>结束：10%</p></li></ul><p>可发现大部分时间耗费在客户端与服务端通信的时间，因此可以使用 insert 包含多个值来减少客户端和服务器之间的通信。我们通过实验来验证下一次插入多行与一次插入一行的效率对比。</p><p>上面虽然说得是insert，但select的情况其实也差不多。现在我把Mapper查询的时间也包括进来：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877601504-4c6d4ea7-967a-4e78-9d0c-1219fc21c491-20210923151138685.png" alt="img"></p><p><strong>竟然暴增到496毫秒！！</strong></p><p>好了，这个例子告诉我们，网络请求（以及IO操作）是非常耗时的操作，我们应该尽量避免在循环中调用网络请求或进行IO操作，比如：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877845815-757a0f69-eaee-42bc-90b4-d4949e03cb0c-20210923151148208.png" alt="img"></p><p>这是非常差劲的写法。</p><p>OK，到这里大家应该能形成一个认知：一次正常的请求，最可能出现性能瓶颈的地方就是网络请求及IO操作（通常而言性能瓶颈往往出现在数据库）。</p><p>要想优化数据的查询，大方向有两个：</p><ul><li>优化关系型数据库本身，比如增加索引等</li><li>借助大数据和ES，转嫁查询压力（本质已经和关系型数据库无关了）</li></ul><p>对于一般小公司而言，大数据和ES还是稀罕物，所以当我们讨论性能优化时，SQL优化几乎是重点！和SQL的性能提升相比，代码的优化有时是微不足道的。<strong>即使有优化，归根到底其实还是减少、减小对数据库的请求。</strong>大家应该要感到高兴，因为你们终于也将登堂入室，要去探索SQL优化了。</p><p>没有特殊情况的话，本文讨论的内容都是基于InnoDB引擎</p><p>在我看来，对于一般的Java开发而言，SQL优化分为几个层次：</p><ul><li><p>索引优化 70%</p></li><li><p>事务及锁 20%</p></li><li><p>读写分离等 10%</p></li></ul><p>其中，索引优化是最重要、也是一般Java开发人员最常用的手段。</p><h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><p>索引的分类可能有不同维度，这里不追求特别准确的分类，毕竟不是做学术，只要感性认识几种即可。</p><p>打开Navicat，尝试创建索引时会发现有4种索引类型可以选择：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589520399248-9a8373e7-567f-4ab5-9d74-f39ac0bb3332-20210923151215022.png" alt="img"></p><ul><li><p>全文索引</p></li><li><p>普通索引</p></li><li><p>空间索引</p></li><li><p>唯一索引</p></li></ul><p>普通索引就可以组织树结构了，而唯一索引在普通索引的基础上还要求索引列不能重复。比如，假设我们给student表的name列加了唯一索引，如果表中已经存在”张三”，那么再次插入”张三”将会报错。</p><p>MySQL这种关系型数据库并不适合进行全文检索（考虑Elastic Search），所以全文索引一般很少使用。</p><p>至于空间索引，我也不知道是什么。</p><p>实际开发常用的索引只有<strong>普通索引</strong>和<strong>唯一索引</strong>，其他的可以不用理会（主键索引其实相当于唯一索引+非NULL）。</p><h1 id="索引的实现方式"><a href="#索引的实现方式" class="headerlink" title="索引的实现方式"></a>索引的实现方式</h1><p>常见的索引实现方式有两种，通过B+树结构或hash算法实现。</p><p><strong>特别注意，这里虽然写的是”BTREE”，但MySQL确实使用的是B+Tree。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589533482892-ea6a7e77-c129-45e3-8519-827ae57c69c7-20210923151221445.png" alt="img"></p><p>这个概念，其实和上面“索引的类型”并不冲突。</p><p>比如，对于普通索引，我们可以使用B+树的结构组织索引，也可以使用hash算法实现。经过上一篇的学习，我们对B+树结构已经比较了解，所以这里单独聊一下hash索引。</p><p>所谓hash索引，其实就是利用<strong>哈希算法为索引列计算得到唯一的存储地址</strong>，一般来说这个地址是不会重复的（重复的情况被称为哈希冲突）。</p><p>举个燕十八老师说的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589533947057-755cdba3-b196-44cd-88c4-813dc6397463-20210923151227170.png" alt="img"></p><p>在墙上装一根弹性永不衰变的弹簧，每次拿不同的物件把弹簧压到极限后放开，不同的物件最终落点会不同。比如你上回存了一本书，那么下次想要找到这本书时，只需要拿一本<strong>一模一样的书</strong>重新弹一下，即可在本次落点处找到上次那本书。</p><p>数据库hash索引的设计也类似，假设你要存入id=10086的数据，就需要通过hash算法对id进行计算，得到一个存储位置后写入数据。下次拿着id=10086查询时，只要按同样的算法再次计算，就能马上找到对应的数据，是不是很快呢~</p><p>需要注意的是，弹簧的例子用来比喻hash算法虽然挺形象的，但可能会让人误以为越重的物品落点越近，越轻的物品落点越远，进而得出结论：hash索引可以进行范围查找。</p><p>其实并不是如此。</p><p>hash算法有个比较显著的特征：即使源数据具备一定的相关性，经过hash映射后得到的结果也会变得“很散”，没有规律可循。回到之前的例子中，你可以理解为重量并不是影响书本最终落点的唯一因素，书的材质、形状等都占有一定比例，最终体现到空气阻力上导致落点的不规则。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608951320970-75bcceba-6e55-4737-9e29-8a7da83502b6-20210923151233076.png" alt="img"></p><p>不知道大家还是否记得，在JavaSE阶段接触HashMap时，很多人会发现put的顺序和get的顺序并不一定相同。比如put的顺序是1000克、500克、300克，而get的顺序却是500克、300克、1000克。也就是说，经过hash计算后，数据的相关性会大大减弱。</p><p>所以，当你希望查找500g~1000g的书本时，就无法利用边界值进行范围查找。而B+树<strong>叶子节点是有序链表</strong>，范围查询非常方便。</p><p><strong>hash索引除了无法进行范围查找外，还不能进行模糊搜索。</strong></p><p>hash算法本身代表着精确定位，依赖于计算的入参得出“唯一”的值，所以无法进行模糊匹配。比如，你给我”bravo”，我可以计算唯一的hash值，你给我”bra%”，我会以为这人就叫”bra%”，也计算一个值，<strong>而****这个值代表着”bra%”计算得到的落点，而不是”所有以bra开头的数据”的落点</strong>，显然是不对的。</p><p>但B+树可以进行模糊搜索，你可以姑且认为因为它会顺着树查找，并在装有数据的节点内调用类似Java的String#startWith()方法进行比较。</p><p>hash索引的优劣势</p><ul><li>优势：速度非常快，只需一次计算即可得到地址，时间复杂度O(1)，而B+树是O(logn)</li><li>劣势：不支持模糊查询、范围查询、索引排序（本身就是不规则的，如何利用索引排序呢）</li></ul><p>最后，《实用小算法》中List转HashMap的操作其实就是借鉴了hash索引！</p><h1 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h1><p>索引的创建时机一般有两处：</p><ul><li>起初，建表时顺便建立索引</li><li>后期，修改表结构创建索引（一般都是这样，因为很难未卜先知，提前优化等于瞎优化）</li></ul><p>比如，一开始就创建索引：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589520661369-1d8b2328-8dca-4f08-8fb4-94df84b770b5-20210923151242400.png" alt="img"></p><p>这张表有两个索引：主键索引、auditor_id普通索引。</p><p>主键索引并不属于上面介绍的4种索引类型之一，但所谓的Primary Key可以看做 唯一索引 + NOT NULL约束。</p><p>后期如果需要添加索引，可以通过两种方式：</p><ul><li>SQL语句</li><li>Navicat图形界面</li></ul><p>利用SQL语句添加索引：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 1.添加PRIMARY KEY（主键索引） </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span> (`<span class="hljs-keyword">column</span>`) ;<br><span class="hljs-comment">-- 2.添加UNIQUE(唯一索引) </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> (`<span class="hljs-keyword">column</span>`);<br><span class="hljs-comment">-- 3.添加INDEX(普通索引) </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (`<span class="hljs-keyword">column</span>`);<br><span class="hljs-comment">-- 4.添加FULLTEXT(全文索引) </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> FULLTEXT (`<span class="hljs-keyword">column</span>`);<br><span class="hljs-comment">-- 5.添加联合索引 </span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-built_in">table_name</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (`column1`, `column2`, `column3`);<br></code></pre></div></td></tr></table></figure><p>在本案例中，可以写：</p><figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">ALTER TABLE `moneywithdraw` ADD INDEX idx_auditor_id (`auditor_id`)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>利用Navicat图形界面创建<strong>单列索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589521376561-1c62b92e-60ae-4d06-ad73-6cfa4c69101b-20210923151251589.png" alt="img"></p><p>利用Navicat图形界面创建<strong>联合索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589521546600-37ba8127-ad31-4f94-a137-e1986de9354f-20210923151256752.png" alt="img"></p><p>哦，对了，数据量太大的表，不要自己随便加索引，搞不好会锁表哦…后面有机会再说。总之，你可以“懂索引”，但要“动索引”前，最好三思。</p><h1 id="索引的好与坏"><a href="#索引的好与坏" class="headerlink" title="索引的好与坏"></a>索引的好与坏</h1><p>提到索引，很多人就会说：哦，索引能提高查询速度。一般这么说的人，可能学得还不错，但绝对还没有完全掌握索引的底层原理。</p><p>如果你认为索引的优势只是加快查询，那就太小看索引了。</p><p>索引的优势是：</p><ul><li><p>加快查询速度（包括关联查询）</p></li><li><p>加快排序速度（ORDER BY）</p></li><li><p>加快分组速度（GROUP BY）</p></li></ul><p>虽然加快排序、加快分组最终还是体现在加快查询速度上，但能主动意识到这一点算是一种突破。只有当你意识到索引能加快排序和分组，你才会在写ORDER BY和GROUP BY时有意识地利用索引分组和排序（最左匹配原则），从而写出更优的SQL。</p><p>索引的劣势：</p><ul><li><p>创建索引是需要付出代价的，主要体现在维护成本、空间成本和回表成本。也就是说<strong>索引能提高查询效率，但往往会降低增删改的速度</strong>（字典新增几百个字，需要额外编排目录吧，要多占几页纸吧）</p></li><li><p>如果使用了联合索引，还需要考虑索引失效问题（下篇介绍联合索引）</p></li><li><p>太多的索引会增加查询优化器的选择时间（选择太多也麻烦）</p></li></ul><h1 id="建索引的原则"><a href="#建索引的原则" class="headerlink" title="建索引的原则"></a>建索引的原则</h1><p>很多人觉得SQL优化才是重中之重，创建索引只需要一行代码即可，没什么大不了的。但现在你已经知道了索引的优势与劣势，你会明白“在合适的时候、合适的字段建立索引”是多么空泛的口号。创建索引的判断依据究竟是什么呢？</p><p>创建索引有4个大原则：</p><ul><li><p>索引并不是越多越好，联合索引应该优于多个单列索引</p></li><li><p>索引应该建立在区分度高的字段上</p></li><li><p>尽量给查询频繁的字段创建索引，避免为修改频繁的字段创建索引</p></li><li><p>避免重复索引</p></li></ul><p>第一个原则背后的原因是，实际上数据库一次查询只会选择<strong>一棵索引树</strong>（不包括回表），更专业的说法是每次查询只会选择一个执行计划。即使你给a,b,c,d,e,f,g…所有列都加了索引，SELECT xx, xxx FROM table WHERE …时，数据库也只会<strong>择优****选择</strong>一个执行计划进行查询。</p><p>需要注意的是，<strong>每建一个索引，就需要维护一棵索引树，</strong>所以索引绝对不是越多越好，不合适的索引会增加数据库的负担。比如，你已经搞了一个根据拼音查找汉字的目录，又想根据偏旁部首来，那没辙了，只能劳烦您自己再搞一个目录了。</p><p>看到这，你可能会反问：我靠，那MySQL也太笨了吧，为什么这么死心眼一次只利用一个索引？</p><p>比较粗浅的理由是：你根据拼音查完汉字以后，还会根据偏旁部首再查一遍吗？</p><p>比较正经的理由是：按我个人的理解，索引本身的出发点是“走完一遍索引后，数据库应该返回<strong>精确的结果</strong>或<strong>很小的结果集</strong>”，从成本上考虑，此时再走一遍索引还不如直接遍历结果集来得快。当然，要想一次索引就得到精确的结果集，着实需要下一番苦功夫。给哪个字段加索引好呢？我建议，应该尽可能给区分度高的字段添加索引。</p><p>什么是区分度很高？这就是建索引的第二个原则啦。比如，表中有100w学生数据，你如果在sex列加索引，那么根据sex大概只能过滤掉50w数据，剩下的结果集仍然很大，说明这个索引建得不太合适，区分度太低了。</p><p>第三个原则就是字面意思。比如一本字典根据内容编好目录以后，隔三差五地就有新词汇要往里面加，或者经常要修改汉字读音，一顿操作后必然要连累目录，只能重新编排啦。也就是说，为了保证目录能正确指向对应的汉字，每次增删改后都要额外多一个操作：重新修订目录。</p><p>总之要意识到索引在加快查询的同时几乎必然会对修改产生负担，所以创建索引并没有那么简单，它绝对是一门“平衡的艺术”。</p><p>第四个原则是，比如已经建立a索引，又建立index(a,b,c)联合索引，此时单列索引a就是冗余的，因为联合索引已经可以保证符合条件时会利用a索引。<strong>在物理存储上，a单列索引和index(a, b, c)是两个独立的B+树，</strong>重复的索引会增加维护成本。</p><p>以上四个原则，后面的内容还会重新提到。</p><h1 id="MySQL常用引擎"><a href="#MySQL常用引擎" class="headerlink" title="MySQL常用引擎"></a>MySQL常用引擎</h1><p>MySQL的引擎有很多种，但最常听到的就MyISAM和InnoDB，而实际开发几乎99%选择使用InnoDB，而且MySQL5.6还是哪个版本以后默认引擎就从MyISAM变成了InnoDB，所以这里着重介绍InnoDB，简略介绍MyISAM。</p><p>对于两种引擎的介绍，可以看：<a href="https://www.bilibili.com/video/BV1RE41187Yo?p=9">存储引擎简介</a></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589527342910-49ca1484-7ba5-4924-944f-d1008cd46e85-20210923151312836.png" alt="img"></p><p>这里主要想和大家讨论MyISAM和InnoDB在索引组织上的区别。大家应该都已经知道，MyISAM和InnoDB存储数据的方式是不同的。</p><p>MyISAM的每张表在存储时会分为3个文件：</p><ul><li><p>表结构</p></li><li><p>表数据</p></li><li><p>索引</p></li></ul><p>也就是说，表数据和索引是分别独立存储的。</p><p>而InnoDB的表数据在存储时只分为2个文件：</p><ul><li>表结构</li><li>表数据+索引</li></ul><p>需要注意的是，InnoDB所有表的数据和索引都在同一个文件里（见下一个小节）。</p><h1 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h1><p>对于BTREE索引而言，从数据的组织形式来看，索引又可以分为两大类：</p><ul><li>聚簇索引</li><li>非聚簇索引</li></ul><p>所谓聚簇索引，可以简单理解为索引和数据是“聚合”在一起的，而非聚簇索引的数据和索引是分开的。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589532501128-7bf641bd-946e-446b-9a0f-a581b3f13887-20210923151325454.png" alt="img"></p><p>根据InnoDB引擎的<strong>主键索引</strong>查询时无需回表，每一行完整的数据都直接挂在叶子节点下，可以直接返回。也就是说，对于InnoDB的<strong>主键索引</strong>而言，数据即索引，索引即数据。<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589586538060-89e3781c-22ed-4b16-a734-d5466af2d6aa-20210923151335790.png" alt="img"></p><p>MyISAM不是很重要，不提了。</p><p>InnoDB的索引也并不是都不需要回表，根据是否需要回表其实可以分为两类：主键索引、辅助索引（或者叫二级索引、普通索引）。</p><p>会什么要做这种区分呢？</p><p>假设一个场景：</p><p>新建一张表后，自然会产生主键索引。但后期发现name字段查询很频繁，于是加了name索引。</p><p><strong>如果name索引也和主键索引一样挂着数据，那么两个索引数据就会重复。想象一下，现在磁盘中有一颗叫name的树和一棵叫id的树，一个以name为节点，一个以id为节点，相同的是最底层叶子节点都挂着完整的表数据。也就是说，磁盘中存了两份一模一样的student数据。且不说数据冗余，更新时还可能产生数据不一致（要同步数据，确保多张表的数据一致性）。</strong></p><p>所以InnoDB的做法是，辅助索引只存储索引列+主键，必要时进行“回表”操作：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589536446002-5fddd16a-59f2-4928-b10e-088aaa01f927-20210923151343933.png" alt="img"></p><p>由于SELECT * FROM stu WHERE name=’bravo’中，查询的数据是*，也就是整行数据。而上面的辅助索引只存了主键+name，所以必须回表：拿着主键再去跑一遍主键索引，最终返回整行数据。</p><p>现在，我们可以给MyISAM和InnoDB的索引分类做个简单的总结：</p><ul><li><p>MyISAM：非聚簇索引，需要回表</p></li><li><p>InnoDB：</p></li><li><ul><li>聚簇索引：主键索引，叶子节点是表数据，不需要回表</li><li>非聚簇索引：辅助索引（唯一索引、普通索引），叶子节点是主键，必要时需要根据主键回表查询</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608956710604-75cdbc20-a59e-473f-9e98-b963ac3cd49d-20210923151351478.png" alt="img"></p><p>InnoDB每张表只能有一个主键索引，辅助索引则可以有多个。表数据只有一份，挂在主键索引下面。</p><p>需要注意的是，如有可能，应该尽量避免回表。<strong>SQL优化的本质其实就是减少/减小磁盘IO</strong>，而回表必然会增加磁盘IO次数。</p><p>举个例子，假设某张表总共就两棵索引树：主键索引+name辅助索引，两棵树高度都是3。由于只有主键索引下才挂着表数据，所以对于SELECT * FROM table WHERE name=’xxx’来说，需要先走辅助索引取得id，再根据id走一遍主键索引。假设两棵树需要的数据都在第三层，那么这条SQL需要进行6次逻辑IO访问。而如果直接根据id查询，就可以直接走主键索引，IO次数为3。</p><p>所以，<strong>通常情况下</strong>辅助索引查询都是需要回表的，比主键索引查询多扫描一棵索引树（自身+主键索引），实际编写SQL时，应该尽量走主键索引。</p><p>那么，<strong>什么情况下</strong>辅助索引可以避免回表吗？</p><h1 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h1><p>索引覆盖这个名字，咋一听不知所云，所以很多初学者一直搞不明白什么意思，其实它最大的作用就是：避免回表。</p><p>下面通过一个案例来说明。</p><p>假设有个需求：前端需要支持<strong>根据用户名模糊搜索订单，</strong>而页面需要的字段如下。</p><table><thead><tr><th><strong>id</strong></th><th><strong>productName</strong></th><th><strong>price</strong></th><th><strong>userName</strong></th><th><strong>userAge</strong></th></tr></thead><tbody><tr><td>1</td><td>iphone12</td><td>5999</td><td>bravo1988</td><td>18</td></tr></tbody></table><p>一个可行的方案是：</p><ol><li><p>在t_user表中根据name搜索用户，得到user_id、user_name、user_age</p></li><li><p>在t_order表中根据user_id查询订单</p></li><li><p>在内存中根据user_id匹配order和user数据后返回</p></li></ol><p>由于t_user表此时的查询条件是user_name，为了加快t_user表的查询速度，可以给user_name加普通索引。但，这样真的好吗？我劝！不要犯这样的聪明，小聪明啊。</p><p>你要知道，此时我们从t_user表查询的可不止user_name，还有user_age和id。如果只是给user_name加了索引，那么此时磁盘中产生的索引树是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610162572296-97295d9c-ab7c-444b-a99a-6c8ea8f106eb-20210923151400366.png" alt="img"></p><p>这棵树的非叶子节点是user_name，叶子节点是id，<strong>也就是说从这棵树上我们只能得到user_name和user_id</strong>，至于user_age，MySQL底层只能跳出name索引树，然后跑到隔壁主键索引获取。整个过程被称为回表，而回表意味着多跑一趟。</p><p>此时我们可以给user_name和user_age加一个联合索引，这样就能产生所谓的“索引覆盖”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610162521710-d2586c99-f888-4db1-b713-3a69dc59028d-20210923151409810.png" alt="img"></p><p>当辅助索引上的字段完全满足本次查询的列时，就是所谓的索引覆盖，这是一个好消息，意味着不需要回表，查询效率将会大大提高。这也是为什么SQL优化原则中经常会强调：尽量只取必要的字段，避免SELECT *（提高索引覆盖的几率，查询的字段越多，几率越低）。</p><p>即使目前表中只有两个字段且已经索引覆盖，也不要写SELECT *。因为后期随着业务扩展，这张表会新增其他字段，此时SELECT *将不再覆盖索引！</p><p>为了方便记忆，大家可以把索引覆盖理解为 索引的字段 &gt;= 查询需要的字段。比如联合索引的字段是index(a,b,c)，那么此时SELCT a, b就会发生索引覆盖，索引覆盖最大的好处是避免回表。</p><p>需要强调的是，覆盖索引和联合索引没有必然关系。比如我只给user_name加单索引，而我查询语句是</p><p>SELECT id, user_name FROM t_user WHERE name=’bravo’;</p><p>此时也是索引覆盖。所以，<strong>能否索引覆盖不取决于索引单方面，需要查询配合。</strong></p><p>关于联合索引，我们放在下一篇介绍。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化(2)-索引与B+树</title>
    <link href="/2020/08/11/SQL%E4%BC%98%E5%8C%96-%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/"/>
    <url>/2020/08/11/SQL%E4%BC%98%E5%8C%96-%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于60%的程序员而言，Java的三层架构Controller、Service、Dao可以说是“越往后走天越黑”，特别是到了Dao层，提着灯笼也只能看到脚边一米开外的河边小石子，只闻对岸风啸马嘶却不知到底是人是鬼，只能借着MyBatis或JPA这些ORM框架隔着宽宽的河举行一场又一场的刺刀战，你砍我一刀，我刺你一剑。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589374354625-30b6de0f-8337-4db5-964b-6c6df7ae09ad-20210923150111295.png" alt="img"></p><p>诚然，很多人对MySQL数据库的印象就是一个模糊的大铁柜，闭上眼睛深吸一口气仿佛还能嗅到一股铁锈味。只知柜子里藏着很多张表，表里面存着很多行数据，再详细一点的呢？不知道。</p><p>MySQL有太多太多细节，根本无法用四、五篇文章说透，但我仍希望这个系列的文章能成为非常好的入门教程，让从来没接触过SQL优化的同学也能快速建立较为系统的知识框架，方便日后学习其他专栏时进一步拓展。</p><hr><h1 id="柏青哥"><a href="#柏青哥" class="headerlink" title="柏青哥"></a>柏青哥</h1><p>大家小时候在游戏厅看过下面这种机器吗：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589354675837-5eaba89f-fb57-4fdf-aa7e-80573ada61a6-20210923150439959.png" alt="img"></p><p>日本人管它叫柏青哥（パチンコ），玩法是：</p><p>从机器最上方的唯一入口投入一颗钢珠，由于重力的作用，钢珠会往下落。机器是直立的，面板上有很多突出的圆柱，它们的作用是随机改变钢珠的落点。最终，钢珠掉落在下方的某个槽中。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589355808319-788e3454-19ae-4c57-9707-b68edc99f05c-20210923150137448.png" alt="img"></p><p>这里提柏青哥，是为后面的B+树及分析B+树搜索过程做铺垫。到时你会发现，沿着索引树搜索的过程和柏青哥小钢珠的下落过程是多么相似！</p><p>很多人都听过数据库索引，但是很少人会去思考下面几个问题：</p><ul><li><p>索引是什么</p></li><li><p>为什么需要索引</p></li><li><p>索引怎么起作用</p></li></ul><p>在历史的长河中，索引的出现几乎是必然的。不信？那就跟我重走一遍历史吧。</p><p>请大家先忘了MySQL、Oracle等乱七八糟的玩意儿，就假设你是上世纪第一批程序员，此时连正儿八经的数据库都没有，需要由你来开天辟地。目前摆在你面前的最大难题是：如何较为<strong>高效地</strong>存取数据？</p><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p>最直观的想法就是存“格子”里，也就是将数据存在线性结构的容器中，比如数组或链表。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589356217794-f7c00e60-53e2-447d-a2b5-2c97d4726d0c-20210923150143937.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589357468320-10555c9b-b1f5-41a7-922d-73ea4f70c03c-20210923150149784.png" alt="img"></p><p>用线性结构存储数据<strong>短期</strong>看是没问题的，但是一家名为SUN的公司发现，随着公司业务增长，平台要经手的用户数据越来越多，特别是今年，他们收到了很多客户的信件投诉，说网页数据的加载越来越慢了！</p><p>SUN的工程师做了个实验，一个线性表如果存了42亿条数据，想要找到id=100的数据，游标只需爬99格即可返回，但如果id=10000000，就要爬将近1000w个格子才能返回。对于这42亿条数据，平均查询次数是21亿次！！</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>作为改进，有人提出用树结构来存储数据。比如，如果要找id=6的数据，那么只要比较3次，小于爬格子次数（5次）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358245965-f357a5d0-90fc-49e7-affe-8cfa11a2243d-20210923150156142.png" alt="img"></p><p>如果要找id=9的数据，只要比较4次，小于爬格子次数（8次）。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358394072-a5d5f642-25e5-4d01-ba52-ba7251609d4a-20210923150201825.png" alt="img"></p><p>结合两次实验，SUN的工程师发现：</p><p>在一棵树中找到目标数据所需的比较次数 = 目标数据所在的层级</p><p>如果用一棵树来存储42亿条数据，即232=42亿，树的层级是32，最差的情况也只要查32次（需要是二叉平衡树），远远小于线性结构的平均21亿次，这是非常夸张的。</p><p>注意，在线性结构的案例中，不是我故意不用二分查找，而是不能使用二分查找。一般来说，<strong>对于线性结构的数据集合，如果要使用二分查找，那么整个数据都要事先在内存中，</strong>但显然没人会这样做！相比在内存中对线性结构进行二分查找，树在逻辑上天然支持二分查找。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608365614192-1f7e343b-f3fc-4dd6-b4c7-90d64f7569d9-20210923150207584.png" alt="img"></p><p>然而，树结构也分好几种：</p><ul><li><p>Binary Search Tree（二叉查找树）</p></li><li><p>AVL Tree（二叉平衡树）</p></li><li><p>B Tree（平衡树）</p></li><li><p>B+ Tree（大名鼎鼎的B+树，对B Tree的改进）</p></li><li><p>…</p></li></ul><p>大家可以访问<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a>这个网站动手玩一下，特别注意上面的4种树：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589360823134-4c779906-c5d8-4ea4-ab72-47af54d8af3c-20210923150214447.png" alt="img"></p><p>如果你听我的建议，打开上面的网站选择Binary Search Tree并按1,2,3,4…的顺序插入数据时，<strong>它其实变成了线性结构：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358856443-e8032dc1-b241-4f23-9c43-883c36b3b25e-20210923150222903.png" alt="img"></p><p>显然，这不是我们想要的结果，因为刚才已经讨论过，线性结构不适合存储大数据，等后期数据量大了以后要爬很多“格子”。</p><h1 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h1><p>相比来说，AVL Tree更符合SUN工程师的需求：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358993173-e6bd2cc0-279a-4d98-8fdc-68abf82b2744-20210923150229048.png" alt="img"></p><p>二叉平衡树会在数据插入完毕后<strong>自动调整节点，好让“树的层级”不至于太深。（赶紧去动手玩一下）</strong></p><p>按理来说，如果我们按二叉平衡树组织表数据的话，应该是非常完美的。你想啊，42亿数据中找一条记录最多只需比较32次，尤其是对于CPU来说，<strong>别说32次比较，哪怕32w次简单数据的比较都不会超过0.1秒。</strong>但是！问题在于这里所谓的“32w次简单数据的比较不会超过0.1秒”有个前提条件：<strong>数据必须全部在内存中。</strong></p><p>而我们的表数据因为数据量很大，而且需要持久化，所以一般来说是存在磁盘中，等需要使用时再从磁盘载入内存，也就是涉及磁盘-内存的IO操作。</p><p>通常情况下，没有人会直接把500w行数据一次性加载到内存中进行二分查找，内存极有可能顶不住（同时访问多张表，全部加载）。所以，最终我们组织数据库的方式只能是：</p><ul><li><p>把数据存在磁盘中</p></li><li><p>数据按树结构组织</p></li><li><p>查询时分块读取数据并比较，持续进行磁盘IO读取节点，直到找到目标数据</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608365864685-03842132-d684-4a5b-9ca8-42ceb43181f7-20210923150235370.png" alt="img"></p><p>每一个节点存储“一小块数据”，分多次IO读取每一块数据到内存判断，直到找到匹配的数据。</p><h1 id="二叉平衡树与磁盘IO"><a href="#二叉平衡树与磁盘IO" class="headerlink" title="二叉平衡树与磁盘IO"></a>二叉平衡树与磁盘IO</h1><p>数据存在磁盘中，没问题。</p><p>数据桉树结构组织，没问题。</p><p><strong>查询时分块读取数据，有一点点问题。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589361951577-71cfd4b1-bfd8-44cc-a968-5de2d821fe2b-20210923150241680.png" alt="img"></p><p>磁盘IO是非常耗时的操作，耗时到什么程度呢？大家可能都听过各个语言的执行效率：</p><p>C &gt; C++ &gt; Java &gt;&gt; Python</p><p>但这些都是在内存层面谈论语言自身的执行效率，而实际上开发一个Web应用，无论用上述哪个语言，对于普通应用而言，都是可以满足用户需求的，真正的瓶颈是IO（网络IO和磁盘IO）。就好比F1赛车、奥迪A4和拖拉机一起跑在北京4环的路上，限制它们的不是引擎，而是堵车。</p><p>所以，二叉平衡树虽然查找42亿数据最多只需32次，但是32次磁盘IO还是不能接受的。</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>基于上面的分析，如果考虑磁盘IO，那么原本优秀的二叉平衡树将显得不再那么优秀。错的不是二叉平衡树，而是我们没有那么大的内存，也不方便把数据都放内存（考虑数据丢失与持久化）。</p><p>但现在不是考虑谁对谁错的时候，要想优化当前数据库，关键是减少磁盘IO次数，<strong>而影响IO次数的关键因素就是树的层级（深度）！</strong>举个例子，如果目标数据在第二层，那么只要比较到第二层，就找到目标数据直接返回，不用再继续磁盘IO读取下一个节点。而如果数据在32层，那么就需要进行32次磁盘IO，比较到最后一层的节点。</p><p>那么，如何减少树的层级呢（让树变矮）？</p><p>请大家思考一下232中的“2”指的是什么？</p><p>其实就是“二叉平衡树”的“二”，而指数32代表树的层级。也就是说，如果以二叉平衡树的结构组织42亿行数据，那么树的深度是32。如果是“三叉平衡树”呢？</p><p>3?? = 232 </p><p>3的指数大概为21。也就是说，如果用“三叉树”组织数据，那么层级将会减少到21，也就意味着磁盘IO次数最多为21次。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589362752238-4daa5676-b2c3-419f-9016-a3cf84bb057f-20210923150255800.png" alt="img"></p><p>所以，到这里我们已经有答案了：要想减少二叉平衡树的磁盘IO次数，需要增加它的“叉”，变成“N叉平衡树”，从而减少树的深度。</p><p>此时有位长者说了一句：你们心里没点B树吗。</p><p>听到这，SUN的工程师颇受启发：对哦，直接用B树就好了。</p><p>B树有个“阶”的概念，比如“三叉平衡”的B树其实叫“3阶B树”。</p><p>通过上面的图，我们会发现“N阶B树”<strong>每个节点可以存N-1个数据</strong>（二叉平衡树每个节点只存1个数据），且每个节点至多可以连接N个子节点。</p><p>这样组织的好处是，<strong>每次加载一个节点时都可以从磁盘带出更多条数据，从而减少磁盘IO的次数。</strong>比如原先比完id=3，接下来要和id=5比较，需要再从磁盘中把id=5的数据读出来。而现在当前节点已经有id=3,id=5的数据了，直接比较即可，无需做磁盘IO。</p><p>这是典型的“空间换时间”。</p><p>但B树最难的地方不是结构本身，而是如何实现这种结构，尤其是如何通过B树组织数据库的表数据？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589370021227-2ce244b2-e5de-4aeb-8a57-5cfb81109d80-20210923150305159.png" alt="img"></p><p>举个例子，当我要找id=7的数据时，需要先找到根节点，和id=4的节点比较，由于7&gt;4，所以选择右侧那一支，接着因为6&lt;7&lt;8，所以这个节点中三个addr选择中间的addr，顺着这个地址找到7的节点，然后取出数据。</p><p>需要注意的是，当一个节点被加载到内存后，这个节点内部的数据就可以通过二分查找得到啦，所以那么id=7去上图右边节点查找正确的addr是很快的。</p><p>上面只是演示了3阶B树，实际上1个节点可以存更多数据，做成N阶B树：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589370580691-8b9a4589-4f48-42cb-9daf-918ad3183d99-20210923150314176.png" alt="img"></p><p>分析到这里，历史的话剧就告一个段落，让我们看看MySQL索引的真正实现方式吧。</p><h1 id="B-树与索引"><a href="#B-树与索引" class="headerlink" title="B+树与索引"></a>B+树与索引</h1><p>实际上MySQL索引采用的是B+树，而不是B树。</p><p>为什么不用B树呢？</p><p>在操作系统中有个叫“页”的概念，是用来存储数据的一种单位，大小为4k。MySQL中也有“页”的概念，但大小为16k，你可以理解为MySQL中的“页”就是上面B树的一个个节点。</p><p>那么问题来了：你知道日常开发中，表中的一行数据大概占多少字节吗？</p><p>让我们来计算一下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589371147835-6bf74fd5-b52c-4abc-869a-88fd74c96e0a-20210923150326037.png" alt="img"></p><p>在上面这张表中，按每列数据类型推算，一行数据大概 8+150+150+150+150+9+2+9+750+5+5+8+8=1404字节，就算1k好了，因为节点最大size是16k，所以每个节点最多只能存16行数据。</p><p>我们之前之所以从二叉平衡树转为B树，是因为B树的每个节点可以存更多数据。但上面的计算告诉我们，其实也就是比二叉平衡树多了15条数据而已。</p><p>但原则是对的，为了尽可能使树“变矮”从而减少磁盘IO，最好的做法是让<strong>一个节点尽可能地塞入更多的数据。</strong></p><p>不过把整行数据塞到节点中，有点太浪费了，我们其实可以<strong>把每一行数据的主键存进去。</strong>即使用bigint类型做主键，一个主键也就8个字节。假设每个主键对应一个addr（指针），MySQL中一个指针为6个字节，那么节点内每个主键-地址这样形式的数据能存16*1024/14=1170个。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589376951699-3f01f932-8684-414e-8dcb-2c0573837744-20210923150332743.png" alt="img"></p><p>这其实就是B+树对B树的改造。</p><p><strong>所谓的B+树，就是把原先B树中分散在各个节点的数据都“赶到”最底层的叶子节点，非叶子节点只存储主键-addr形式的数据：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589372895183-3540a1e5-82ba-4d3d-9dca-252f95007eee-20210923150338523.png" alt="img"></p><p>最终，一棵3层的B+树，最底下的叶子节点总共能存2000w条数据。</p><p>有部分同学可能还是不明白B+树为什么比B树能存储更多数据，这里再举个最极端的例子，假设一行表数据8k，而一个节点容量是16k，如果是B Tree，那么一个节点只能存两行数据，最终每个节点只能“夹带”3个addr，只能指向3个子节点：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589377482590-ca616c4f-89de-4de2-b459-1b7ef408a5ff-20210923150345350.png" alt="img"></p><p>但如果是B+ Tree，只存主键：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589377712338-9f1bfde7-bce8-4ecb-a9a0-27d1a5670b67-20210923150352723.png" alt="img"></p><p>那么最上面的节点可以存更多的主键，指向更多的下级节点，就有更多的“16k数据”。上面还只是分析单个节点的情况，如果放眼整棵索引树，最终叶子节点会多很多很多的“16k数据”。</p><p>从MySQL学习者的角度而言，我们只需要知道B+树2个很重要的特征：</p><ul><li>非叶子节点不存数据</li><li>叶子节点数据用链表相连</li></ul><p>所以更详细的版本是：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589448311743-b494fa66-02d0-43b8-ab9f-f920caec8af2-20210923150358426.png" alt="img"></p><p>叶子节点是有序链表，可以帮助做范围查询。</p><p>最后，还有个问题，如果我不提估计很少有人会考虑：B+树如何查找数据。</p><p>为什么会有这个疑问呢？</p><p>之前说过，B数的节点存了完整的数据，假设数据总共3层，而你要找的数据在第2层的某个节点，当你找到后便可以直接返回整行数据。而B+树为了一个节点能存入更多的addr，节点内部只存了主键id，所以即使你在第二层找到匹配的id，还是不能直接返回，必须继续往下，直到在叶子节点读取完整数据。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589421184838-106cccdb-a84e-448f-8806-58e9dfa9b76e-20210923150406906.gif" alt="img"></p><p>讨论到这，我们来对比一下B树和B+树：</p><ul><li><p>B树的节点都会存储整行数据，占用空间大存储addr少，而B+树的非叶子节点只存储主键，能容纳更多addr</p></li><li><p>由于非叶子节点能容纳更多addr，那么同一个节点能指向更多下级节点，所以相同数据量时，B+树通常更加“矮”，IO更少</p></li><li><p>B树的查询效率是不稳定的，最好情况是根节点，最差情况是叶子节点，而B+树是稳定的，每次都要查询到叶子节点</p></li><li><p>B+树的叶子节点是有序列表，非常便于范围查询</p></li></ul><p>对于第三点，很多人可能觉得B+树每次都是稳定地查询叶子节点，还不如B树（最好情况根节点就返回了）。其实上面分析过了，B+树每个节点能存储的数据是B树的1170/16≈73倍，意味着B+树每个节点可以连接的分支更多，相同数据量的情况下，B+树远远矮于B树。比如B树的查询IO次数是1~100，而B+树恒定为3，你觉得哪个效率高？</p><p>回头看看柏青哥，钢珠掉落的过程是不是很像沿着索引查找数据呢~</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589373836878-c32bc126-fc73-48e4-ae95-d7e23ccf77c8-20210923150420395.png" alt="img"></p><p>学到这里，相信Dao层的对岸到底是什么，大家心里已经有B+树了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589374780467-c8dbebf7-eb2e-418b-8536-cc90aea27b37-20210923150427648.png" alt="img"></p><p>至此，我们回过头来给索引下个定义：</p><p><strong>索引是一种数据结构，</strong>用于高效搜索目标数据，在MySQL中具体实现为B+树（InnoDB引擎）。</p><p>最后说一句，没有所谓的“B减树”，很多人可能看到B树的英文表示法是”B-Tree”，误读为“B减树”。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UDP&amp;TCP</title>
    <link href="/2020/07/29/UDP%20&amp;%20TCP%20/"/>
    <url>/2020/07/29/UDP%20&amp;%20TCP%20/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>讲解 TCP 三次握手和四次握手之前，我们先了解一下 TCP 和 UDP 这两个重量级的传输层协议。</p><p>💦 <strong>用户数据报协议 UDP</strong>（User Datagram Protocol）：</p><ul><li><strong>UDP 在传送数据之前不需要先建立连接</strong>，远程主机在收到 UDP 报文后，不需要给出任何确认。</li><li>虽然 UDP <strong>不提供可靠交付</strong>，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等</li></ul><p>💦 <strong>传输控制协议 TCP</strong>（Transmission Control Protocol）：</p><ul><li>TCP 提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 不提供广播或多播服务。由于 TCP 要提供<strong>可靠</strong>的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</li><li>TCP <strong>一般用于文件传输、发送和接收邮件、远程登录等场景</strong>。</li></ul><h2 id="2-TCP-报文段首部格式"><a href="#2-TCP-报文段首部格式" class="headerlink" title="2. TCP 报文段首部格式"></a>2. TCP 报文段首部格式</h2><p>TCP 报文段的具体格式大家可以不必都记住，但是其中的几个<strong>控制位</strong>与我们接下来要讲的三次握手和四次挥手息息相关，大家一定要牢记。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144029349" alt="图片"></p><p>首部固定部分各字段意义如下：</p><ul><li><p>1 - <strong>源端口和目的端口</strong>：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址</p></li><li><p>2 - <strong>序号/序列号</strong>（Sequense Number，SN）：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。<strong>初始序号称为 Init Sequense Number, ISN</strong>（序号/序列号这个字段很重要，大家留个印象，下文会详细讲解）</p><p>例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。</p></li><li><p>3 - <strong>确认号 ack</strong>：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。</p></li><li><p>4 - <strong>数据偏移</strong>（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。</p></li><li><p>5 - <strong>保留</strong>：占 6 位，应置为 0，保留为今后使用。</p></li></ul><p>⭐ 大家看上图，保留位的右边还有 6 个控制位（重要），这是TCP 用来说明该报文段性质的：</p><ul><li><p><strong>紧急位 URG</strong>：当 URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。该控制位需配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）</p><p>举个例子：我们需要取消一个已经发送了很长程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这个指令将存储在接收 TCP 的缓存末尾，只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程，这样做就无法实现立即中断。</p></li><li><p><strong>确认 ACK</strong>：仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</p></li><li><p><strong>推送 PSH</strong>：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。</p></li><li><p><strong>复位 RST</strong>：当 RST = 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。</p></li><li><p><strong>同步 SYN</strong>：SYN = 1 表示这是一个连接请求或连接接受报文。</p><p>当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 且 ACK = 1。</p></li><li><p><strong>终止 FIN</strong>：用来释放一个连接。当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p></li></ul><h2 id="3-TCP-三次握手建立连接"><a href="#3-TCP-三次握手建立连接" class="headerlink" title="3. TCP 三次握手建立连接"></a>3. TCP 三次握手建立连接</h2><h3 id="①-三次握手过程详解"><a href="#①-三次握手过程详解" class="headerlink" title="① 三次握手过程详解"></a>① 三次握手过程详解</h3><p>三次握手的原文是 <code>three-way handshake</code>，整个名词的可以翻译为：<strong>需要三个步骤才能建立握手/连接的机制</strong>。当然，三次握手也可以叫 <code>three-message handshake</code>，通过三条消息来建立的握手/连接。</p><p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的 <strong>初始化序列号(Init Sequense Number,  <code>ISN</code>)</strong> 为后面的可靠性传输做准备。</p><p>三次握手过程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144034490" alt="图片"></p><p>回顾一下图中字符的含义：</p><ul><li><code>SYN</code>：连接请求/接收 报文段</li><li><code>seq</code>：发送的第一个字节的序号</li><li><code>ACK</code>：确认报文段</li><li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p><strong>刚开始客户端处于 <code>Closed</code> 的状态，而服务端处于 <code>Listen</code> 状态</strong>：</p><blockquote><p><code>CLOSED</code>：没有任何连接状态</p><p><code>LISTEN</code>：侦听来自远方 TCP 端口的连接请求</p></blockquote><p><strong>1）第一次握手</strong>：客户端向服务端发送一个 SYN 报文（SYN = 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq = x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 <code>SYN_Send</code> 状态。</p><blockquote><p><code>SYN-SENT</code> ：在发送连接请求后等待匹配的连接请求</p></blockquote><p><strong>2）第二次握手</strong>：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN = 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq = y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 <code>SYN_REVD</code> 的状态。</p><blockquote><p><code>SYN-RECEIVED</code>：在收到和发送一个连接请求后等待对连接请求的确认</p></blockquote><p><strong>3）第三次握手</strong>：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 <code>Establised</code> 状态。</p><p>服务器收到 ACK 报文之后，也处于 <code>Establised 状态</code>，至此，双方建立起了 TCP 连接。</p><blockquote><p><code>ESTABLISHED</code>：代表一个打开的连接，数据可以传送给用户</p></blockquote><h3 id="②-为什么要三次握手"><a href="#②-为什么要三次握手" class="headerlink" title="② 为什么要三次握手"></a>② 为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的</strong>。</p><p>只有经过三次握手才能确认双发的收发功能都正常，缺一不可：</p><ul><li><p>第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常</p></li><li><p>第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：</p><p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p><p>服务器确认了：对方发送正常，自己接收正常</p></li><li><p>第三次握手（客户端发送 ACK 报文给服务器）：</p><p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p><p>服务器确认了：自己发送、接收正常，对方发送、接收正常</p></li></ul><h3 id="③-ISN-Initial-Sequence-Number-是固定的吗"><a href="#③-ISN-Initial-Sequence-Number-是固定的吗" class="headerlink" title="③ ISN (Initial Sequence Number) 是固定的吗"></a>③ ISN (Initial Sequence Number) 是固定的吗</h3><p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据</strong>。</p><p>当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。<strong>如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的</strong>。</p><h3 id="④-三次握手过程中可以携带数据吗"><a href="#④-三次握手过程中可以携带数据吗" class="headerlink" title="④ 三次握手过程中可以携带数据吗"></a>④ 三次握手过程中可以携带数据吗</h3><p>第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手绝对不可以携带数据</strong></p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>⭐ <strong>简单的记忆就是，请求连接/接收 即 <code>SYN = 1</code> 的时候不能携带数据</strong></p><p>而对于第三次的话，此时客户端已经处于 <code>ESTABLISHED</code> 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。</p><h3 id="⑤-半连接队列"><a href="#⑤-半连接队列" class="headerlink" title="⑤ 半连接队列"></a>⑤ 半连接队列</h3><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code> 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>当然还有一个<strong>全连接队列</strong>，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><h3 id="⑥-SYN-洪泛攻击"><a href="#⑥-SYN-洪泛攻击" class="headerlink" title="⑥ SYN 洪泛攻击"></a>⑥ SYN 洪泛攻击</h3><p>SYN 攻击就是 <strong>Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包</strong>，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</p><h3 id="⑦-如果第三次握手丢失了，客户端服务端会如何处理"><a href="#⑦-如果第三次握手丢失了，客户端服务端会如何处理" class="headerlink" title="⑦ 如果第三次握手丢失了，客户端服务端会如何处理"></a>⑦ 如果第三次握手丢失了，客户端服务端会如何处理</h3><p>服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><h2 id="4-TCP-四次挥手释放连接"><a href="#4-TCP-四次挥手释放连接" class="headerlink" title="4. TCP 四次挥手释放连接"></a>4. TCP 四次挥手释放连接</h2><h3 id="①-四次挥手过程详解"><a href="#①-四次挥手过程详解" class="headerlink" title="① 四次挥手过程详解"></a>① 四次挥手过程详解</h3><p>建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的<strong>半关闭</strong>（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 连接的释放需要发送四个包（执行四个步骤），因此称为四次挥手(<code>Four-way handshake</code>)，<strong>客户端或服务端均可主动发起挥手动作</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144040116" alt="图片"></p><p>回顾一下上图中符号的意思：</p><ul><li><code>FIN</code> ：连接终止位</li><li><code>seq</code>：发送的第一个字节的序号</li><li><code>ACK</code>：确认报文段</li><li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p>刚开始双方都处于<code>ESTABLISHED</code> 状态，假设是客户端先发起关闭请求。四次挥手的过程如下：</p><p><strong>1）第一次挥手</strong>：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并<strong>停止再发送数据，主动关闭 TCP 连接</strong>。此时客户端处于 <code>FIN_WAIT1</code> 状态，等待服务端的确认。</p><blockquote><p><code>FIN-WAIT-1</code> - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></blockquote><p><strong>2）第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。</p><blockquote><p><code>CLOSE-WAIT</code> - 等待从本地用户发来的连接中断请求；</p></blockquote><p><strong>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放</strong>。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待 2）状态，等待服务端发出的连接释放报文段。</p><blockquote><p><code>FIN-WAIT-2</code> - 从远程TCP等待连接中断请求；</p></blockquote><p><strong>3）第三次挥手</strong>：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态，等待客户端的确认。</p><blockquote><p><code>LAST-ACK</code> - 等待原来发向远程TCP的连接中断请求的确认；</p></blockquote><p><strong>4）第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 <strong><code>TIME_WAIT</code> （时间等待）状态</strong>。</p><blockquote><p><code>TIME-WAIT</code> - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></blockquote><p>🚨 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，<strong>需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 <code>CLOSED</code> 状态</strong>（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 <code>CLOSED</code> 状态。</p><h3 id="②-为什么要四次挥手"><a href="#②-为什么要四次挥手" class="headerlink" title="② 为什么要四次挥手"></a>② 为什么要四次挥手</h3><p>由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就<strong>完全关闭</strong>了TCP连接。</p><p><strong>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手</strong>。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Communication protocol</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双亲委派机制</title>
    <link href="/2020/06/15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/06/15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在介绍双亲委派机制的时候，不得不提ClassLoader（类加载器）。说ClassLoader之前，我们得先了解下Java的基本知识。<br>  Java是运行在Java的虚拟机(JVM)中的，但是它是如何运行在JVM中了呢？我们在IDE中编写的Java源代码被编译器编译成.class的字节码文件。然后由我们得ClassLoader负责将这些class文件给加载到JVM中去执行。<br>  JVM中提供了三层的ClassLoader：</p><p>Bootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader。</p><p>ExtClassLoader：主要负责加载jre/lib/ext目录下的一些扩展的jar。</p><p>AppClassLoader：主要负责加载应用程序的主函数类</p><p>那如果有一个我们写的Hello.java编译成的Hello.class文件，它是如何被加载到JVM中的呢？别着急，请继续往下看。</p><p>双亲委派机制</p><p>我打开了我的AndroidStudio，搜索了下“ClassLoader”,然后打开“java.lang”包下的ClassLoader类。然后将代码翻到loadClass方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-keyword">false</span>);<br>&#125;<br><span class="hljs-comment">//              -----??-----</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>        <span class="hljs-comment">// 首先，检查是否已经被类加载器加载过</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 存在父加载器，递归的交由父加载器</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 直到最上面的Bootstrap类加载器</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br> <br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其实这段代码已经很好的解释了双亲委派机制，为了大家更容易理解，我做了一张图来描述一下上面这段代码的流程：  </p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70.png"></p><p>从上图中我们就更容易理解了，当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。那么有人就有下面这种疑问了？</p><p>为什么要设计这种机制</p><p>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。</p><p>总结了一张脑图如下：</p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70-20210719110251508.png" style="zoom:200%;" />]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis哨兵模式</title>
    <link href="/2020/05/22/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/22/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p><h3 id="一、哨兵模式概述"><a href="#一、哨兵模式概述" class="headerlink" title="一、哨兵模式概述"></a>一、哨兵模式概述</h3><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/sen1.png"></p><p>这里的哨兵有两个作用</p><ul><li><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</p></li><li><p>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</p></li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p>用文字描述一下<strong>故障切换（failover）</strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><hr><h3 id="二、Redis配置哨兵模式"><a href="#二、Redis配置哨兵模式" class="headerlink" title="二、Redis配置哨兵模式"></a>二、Redis配置哨兵模式</h3><p>配置3个哨兵和1主2从的Redis服务器来演示这个过程。</p><p>| 服务类型  |是否是主服务器 |ip地址| 端口|<br>| :——— | :———— | :———— | :———— | :———— |<br>|redis|是|192.168.11.128|6379|<br>|redis|否|192.168.11.129|6379|<br>|redis|否|192.168.11.130|6379|<br>|sentinel|-|192.168.11.128|26379|<br>|sentinel|-|192.168.11.129|26379|<br>|sentinel|-|192.168.11.130|26379|</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/sen2.png"></p><p>首先配置Redis的主从服务器，修改redis.conf文件如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"># 使得Redis服务器可以跨网络访问<br>bind 0.0.0.0<br># 设置密码<br>requirepass &quot;123456&quot;<br># 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置<br>slaveof 192.168.11.128 6379<br># 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置<br>masterauth 123456<br></code></pre></div></td></tr></table></figure><p>上述内容主要是配置Redis服务器，从服务器比主服务器多一个slaveof的配置和密码。</p><p>配置3个哨兵，每个哨兵的配置都是一样的。在Redis安装目录下有一个sentinel.conf文件，copy一份进行修改</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"># 禁止保护模式<br>protected-mode no<br># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。<br>sentinel monitor mymaster 192.168.11.128 6379 2<br># sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码<br># sentinel auth-pass <span class="hljs-tag">&lt;<span class="hljs-name">master-name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br>sentinel auth-pass mymaster 123456<br></code></pre></div></td></tr></table></figure><p>上述关闭了保护模式，便于测试。</p><p>有了上述的修改，我们可以进入Redis的安装目录的src目录，通过下面的命令启动服务器和哨兵</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"># 启动Redis服务器进程<br>./redis-server ../redis.conf<br># 启动哨兵进程<br>./redis-sentinel ../sentinel.conf<br></code></pre></div></td></tr></table></figure><p>注意启动的顺序。首先是主机（192.168.11.128）的Redis服务进程，然后启动从机的服务进程，最后启动3个哨兵的服务进程。</p><hr><h3 id="三、Java中使用哨兵模式"><a href="#三、Java中使用哨兵模式" class="headerlink" title="三、Java中使用哨兵模式"></a>三、Java中使用哨兵模式</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试Redis哨兵模式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSentinels</span> </span>&#123;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;resource&quot;)</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSentinel</span><span class="hljs-params">()</span> </span>&#123;<br>        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>);<br>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>);<br>        jedisPoolConfig.setMinIdle(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 哨兵信息</span><br>        Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;192.168.11.128:26379&quot;</span>,<br>                <span class="hljs-string">&quot;192.168.11.129:26379&quot;</span>,<span class="hljs-string">&quot;192.168.11.130:26379&quot;</span>));<br>        <span class="hljs-comment">// 创建连接池</span><br>        JedisSentinelPool pool = <span class="hljs-keyword">new</span> JedisSentinelPool(<span class="hljs-string">&quot;mymaster&quot;</span>, sentinels,jedisPoolConfig,<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">// 获取客户端</span><br>        Jedis jedis = pool.getResource();<br>        <span class="hljs-comment">// 执行两个命令</span><br>        jedis.set(<span class="hljs-string">&quot;mykey&quot;</span>, <span class="hljs-string">&quot;myvalue&quot;</span>);<br>        String value = jedis.get(<span class="hljs-string">&quot;mykey&quot;</span>);<br>        System.out.println(value);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面是通过Jedis进行使用的，同样也可以使用Spring进行配置RedisTemplate使用。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;poolConfig&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 最大空闲数 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 最大连接数 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxTotal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 最大等待时间 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxWaitMillis&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;connectionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolConfig&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;poolConfig&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sentinelConfig&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sentinelConfig&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-comment">&lt;!-- JDK序列化器 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdkSerializationRedisSerializer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-comment">&lt;!-- String序列化器 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stringRedisSerializer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;redisTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connectionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;connectionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keySerializer&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stringRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultSerializer&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stringRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;valueSerializer&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jdkSerializationRedisSerializer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <br>      <span class="hljs-comment">&lt;!-- 哨兵配置 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sentinelConfig&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisSentinelConfiguration&quot;</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 服务名称 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;master&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mymaster&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 哨兵服务IP和端口 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sentinels&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;192.168.11.128&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26379&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;192.168.11.129&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26379&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;192.168.11.130&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26379&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="四、哨兵模式的其他配置项"><a href="#四、哨兵模式的其他配置项" class="headerlink" title="四、哨兵模式的其他配置项"></a>四、哨兵模式的其他配置项</h3><table><thead><tr><th align="left">配置项</th><th align="left">参数类型</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">port</td><td align="left">整数</td><td align="left">启动哨兵进程端口</td></tr><tr><td align="left">dir</td><td align="left">文件夹目录</td><td align="left">哨兵进程服务临时文件夹，默认为/tmp，要保证有可写入的权限</td></tr><tr><td align="left">sentinel down-after-milliseconds</td><td align="left">&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td align="left">指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）</td></tr><tr><td align="left">sentinel parallel-syncs</td><td align="left">&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td><td align="left">指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高</td></tr><tr><td align="left">sentinel failover-timeout</td><td align="left">&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td align="left">指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟</td></tr><tr><td align="left">sentinel notification-script</td><td align="left">&lt;服务名称&gt;&lt;脚本路径&gt;</td><td align="left">指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，比较常用</td></tr></tbody></table><p>sentinel down-after-milliseconds配置项只是一个哨兵在超过规定时间依旧没有得到响应后，会自己认为主机不可用。对于其他哨兵而言，并不是这样认为。哨兵会记录这个消息，当拥有认为主观下线的哨兵达到sentinel monitor所配置的数量时，就会发起一次投票，进行failover，此时哨兵会重写Redis的哨兵配置文件，以适应新场景的需要。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>redis</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis常用命令</title>
    <link href="/2020/05/21/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/05/21/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://1drv.ms/u/s!AuIKtprkDa8kjCfpQcXgXISfDleN?e=jKW0qf">课件地址</a>      <a href="http://redisdoc.com/">redis命令大全</a></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">redis-server /配置文件位置     #启动redis <br>redis-cli -p 6379     #切换到redis控制台 redis默认端口 6379<br>redis-cli shutdown   #单实例关闭<br>redis-cli -p 6379 shutdown    #多实例关闭，指定端口关闭<br>select db #切换到该数据库 0 - 15 <br>dbsize #查看当前库key的数量<br>flushdb #清空当当前库<br>flushall #清空16个库 慎用！<br></code></pre></div></td></tr></table></figure><h2 id="Redis-键（key）"><a href="#Redis-键（key）" class="headerlink" title="Redis 键（key）"></a><strong>Redis 键（key）</strong></h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">keys *  #查看所有keys <br>exists key  #判断key是否存在<br>move key db  #将key移动到db  当前库就没有了<br>expire key second  # 为key设置过期时间 单位秒<br>ttl key  #查看该key 还有多少秒过期  -1表示永不过期   -2表示已过期（过期后该key被移除）<br>type key #查看该key类型<br>del key #删除该key<br></code></pre></div></td></tr></table></figure><h2 id="Redis-String"><a href="#Redis-String" class="headerlink" title="Redis String"></a><strong>Redis String</strong></h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">set key #设置该key的value<br>get key #获取该key的value<br>del key #删除该key<br>append key value #在该key后面添加value<br>strlen key #获取该key长度<br>incr key  #该key的值 加1  该key的值必须是数字 <br>decr key  #该key的值 减1  该key的值必须是数字 <br>incrby key num # 该key的值加 num 该key的值必须是数字 <br>decrby key num # 该key的值减 num 该key的值必须是数字 <br>getrange key start end # 获取start和end区间的值， 0  -1 为获取全部<br>setrange key offset value  # 设置该key从offset开始的值为value <br>setex key second value # set with expire 设置该key的值为value 存活时间为second <br>setnx key value # set if not exist 如果该key不存在，设置该key的值为value<br>mset key value key value ...  #一次存入多个键值对<br>mget key key key ... #一次取出多个key的value<br>msetnx key value key value # 一次存入多个键值对  key必须是未存在#个key已存在，则整个命令失败<br></code></pre></div></td></tr></table></figure><h2 id="Redis-List-列表-有序可重"><a href="#Redis-List-列表-有序可重" class="headerlink" title="Redis List(列表  有序可重)"></a><strong>Redis List</strong>(列表  有序可重)</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">lpush key value value value  # 存入一个list value之间用空格分开 往左端加 若key已存在 则添加元素<br>rpush key value value value  # 存入一个list value之间用空格分开 往右端加 若key已存在 则添加元素<br>lrange key statr stop  # 取出key中value 从start开始 stop结束  0 -1 表示取出全部<br>lpop key  # 从该key的list左边 单次出栈<br>rpop key  # 从该key的lits右边 单次出栈<br>lindex key index # 按index获取list中的值 从0开始 <br>llen key  # 获取该key的list的长度<br>lrem key count value  #删除该key的list中count个值为value的元素<br>ltrim key start stop  #截取key的list中 从start 到 stop的元素 ，重新赋值给key<br>rpoplpush source destination  # 获取source最右端元素，移动到destination最左端 <br>lset key index value  # 将该key的list的第index位元素的值设置为value<br>linsert key before|after pivot value #在key对应的list的  pivot元素前(befroe)或后(after)  插入值为value的元素<br><span class="hljs-meta"> </span><br><span class="hljs-meta">#</span><span class="bash"> REDIS LIST是一个字符串了链表，left、right都可以插入添加</span><br><span class="hljs-meta">#</span><span class="bash"> 如果键不存在，创建新的链表</span> <br><span class="hljs-meta">#</span><span class="bash"> 如果键已存在，新增内容 lpush往左端加 rpush往右端加</span><br><span class="hljs-meta">#</span><span class="bash"> 如果值全部移除，对应的键也就消失了</span><br><span class="hljs-meta">#</span><span class="bash"> 链表的操作 头尾效率都极高 ，但是对中间元素操作的效率很惨淡</span><br><br></code></pre></div></td></tr></table></figure><h2 id="Redis-Set-集合-无序不可重"><a href="#Redis-Set-集合-无序不可重" class="headerlink" title="Redis Set(集合  无序不可重)"></a><strong>Redis Set(集合  无序不可重)</strong></h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sadd key member member .. # 添加键为key 值为member 的set  若key已存在 则添加元素  元素不能重复 <br>smembers key # 查看该key的所有元素<br>sismember key member # 产看该key中是否有member元素 有返回 1 无返回 0<br>scard key #获取集合里的元素个数<br>srem key value #删除key对应的集合中值为value的元素<br>srandmember key count #从key集合中随机获取count个元素<br>spop key  #从key集合中随机出栈1个元素<br>smove key1 key2 key1中某个值    # 将key1中的某个值赋给key2<br>sdiff key1 key2   # 已key1为全集 求key2相对key1的差集<br>sinter key1 key2  # 求key1 key2的交集 <br>sunion key1 key2  # 求key1 key2的并集 （自动去重）<br></code></pre></div></td></tr></table></figure><h2 id="Redis-Hash-hash的value是以键值对的形式存储的-key-value-key-value"><a href="#Redis-Hash-hash的value是以键值对的形式存储的-key-value-key-value" class="headerlink" title="Redis Hash(hash的value是以键值对的形式存储的    key  value(key  value)  )"></a><strong>Redis Hash</strong>(hash的value是以键值对的形式存储的    key  value(key  value)  )</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">hset key Vkey Vvalue   #添加键为key 值为Vkey Vvalue 的hash （ hash的格式为 key value(key value) ）<br>hget key Vkey  #获取键为key的hash的 value key 为Vkey的 value<br>hmset key Vkey Vvalue Vkey Vvalue ...  # 添加键为key的hash的 多个value <br>hmget key Vkey Vkey Vkey ...  #获取键为key的hash的多个value的 valueKey为Vkey的 value<br>hgetall key  #获取键为key的hash的所有value （键值对形式）<br>hdel key Vkey  #删除键为key的hash的value的 键为Vkey的 value <br>hlen key  #获取键为key的hash的长度 <br>hexists key Vkey  #判断键为key的hash中是否存在 键为Vkey的 value 存在返回1 不存在返回0<br>hkeys key  #获取键为key的 hash中 所有value的 key<br>hvals key #获取键为key的hash中 所有value 的value<br>hincrby key Vkey num   # 给key对应的value的 value key所对应的 value value 加num（整数）（Vkey对应的value必须数integer）<br>hincrbyfloat key Vkey float   # 给key对应的value的 value key所对应的 value value 加float （小数）<br>hsetnx key Vkey Vvalue   #给key对应的hash数据添加新的value键值对 （Vkey Vvalue） Vkey不能已存在<br></code></pre></div></td></tr></table></figure><h2 id="Redis-Zset-sorted-set-有序不可重集合"><a href="#Redis-Zset-sorted-set-有序不可重集合" class="headerlink" title="Redis Zset (sorted set) 有序不可重集合"></a><strong>Redis Zset (sorted set)</strong> 有序不可重集合</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在<span class="hljs-built_in">set</span>基础上，加一个score值。<span class="hljs-built_in">set</span>是k1 v1 v2 v3， zset是k1 score1 v1 score2 v2</span><br>zadd key score value score value ....  #添加键为key 索引为score 值为value的Zset数据 <br>zrange key min max  #获取min max闭区间内该key对应的所有value (min 和 max 为value对应的下标 从0开始) 0 -1表示全部<br>zrangebyscore key startScore stopScore  #获取 startScore stopScore闭区间内该key对应的所有value<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 在命令最后加上 withscores可以显示每个vvalue对应的score</span></span> <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 在startScore 或是 stopScore前加 &quot;(&quot; 表示开区间  如 startScore (stopScore 等于 [startScore stopScore) ，&quot;(&quot;后的索引对应的value将被排除在结果中</span></span> <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># stopScore为 &quot;+inf&quot; 表示获取 startScore到 end 闭区间内的所有value</span></span><br>zrangebyscore key startScore stopScore limit start step #分页显示[startScope stopScore]内结果集，start为开始索引 step为步进 <br>zrem key value  #删除该key对应的zset集合中的对应value<br>zcard key #获取该集合中的元素个数<br>zcount key startScore stopScore #获取 [startScope stopScore] 闭区间内元素个数<br>zrank key value #获取该value在该集合中的下标 (0开始)<br>zscore key value #获取该value在该集合下对应的score<br>zrevrank key value #获取该value在该集合中的逆下标 <br>zrevrange key min max # #逆序获取min max闭区间内该key对应的所有value(min 和 max 为value对应的下标 从0开始)  0 -1表示全部<br>zrevrangebyscore key stopScore startScore #获取  stopScore startScore 闭区间内的所有value <br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>redis</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis笔记</title>
    <link href="/2020/05/21/Redis/"/>
    <url>/2020/05/21/Redis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>##<strong>Redis基本数据类型</strong></p><ol><li>字符串：redis没有直接使用C语言传统的字符串表示，而是自己实现的叫做简单动态字符串SDS的抽象类型。C语言的字符串不记录自身的长度信息，而SDS则保存了长度信息，这样将获取字符串长度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串长度时所需的内存重分配次数。</li><li>链表linkedlist：redis链表是一个双向无环链表结构，很多发布订阅、慢查询、监视器功能都是使用到了链表来实现，每个链表的节点由一个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。</li><li>字典hashtable：用于保存键值对的抽象数据结构。redis使用hash表作为底层实现，每个字典带有两个hash表，供平时使用和rehash时使用，hash表使用链地址法来解决键冲突，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对hash表进行扩容或者缩容的时候，为了服务的可用性，rehash的过程不是一次性完成的，而是渐进式的。</li><li>跳跃表skiplist：跳跃表是有序集合的底层实现之一，redis中在实现有序集合键和集群节点的内部结构中都是用到了跳跃表。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表信息（表头、表尾节点、长度等），zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1-32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。</li><li>整数集合intset：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</li><li>压缩列表ziplist：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li></ol><p>基于这些基础的数据结构，redis封装了自己的对象系统，包含字符串对象string、列表对象list、哈希对象hash、集合对象set、有序集合对象zset，每种对象都用到了至少一种基础的数据结构。</p><p>redis通过encoding属性设置对象的编码形式来提升灵活性和效率，基于不同的场景redis会自动做出优化。不同对象的编码如下：</p><ol><li>字符串对象string：int整数、embstr编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：ziplist、linkedlist</li><li>哈希对象hash：ziplist、hashtable</li><li>集合对象set：intset、hashtable</li><li>有序集合对象zset：ziplist、skiplist</li></ol><h2 id="Redis为什么快呢？"><a href="#Redis为什么快呢？" class="headerlink" title="Redis为什么快呢？"></a><strong>Redis为什么快呢？</strong></h2><p>redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几十倍。速度快的原因主要有几点：</p><ol><li>完全基于内存操作</li><li>C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高</li><li>使用单线程，无上下文的切换成本</li><li>基于非阻塞的IO多路复用机制</li></ol><h2 id="那为什么Redis6-0之后又改用多线程呢"><a href="#那为什么Redis6-0之后又改用多线程呢" class="headerlink" title="那为什么Redis6.0之后又改用多线程呢?"></a><strong>那为什么Redis6.0之后又改用多线程呢?</strong></h2><p>redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。</p><p>这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。</p><h2 id="什么是热key吗？热key问题怎么解决？"><a href="#什么是热key吗？热key问题怎么解决？" class="headerlink" title="什么是热key吗？热key问题怎么解决？"></a><strong>什么是热key吗？热key问题怎么解决？</strong></h2><p>所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/1.jpg"></p><p>针对热key的解决方案：</p><ol><li>提前把热key打散到不同的服务器，降低压力</li><li>加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询</li></ol><h2 id="什么是缓存击穿、缓存穿透、缓存雪崩？"><a href="#什么是缓存击穿、缓存穿透、缓存雪崩？" class="headerlink" title="什么是缓存击穿、缓存穿透、缓存雪崩？"></a><strong>什么是缓存击穿、缓存穿透、缓存雪崩？</strong></h2><p>###<strong>缓存击穿</strong></p><p>缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上，这个和热key的问题比较类似，只是说的点在于过期导致请求全部打到DB上而已。</p><p>解决方案：</p><ol><li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了。</li><li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/2.jpg"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h3><p>缓存穿透是指查询不存在缓存中的数据，每次请求都会打到DB，就像缓存不存在一样。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/3.jpg"></p><p>针对这个问题，加一层布隆过滤器。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。</p><p>这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。</p><p>显然，使用布隆过滤器之后会有一个问题就是误判，因为它本身是一个数组，可能会有多个值落到同一个位置，那么理论上来说只要我们的数组长度够长，误判的概率就会越低，这种问题就根据实际情况来就好了。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/4.jpg"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃，称为雪崩。雪崩和击穿、热key的问题不太一样的是，他是指大规模的缓存都过期失效了。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/5.jpg"></p><p>针对雪崩几个解决方案：</p><ol><li>针对不同key设置不同的过期时间，避免同时过期</li><li>限流，如果redis宕机，可以限流，避免同时刻大量请求打崩DB</li><li>二级缓存，同热key的方案。</li></ol><h2 id="Redis的过期策略有哪些？"><a href="#Redis的过期策略有哪些？" class="headerlink" title="Redis的过期策略有哪些？"></a><strong>Redis的过期策略有哪些？</strong></h2><p>redis主要有2种过期删除策略</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><strong>惰性删除</strong></h3><p>惰性删除指的是当我们查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/6.jpg"></p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a><strong>定期删除</strong></h3><p>定期删除指的是redis每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。</p><p>###<strong>那么定期+惰性都没有删除过期的key怎么办？</strong></p><p>假设redis每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存在redis里面无法被删除，这时候就会走到redis的内存淘汰机制。</p><ol><li>volatile-lru：从已设置过期时间的key中，移出最近最少使用的key进行淘汰</li><li>volatile-ttl：从已设置过期时间的key中，移出将要过期的key</li><li>volatile-random：从已设置过期时间的key中随机选择key淘汰</li><li>allkeys-lru：从key中选择最近最少使用的进行淘汰</li><li>allkeys-random：从key中随机选择key进行淘汰</li><li>noeviction：当内存达到阈值的时候，新写入操作报错</li></ol><p>##<strong>持久化方式有哪些？有什么区别？</strong></p><p>redis持久化方案分为RDB和AOF两种。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h3><p>RDB持久化可以手动执行也可以根据配置定期执行，它的作用是将某个时间点上的数据库状态保存到RDB文件中，RDB文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态。由于RDB文件是保存在硬盘上的，所以即使redis崩溃或者退出，只要RDB文件存在，就可以用它来恢复还原数据库的状态。</p><p>可以通过SAVE或者BGSAVE来生成RDB文件。</p><p>SAVE命令会阻塞redis进程，直到RDB文件生成完毕，在进程阻塞期间，redis不能处理任何命令请求，这显然是不合适的。</p><p>BGSAVE则是会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h3><p>AOF和RDB不同，AOF是通过保存redis服务器所执行的写命令来记录数据库状态的。</p><p>AOF通过追加、写入、同步三个步骤来实现持久化机制。</p><ol><li>当AOF持久化处于激活状态，服务器执行完写命令之后，写命令将会被追加append到aof_buf缓冲区的末尾</li><li>在服务器每结束一个事件循环之前，将会调用flushAppendOnlyFile函数决定是否要将aof_buf的内容保存到AOF文件中，可以通过配置appendfsync来决定。</li></ol><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">always</span> <span class="hljs-string">##aof_buf内容写入并同步到AOF文件</span><br><span class="hljs-attr">everysec</span> <span class="hljs-string">##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步</span><br><span class="hljs-attr">no</span> <span class="hljs-string">##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定</span><br></code></pre></div></td></tr></table></figure><p>如果不设置，默认选项将会是everysec，因为always来说虽然最安全（只会丢失一次事件循环的写命令），但是性能较差，而everysec模式只不过会可能丢失1秒钟的数据，而no模式的效率和everysec相仿，但是会丢失上次同步AOF文件之后的所有写命令数据。</p><p>##<strong>怎么实现Redis的高可用？</strong></p><p>要想实现高可用，一台机器肯定是不够的，而redis要保证高可用，有2个可选方案。</p><p>###<strong>主从架构</strong></p><p>主从模式是最简单的实现高可用的方案，核心就是主从同步。主从同步的原理如下：</p><ol><li>slave发送sync命令到master</li><li>master收到sync之后，执行bgsave，生成RDB全量文件</li><li>master把slave的写命令记录到缓存</li><li>bgsave执行完毕之后，发送RDB文件到slave，slave执行</li><li>master发送缓存中的写命令到slave，slave执行</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/7.jpg"></p><p>这里我写的这个命令是sync，但是在redis2.8版本之后已经使用psync来替代sync了，原因是sync命令非常消耗系统资源，而psync的效率更高。</p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a><strong>哨兵</strong></h3><p>基于主从方案的缺点还是很明显的，假设master宕机，那么就不能写入数据，那么slave也就失去了作用，整个架构就不可用了，除非你手动切换，主要原因就是因为没有自动故障转移机制。而哨兵(sentinel)的功能比单纯的主从架构全面的多了，它具备自动故障转移、集群监控、消息通知等功能。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/8.jpg"></p><p>哨兵可以同时监视多个主从服务器，并且在被监视的master下线时，自动将某个slave提升为master，然后由新的master继续接收命令。整个过程如下：</p><ol><li>初始化sentinel，将普通的redis代码替换成sentinel专用代码</li><li>初始化masters字典和服务器信息，服务器信息主要保存ip:port，并记录实例的地址和ID</li><li>创建和master的两个连接，命令连接和订阅连接，并且订阅sentinel:hello频道</li><li>每隔10秒向master发送info命令，获取master和它下面所有slave的当前信息</li><li>当发现master有新的slave之后，sentinel和新的slave同样建立两个连接，同时每个10秒发送info命令，更新master信息</li><li>sentinel每隔1秒向所有服务器发送ping命令，如果某台服务器在配置的响应时间内连续返回无效回复，将会被标记为下线状态</li><li>选举出领头sentinel，领头sentinel需要半数以上的sentinel同意</li><li>领头sentinel从已下线的的master所有slave中挑选一个，将其转换为master</li><li>让所有的slave改为从新的master复制数据</li><li>将原来的master设置为新的master的从服务器，当原来master重新回复连接时，就变成了新master的从服务器</li></ol><p>sentinel会每隔1秒向所有实例（包括主从服务器和其他sentinel）发送ping命令，并且根据回复判断是否已经下线，这种方式叫做主观下线。当判断为主观下线时，就会向其他监视的sentinel询问，如果超过半数的投票认为已经是下线状态，则会标记为客观下线状态，同时触发故障转移。</p><h2 id="redis集群的原理"><a href="#redis集群的原理" class="headerlink" title="redis集群的原理"></a><strong>redis集群的原理</strong></h2><p>如果说依靠哨兵可以实现redis的高可用，如果还想在支持高并发同时容纳海量的数据，那就需要redis集群。redis集群是redis提供的分布式数据存储方案，集群通过数据分片sharding来进行数据的共享，同时提供复制和故障转移的功能。</p><p>###<strong>节点</strong></p><p>一个redis集群由多个节点node组成，而多个node之间通过cluster meet命令来进行连接，节点的握手过程：</p><ol><li>节点A收到客户端的cluster meet命令</li><li>A根据收到的IP地址和端口号，向B发送一条meet消息</li><li>节点B收到meet消息返回pong</li><li>A知道B收到了meet消息，返回一条ping消息，握手成功</li><li>最后，节点A将会通过gossip协议把节点B的信息传播给集群中的其他节点，其他节点也将和B进行握手</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/9.jpg"></p><h3 id="槽slot"><a href="#槽slot" class="headerlink" title="槽slot"></a><strong>槽slot</strong></h3><p>redis通过集群分片的形式来保存数据，整个集群数据库被分为16384个slot，集群中的每个节点可以处理0-16384个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有一个slot没有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。</p><p>slot是一个位数组，数组的长度是16384/8=2048，而数组的每一位用1表示被节点处理，0表示不处理，如图所示的话表示A节点处理0-7的slot。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/10.jpg"></p><p>当客户端向节点发送命令，如果刚好找到slot属于当前节点，那么节点就执行命令，反之，则会返回一个MOVED命令到客户端指引客户端转向正确的节点。（MOVED过程是自动的）</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/11.jpg"></p><p>如果增加或者移出节点，对于slot的重新分配也是非常方便的，redis提供了工具帮助实现slot的迁移，整个过程是完全在线的，不需要停止服务。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a><strong>故障转移</strong></h3><p>如果节点A向节点B发送ping消息，节点B没有在规定的时间内响应pong，那么节点A会标记节点B为pfail疑似下线状态，同时把B的状态通过消息的形式发送给其他节点，如果超过半数以上的节点都标记B为pfail状态，B就会被标记为fail下线状态，此时将会发生故障转移，优先从复制数据较多的从节点选择一个成为主节点，并且接管下线节点的slot，整个过程和哨兵非常类似，都是基于Raft协议做选举。</p><p>##<strong>Redis事务机制</strong></p><p>redis通过MULTI、EXEC、WATCH等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，并且在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。事务的执行过程如下：</p><ol><li>服务端收到客户端请求，事务以MULTI开始</li><li>如果客户端正处于事务状态，则会把事务放入队列同时返回给客户端QUEUED，反之则直接执行这个命令</li><li>当收到客户端EXEC命令时，WATCH命令监视整个事务中的key是否有被修改，如果有则返回空回复到客户端表示失败，否则redis会遍历整个事务队列，执行队列中保存的所有命令，最后返回结果给客户端</li></ol><p>WATCH的机制本身是一个CAS的机制，被监视的key会被保存到一个链表中，如果某个key被修改，那么REDIS_DIRTY_CAS标志将会被打开，这时服务器会拒绝执行事务。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>redis</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化(1)-SQL基础</title>
    <link href="/2020/03/22/SQL%E4%BC%98%E5%8C%96(1)-SQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/03/22/SQL%E4%BC%98%E5%8C%96(1)-SQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h1><p>实际上数据库范式不止3种，但大家熟知的就三种。</p><p>第一范式</p><p>所有列应该不可再分</p><p>比如，往contact列存储”18257500000,杭州,<a href="mailto:&#53;&#x32;&#51;&#56;&#x33;&#x39;&#48;&#48;&#x30;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;">&#53;&#x32;&#51;&#56;&#x33;&#x39;&#48;&#48;&#x30;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;</a>“是比较糟糕的做法，因为此时该列包含了phone、address、email三个维度的数据，应该拆成phone、address、email三个字段分别存储，这样对更新和查询都有好处。</p><p>第二范式</p><p>必须存在业务主键，且非主键字段应该依赖于全部业务主键（之所以写“全部”，因为可能存在复合主键）</p><p>说人话就是：每张表最好都设定主键。虽然某些列可能具备主键的特质（比如user表的id_card），但个人认为主键最好与业务无关，比如自增id。</p><table><thead><tr><th>id</th><th>xxx</th><th>yyy</th><th>zzz</th><th>…</th></tr></thead><tbody><tr><td>1</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>第三范式：</p><p>非主键列不能依赖除主键列以外的其他列</p><p>听起来很抽象，举个例子就明白了：</p><table><thead><tr><th><strong>t_student</strong></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>stu_name</td><td>stu_age</td><td>teacher_name</td><td>teacher_age</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>李四</td><td>40</td></tr></tbody></table><p>上面这张t_student表就违反了第三范式：非主键列teacher_name、teacher_age并不依赖id（学生的）。这种做法被称为“冗余”，它的弊端是<strong>有可能导致数据不一致。</strong>比如t_teacher表数据更新了，李四的age变成41，而代码里却没有及时维护t_student表的数据，就会导致从t_student表查出来的数据中，李四还是40岁。</p><p>改写成符合第三范式的设计：</p><table><thead><tr><th><strong>t_student</strong></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>stu_name</td><td>stu_age</td><td><strong>teacher_id</strong></td></tr><tr><td>1</td><td>张三</td><td>18</td><td><strong>10086</strong></td></tr></tbody></table><table><thead><tr><th><strong>t_teacher</strong></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>teacher_name</td><td>teacher_age</td><td>address</td></tr><tr><td>10086</td><td>李四</td><td>40</td><td>hangzhou</td></tr></tbody></table><p>总结一下三范式：</p><ul><li><p>每一列字段应该不可再分，职责单一</p></li><li><p>要有主键，最好是与业务无关的自增id</p></li><li><p>不要有冗余字段，为了避免数据更新不一致，应该拆成两张表，用（逻辑）外键关联</p></li></ul><p>一般来说，前两个范式大家都会遵守，但第三范式有时会被打破（就像上面的t_student一样）。<strong>因为实际工作中，越遵从范式化设计，表的拆分越细致，查询时需要关联的表就越多。</strong></p><p>比如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">SELECT <span class="hljs-built_in">t1</span>.aaa, <span class="hljs-built_in">t2</span>.<span class="hljs-keyword">bbb, </span><span class="hljs-built_in">t3</span>.ccc<br>FROM <span class="hljs-built_in">t1</span> <br>LEFT <span class="hljs-keyword">JOIN </span><span class="hljs-built_in">t2</span> ON xxxx<br>LEFT <span class="hljs-keyword">JOIN </span><span class="hljs-built_in">t3</span> ON xxxx;<br></code></pre></div></td></tr></table></figure><p>此时我们可以<strong>适当反范式化设计</strong>（反第三范式），目的是减少查询时需要关联的表的数量从而提升查询性能：</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">SELECT <span class="hljs-built_in">t1</span>.aaa, <span class="hljs-built_in">t1</span>.<span class="hljs-keyword">bbb, </span><span class="hljs-built_in">t1</span>.ccc<br>FROM <span class="hljs-built_in">t1</span>;<br></code></pre></div></td></tr></table></figure><p>所以才会出现上面t_student表里冗余teacher_name和teacher_age的设计。</p><p>但不论范式化设计还是反范式化设计，都不能过度：</p><ul><li>遵守第三范式，有时会让查询变得非常麻烦，要么JOIN关联，要么内存中匹配，甚至干脆无法满足需求</li><li>不遵守第三范式，则需要主动维护冗余数据，避免造成数据更新不一致</li></ul><p>但有些场景下，冗余数据百利而无一害。举个例子，比如订单表中的商品价格。商品价格会随着时间发生改变（促销等），而订单表只需记录当前下单的价格即可，不需要更新，否则你双11花了2999买的手机，过几天查询订单发现价格变成了3200，会怀疑自己是不是多付了。</p><h1 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h1><p>分类的方法很多，但这里只按自己的理解及使用频率分为4大类：</p><ul><li><p>整数类型</p></li><li><p>字符类型</p></li><li><p>小数类型</p></li><li><p>时间类型</p></li></ul><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>数值类型唯一需要注意的3点：</p><ul><li><p>如果业务允许，尽量设置unsigned</p></li><li><p>int(11)里的11和占用字节大小无关</p></li><li><p>注意各个类型的选取标准</p></li></ul><p>所谓unsigned，即无符号。比如tinyint，正常取值范围是-128<del>127。但实际业务中很少需要用到负数，比如年龄、身高等都是整数，最小为0。此时使用unsigned可以让正向范围翻倍：0</del>255。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589609778497-d64e7ece-7979-4baa-83d7-15555882f163-20210923213840093.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605039821-daa06c46-0aad-482a-a2e3-5935f95ca480-20210923213848199.png" alt="img"></p><p>如果业务需要，可以为当前字段设置默认值，比如文章状态status默认0，表示“待审核”。</p><p>另外，关于int(11)里的11，很多人都不是很清楚。其实括号里的数字和占用字节大小无关，哪怕你写成int(1)也不代表它比int(11)省空间，这只是列宽表示，比如位数不够就前面补零啥的，但对实际数值大小没有影响。<strong>总之，对于数值类型来说，每种类型占用空间大小是固定的。</strong></p><p>来看一下各种数值类型的占用空间：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占据空间</strong></th><th><strong>范围（有符号）</strong></th><th><strong>范围（无符号）</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>tinyint</td><td>1 个字节</td><td>-2^7 ~ 2^7-1</td><td>0 - 255</td><td>小整数值</td></tr><tr><td>smallint</td><td>2 个字节</td><td>-2^15 ~ 2^15-1</td><td>0 - 65535</td><td>大整数值</td></tr><tr><td>mediumint</td><td>3 个字节</td><td>-2^23 ~ 2^23-1</td><td>0 - 16777215</td><td>大整数值</td></tr><tr><td>int</td><td>4 个字节</td><td>-2^31 ~ 2^31-1</td><td>0 - 4294967295</td><td>大整数值</td></tr><tr><td>bigint</td><td>8 个字节</td><td>-2^63 ~ 2^63-1</td><td>0 - 18446744073709551615</td><td>极大整数值</td></tr></tbody></table><p>选择数值类型时，最重要的规则是“够用就好”。比如对于“性别”或“年龄”，用tinyint足够了，毕竟还没听过有人活过250岁的。这里并不是为了省磁盘空间而去扣这些细节，毕竟磁盘是最不值钱的，主要关系到索引。后面会解释，总之记住“够用就好”。</p><p>通常来说：</p><ul><li><p>主键id用bigint</p></li><li><p>age、height等普通数据用int</p></li><li><p>deleted、status、type用tinyint</p></li></ul><p>之前听说有些公司对于只有0、1两种状态的字段使用bit，也…行吧，按公司的约定来吧。隐约听过有坑，但我自己试了下没发现。大家没啥事可以自己去试试各种类型，做做实验：</p><p>此处为语雀视频卡片，点击链接查看：<a href="https://www.yuque.com/books/share/2b434c74-ed3a-470e-b148-b4c94ba14535/ghl3hi#JEUdS">Kapture 2020-12-29 at 23.26.36.mp4</a></p><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>平时大家会经常看到char(8)或者varchar(255)这样的形式对吧？经过上面的学习，你可能会觉得：哦，这也是显示作用，和实际大小无关。</p><p><strong>那你就错了。</strong></p><p><strong>字符类型的数字和实际大小有关，</strong>准确地说这里的数值和实际存储大小的<strong>上限</strong>有关。比如char(3)，表示会<strong>固定</strong>占用3个字符空间，即使存储的值不够3个字符，照样会占着那块空间，但不能超过3个字符：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605677558-0fa1e912-abbd-4568-a151-ed0d93b2130b-20210923213856943.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605713308-618696b9-23f5-45a4-8cdd-afa9f91a9803-20210923213903139.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605740485-d2756bfc-bbbd-4c72-88ef-c29657f80faa-20210923213907419.png" alt="img"></p><p>实际开发中，一不小心就会出现上面的报错信息，此时你应该要意识到这是字符超过规定长度了。</p><p>至于varchar(255)，表示最多存储255个字符。看起来好像和char(255)没区别？实际上，char和varchar分别代表着两种类型：定长与变长。</p><p>比如int、bigint这些都是定长，而varchar是变长。</p><p>varchar作为“变长字符”，它的占用空间是可伸缩的。 varchar(255)表示最多能存储255个字符，但最终占用空间以实际存储的值为准，可能实际占用M个字符（M&lt;=255），而char(255)则一定会占用255个字符的控件。</p><p>看起来好像varchar是百利而无一害，完爆char对吧？</p><p>char VS varchar</p><ul><li><p>char长度固定，不需要考虑边界问题，读写效率高于varchar，适合存储长度固定、频繁读写的数据</p></li><li><p>varchar长度不固定，但可以通过varchar(10)的方式指定上限，适合存储长度波动、更新不频繁的数据</p></li><li><p>char的存储长度不够灵活，而varchar则需要浪费1~2个字节来存储当前值的实际长度，且更新会导致重新计算</p></li></ul><p>关于第一点，你可以简单理解为：</p><p>char是定长，说了一个字段用3个格子存储就一定是3个格子，所以当你要找第3个数据时，只需要往右数6个格子，那么7~9就存着你要找的数据。而varchar(3)的“3”只代表上限，实际不一定占用3个格子，所以不能直接计算得到位置。</p><p>没有最完美的类型，只有最合适的类型。比如，当你需要存储手机号码或者身份证号时，用char(11)、char(18)显然更合适。但存储“个人介绍”时，用varchar更好，因为个人介绍的长度是可变的。</p><h2 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h2><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占据空间</strong></th><th><strong>是够精确</strong></th></tr></thead><tbody><tr><td>float</td><td>4个字节</td><td>非精确</td></tr><tr><td>double</td><td>8 个字节</td><td>非精确</td></tr><tr><td>decimal</td><td>每4个字节存9个数字，小数点占一个字节</td><td>精确</td></tr></tbody></table><p>对于decimal的大小，比如123456789.987654321，用decimal(18,9)存储，占9个字节，前后各4个字节，小数点一个字节。decimal的效率不如float和double。</p><p>当然，很多电商公司其实都是直接存最小单位“分”，也就没有精度问题了。</p><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占据空间</strong></th><th><strong>取值范围</strong></th></tr></thead><tbody><tr><td>date</td><td>3个字节</td><td>1000-01-01 ~ 9999-12-31</td></tr><tr><td>time</td><td>3~6个字节</td><td>-838:59:59 ~ 838:59:59</td></tr><tr><td>datetime</td><td>5~8个字节</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td></tr><tr><td>timestamp</td><td>4~7个字节</td><td>1970-01-01 00:00:01 ~ 2038-01-19 03:14:07</td></tr></tbody></table><p>DATETIME 和 TIMESTAMP的区别：</p><ul><li>时间范围不同，DATETIME更大，内存稍微大一点</li><li>TIMESTAMP的时间会根据时区变化。比如 SET time_zone=’+10:00’，那么查询后会自动增加10小时</li></ul><p>具体跟着公司走就好了，比如我们公司甚至没用时间类型，直接用Long存秒数。</p><h1 id="类型选择小结"><a href="#类型选择小结" class="headerlink" title="类型选择小结"></a>类型选择小结</h1><ul><li><p>更小的通常更好</p></li><li><p>简单合适就好</p></li><li><p>尽量避免null（设置NOT NULL，除非业务要求可能NULL）</p></li><li><p>如果确定不会出现负数，可以使用unsigned</p></li></ul><p>NOT NULL：一定要传递值，且不能为NULL，否则报错</p><p>DEFAULT ‘xx’：传不传都可以，不传就使用默认值xx，<strong>可以传NULL</strong></p><p>NOT NULL DEFAULT ‘xx’：传不传都可以，不传就使用默认值xx，<strong>不能传NULL</strong></p><p>可以做个实验：</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`test`</span> (<br>  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-symbol">`age_not_null_default`</span> int(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> DEFAULT <span class="hljs-string">&#x27;0&#x27;</span>,<br>  <span class="hljs-symbol">`age_not_null`</span> int(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`age_default`</span> int(<span class="hljs-number">10</span>) DEFAULT <span class="hljs-string">&#x27;0&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;<br></code></pre></div></td></tr></table></figure><p>测试：</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"># age_not_null_default 要么不传，要么传非NULL值，这里选择不传，则插入默认值0<br># age_not_null 一定要传值，且不能为NULL<br># age_default 传不传都可以，可以传NULL<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`test`</span> (<span class="hljs-symbol">`age_not_null`</span>, <span class="hljs-symbol">`age_default`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>);<br></code></pre></div></td></tr></table></figure><h1 id="语句书写顺序"><a href="#语句书写顺序" class="headerlink" title="语句书写顺序"></a>语句书写顺序</h1><p>SELECT … FROM table WHERE … GROUP BY … HAVING … ORDER BY … LIMIT …</p><p>除了SELECT，后面几个顺序可以记忆为：温哥华OL，意思是温哥华白领。</p><h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><h2 id="隐式连接"><a href="#隐式连接" class="headerlink" title="隐式连接"></a>隐式连接</h2><p>什么是隐式连接？不用写JOIN关键字的连接。</p><p>格式是：</p><p>FROM t_a, t_b WHERE或ON 等值连接条件</p><p>隐式连接属于内连接，效果等同于：</p><p>FROM t_a [INNER] JOIN t_b ON 连接条件</p><h2 id="显式连接"><a href="#显式连接" class="headerlink" title="显式连接"></a>显式连接</h2><p><strong>内连接</strong></p><p>格式：</p><p>FROM t_a [INNER] JOIN t_b ON 连接条件</p><p>INNER写不写都可以，查询效果和隐式连接一样，连接条件写在ON后面。</p><p>如果两个表做等值判断的字段相同，比如 ON t1.id = t2.id 可以改写为 USING(id)，但没什么卵用，我要不是这次复习，都不知道这是啥意思。所以尽量别用这种乱七八糟的写法，给同事添堵。</p><p><strong>外连接</strong></p><ul><li>LEFT JOIN</li><li>RIGHT JOIN </li></ul><p>本质是一样的，换个位置而已。</p><p><strong>自连接</strong></p><p>格式：</p><p>FROM t_a child, t_a parent ON 连接条件</p><p>自连接不是一种新的连接形式，它可以用上面的任意一种连接方式，只不过是把同一张表当做两张表，自己和自己关联。</p><p>其他的什么自然连接(NATURAL JOIN)、交叉连接(CROSS JOIN)不提了，我反正从来没用过，大家有兴趣自行了解，不徒增大家的记忆负担。</p><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询指的就是在一个查询之中嵌套了其他若干个查询。</p><p>子查询通常出现在</p><ul><li><p>WHERE后面：SELECT name FROM table_a WHERE id IN (SELECT id FROM table_b)</p></li><li><p>FROM后面：SELECT name FROM (SELECT name, age FROM table_a) temp LEFT JOIN….</p></li><li><p>EXISTST后面：没用过，大家自己可以了解一下（很真实）</p></li></ul><p>放在FROM后的子查询可以看做一张临时表，WHERE后面的子查询就是动态的查询条件而已。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis分布式锁</title>
    <link href="/2020/03/04/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2020/03/04/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇文章我想和你聊一聊，关于 Redis 分布式锁的「安全性」问题。</p><p>Redis 分布式锁的话题，很多文章已经写烂了，我为什么还要写这篇文章呢？</p><p>因为我发现网上 99% 的文章，并没有把这个问题真正讲清楚。导致很多读者看了很多文章，依旧云里雾里。例如下面这些问题，你能清晰地回答上来吗？</p><ul><li>基于 Redis 如何实现一个分布式锁？</li><li>Redis 分布式锁真的安全吗？</li><li>Redis 的 Redlock 有什么问题？一定安全吗？</li><li>业界争论 Redlock，到底在争论什么？哪种观点是对的？</li><li>分布式锁到底用 Redis 还是 Zookeeper？</li><li>实现一个有「容错性」的分布式锁，都需要考虑哪些问题？</li></ul><p>这篇文章，我就来把这些问题彻底讲清楚。</p><p>读完这篇文章，你不仅可以彻底了解分布式锁，还会对「分布式系统」有更加深刻的理解。</p><p><strong>文章有点长，但干货很多，希望你可以耐心读完。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101801037.png" alt="图片"></strong></p><h1 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h1><p>在开始讲分布式锁之前，有必要简单介绍一下，为什么需要分布式锁？</p><p>与分布式锁相对应的是「单机锁」，我们在写多线程程序时，避免同时操作一个共享变量产生数据问题，通常会使用一把锁来「互斥」，以保证共享变量的正确性，其使用范围是在「同一个进程」中。</p><p>如果换做是多个进程，需要同时操作一个共享资源，如何互斥呢？</p><p>例如，现在的业务应用通常都是微服务架构，这也意味着一个应用会部署多个进程，那这多个进程如果需要修改 MySQL 中的同一行记录时，为了避免操作乱序导致数据错误，此时，我们就需要引入「分布式锁」来解决这个问题了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101752919.png" alt="图片"></p><p>想要实现分布式锁，必须借助一个外部系统，所有进程都去这个系统上申请「加锁」。</p><p>而这个外部系统，必须要实现「互斥」的能力，即两个请求同时进来，只会给一个进程返回成功，另一个返回失败（或等待）。</p><p>这个外部系统，可以是 MySQL，也可以是 Redis 或 Zookeeper。但为了追求更好的性能，我们通常会选择使用 Redis 或 Zookeeper 来做。</p><p>下面我就以 Redis 为主线，由浅入深，带你深度剖析一下，分布式锁的各种「安全性」问题，帮你彻底理解分布式锁。</p><h1 id="分布式锁怎么实现？"><a href="#分布式锁怎么实现？" class="headerlink" title="分布式锁怎么实现？"></a>分布式锁怎么实现？</h1><p>我们从最简单的开始讲起。</p><p>想要实现分布式锁，必须要求 Redis 有「互斥」的能力，我们可以使用 SETNX 命令，这个命令表示<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists，即如果 key 不存在，才会设置它的值，否则什么也不做。</p><p>两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p><p>客户端 1 申请加锁，加锁成功：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; SETNX lock 1<br>(integer) 1     // 客户端1，加锁成功<br></code></pre></div></td></tr></table></figure><p>客户端 2 申请加锁，因为它后到达，加锁失败：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; SETNX lock 1<br>(integer) 0     // 客户端2，加锁失败<br></code></pre></div></td></tr></table></figure><p>此时，加锁成功的客户端，就可以去操作「共享资源」，例如，修改 MySQL 的某一行数据，或者调用一个 API 请求。</p><p>操作完成后，还要及时释放锁，给后来者让出操作共享资源的机会。如何释放锁呢？</p><p>也很简单，直接使用 DEL 命令删除这个 key 即可：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; DEL lock // 释放锁<br>(integer) 1<br></code></pre></div></td></tr></table></figure><p>这个逻辑非常简单，整体的路程就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101730050.png" alt="图片"></p><p>但是，它存在一个很大的问题，当客户端 1 拿到锁后，如果发生下面的场景，就会造成「死锁」：</p><ol><li>程序处理业务逻辑异常，没及时释放锁</li><li>进程挂了，没机会释放锁</li></ol><p>这时，这个客户端就会一直占用这个锁，而其它客户端就「永远」拿不到这把锁了。</p><p>怎么解决这个问题呢？</p><h1 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h1><p>我们很容易想到的方案是，在申请锁时，给这把锁设置一个「租期」。</p><p>在 Redis 中实现时，就是给这个 key 设置一个「过期时间」。这里我们假设，操作共享资源的时间不会超过 10s，那么在加锁时，给这个 key 设置 10s 过期即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">127.0.0.1:6379&gt; SETNX lock 1    // 加锁<br>(integer) 1<br>127.0.0.1:6379&gt; EXPIRE lock 10  // 10s后自动过期<br>(integer) 1<br></code></pre></div></td></tr></table></figure><p>这样一来，无论客户端是否异常，这个锁都可以在 10s 后被「自动释放」，其它客户端依旧可以拿到锁。</p><p>但这样真的没问题吗？</p><p>还是有问题。</p><p>现在的操作，加锁、设置过期是 2 条命令，有没有可能只执行了第一条，第二条却「来不及」执行的情况发生呢？例如：</p><ol><li>SETNX 执行成功，执行 EXPIRE 时由于网络问题，执行失败</li><li>SETNX 执行成功，Redis 异常宕机，EXPIRE 没有机会执行</li><li>SETNX 执行成功，客户端异常崩溃，EXPIRE 也没有机会执行</li></ol><p>总之，这两条命令不能保证是原子操作（一起成功），就有潜在的风险导致过期时间设置失败，依旧发生「死锁」问题。</p><p>怎么办？</p><p>在 Redis 2.6.12 版本之前，我们需要想尽办法，保证 SETNX 和 EXPIRE 原子性执行，还要考虑各种异常情况如何处理。</p><p>但在 Redis 2.6.12 之后，Redis 扩展了 SET 命令的参数，用这一条命令就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">// 一条命令保证原子性执行<br>127.0.0.1:6379&gt; SET lock 1 EX 10 NX<br>OK<br></code></pre></div></td></tr></table></figure><p>这样就解决了死锁问题，也比较简单。</p><p>我们再来看分析下，它还有什么问题？</p><p>试想这样一种场景：</p><ol><li>客户端 1 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源的时间，「超过」了锁的过期时间，锁被「自动释放」</li><li>客户端 2 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源完成，释放锁（但释放的是客户端 2 的锁）</li></ol><p>看到了么，这里存在两个严重的问题：</p><ol><li><strong>锁过期</strong>：客户端 1 操作共享资源耗时太久，导致锁被自动释放，之后被客户端 2 持有</li><li><strong>释放别人的锁</strong>：客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁</li></ol><p>导致这两个问题的原因是什么？我们一个个来看。</p><p><strong>第一个问题，可能是我们评估操作共享资源的时间不准确导致的。</strong></p><p>例如，操作共享资源的时间「最慢」可能需要 15s，而我们却只设置了 10s 过期，那这就存在锁提前过期的风险。</p><p>过期时间太短，那增大冗余时间，例如设置过期时间为 20s，这样总可以了吧？</p><p>这样确实可以「缓解」这个问题，降低出问题的概率，但依旧无法「彻底解决」问题。</p><p>为什么？</p><p>原因在于，客户端在拿到锁之后，在操作共享资源时，遇到的场景有可能是很复杂的，例如，程序内部发生异常、网络请求超时等等。</p><p>既然是「预估」时间，也只能是大致计算，除非你能预料并覆盖到所有导致耗时变长的场景，但这其实很难。</p><p>有什么更好的解决方案吗？</p><p>别急，关于这个问题，我会在后面详细来讲对应的解决方案。</p><p>我们继续来看第二个问题。</p><p><strong>第二个问题在于，一个客户端释放了其它客户端持有的锁。</strong></p><p>想一下，导致这个问题的关键点在哪？</p><p>重点在于，每个客户端在释放锁时，都是「无脑」操作，并没有检查这把锁是否还「归自己持有」，所以就会发生释放别人锁的风险，这样的解锁流程，很不「严谨」！</p><p>如何解决这个问题呢？</p><h1 id="锁被别人释放怎么办"><a href="#锁被别人释放怎么办" class="headerlink" title="锁被别人释放怎么办?"></a>锁被别人释放怎么办?</h1><p>解决办法是：客户端在加锁时，设置一个只有自己知道的「唯一标识」进去。</p><p>例如，可以是自己的线程 ID，也可以是一个 UUID（随机且唯一），这里我们以 UUID 举例：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// 锁的VALUE设置为UUID<br>127.0.0.1:6379&gt; SET lock $uuid EX 20 NX<br>OK<br></code></pre></div></td></tr></table></figure><blockquote><p>这里假设 20s 操作共享时间完全足够，先不考虑锁自动过期的问题。</p></blockquote><p>之后，在释放锁时，要先判断这把锁是否还归自己持有，伪代码可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 锁是自己的，才释放</span><br><span class="hljs-keyword">if</span> redis.get(<span class="hljs-string">&quot;lock&quot;</span>) == $uuid:<br>    redis.del(<span class="hljs-string">&quot;lock&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>这里释放锁使用的是 GET + DEL 两条命令，这时，又会遇到我们前面讲的原子性问题了。</p><ol><li>客户端 1 执行 GET，判断锁是自己的</li><li>客户端 2 执行了 SET 命令，强制获取到锁（虽然发生概率比较低，但我们需要严谨地考虑锁的安全性模型）</li><li>客户端 1 执行 DEL，却释放了客户端 2 的锁</li></ol><p>由此可见，这两个命令还是必须要原子执行才行。</p><p>怎样原子执行呢？Lua 脚本。</p><p>我们可以把这个逻辑，写成 Lua 脚本，让 Redis 来执行。</p><p>因为 Redis 处理每一个请求是「单线程」执行的，在执行一个 Lua 脚本时，其它请求必须等待，直到这个 Lua 脚本处理完成，这样一来，GET + DEL 之间就不会插入其它命令了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101642484.png" alt="图片"></p><p>安全释放锁的 Lua 脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">// 判断锁是自己的，才释放<br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;GET&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;DEL&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>好了，这样一路优化，整个的加锁、解锁的流程就更「严谨」了。</p><p>这里我们先小结一下，基于 Redis 实现的分布式锁，一个严谨的的流程如下：</p><ol><li>加锁：SET lock_key $unique_id EX $expire_time NX</li><li>操作共享资源</li><li>释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101626176.png" alt="图片"></p><p>好，有了这个完整的锁模型，让我们重新回到前面提到的第一个问题。</p><p>锁过期时间不好评估怎么办？</p><h1 id="锁过期时间不好评估怎么办？"><a href="#锁过期时间不好评估怎么办？" class="headerlink" title="锁过期时间不好评估怎么办？"></a>锁过期时间不好评估怎么办？</h1><p>前面我们提到，锁的过期时间如果评估不好，这个锁就会有「提前」过期的风险。</p><p>当时给的妥协方案是，尽量「冗余」过期时间，降低锁提前过期的概率。</p><p>这个方案其实也不能完美解决问题，那怎么办呢？</p><p>是否可以设计这样的方案：<strong>加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。</strong></p><p>这确实一种比较好的方案。</p><p>如果你是 Java 技术栈，幸运的是，已经有一个库把这些工作都封装好了：<strong>Redisson</strong>。</p><p>Redisson 是一个 Java 语言实现的 Redis SDK 客户端，在使用分布式锁时，它就采用了「自动续期」的方案来避免锁过期，这个守护线程我们一般也把它叫做「看门狗」线程。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101618896.png" alt="图片"></p><p>除此之外，这个 SDK 还封装了很多易用的功能：</p><ul><li>可重入锁</li><li>乐观锁</li><li>公平锁</li><li>读写锁</li><li>Redlock（红锁，下面会详细讲）</li></ul><p>这个 SDK 提供的 API 非常友好，它可以像操作本地锁的方式，操作分布式锁。如果你是 Java 技术栈，可以直接把它用起来。</p><blockquote><p>这里不重点介绍 Redisson 的使用，大家可以看官方 Github 学习如何使用，比较简单。</p></blockquote><p>到这里我们再小结一下，基于 Redis 的实现分布式锁，前面遇到的问题，以及对应的解决方案：</p><ul><li><strong>死锁</strong>：设置过期时间</li><li><strong>过期时间评估不好，锁提前过期</strong>：守护线程，自动续期</li><li><strong>锁被别人释放</strong>：锁写入唯一标识，释放锁先检查标识，再释放</li></ul><p>还有哪些问题场景，会危害 Redis 锁的安全性呢？</p><p>之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 的部署架构细节。</p><p>而我们在使用 Redis 时，一般会采用<strong>主从集群 + 哨兵</strong>的模式部署，这样做的好处在于，当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p><p><strong>那当「主从发生切换」时，这个分布锁会依旧安全吗？</strong></p><p>试想这样的场景：</p><ol><li>客户端 1 在主库上执行 SET 命令，加锁成功</li><li>此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）</li><li>从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101604473.png" alt="图片"></p><p>可见，当引入 Redis 副本后，分布锁还是可能会受到影响。</p><p>怎么解决这个问题？</p><p>为此，Redis 的作者提出一种解决方案，就是我们经常听到的 <strong>Redlock（红锁）</strong>。</p><p>它真的可以解决上面这个问题吗？</p><h1 id="Redlock-真的安全吗？"><a href="#Redlock-真的安全吗？" class="headerlink" title="Redlock 真的安全吗？"></a>Redlock 真的安全吗？</h1><p>好，终于到了这篇文章的重头戏。啊？上面讲的那么多问题，难道只是基础？</p><p>是的，那些只是开胃菜，真正的硬菜，从这里刚刚开始。</p><p>如果上面讲的内容，你还没有理解，我建议你重新阅读一遍，先理清整个加锁、解锁的基本流程。</p><p>如果你已经对 Redlock 有所了解，这里可以跟着我再复习一遍，如果你不了解 Redlock，没关系，我会带你重新认识它。</p><p>值得提醒你的是，<strong>后面我不仅仅是讲 Redlock 的原理，还会引出有关「分布式系统」中的很多问题，你最好跟紧我的思路，在脑中一起分析问题的答案。</strong></p><p>现在我们来看，Redis 作者提出的 Redlock 方案，是如何解决主从切换后，锁失效问题的。</p><p>Redlock 的方案基于 2 个前提：</p><ol><li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong></li><li>但主库要部署多个，官方推荐至少 5 个实例</li></ol><p>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><blockquote><p><strong>注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101557341.png" alt="图片"></p><p>Redlock 具体如何使用呢？</p><p>整体的流程是这样的，一共分为 5 步：</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 &gt;=3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p>我简单帮你总结一下，有 4 个重点：</p><ol><li>客户端在多个 Redis 实例上申请加锁</li><li>必须保证大多数节点加锁成功</li><li>大多数节点加锁的总耗时，要小于锁设置的过期时间</li><li>释放锁，要向全部节点发起释放锁请求</li></ol><blockquote><p>第一次看可能不太容易理解，建议你把上面的文字多看几遍，加深记忆。</p><p>然后，记住这 5 步，非常重要，下面会根据这个流程，剖析各种可能导致锁失效的问题假设。</p></blockquote><p>好，明白了 Redlock 的流程，我们来看 Redlock 为什么要这么做。</p><p><strong>1) 为什么要在多个实例上加锁？</strong></p><p>本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用。</p><p><strong>2) 为什么大多数加锁成功，才算成功？</strong></p><p>多个 Redis 实例一起来用，其实就组成了一个「分布式系统」。</p><p>在分布式系统中，总会出现「异常节点」，所以，在谈论分布式系统问题时，需要考虑异常节点达到多少个，也依旧不会影响整个系统的「正确性」。</p><p>这是一个分布式系统「容错」问题，这个问题的结论是：<strong>如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的。</strong></p><blockquote><p>这个问题的模型，就是我们经常听到的「拜占庭将军」问题，感兴趣可以去看算法的推演过程。</p></blockquote><p><strong>3) 为什么步骤 3 加锁成功后，还要计算加锁的累计耗时？</strong></p><p>因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久，而且，因为是网络请求，网络情况是复杂的，有可能存在<strong>延迟、丢包、超时</strong>等情况发生，网络请求越多，异常发生的概率就越大。</p><p>所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经「超过」了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。</p><p><strong>4) 为什么释放锁，要操作所有节点？</strong></p><p>在某一个 Redis 节点加锁时，可能因为「网络原因」导致加锁失败。</p><p>例如，客户端在一个 Redis 实例上加锁成功，但在读取响应结果时，网络问题导致<strong>读取失败</strong>，那这把锁其实已经在 Redis 上加锁成功了。</p><p>所以，释放锁时，不管之前有没有加锁成功，需要释放「所有节点」的锁，以保证清理节点上「残留」的锁。</p><p>好了，明白了 Redlock 的流程和相关问题，看似 Redlock 确实解决了 Redis 节点异常宕机锁失效的问题，保证了锁的「安全性」。</p><p>但事实真的如此吗？</p><h1 id="Redlock-的争论谁对谁错？"><a href="#Redlock-的争论谁对谁错？" class="headerlink" title="Redlock 的争论谁对谁错？"></a>Redlock 的争论谁对谁错？</h1><p>Redis 作者把这个方案一经提出，就马上受到业界著名的分布式系统专家的<strong>质疑</strong>！</p><p>这个专家叫 <strong>Martin</strong>，是英国剑桥大学的一名分布式系统研究员。在此之前他曾是软件工程师和企业家，从事大规模数据基础设施相关的工作。它还经常在大会做演讲，写博客，写书，也是开源贡献者。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101545963.png" alt="图片"></p><p>他马上写了篇文章，质疑这个 Redlock 的算法模型是有问题的，并对分布式锁的设计，提出了自己的看法。</p><p>之后，Redis 作者 Antirez 面对质疑，不甘示弱，也写了一篇文章，反驳了对方的观点，并详细剖析了 Redlock 算法模型的更多设计细节。</p><p>而且，关于这个问题的争论，在当时互联网上也引起了非常激烈的讨论。</p><p><strong>二人思路清晰，论据充分，这是一场高手过招，也是分布式系统领域非常好的一次思想的碰撞！双方都是分布式系统领域的专家，却对同一个问题提出很多相反的论断，究竟是怎么回事？</strong></p><p>下面我会从他们的争论文章中，提取重要的观点，整理呈现给你。</p><blockquote><p>提醒：后面的信息量极大，可能不宜理解，最好放慢速度阅读。</p></blockquote><h2 id="分布式专家-Martin-对于-Relock-的质疑"><a href="#分布式专家-Martin-对于-Relock-的质疑" class="headerlink" title="分布式专家 Martin 对于 Relock 的质疑"></a>分布式专家 Martin 对于 Relock 的质疑</h2><p>在他的文章中，主要阐述了 4 个论点：</p><p><strong>1) 分布式锁的目的是什么？</strong></p><p>Martin 表示，你必须先清楚你在使用分布式锁的目的是什么？</p><p>他认为有两个目的。</p><p><strong>第一，效率。</strong></p><p>使用分布式锁的互斥能力，是避免不必要地做同样的两次工作（例如一些昂贵的计算任务）。如果锁失效，并不会带来「恶性」的后果，例如发了 2 次邮件等，无伤大雅。</p><p><strong>第二，正确性。</strong></p><p>使用锁用来防止并发进程互相干扰。如果锁失效，会造成多个进程同时操作同一条数据，产生的后果是<strong>数据严重错误、永久性不一致、数据丢失</strong>等恶性问题，就像给患者服用了重复剂量的药物，后果很严重。</p><p>他认为，如果你是为了前者——效率，那么使用单机版 Redis 就可以了，即使偶尔发生锁失效（宕机、主从切换），都不会产生严重的后果。而使用 Redlock 太重了，没必要。</p><p><strong>而如果是为了正确性，Martin 认为 Redlock 根本达不到安全性的要求，也依旧存在锁失效的问题！</strong></p><p><strong>2) 锁在分布式系统中会遇到的问题</strong></p><p>Martin 表示，一个分布式系统，更像一个复杂的「野兽」，存在着你想不到的各种异常情况。</p><p>这些异常场景主要包括三大块，这也是分布式系统会遇到的三座大山：<strong>NPC</strong>。</p><ul><li>N：Network Delay，网络延迟</li><li>P：Process Pause，进程暂停（GC）</li><li>C：Clock Drift，时钟漂移</li></ul><p>Martin 用一个进程暂停（GC）的例子，指出了 Redlock 安全性问题：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC（时间比较久）</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取到了 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到了锁，发生「冲突」</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101536288.png" alt="图片"></p><p>Martin 认为，GC 可能发生在程序的任意时刻，而且执行时间是不可控的。</p><blockquote><p>注：当然，即使是使用没有 GC 的编程语言，在发生网络延迟、时钟漂移时，也都有可能导致 Redlock 出现问题，这里 Martin 只是拿 GC 举例。</p></blockquote><p><strong>3) 假设时钟正确的是不合理的</strong></p><p>又或者，当多个 Redis 节点「时钟」发生问题时，也会导致 Redlock <strong>锁失效</strong>。</p><ol><li>客户端 1 获取节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E</li><li>节点 C 上的时钟「向前跳跃」，导致锁到期</li><li>客户端 2 获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B</li><li>客户端 1 和 2 现在都相信它们持有了锁（冲突）</li></ol><p>Martin 觉得，Redlock 必须「强依赖」多个节点的时钟是保持同步的，一旦有节点时钟发生错误，那这个算法模型就失效了。</p><blockquote><p>即使 C 不是时钟跳跃，而是「崩溃后立即重启」，也会发生类似的问题。</p></blockquote><p>Martin 继续阐述，机器的时钟发生错误，是很有可能发生的：</p><ul><li>系统管理员「手动修改」了机器时钟</li><li>机器时钟在同步 NTP 时间时，发生了大的「跳跃」</li></ul><p>总之，Martin 认为，Redlock 的算法是建立在「同步模型」基础上的，有大量资料研究表明，同步模型的假设，在分布式系统中是有问题的。</p><p>在混乱的分布式系统的中，你不能假设系统时钟就是对的，所以，你必须非常小心你的假设。</p><p><strong>4) 提出 fecing token 的方案，保证正确性</strong></p><p>相对应的，Martin 提出一种被叫作 fecing token 的方案，保证分布式锁的正确性。</p><p>这个模型流程如下：</p><ol><li>客户端在获取锁时，锁服务可以提供一个「递增」的 token</li><li>客户端拿着这个 token 去操作共享资源</li><li>共享资源可以根据 token 拒绝「后来者」的请求</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101529458.png" alt="图片"></p><p>这样一来，无论 NPC 哪种异常情况发生，都可以保证分布式锁的安全性，因为它是建立在「异步模型」上的。</p><p>而 Redlock 无法提供类似 fecing token 的方案，所以它无法保证安全性。</p><p>他还表示，<strong>一个好的分布式锁，无论 NPC 怎么发生，可以不在规定时间内给出结果，但并不会给出一个错误的结果。也就是只会影响到锁的「性能」（或称之为活性），而不会影响它的「正确性」。</strong></p><p>Martin 的结论：</p><p><strong>1、Redlock 不伦不类</strong>：它对于效率来讲，Redlock 比较重，没必要这么做，而对于正确性来说，Redlock 是不够安全的。</p><p><strong>2、时钟假设不合理</strong>：该算法对系统时钟做出了危险的假设（假设多个节点机器时钟都是一致的），如果不满足这些假设，锁就会失效。</p><p><strong>3、无法保证正确性</strong>：Redlock 不能提供类似 fencing token 的方案，所以解决不了正确性的问题。为了正确性，请使用有「共识系统」的软件，例如 Zookeeper。</p><p>好了，以上就是 Martin 反对使用 Redlock 的观点，看起来有理有据。</p><p>下面我们来看 Redis 作者 Antirez 是如何反驳的。</p><h2 id="Redis-作者-Antirez-的反驳"><a href="#Redis-作者-Antirez-的反驳" class="headerlink" title="Redis 作者 Antirez 的反驳"></a>Redis 作者 Antirez 的反驳</h2><p>在 Redis 作者的文章中，重点有 3 个：</p><p><strong>1) 解释时钟问题</strong></p><p>首先，Redis 作者一眼就看穿了对方提出的最为核心的问题：<strong>时钟问题</strong>。</p><p>Redis 作者表示，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了，允许有「误差」。</p><p>例如要计时 5s，但实际可能记了 4.5s，之后又记了 5.5s，有一定误差，但只要不超过「误差范围」锁失效时间即可，这种对于时钟的精度要求并不是很高，而且这也符合现实环境。</p><p>对于对方提到的「时钟修改」问题，Redis 作者反驳到：</p><ol><li><strong>手动修改时钟</strong>：不要这么做就好了，否则你直接修改 Raft 日志，那 Raft 也会无法工作…</li><li><strong>时钟跳跃</strong>：通过「恰当的运维」，保证机器时钟不会大幅度跳跃（每次通过微小的调整来完成），实际上这是可以做到的</li></ol><blockquote><p>为什么 Redis 作者优先解释时钟问题？因为在后面的反驳过程中，需要依赖这个基础做进一步解释。</p></blockquote><p><strong>2) 解释网络延迟、GC 问题</strong></p><p>之后，Redis 作者对于对方提出的，网络延迟、进程 GC 可能导致 Redlock 失效的问题，也做了反驳：</p><p>我们重新回顾一下，Martin 提出的问题假设：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取节点 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到锁，发生「冲突」</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101522843.png" alt="图片"></p><p>Redis 作者反驳到，这个假设其实是有问题的，Redlock 是可以保证锁安全的。</p><p>这是怎么回事呢？</p><p>还记得前面介绍 Redlock 流程的那 5 步吗？这里我再拿过来让你复习一下。</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p><strong>注意，重点是 1-3，在步骤 3，加锁成功后为什么要重新获取「当前时间戳T2」？还用 T2 - T1 的时间，与锁的过期时间做比较？</strong></p><p>Redis 作者强调：如果在 1-3 发生了网络延迟、进程 GC 等耗时长的异常情况，那在第 3 步 T2 - T1，是可以检测出来的，如果超出了锁设置的过期时间，那这时就认为加锁会失败，之后释放所有节点的锁就好了！</p><p>Redis 作者继续论述，如果对方认为，发生网络延迟、进程 GC 是在步骤 3 之后，也就是客户端确认拿到了锁，去操作共享资源的途中发生了问题，导致锁失效，那这<strong>不止是 Redlock 的问题，任何其它锁服务例如 Zookeeper，都有类似的问题，这不在讨论范畴内。</strong></p><p>这里我举个例子解释一下这个问题：</p><ol><li>客户端通过 Redlock 成功获取到锁（通过了大多数节点加锁成功、加锁耗时检查逻辑）</li><li>客户端开始操作共享资源，此时发生网络延迟、进程 GC 等耗时很长的情况</li><li>此时，锁过期自动释放</li><li>客户端开始操作 MySQL（此时的锁可能会被别人拿到，锁失效）</li></ol><p>Redis 作者这里的结论就是：</p><ul><li>客户端在拿到锁之前，无论经历什么耗时长问题，Redlock 都能够在第 3 步检测出来</li><li>客户端在拿到锁之后，发生 NPC，那 Redlock、Zookeeper 都无能为力</li></ul><p>所以，Redis 作者认为 Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p><p><strong>3) 质疑 fencing token 机制</strong></p><p>Redis 作者对于对方提出的 fecing token 机制，也提出了质疑，主要分为 2 个问题，这里最不宜理解，请跟紧我的思路。</p><p><strong>第一</strong>，这个方案必须要求要操作的「共享资源服务器」有拒绝「旧 token」的能力。</p><p>例如，要操作 MySQL，从锁服务拿到一个递增数字的 token，然后客户端要带着这个 token 去改 MySQL 的某一行，这就需要利用 MySQL 的「事物隔离性」来做。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 两个客户端必须利用事物和隔离性达到目的<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 注意 token 的判断条件<br>UPDATE <span class="hljs-keyword">table</span> T <span class="hljs-keyword">SET</span> val <span class="hljs-operator">=</span> $new_val <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> $id <span class="hljs-keyword">AND</span> current_token <span class="hljs-operator">&lt;</span> $token<br></code></pre></div></td></tr></table></figure><p>但如果操作的不是 MySQL 呢？例如向磁盘上写一个文件，或发起一个 HTTP 请求，那这个方案就无能为力了，这对要操作的资源服务器，提出了更高的要求。</p><p>也就是说，大部分要操作的资源服务器，都是没有这种互斥能力的。</p><p><strong>再者，既然资源服务器都有了「互斥」能力，那还要分布式锁干什么？</strong></p><p>所以，Redis 作者认为这个方案是站不住脚的。</p><p><strong>第二</strong>，退一步讲，即使 Redlock 没有提供 fecing token 的能力，但 Redlock 已经提供了随机值（就是前面讲的 UUID），利用这个随机值，也可以达到与 fecing token 同样的效果。</p><p>如何做呢？</p><blockquote><p>Redis 作者只是提到了可以完成 fecing token 类似的功能，但却没有展开相关细节，根据我查阅的资料，大概流程应该如下，如有错误，欢迎交流~</p></blockquote><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端在操作共享资源之前，先把这个锁的 VALUE，在要操作的共享资源上做标记</li><li>客户端处理业务逻辑，最后，在修改共享资源时，判断这个标记是否与之前一样，一样才修改（类似 CAS 的思路）</li></ol><p>还是以 MySQL 为例，举个例子就是这样的：</p><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端要修改 MySQL 表中的某一行数据之前，先把锁的 VALUE 更新到这一行的某个字段中（这里假设为 current_token 字段)</li><li>客户端处理业务逻辑</li><li>客户端修改 MySQL 的这一行数据，把 VALUE 当做 WHERE 条件，再修改</li></ol><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">UPDATE <span class="hljs-keyword">table</span> T <span class="hljs-keyword">SET</span> val <span class="hljs-operator">=</span> $new_val <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> $id <span class="hljs-keyword">AND</span> current_token <span class="hljs-operator">=</span> $redlock_value<br></code></pre></div></td></tr></table></figure><p>可见，这种方案依赖 MySQL 的事物机制，也达到对方提到的 fecing token 一样的效果。</p><p>但这里还有个小问题，是网友参与问题讨论时提出的：<strong>两个客户端通过这种方案，先「标记」再「检查+修改」共享资源，那这两个客户端的操作顺序无法保证啊？</strong></p><p>而用 Martin 提到的 fecing token，因为这个 token 是单调递增的数字，资源服务器可以拒绝小的 token 请求，保证了操作的「顺序性」！</p><p>Redis 作者对这问题做了不同的解释，我觉得很有道理，他解释道：<strong>分布式锁的本质，是为了「互斥」，只要能保证两个客户端在并发时，一个成功，一个失败就好了，不需要关心「顺序性」。</strong></p><blockquote><p>前面 Martin 的质疑中，一直很关心这个顺序性问题，但 Redis 的作者的看法却不同。</p></blockquote><p>综上，Redis 作者的结论：</p><p><strong>1、作者同意对方关于「时钟跳跃」对 Redlock 的影响，但认为时钟跳跃是可以避免的，取决于基础设施和运维。</strong></p><p><strong>2、Redlock 在设计时，充分考虑了 NPC 问题，在 Redlock 步骤 3 之前出现 NPC，可以保证锁的正确性，但在步骤 3 之后发生 NPC，不止是 Redlock 有问题，其它分布式锁服务同样也有问题，所以不在讨论范畴内。</strong></p><p>是不是觉得很有意思？</p><p>在分布式系统中，一个小小的锁，居然可能会遇到这么多问题场景，影响它的安全性！</p><p>不知道你看完双方的观点，更赞同哪一方的说法呢？</p><p>别急，后面我还会综合以上论点，谈谈自己的理解。</p><p>好，讲完了双方对于 Redis 分布锁的争论，你可能也注意到了，Martin 在他的文章中，推荐使用 Zookeeper 实现分布式锁，认为它更安全，确实如此吗？</p><h1 id="基于-Zookeeper-的锁安全吗？"><a href="#基于-Zookeeper-的锁安全吗？" class="headerlink" title="基于 Zookeeper 的锁安全吗？"></a>基于 Zookeeper 的锁安全吗？</h1><p>如果你有了解过 Zookeeper，基于它实现的分布式锁是这样的：</p><ol><li>客户端 1 和 2 都尝试创建「临时节点」，例如 /lock</li><li>假设客户端 1 先到达，则加锁成功，客户端 2 加锁失败</li><li>客户端 1 操作共享资源</li><li>客户端 1 删除 /lock 节点，释放锁</li></ol><p>你应该也看到了，Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端 1 拿到锁后，只要连接不断，就可以一直持有锁。</p><p>而且，如果客户端 1 异常崩溃了，那么这个临时节点会自动删除，保证了锁一定会被释放。</p><p><strong>不错，没有锁过期的烦恼，还能在异常时自动释放锁，是不是觉得很完美？</strong></p><p>其实不然。</p><p>思考一下，客户端 1 创建临时节点后，Zookeeper 是如何保证让这个客户端一直持有锁呢？</p><p>原因就在于，<strong>客户端 1 此时会与 Zookeeper 服务器维护一个 Session，这个 Session 会依赖客户端「定时心跳」来维持连接。</strong></p><p>如果 Zookeeper 长时间收不到客户端的心跳，就认为这个 Session 过期了，也会把这个临时节点删除。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101445733.png" alt="图片"></p><p>同样地，基于此问题，我们也讨论一下 GC 问题对 Zookeeper 的锁有何影响：</p><ol><li>客户端 1 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 发生长时间 GC</li><li>客户端 1 无法给 Zookeeper 发送心跳，Zookeeper 把临时节点「删除」</li><li>客户端 2 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 GC 结束，它仍然认为自己持有锁（冲突）</li></ol><p>可见，即使是使用 Zookeeper，也无法保证进程 GC、网络延迟异常场景下的安全性。</p><p><strong>这就是前面 Redis 作者在反驳的文章中提到的：如果客户端已经拿到了锁，但客户端与锁服务器发生「失联」（例如 GC），那不止 Redlock 有问题，其它锁服务都有类似的问题，Zookeeper 也是一样！</strong></p><p>所以，这里我们就能得出结论了：<strong>一个分布式锁，在极端情况下，不一定是安全的。</strong></p><p>如果你的业务数据非常敏感，在使用分布式锁时，一定要注意这个问题，不能假设分布式锁 100% 安全。</p><p>好，现在我们来总结一下 Zookeeper 在使用分布式锁时优劣：</p><p>Zookeeper 的优点：</p><ol><li>不需要考虑锁的过期时间</li><li>watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁</li></ol><p>但它的劣势是：</p><ol><li>性能不如 Redis</li><li>部署和运维成本高</li><li>客户端与 Zookeeper 的长时间失联，锁被释放问题</li></ol><h1 id="我对分布式锁的理解"><a href="#我对分布式锁的理解" class="headerlink" title="我对分布式锁的理解"></a>我对分布式锁的理解</h1><p>好了，前面详细介绍了基于 Redis 的 Redlock 和 Zookeeper 实现的分布锁，在各种异常情况下的安全性问题，下面我想和你聊一聊我的看法，仅供参考，不喜勿喷。</p><p><strong>1) 到底要不要用 Redlock？</strong></p><p>前面也分析了，Redlock 只有建立在「时钟正确」的前提下，才能正常工作，如果你可以保证这个前提，那么可以拿来使用。</p><p>但保证时钟正确，我认为并不是你想的那么简单就能做到的。</p><p><strong>第一，从硬件角度来说</strong>，时钟发生偏移是时有发生，无法避免。</p><p>例如，CPU 温度、机器负载、芯片材料都是有可能导致时钟发生偏移的。</p><p><strong>第二，从我的工作经历来说</strong>，曾经就遇到过时钟错误、运维暴力修改时钟的情况发生，进而影响了系统的正确性，所以，人为错误也是很难完全避免的。</p><p>所以，我对 Redlock 的个人看法是，尽量不用它，而且它的性能不如单机版 Redis，部署成本也高，我还是会优先考虑使用主从+ 哨兵的模式 实现分布式锁。</p><p>那正确性如何保证呢？第二点给你答案。</p><p><strong>2) 如何正确使用分布式锁？</strong></p><p>在分析 Martin 观点时，它提到了 fecing token 的方案，给我了很大的启发，虽然这种方案有很大的局限性，但对于保证「正确性」的场景，是一个非常好的思路。</p><p>所以，我们可以把这两者结合起来用：</p><p><strong>1、使用分布式锁，在上层完成「互斥」目的，虽然极端情况下锁会失效，但它可以最大程度把并发请求阻挡在最上层，减轻操作资源层的压力。</strong></p><p><strong>2、但对于要求数据绝对正确的业务，在资源层一定要做好「兜底」，设计思路可以借鉴 fecing token 的方案来做。</strong></p><p>两种思路结合，我认为对于大多数业务场景，已经可以满足要求了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，总结一下。</p><p>这篇文章，我们主要探讨了基于 Redis 实现的分布式锁，究竟是否安全这个问题。</p><p>从最简单分布式锁的实现，到处理各种异常场景，再到引出 Redlock，以及两个分布式专家的辩论，得出了 Redlock 的适用场景。</p><p>最后，我们还对比了 Zookeeper 在做分布式锁时，可能会遇到的问题，以及与 Redis 的差异。</p><p>这里我把这些内容总结成了思维导图，方便你理解。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640.png" alt="图片"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇文章的信息量其实是非常大的，我觉得应该把分布锁的问题，彻底讲清楚了。</p><p>如果你没有理解，我建议你多读几遍，并在脑海中构建各种假定的场景，反复思辨。</p><p>在写这篇文章时，我又重新研读了两位大神关于 Redlock 争辩的这两篇文章，可谓是是收获满满，在这里也分享一些心得给你。</p><p>1、在分布式系统环境下，看似完美的设计方案，可能并不是那么「严丝合缝」，如果稍加推敲，就会发现各种问题。所以，在思考分布式系统问题时，一定要<strong>谨慎再谨慎</strong>。</p><p>2、从 Redlock 的争辩中，我们不要过多关注对错，而是要多学习大神的思考方式，以及对一个问题严格审查的严谨精神。</p><p>最后，用 Martin 在对于 Redlock 争论过后，写下的感悟来结尾：</p><p>“<strong>前人已经为我们创造出了许多伟大的成果：站在巨人的肩膀上，我们可以才得以构建更好的软件。无论如何，通过争论和检查它们是否经得起别人的详细审查，这是学习过程的一部分。但目标应该是获取知识，而不是为了说服别人，让别人相信你是对的。有时候，那只是意味着停下来，好好地想一想。</strong>”</p><p>共勉。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie&amp;session&amp;token</title>
    <link href="/2020/03/02/Cookie&amp;Session&amp;Token/"/>
    <url>/2020/03/02/Cookie&amp;Session&amp;Token/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>1991 年 HTTP 0.9 诞生了，当时只是为了满足大家浏览 web 文档的要求 ，所以只有 GET 请求，浏览完了就走了，两个连接之间是没有任何联系的，这也是 HTTP 为无状态的原因，因为它诞生之初就没有这个需求。</p><p>但随着交互式 Web 的兴起（所谓交互式就是你不光可以浏览，还可以登录，发评论，购物等用户操作的行为），单纯地浏览 web 已经无法满足人们的要求，比如随着网上购物的兴起，需要记录用户的购物车记录，就需要有一个机制记录每个连接的关系，这样我们就知道加入购物车的商品到底属于谁了，于是 Cookie 就诞生了。</p><blockquote><p>Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行 Session 跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。</p></blockquote><p>工作机制如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101127316" alt="图片">img</p><p>以加入购物车为例，每次浏览器请求后 server 都会将本次商品 id 存储在 Cookie 中返回给客户端，客户端会将 Cookie 保存在本地，下一次再将上次保存在本地的 Cookie 传给 server 就行了，这样每个 Cookie 都保存着用户的商品 id，购买记录也就不会丢失了</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101133075" alt="图片">img</p><p>仔细观察上图相信你不难发现随着购物车内的商品越来越多，每次请求的 cookie 也越来越大，这对每个请求来说是一个很大的负担，我只是想将一个商品加入购买车，为何要将历史的商品记录也一起返回给 server ？购物车信息其实已经记录在 server 了，浏览器这样的操作岂不是多此一举？怎么改进呢</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>仔细考虑下，由于用户的购物车信息都会保存在 Server 中，所以在 Cookie 里只要保存能识别用户身份的信息，知道是谁发起了加入购物车操作即可，这样每次请求后只要在 Cookie 里带上用户的身份信息，请求体里也只要带上本次加入购物车的商品 id，大大减少了 cookie 的体积大小，我们把这种能识别哪个请求由哪个用户发起的机制称为 Session（会话机制），生成的能识别用户身份信息的字符串称为 sessionId，它的工作机制如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101138792" alt="图片"></p><ol><li>首先用户登录，server 会为用户生成一个 session，为其分配唯一的 sessionId，这个 sessionId 是与某个用户绑定的，也就是说根据此 sessionid（假设为 abc） 可以查询到它到底是哪个用户，然后将此 sessionid 通过 cookie 传给浏览器</li><li>之后浏览器的每次添加购物车请求中只要在 cookie 里带上 sessionId=abc 这一个键值对即可，server 根据 sessionId 找到它对应的用户后，把传过来的商品 id 保存到 server 中对应用户的购物车即可</li></ol><p>可以看到通过这种方式再也不需要在 cookie 里传所有的购物车的商品 id 了，大大减轻了请求的负担！</p><p>另外通过上文不难观察出 <strong>cookie 是存储在 client 的，而 session 保存在 server</strong>，sessionId 需要借助 cookie 的传递才有意义。</p><h3 id="session-的痛点"><a href="#session-的痛点" class="headerlink" title="session 的痛点"></a>session 的痛点</h3><p>看起来通过  cookie + session 的方式是解决了问题， 但是我们忽略了一个问题，上述情况能正常工作是因为我们假设 server 是单机工作的，但实际在生产上，为了保障高可用，一般服务器至少需要两台机器，通过负载均衡的方式来决定到底请求该打到哪台机器上。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101154301" alt="图片">balance</p><p><strong>如图示：客户端请求后，由负载均衡器（如 Nginx）来决定到底打到哪台机器</strong></p><p>假设登录请求打到了 A 机器，A 机器生成了 session 并在 cookie 里添加 sessionId 返回给了浏览器，那么问题来了：下次添加购物车时如果请求打到了 B 或者 C，由于 session 是在 A 机器生成的，此时的 B,C 是找不到 session 的，那么就会发生无法添加购物车的错误，就得重新登录了，此时请问该怎么办。主要有以下三种方式</p><blockquote><p>1、session 复制</p></blockquote><p>A 生成 session 后复制到 B, C，这样每台机器都有一份 session，无论添加购物车的请求打到哪台机器，由于 session 都能找到，故不会有问题</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101201725" alt="图片">balance (1)</p><p>这种方式虽然可行，但缺点也很明显：</p><ol><li>同一样的一份 session 保存了多份，数据冗余</li><li>如果节点少还好，但如果节点多的话，特别是像阿里，微信这种由于 DAU 上亿，可能需要部署成千上万台机器，这样节点增多复制造成的性能消耗也会很大。</li></ol><blockquote><p>2、session 粘连</p></blockquote><p>这种方式是让每个客户端请求只打到固定的一台机器上，比如浏览器登录请求打到 A 机器后，后续所有的添加购物车请求也都打到 A 机器上，Nginx 的 sticky 模块可以支持这种方式，支持按 ip 或 cookie 粘连等等，如按 ip 粘连方式如下</p><figure class="highlight roboconf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs roboconf">upstream tomcats &#123;<br>  <span class="hljs-attribute">ip_hash;</span><br><span class="hljs-attribute">  server 10.1.1.107</span>:88;<br>  <span class="hljs-attribute">server 10.1.1.132</span>:80;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101207746" alt="图片">img</p><p>这样的话每个 client 请求到达 Nginx 后，只要它的 ip 不变，根据 ip hash 算出来的值会打到固定的机器上，也就不存在 session 找不到的问题了，当然不难看出这种方式缺点也是很明显，对应的机器挂了怎么办？</p><blockquote><p>3、session 共享</p></blockquote><p>这种方式也是目前各大公司普遍采用的方案，将 session 保存在 redis，memcached 等中间件中，请求到来时，各个机器去这些中间件取一下 session 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101212174" alt="图片">img</p><p>缺点其实也不难发现，就是每个请求都要去 redis 取一下 session，多了一次内部连接，消耗了一点性能，另外为了保证 redis 的高可用，必须做集群，当然了对于大公司来说, redis 集群基本都会部署，所以这方案可以说是大公司的首选了。</p><h3 id="Token：no-session"><a href="#Token：no-session" class="headerlink" title="Token：no session!"></a>Token：no session!</h3><p>通过上文分析我们知道通过在服务端共享 session 的方式可以完成用户的身份定位，但是不难发现也有一个小小的瑕疵：搞个校验机制我还得搭个 redis 集群？大厂确实 redis 用得比较普遍，但对于小厂来说可能它的业务量还未达到用 redis 的程度，所以有没有其他不用 server 存储 session 的用户身份校验机制呢，这就是我们今天要介绍的主角：token。</p><p>首先请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地，之后向 server 请求时在请求头带上此 token 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101217167" alt="图片">img</p><p>相信大家看了上图会发现存在两个问题</p><p>1、 token 只存储在浏览器中，服务端却没有存储，这样的话我随便搞个 token 传给 server 也行？</p><p>答：server 会有一套校验机制，校验这个 token 是否合法。</p><p>2、怎么不像 session 那样根据 sessionId 找到 userid 呢，这样的话怎么知道是哪个用户？</p><p>答：token 本身携带 uid 信息</p><p>第一个问题，如何校验 token 呢？我们可以借鉴 HTTPS 的签名机制来校验。先来看 jwt token 的组成部分</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101223022" alt="图片">img</p><p>可以看到 token 主要由三部分组成</p><ol><li>header：指定了签名算法</li><li>payload：可以指定用户 id，过期时间等非敏感数据</li><li>Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。</li></ol><p>当 server 收到浏览器传过来的 token 时，它会首先取出 token 中的 header + payload，根据密钥生成签名，然后再与 token 中的签名比对，如果成功则说明签名是合法的，即 token 是合法的。而且你会发现 payload 中存有我们的 userId，所以拿到 token 后直接在 payload 中就可获取 userid，避免了像 session 那样要从 redis 去取的开销</p><p><strong>画外音：header, payload 实际上是以 base64 的形式存在的，文中为了描述方便，省去了这一步。</strong></p><p>你会发现这种方式确实很妙，只要 server 保证密钥不泄露，那么生成的 token 就是安全的，因为如果伪造 token 的话在签名验证环节是无法通过的，就此即可判定 token 非法。</p><p>可以看到通过这种方式有效地避免了 token 必须保存在 server 的弊端，实现了分布式存储，不过需要注意的是，token 一旦由 server 生成，它就是有效的，直到过期，无法让 token 失效，除非在 server 为 token 设立一个黑名单，在校验 token 前先过一遍此黑名单，如果在黑名单里则此  token 失效，但一旦这样做的话，那就意味着黑名单就必须保存在 server，这又回到了 session 的模式，那直接用 session 不香吗。所以一般的做法是当客户端登出要让 token 失效时，直接在本地移除 token 即可，下次登录重新生成 token 就好。</p><p>另外需要注意的是 token 一般是放在 header 的 Authorization 自定义头里，不是放在 Cookie 里的，这主要是为了解决跨域不能共享 Cookie 的问题 （下文详述）</p><h3 id="Cookie-与-Token-的简单总结"><a href="#Cookie-与-Token-的简单总结" class="headerlink" title="Cookie 与 Token 的简单总结"></a>Cookie 与 Token 的简单总结</h3><blockquote><p>Cookie 有哪些局限性？</p></blockquote><p>1、 Cookie 跨站是不能共享的，这样的话如果你要实现多应用（多系统）的单点登录（SSO），使用 Cookie 来做需要的话就很困难了（要用比较复杂的 trick 来实现，有兴趣的话可以看文末参考链接）</p><p><strong>画外音: 所谓单点登录，是指在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</strong></p><p>但如果用 token 来实现 SSO 会非常简单，如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101228882" alt="图片">img</p><p>只要在 header 中的 authorize 字段（或其他自定义）加上 token 即可完成所有跨域站点的认证。</p><p>2、 在移动端原生请求是没有 cookie 之说的，而 sessionid 依赖于 cookie，sessionid 就不能用 cookie 来传了，如果用 token 的话，由于它是随着 header 的 authoriize 传过来的，也就不存在此问题，换句话说token 天生支持移动平台，可扩展性好</p><p>综上所述，token 具有存储实现简单，扩展性好这些特点。</p><blockquote><p>token 有哪些缺点</p></blockquote><p>那有人就问了，既然 token 这么好，那为什么各个大公司几乎都采用共享 session 的方式呢，可能很多人是第一次听到 token，token 不香吗? token 有以下两点劣势：</p><p>1、 token 太长了</p><p>token 是 header, payload 编码后的样式，所以一般要比 sessionId 长很多，很有可能超出 cookie 的大小限制（cookie 一般有大小限制的，如 4kb），如果你在 token 中存储的信息越长，那么 token 本身也会越长，这样的话由于你每次请求都会带上 token，对请求来是个不小的负担</p><p>2、 不太安全</p><p>网上很多文章说 token 更安全，其实不然，细心的你可能发现了，我们说 token 是存在浏览器的，再细问，存在浏览器的哪里？既然它太长放在 cookie 里可能导致 cookie 超限，那就只好放在 local storage 里，这样会造成安全隐患，因为 local storage 这类的本地存储是可以被 JS 直接读取的，另外由上文也提到，token 一旦生成无法让其失效，必须等到其过期才行，这样的话如果服务端检测到了一个安全威胁，也无法使相关的 token 失效。</p><p><strong>所以 token 更适合一次性的命令认证，设置一个比较短的有效期</strong></p><h3 id="误解-Cookie-相比-token-更不安全，比如-CSRF-攻击"><a href="#误解-Cookie-相比-token-更不安全，比如-CSRF-攻击" class="headerlink" title="误解: Cookie 相比 token 更不安全，比如 CSRF 攻击"></a>误解: Cookie 相比 token 更不安全，比如 CSRF 攻击</h3><p>首先我们需要解释下 CSRF 攻击是怎么回事</p><p>攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过（cookie 里带来 sessionId 等身份认证的信息），所以被访问的网站会认为是真正的用户操作而去运行。</p><p>比如用户登录了某银行网站（假设为 **<a href="http://www.examplebank.com/**%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BD%AC%E8%B4%A6%E5%9C%B0%E5%9D%80%E4%B8%BA">http://www.examplebank.com/**，并且转账地址为</a> <strong><a href="http://www.examplebank.com/withdraw?amount=1000&amp;transferTo=PayeeName">http://www.examplebank.com/withdraw?amount=1000&amp;transferTo=PayeeName</a></strong>），登录后 cookie 里会包含登录用户的 sessionid，攻击者可以在另一个网站上放置如下代码</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-params">&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice<span class="hljs-variable">&amp;amount</span>=<span class="hljs-number">1000</span><span class="hljs-variable">&amp;for</span>=Badman&quot;&gt;</span><br></code></pre></div></td></tr></table></figure><p>那么如果正常的用户误点了上面这张图片，由于相同域名的请求会自动带上 cookie，而 cookie 里带有正常登录用户的 sessionid，类似上面这样的转账操作在 server 就会成功，会造成极大的安全风险</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101238289" alt="图片">csrf 示意图</p><p>CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 cookie 都会被自动带上，这个是浏览器的机制决定的，所以很多人据此认定 cookie 不安全。</p><p>使用 token 确实避免了CSRF 的问题，但正如上文所述，由于 token 保存在 local storage，它会被 JS 读取，<strong>从存储角度来看</strong>也不安全（实际上防护 CSRF 攻击的正确方式是用 CSRF token）</p><p>所以不管是 cookie 还是 token，从存储角度来看其实都不安全，都有暴露的风险，我们所说的安全更多的是强调传输中的安全，可以用 HTTPS 协议来传输， 这样的话请求头都能被加密，也就保证了传输中的安全。</p><p>其实我们把 cookie 和 token 比较本身就不合理，一个是存储方式，一个是验证方式，正确的比较应该是 session vs token。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>session 和 token 本质上是没有区别的，都是对用户身份的认证机制，只是他们实现的校验机制不一样而已（一个保存在 server，通过在 redis 等中间件获取来校验，一个保存在 client，通过签名校验的方式来校验），多数场景上使用 session 会更合理，但如果在单点登录，一次性命令认证上使用 token 会更合适，最好在不同的业务场景中合理选型，才能达到事半功倍的效果。</p><p>巨人的肩膀</p><ul><li>Cookie Session跨站无法共享问题(单点登录解决方案)：<a href="https://blog.csdn.net/wtopps/article/details/75040224">https://blog.csdn.net/wtopps/article/details/75040224</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Communication protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程基础(下)</title>
    <link href="/2019/12/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%8B)/"/>
    <url>/2019/12/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很多博客或者视频每次都会说“实现”多线程的方式有3种：Thread、Runnable和Callable，其实我个人是不太认同这种说法的，Thread是<strong>线程类</strong>，另外两个是<strong>任务类</strong>，不是一类事物啊！</p><p>也即是说，JDK看似提供了很多和多线程相关的类，实际上<strong>有且仅有Thread类能通过start0()方法向操作系统申请线程资源（本地方法）。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1597586134875-8b46bb15-50a0-488c-b703-61f1b02d0909-20210923215627617.png" alt="img"></p><p>并且，在JVM的设定中Java的线程和操作系统的线程是<strong>一一对应</strong>的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1597563841354-7196fcb8-683e-42fd-88d9-eb1cf5ee0f08-20210923215636217.png" alt="img"></p><p><strong>而Runnable和Callable如果没有线程或线程池去执行它们，就什么也不是，只是一坨普通的代码。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608708324821-680b47cf-1db5-45e9-a0cf-a59ef3023880-20210923215642589.png" alt="img"></p><p>注意，当Thread#start()向操作系统申请线程后，线程的执行入口始终是Thread#run()，而不是Runnable/Callable的run()</p><p>到这里，我们帮大家扫清了一些繁杂的概念，<strong>只需记住Java创建多线程只有一种方式：Thread！</strong>无论是直接通过new Thread().start()，或是通过线程池，底层都是Thread在向操作系统申请资源，而且新线程启动后，会找到原来的Thread，从它的run()方法开始执行。</p><h1 id="如何让多线程执行我们的任务？"><a href="#如何让多线程执行我们的任务？" class="headerlink" title="如何让多线程执行我们的任务？"></a>如何让多线程执行我们的任务？</h1><p>线程创建以后，如何让它帮我们执行任务呢？一般来说，可以把待执行任务“塞到”3个地方：</p><ul><li>重写Thread的run()，把任务直接塞到Thread内部，执行路径是：JVM线程–&gt;Thread#run()</li><li>实现Runnable，然后通过Thread构造器传入Runnable实例，执行路径是：JVM线程–&gt;Thread#run()–&gt;target.run()</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1622955712025-8f779783-f665-447f-a87a-38a18345b6c4-20210923215648295.png" alt="img"></p><ul><li>把任务塞到Runnable/Callable，丢到线程池里，屏蔽内部细节，省心省力</li></ul><p><strong>为什么要塞到这3个地方呢？因为当初在设计这些类时，其实就规划好了线程的执行路径，我们只要把待执行任务埋伏到指定位置就一定能碰上啦！</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncAndWaitTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 方式1：重写Thread#run()</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;========&gt;正在执行&quot;</span>);<br>            &#125;<br>        &#125;;<br>        thread.start();<br><br>        <span class="hljs-comment">// 方式2：构造方法传入Runnable实例</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;========&gt;正在执行&quot;</span>);<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 方式3：线程池 + Callable/Runnable，这里以Callble为例</span><br>        ExecutorService executorService = Executors.newSingleThreadExecutor();<br>        Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;========&gt;正在执行&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">3</span> * <span class="hljs-number">1000L</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>        &#125;);<br>        String result = submit.get();<br>        System.out.println(<span class="hljs-string">&quot;result=======&gt;&quot;</span> + result);<br>        <span class="hljs-comment">// 关闭线程池</span><br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1597564427871-eb185e43-a08a-4a98-a13e-e2a70bcf6bbd-20210923215705510.gif" alt="img"></p><p>上面介绍了多线程执行任务的3种方式（Runnable/Callable/线程池），我们再另外介绍一种初学者可能觉得有点绕，但源码里经常会见到的写法，算是Runnable的变种写法<strong>：</strong></p><p>把new Thread().start()隐藏到某个类的内部</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1598166618379-8f8944e7-225d-4517-9c62-78d513a9c38d-20210923215714201.png" alt="img"></p><p>重点关注Worker到底是什么，以及begin()内部做了什么。不熟悉的同学不妨自己写一下，琢磨一下。<strong>我们马上会在JDK的某个类中看到类似的写法！</strong></p><p>总之，在我心里Thread的Level要比Runnbale、Callable高一级。看到很多人把它们混在一起，不禁想起一句话：</p><p>萧某大好男儿，竟和你这种人齐名！ — 《天龙八部》乔峰</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1631540140685-22fcba24-f53a-4ec9-bafd-bc2ab3776471-20210923215722765.jpeg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态代理&amp;动态代理</title>
    <link href="/2019/12/08/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&amp;%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2019/12/08/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&amp;%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a><strong>静态代理</strong></h2><p>假设现在项目经理有一个需求：在项目现有所有类的方法前后打印日志。</p><p>你如何在<strong>不修改已有代码的前提下</strong>，完成这个需求？</p><p>我首先想到的是静态代理。具体做法是：</p><p>1.为现有的每一个类都编写一个<strong>对应的</strong>代理类，并且让它实现和目标类相同的接口（假设都有）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-001c5db900d8785d47c1a5a0c6f32762_1440w-20210902214027681.jpg" alt="img"></p><p>2.在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是说，<strong>代理对象 = 增强代码 + 目标对象（原对象）</strong>。有了代理对象后，就不用原对象了</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-e302487f952bdf8e284afc0d8d6a770b_1440w-20210902214033494.jpg" alt="img"></p><p><strong>静态代理的缺陷</strong></p><p>程序员要手动为每一个目标类编写对应的代理类。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？</p><p><strong>复习对象的创建</strong></p><p>很多初学Java的朋友眼中创建对象的过程</p><p>;<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-9cd31ab516bd967e1b8e68736931f8ba_1440w-20210903091359016.jpg" alt="img"></p><p>实际上可以换个角度，也说得通</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-eddc430b991c58039dfc79dd6f3139cc_1440w-20210903091410216.jpg" alt="img"></p><p>所谓的Class对象，是Class类的实例，而Class类是描述所有类的，比如Person类，Student类</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-c9bf695b1b9d2a0ae01cf92501492159_1440w-20210903091424896.jpg" alt="img"></p><p>可以看出，要创建一个实例，最关键的就是<strong>得到对应的Class对象。</strong>只不过对于初学者来说，new这个关键字配合构造方法，实在太好用了，底层隐藏了太多细节，一句 Person p = new Person();直接把对象返回给你了。我自己刚开始学Java时，也没意识到Class对象的存在。</p><p>分析到这里，貌似有了思路：</p><p><strong>能否不写代理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。</strong></p><p>Class对象包含了一个类的所有信息，比如构造器、方法、字段等。如果我们不写代理类，这些信息从哪获取呢？苦思冥想，突然灵光一现：代理类和目标类理应实现同一组接口。<strong>之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。</strong>还是上面这幅图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-e302487f952bdf8e284afc0d8d6a770b_1440w-20210903091438566.jpg" alt="img"></p><p>所以，可以这样说：接口拥有代理对象和目标对象共同的类信息。所以，我们可以从接口那得到理应由代理类提供的信息。但是别忘了，接口是无法创建对象的，怎么办？</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy，所以我们先聊它。</p><p>Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象。</p><p>用通俗的话说，getProxyClass()这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。打个比方，一个大内太监（接口Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小DD（构造器）…（这到底是道德の沦丧，还是人性的扭曲，欢迎走进动态代理）</p><p>所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-d187a82b1eb9c088fe60327828ee63aa_1440w-20210903091450435.jpg" alt="img"></p><p>大体思路</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-28223a1c03c1800052a5dfe4e6cb8c53_1440w-20210903091507755.jpg" alt="img"></p><p>静态代理</p><p><img src="https://pica.zhimg.com/80/v2-ba3d9206f341be466f18afbdd938a3b3_1440w.jpg?source=1940ef5c" alt="img"></p><p>动态代理</p><p>所以，按我理解，Proxy.getProxyClass()这个方法的本质就是：<strong>以Class造Class。</strong></p><p>有了Class对象，就很好办了，具体看代码：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-6b091b6d41bae1f88ba74a510acb24b1_1440w-20210903091542536.jpg" alt="img"></p><p>完美。</p><p>根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代理对象的方法，最终都会调用InvocationHandler的invoke()方法：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-92610586e77cf71ba5ce89087de52ff1_1440w-20210903091554306.jpg" alt="img"></p><p>怎么做到的呢？</p><p>上面不是说了吗，根据代理Class的构造器创建对象时，需要传入InvocationHandler。<strong>通过构造器传入一个引用，那么必然有个成员变量去接收。</strong>没错，代理对象的内部确实有个成员变量invocationHandler，而且代理对象的每个方法内部都会调用handler.invoke()！InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代理这么直接。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-b5fc8b279a6152889afdfedbb0f611cc_1440w-20210903091605600.jpg" alt="img"></p><p>大家仔细看上图右侧的动态代理，我在invocationHandler的invoke()方法中并没有写目标对象。因为一开始invocationHandler的invoke()里确实没有目标对象，需要我们手动new。<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-88147b81ee9342015374159b2671320b_1440w-20210903091623203.jpg" alt="img"></p><p>但这种写法不够优雅，属于硬编码。我这次代理A对象，下次想代理B对象还要进来改invoke()方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>CalculatorImpl target = <span class="hljs-keyword">new</span> CalculatorImpl();<br>                <span class="hljs-comment">//传入目标对象</span><br>                <span class="hljs-comment">//目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法</span><br>Calculator calculatorProxy = (Calculator) getProxy(target);<br>calculatorProxy.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>calculatorProxy.subtract(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object target)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">//参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口</span><br>Class proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());<br>Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);<br>Object proxy = constructor.newInstance(<span class="hljs-keyword">new</span> InvocationHandler() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法开始执行...&quot;</span>);<br>Object result = method.invoke(target, args);<br>System.out.println(result);<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法执行结束...&quot;</span>);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;);<br><span class="hljs-keyword">return</span> proxy;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你把实例传进来，getProxy()都能给你返回对应的代理对象。就这样，我们完美地跳过了代理类，直接创建了代理对象！</p><p>不过实际编程中，一般不用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理Class对象的过程都帮你隐藏：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>CalculatorImpl target = <span class="hljs-keyword">new</span> CalculatorImpl();<br>Calculator calculatorProxy = (Calculator) getProxy(target);<br>calculatorProxy.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>calculatorProxy.subtract(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object target)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Object proxy = Proxy.newProxyInstance(<br>target.getClass().getClassLoader(),<span class="hljs-comment">/*类加载器*/</span><br>target.getClass().getInterfaces(),<span class="hljs-comment">/*让代理对象和目标对象实现相同接口*/</span><br><span class="hljs-keyword">new</span> InvocationHandler()&#123;<span class="hljs-comment">/*代理对象的方法最终都会被JVM导向它的invoke方法*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法开始执行...&quot;</span>);<br>Object result = method.invoke(target, args);<br>System.out.println(result);<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法执行结束...&quot;</span>);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br>);<br><span class="hljs-keyword">return</span> proxy;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在，我想应该能看懂动态代理了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-6aacbe1e9df4fe982a68fe142401952e_1440w-20210903091644194.jpg" alt="img"></p><p>最后讨论一下代理对象是什么类型。</p><p>首先，请区分两个概念：代理Class对象和代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-bb82bd129d63f77265f51b2209159269_1440w-20210903091702198.jpg" alt="img"></p><p>单从名字看，代理Class和Calculator的接口确实相去甚远，但是我们却能将代理对象赋值给接口类型：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-e869e67fc4fbc708b793ff6ea6e2c012_1440w-20210903091722724.jpg" alt="img"></p><p>千万别觉得名字奇怪，就怀疑它不能用接口接收，只要实现该接口就是该类型。</p><blockquote><p>代理对象的本质就是：和目标对象实现相同接口的实例。代理Class可以叫任何名字，whatever，只要它实现某个接口，就能成为该接口类型。</p></blockquote><p>;<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-91d716b1a95099ad364233de91fca7a3_1440w-20210903091736091.jpg" alt="img"></p><p>我写了一个MyProxy类，那么它的Class名字必然叫MyProxy。<strong>但这和能否赋值给接口没有任何关系。</strong>由于它实现了Serializable和Collection，所以myProxy（代理实例）<strong>同时</strong>是这两个接口的类型。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>我想了个很骚的比喻，希望能解释清楚：</p><p>接口Class对象是大内太监，里面的方法和字段比做他的一身武艺，但是他没有小DD（构造器），所以不能new实例。一身武艺后继无人。</p><p>那怎么办呢？</p><p>正常途径（implements）：</p><p>写一个类，实现该接口。这个就相当于大街上拉了一个人，认他做干爹。一身武艺传给他，只是比他干爹多了小DD，可以new实例。</p><p>非正常途径（动态代理）：</p><p>通过妙手圣医Proxy的克隆大法（Proxy.getProxyClass()），克隆一个Class，但是有小DD。所以这个克隆人Class可以创建实例，也就是代理对象。</p><p>代理Class其实就是附有构造器的接口Class，一样的类结构信息，却能创建实例。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-33094b28321ab388bb0db46608eae74a_1440w-20210903091759099.jpg" alt="img">JDK动态代理生成的实例</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-b99009ee292273a56ab483170b2e20aa_1440w-20210903091819161.jpg" alt="img">CGLib动态代理生成的实例</p><p>如果说继承的父类是亲爹（只有一个），那么实现的接口是干爹（可以有多个）。</p><p>实现接口是一个类认干爹的过程。接口无法创建对象，但实现该接口的类可以。</p><p>比如 </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">class Student extends Person implements A, B<br></code></pre></div></td></tr></table></figure><p>这个类new一个实例出来，你问它：你爸爸是谁啊？它会告诉你：我只有一个爸爸Person。</p><p>但是student instanceof A interface，或者student instanceof B interface，它会告诉你两个都是它干爹（true），都可以用来接收它。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-1c36d27a6a2a49a266a7fc2ed457e532_1440w-20210903091835896.jpg" alt="img"></p><p>然而，凡是有利必有弊。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-991ea99b9038d52875ff6ba57e9032de_1440w-20210903091849332.jpg" alt="img"></p><p>也就是说，动态代理生成的代理对象，最终都可以用接口接收，和目标对象一起形成了多态，可以随意切换展示不同的功能。但是切换的同时，只能使用该接口定义的方法。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java动态代理之InvocationHandler</title>
    <link href="/2019/12/08/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BInvocationHandler/"/>
    <url>/2019/12/08/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BInvocationHandler/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网上关于Java的动态代理，Proxy和InvocationHandler这些概念有讲解得非常高深的文章。其实这些概念没有那么复杂。现在咱们通过一个最简单的例子认识什么是InvocationHandler。值得一提的是，InvocationHandler在Spring框架实现中被广泛使用，这意味着我们吃透了InvocationHandler，就为将来的Spring源码学习打下一个坚实的基础。</p><p>开发一个接口，包含两个方法，可以向指定的人问候“你好”或者“再见”。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHello</span> </span>&#123;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span></span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>创建一个简单的类，实现这个IHello接口。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helloimplements</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHello</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot; GoodBye!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>消费这个实现类，迄今为止没什么特别的。</p><p>现在假设我们接到了这个需求：老板要求在该实现类每次问候某人时，必须把问候的细节记录到日志文件里。为了简单起见，我们在问候前打印下面的一行语句来模拟日志记录的动作。</p><p>System.out.println(“问候之前的日志记录…”);</p><p>您也许会说，这还不简单？直接修改Helloimplements的对应方法，把这行日志插入到对应方法即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183109.png"></p><p>然而，老板的要求是：不允许你修改原来的Helloimplements类。在现实场景中，Helloimplements可能是第三方的jar包提供的，我们没有办法修改代码。</p><p>您也许会说，我们可以用设计模式里的代理模式，即创建一个新的Java类作为代理类，同样实现IHello接口，然后将Helloimplements类的实例传入代理类。我们虽然被要求不允许修改Helloimplements的代码，但是可以把日志记录代码写在代理类里。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHello</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> IHello iHello;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImpl</span><span class="hljs-params">(IHello impl)</span></span>&#123;<br><br>  <span class="hljs-keyword">this</span>.iHello = impl;<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>    System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br><br>    iHello.sayHello(name);<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>     System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br><br>     iHello.sayGoogBye(name);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br><br>     Helloimplements hello = <span class="hljs-keyword">new</span> Helloimplements();<br><br>     StaticProxy proxy = <span class="hljs-keyword">new</span> StaticProxy();<br><br>     proxy.setImpl(hello);<br><br>     proxy.sayHello(<span class="hljs-string">&quot;Jerry&quot;</span>);<br><br>  &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种做法能够实现需求：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183127.png"></p><p>下面我们再看如何用InvocationHandler实现同样的效果。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">InvocationHandler是一个JDK提供的标准接口。看下面的代码：<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynaProxyHello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object delegate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">bind</span><span class="hljs-params">(Object delegate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.delegate = delegate;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>        <span class="hljs-keyword">this</span>.delegate.getClass().getClassLoader(), <span class="hljs-keyword">this</span>.delegate<br>        .getClass().getInterfaces(), <span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br>            <span class="hljs-comment">// JVM通过这条语句执行原来的方法(反射机制)</span><br>            result = method.invoke(<span class="hljs-keyword">this</span>.delegate, args);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>上面代码里的bind方法很想我之前代理类StaticProxy的setImpl方法，只不过这个bind方法的输入参数类型更加通用。日志记录的代码写在方法invoke里。</p><p>看看如何使用：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>    DynaProxyHello helloproxy = <span class="hljs-keyword">new</span> DynaProxyHello();<br>    Helloimplements hello = <span class="hljs-keyword">new</span> Helloimplements();<br>    IHello ihello = (IHello) helloproxy.bind(hello);<br>    ihello.sayHello(<span class="hljs-string">&quot;Jerry&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行效果和StaticProxy那种解决方案完全一致。</p><p>咱们先来调试一下。当bind方法执行时，方法Proxy.newProxyInstance被调用，Helloimplements类的实例被传入。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183142.png"></p><p>我们在调试器里观察IHello ihello = (IHello) helloproxy.bind(hello)这行语句返回的ihello变量。虽然它的静态类型是IHello，但请注意，在调试器里观察它的实际类型，并不是Helloimplements的实例，而是JVM给我们加过工的，包含了我们在invoke方法里手写的那行日志记录代码。这个ihello类型为$Proxy0。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183155.png"></p><p>当这个被JVM加过工的变量的sayHello方法被调用时，JVM自动将调用转交到DynaProxyHello.invoke去：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183208.png"></p><p>于是，在invoke方法里，我们手写的日志记录代码被执行，然后通过Java反射执行原始的sayHello代码。</p><p>有的朋友可能会问，你这个InvocationHandler看起来比静态代理StaticProxy还复杂啊？有什么好处？</p><p>假设老板的需求又变了，在调用问候和说再见的方法里，要使用不同的日志记录策略。</p><p>看看用InvocationHandler如何优雅实现吧：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/20210902183221.png"></p><p>希望这个例子能让大家对Java的动态代理之InvocationHandler有了最基本的了解。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程基础(上)</title>
    <link href="/2019/12/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%8A)/"/>
    <url>/2019/12/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="线程、进程概念与区别"><a href="#线程、进程概念与区别" class="headerlink" title="线程、进程概念与区别"></a><strong>线程、进程概念与区别</strong></h2><p><strong>进程</strong></p><p>当我们双击桌面的图标时，系统会将对应的程序加载进内存，程序将会占用一部分内存用以执行操作。进入到内存的程序即为进程（一个应用程序可以同时运行多个进程）。当使用任务管理器关闭程序时（比如QQ），系统又会将程序从内存中清除，此时进程结束。</p><p>可以理解为：<strong>进程指的是占用一定内存的程序。</strong>当内存中的程序被清除，进程即结束。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-fd0f10c0230ac832152cdbd3026721a7_1440w-20210923215102481.jpg" alt="img">程序要运行，必须先加载到内存中</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-b0b5c7d2ceb5594cd407b6619beca690_1440w-20210923215109312.jpg" alt="img">一个应用程序可以同时运行多个进程</p><p><strong>线程</strong></p><p>线程是进程中的一个执行单元，<strong>负责当前进程中程序的执行。</strong>一个进程中至少有一个线程。</p><p><strong>区别</strong></p><p>进程是资源分配的单位，线程是执行单位。早期操作系统没有线程，只有进程。但是进程非常“重”，进程间切换成本高。为了降低并发导致的进程切换成本，提出了线程。一个进程可以拥有多个线程。尽量让线程间进行切换，线程不拥有资源(或者说是很少的必要的资源)。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-81da4d74c8ec012de45ef78790cb9d12_1440w-20210923215115067.jpg" alt="img">多个线程抢占CPU执行权</p><p>需要注意的是，Java本身并不能创造线程，因为线程其实是操作系统的一种资源，它由操作系统管理。我们一般说“Java支持多线程”，指的就是Java可以调用系统资源创建多线程。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-cb16cb8f32cd9e1e47915dade7be2a79_1440w-20210923215119482.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-5e61f736b3c64331a5ca5971bfae3f20_1440w-20210923215125815.jpg" alt="img">单线程方法调用链（main)</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-89c30148f90d4713dcb5fa657b769a35_1440w-20210923215129635.jpg" alt="img">开启多线程</p><hr><p><strong>创建多线程的2种常见方式</strong></p><p>Java中有两种创建多线程的方式：</p><ul><li>方式1：继承Thread类，重写run()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// ThreadDemo1继承了Thread类，并重写run()</span><br>        ThreadDemo1 t = <span class="hljs-keyword">new</span> ThreadDemo1();<br>        <span class="hljs-comment">// 开启线程：t线程得到CPU执行权后会执行run()中的代码</span><br>        t.start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread is running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>方式2：实现Runnable接口，实现run()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// ThreadDemo2实现Runnable接口，并实现run()</span><br>        ThreadDemo2 target = <span class="hljs-keyword">new</span> ThreadDemo2();<br>        <span class="hljs-comment">// 调用Thread构造方法，传入TreadDemo2的实例对象，创建线程对象</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(target);<br>        <span class="hljs-comment">// 开启线程：t线程得到CPU执行权后会执行run()中的代码</span><br>        t.start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread is running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-86814ca28633bf2ce18b4ec6dcae40ff_1440w-20210923215136005.jpg" alt="img"></p><p>上面两段代码，相信大家早已烂熟于心，就不再赘述。这里要提一点：很多初学者，在学习多线程时被反复强调“实际编程往往只用实现Runnable接口的方式”，久而久之，便觉得Thread类干脆没啥用了，只要有Runnable接口就行。</p><p>本末倒置，实在糊涂！</p><p>Runnable里面仅定义了一个抽象方法run()</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-815dff8c5844fb04a8e88c610d5afd53_1440w-20210923215143575.jpg" alt="img"></p><p>从程序运行上来看，这个接口基本没什么卵用。之所以搞出Runnable接口，目的有两个：</p><ol><li>限定Thread构造方法的形参类型（针对方式2说的）</li><li>将run()向上抽取，做成抽象方法，让实现类去重写（为什么？）</li></ol><hr><h2 id="Thread源码浅析"><a href="#Thread源码浅析" class="headerlink" title="Thread源码浅析"></a><strong>Thread源码浅析</strong></h2><p>为了更好地理解上面两句话，先来观察Thread类的源码（截取部分）：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-comment">/* What will be run. */</span><br>    <span class="hljs-keyword">private</span> Runnable target;<br>   <br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span> </span>&#123;<br>        init(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span> </span>&#123;<br>        init(<span class="hljs-keyword">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>            target.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在理解上面源码后，我们开个上帝视角重新看一下Java创建多线程的2种方式：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-8afe4d73801e732abbc19637e1ae7919_1440w-20210923215151585.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-003e14c30d2f9b587179bf226203a990_1440w-20210923215155862.jpg" alt="img">你以为方式2中t.start()开启线程后直接调用本类的run()？NO！它要曲线救国</p><p>现在，大家应该对平时习以为常的这两段代码有了更深刻的理解。但还是不够。我们还没明白上面那两句话到底是什么意思：</p><ul><li>“限定Thread构造方法的形参类型”</li></ul><p>其实这句话，是针对创建多线程的方式2说的。方式2需要我们在创建Thread实例时传入Runnable的实现类对象：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ThreadDemo2实现Runnable接口，并实现run()</span><br>ThreadDemo2 target = <span class="hljs-keyword">new</span> ThreadDemo2();<br><span class="hljs-comment">// 调用Thread构造方法，传入TreadDemo2的实例对象，创建线程对象</span><br>Thread t = <span class="hljs-keyword">new</span> Thread(target);<br></code></pre></div></td></tr></table></figure><p>为什么要传Runnable实现类对象？因为对于方式2而言，要执行的代码并不在Thread线程本身，而是在Runnable的实现类中，所以<strong>必须传入一个对象告诉线程去哪执行。</strong>而Thread的有参构造方法的形参类型是Runnable：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span> </span>&#123;<br>    init(<span class="hljs-keyword">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以方式2要求我们写的类必须implements Runnable，这就是“限定Thread构造方法的形参类型”这句话的背后含义：</p><blockquote><p>Thread的有参构造函数<strong>只允许</strong>接受Runnable的实现类对象（包括Thread子类对象，因为观察源码，我们发现Thread也实现了Runnable）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-9791f7b18e2cfc3e3fb7bd141443a3b7_1440w-20210923215202375.jpg" alt="img">把Thread类看做大水桶，但是入口很严格，由Runnable把持。如果我们的类没有实现Runnable，就无法“塞进”Thread中</p><ul><li>将run()向上抽取，做成抽象方法，强制实现类去重写（为什么？）</li></ul><p>为什么要把run向上抽取做成抽象方法呢？这其实是由Runnable、Thread以及他们各自的实现类及子类的继承体系决定的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-6a18afe8ab8694e6821012767412dc46_1440w-20210923215207618.jpg" alt="img"></p><p>仔细观察，会有以下发现：</p><ul><li>一个线程执行，总是从start()开始，因为它才是开启线程的钥匙。线程开始后会自动调用Thread的run()</li><li>run()的本质，只是为了“包裹”需要线程执行的代码块</li></ul><p>我们实际编码时，工作量只有黄色虚线框内的代码，也就是编写Thread子类或者Runnable实现类。现在请大家专注于这两块代码：</p><p>不难发现，虽然看似有很多run()，但是线程被start()“唤醒”后，只会去调用<strong>Thread的run()<strong>，这个run()可能来自Thread类（方式2），也可能来自Thread的子类对象（方式1）。</strong>换言之，Thread类（及其子类）是线程运行的入口！</strong>没了Thread，Runnable及其实现类就是摆设。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-c681c87c96727c894fc221c0a2eabe46_1440w-20210923215213195.jpg" alt="img">Thread类及其子类永远是入口，方式2写在Runnable实现类中代码之所以能被执行到，仅仅是因为Thread的run()中调用了target.run()</p><hr><h2 id="继承Thread-VS-实现Runnable"><a href="#继承Thread-VS-实现Runnable" class="headerlink" title="继承Thread VS 实现Runnable"></a><strong>继承Thread VS 实现Runnable</strong></h2><p>文章开头已经说了，实际编程往往选择实现Runnable的方式创建多线程。为什么？其实也有点“解耦”的味道的在里面。编程界有句老话：“没有什么问题是引入第三方解决不了的”，而实现Runnable的方式，把原本线程类中的“待执行代码”挪到了Runnable实现类中，硬生生整出了“第三方”。</p><p>实现Runnable的好处恰恰在于“执行者”与“被执行者”被分离了。反观继承Thread这种方式虽然便捷，但是线程和待运行的代码在同一个类中，无法做到资源独立，也就无法共享。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/v2-11e8212648f478b469bac47ebbd44247_1440w-20210923215218446.jpg" alt="img">注意，继承Thread方式并没有做到资源共享，因为每个子类对象都有各自的一份run()，各玩各的</p><hr><p>总结一下：</p><ul><li>Runnable是功能性接口，它的作用是：</li></ul><blockquote><p>为了规范Thread有参构造的传值类型<br>将run()向上抽取，做成抽象方法，让实现类去实现</p></blockquote><ul><li>Thread是多线程的命脉，是入口，没有它多线程无从谈起。不论是方式1还是方式2，切入点都是Thread的run()，然后去执行其中代码，只是方式2更加曲折一些，最终又绕回到Runnable实现类的run()</li><li>实现Runnable的方式更常用，因为它分离了线程与资源。实际编程往往只是把Runnable写成匿名对象，不会去另外写一个类。每New一个Thread就塞一个Runnable，所以也谈不上共享。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">方式<span class="hljs-number">1</span>：<br><span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;The code waiting for Thread1&quot;</span>);<br>            &#125;<br>        &#125;.start();<br>方式<span class="hljs-number">2</span>（只用一次）：<br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;The code waiting for Thread2&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>方式<span class="hljs-number">3</span>（多个线程共享）：<br>        Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            System.out.println(<span class="hljs-string">&quot;The code waiting for Threads&quot;</span>);<br>        &#125;;<br>        Thread t1  = <span class="hljs-keyword">new</span> Thread(r);<br>        Thread t2  = <span class="hljs-keyword">new</span> Thread(r);<br>        Thread t3  = <span class="hljs-keyword">new</span> Thread(r);<br>        Thread t4  = <span class="hljs-keyword">new</span> Thread(r);<br>        Thread t5  = <span class="hljs-keyword">new</span> Thread(r);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        t4.start();<br>        t5.start();<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负数 &gt;&gt;&gt;运算符的计算过程</title>
    <link href="/2019/09/27/%E8%B4%9F%E6%95%B0%3E%3E%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/09/27/%E8%B4%9F%E6%95%B0%3E%3E%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“&gt;&gt;&gt;” 表示无符号右移,正数情况下, a &gt;&gt;&gt; b 等价于 a / Math.pow(2,b)</p><p>以 -16 &gt;&gt;&gt; 2 为例子 负16右移2位</p><ol><li>将-16转为2进制 (用补码表示负数)<ul><li>16 = 00000000 00000000 00000000 00010000</li><li>取反并补码 = 11111111 11111111 11111111 11101111 + 1 = 11111111 11111111 11111111 11110000</li><li>右移2位 = 00111111 11111111 11111111 11111100 = 10进制 1073741820</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
