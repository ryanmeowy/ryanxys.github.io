<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>标签与自由</title>
      <link href="/2025/01/07/%E6%A0%87%E7%AD%BE%E4%B8%8E%E8%87%AA%E7%94%B1-%E7%BB%A9%E4%BC%98%E4%B8%BB%E4%B9%89%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2025/01/07/%E6%A0%87%E7%AD%BE%E4%B8%8E%E8%87%AA%E7%94%B1-%E7%BB%A9%E4%BC%98%E4%B8%BB%E4%B9%89%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>最近学到一个新词, 叫做”妈人旷”，许多名校毕业生和大厂员工辞职后，喊出了“妈妈人生是旷野”的口号，倡导一种更自由、松弛的生活方式。但有趣的是，他们在个人简介里依然保留着“名校毕业”、“前大厂员工”这样的标签。这背后其实藏着一个有意思的矛盾：他们一边说要摆脱标签，另一边却紧紧抓住这些标签不放。</p><span id="more"></span><h3 id="绩优主义的阴影"><a href="#绩优主义的阴影" class="headerlink" title="绩优主义的阴影"></a>绩优主义的阴影</h3><p>这种现象深刻反映出许多人陷入 “优绩主义” 困境的现状。优绩主义，简单来讲，就是以成绩和成就来评判一个人的价值。在这种观念影响下，人们既想甩掉外界评价带来的压力，又难以割舍其带来的安全感和成就感。表面上追求自由生活，内心却不接受 “普通” 的自己。名校学历、大厂经历等标签，成了他们的心理安全网，既能给予自信，又能维持社会认可。比如，在社交场合中，拥有这些标签的人往往更容易成为焦点，获得他人的关注和尊重，这使得他们更加依赖这些标签所带来的心理满足感。</p><h3 id="身份认同的挣扎"><a href="#身份认同的挣扎" class="headerlink" title="身份认同的挣扎"></a>身份认同的挣扎</h3><p>这些标签不仅仅是炫耀过去的辉煌，更多的是对身份认同的挣扎。“如果没有这些光鲜的经历，我到底是谁？别人会怎么看我？”即使嘴上说着要追求自由，实际上他们还是依赖这些标签来支撑自我价值。绩优主义的影响不仅来自外界的压力，更多时候已经内化成我们评价自己的方式。当一个人选择“松弛感”，实际上是想反抗绩优主义，但这种反抗往往并不彻底——虽然嘴上说放下了，心里却依然渴望被认可。</p><h3 id="妈人旷伪装后的绩优主义"><a href="#妈人旷伪装后的绩优主义" class="headerlink" title="妈人旷伪装后的绩优主义"></a>妈人旷伪装后的绩优主义</h3><p>所谓的“妈人旷”，更多的是这些曾经的内卷赢家, 在面对新一轮的内卷竞争处于下风时, 一种不甘的自我安慰罢了。这些人可能不再用年薪、职位来证明自己，但依然通过学历、曾经的经历等标签来维持一种“无声的优越感”。这让他们既想摆脱外界定义，又离不开它提供的心理支撑。一旦这些标签失去意义，内心的不安感就会随之而来。</p><h3 id="对“普通”的恐惧"><a href="#对“普通”的恐惧" class="headerlink" title="对“普通”的恐惧"></a>对“普通”的恐惧</h3><p>我们对学历、职位的执着，反映出对“普通”的恐惧。即便表面上选择了放弃绩优主义的道路，实际上我们还是希望通过这些标签提醒自己“我和别人不一样”。这让“松弛感”变得既矛盾又虚幻。躺平后，很多人依然不自觉地标榜自己的标签，因为它们象征着社会认同，而我们习惯于通过这种认同来定义自我价值。</p><h3 id="爱普通的自己"><a href="#爱普通的自己" class="headerlink" title="爱普通的自己"></a>爱普通的自己</h3><p>爱普通的自己，是走向自由的关键一步。普通不意味着平庸，这是一种真实且本真的状态。当我们能够正视自己的普通，接纳自身的不完美，才能真正放下对标签的过度执着。不必为没有名校光环而自卑，也无需因缺乏大厂经历而沮丧。相比这些，这世界上有更多值得你珍惜，值得你去爱的人和事。普通人的生活里也可以是珍贵和幸福的。学会爱这个普通的自己，在纷繁复杂的世界中，找到内心深处纯粹的宁静与满足。不再用外界的标准来苛刻地评判自己，而是以一颗包容的心去欣赏自己的成长与进步，无论这进步是大是小。摆脱绩优主义，拥抱真正属于自己的自由人生。</p><h3 id="获得真正自由"><a href="#获得真正自由" class="headerlink" title="获得真正自由"></a>获得真正自由</h3><p>摆脱绩优主义的束缚，重新定义自己的价值。外部的标签不应该成为唯一的价值来源。真正的自由，是能够接受没有这些标签的自己，仍然觉得自己足够好。与其被社会的评价体系绑架，不如问自己：没有这些标签，我还能认可自己的价值吗？当你真正放下这些执念时，才能彻底跳出绩优主义的陷阱，找到内心真正的平静与满足。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自由 </tag>
            
            <tag> 绩优主义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载:了解数据，高频业务指标</title>
      <link href="/2024/12/15/%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%AB%98%E9%A2%91%E4%B8%9A%E5%8A%A1%E6%8C%87%E6%A0%87/"/>
      <url>/2024/12/15/%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%AB%98%E9%A2%91%E4%B8%9A%E5%8A%A1%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong><br>本文是指标体系的首篇，主要讲解业务系统中的高频指标，期望能够建立数据的基本认知，方便后面内容的展开。互联网的发展以及人口红利的消失，在企业的管理过程中数据变得越来越重要，需要更加精细化的运营。同时对员工以及公司的管理者都提出了新的要求，如何利用数据，进行指标分析，并进一步通过数据分析从而发现问题及增长点，指导公司的运营，是接下公司发展的趋势。<br>接下来将从数据和业务指标这两个方面来讲解一下。</p><span id="more"></span><h3 id="理解数据的多元视角，解答怎样更好的了解数据"><a href="#理解数据的多元视角，解答怎样更好的了解数据" class="headerlink" title="理解数据的多元视角，解答怎样更好的了解数据"></a>理解数据的多元视角，解答怎样更好的了解数据</h3><p>怎么更好的去理解数据呢，我以两个视角来讲，分别是数据的含义以及数据的分类。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412151801401.png" alt="图片1 如何理解数据"></p><p>数据的含义是说当获取一份数据后，建立对数据的基本认知，如要知道数据到底是什么，怎么产生的，数据字段的含义是怎样的，字段里面是什么样的数据。</p><p>例如，在电商销售数据中，“订单编号” 字段用于唯一标识每一笔交易，其数据格式可能是特定的数字与字母组合；“商品价格” 字段则明确了每件商品的售价，数据类型为数值型。通过对这些问题的深入了解，为后续的数据处理与分析奠定坚实基础。</p><p>在对数据有了初步了解后，进一步对其进行分类，有助于我们更全面、系统地理解数据。常见的数据分类方式包括用户数据、行为数据和业务数据三类，简言之 “谁”“做了什么”“结果如何” 。</p><p><font color=#FF6A6A> <strong>1. 用户数据</strong></font></p><p>用户数据就是用户的一些基础信息，典型的用户数据如用户的名字、年龄、出生日期、性别、住址、职业、教育水平等。</p><p><font color=#FF6A6A> <strong>2. 行为数据</strong></font></p><p>行为数据则记录用户在产品中的行为，它详细记录用户在何时、何地、以何种方式进行了何种行为。在埋点采集体系中，重点采集的便是此类数据。</p><p>以某社交APP为例，行为数据可记录用户的登录时间、浏览的页面内容、点赞、评论、分享等操作。通过对这些行为数据的深度挖掘，能够洞察用户的兴趣偏好、使用习惯，进而优化产品功能与用户体验。</p><p><font color=#FF6A6A> <strong>3. 业务数据</strong></font></p><p>业务数据则着眼于企业运营的核心成果。在公司运营过程中，除了关注具体的用户，用户的行为之外，最终还是要去关注整个业务的结果是怎样。诸如充值金额、销售业绩、运营目标的达成情况等均属于业务数据范畴。</p><p>以在线教育平台为例，业务数据包括课程的报名人数、付费金额、课程完成率等。这些数据直接反映了平台的业务运营状况，是评估企业盈利能力与市场竞争力的关键指标。</p><p>上面讲述了理解数据的两个视角，接下来引出指标的概念，那为什么我会提到指标呢？</p><hr><h3 id="那么指标是什么，指标与数据的关系又是怎样的？"><a href="#那么指标是什么，指标与数据的关系又是怎样的？" class="headerlink" title="那么指标是什么，指标与数据的关系又是怎样的？"></a>那么指标是什么，指标与数据的关系又是怎样的？</h3><p>在实际工作场景中，数据来源复杂多样，格式常常混乱无序，犹如未经加工的原材料，难以直接被理解与应用。而指标则是基于数据加工提炼而成的、用于精准衡量业务情况的标准与尺度。数据为指标提供了原始素材，指标则成为解读数据、量化业务的有力工具。</p><p>正如现代管理学之父彼得・德鲁克所言：“如果你不能衡量，那么你就不能有效增长。” 这句名言深刻凸显了指标在企业管理与发展进程中的核心地位与重要价值。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412151802542.png" alt="图片2 管理学之父彼得・德鲁克"></p><p>在实际工作场景中，常见的数据问题往往都是因为指标引起的。</p><p>例如，指标定义模糊不清，导致业务部门与数据团队对指标含义的理解存在偏差，沟通中犹如 “鸡同鸭讲”，严重影响工作效率与决策的准确性。为有效解决此类问题，构建清晰、准确且通用的指标体系迫在眉睫。</p><p>接下来，我们将深入介绍一些常见的业务指标，帮助读者对数据指标形成系统认知，减少沟通协作中的gap。</p><p>这里我们基于数据类型，列出一些高频常见的业务指标，并讲述指标的口径定义及作用，让大家对业务进行初步理解，具体分为用户数据指标、行为数据指标以及业务数据指标三类。</p><hr><h3 id="常见的用户数据指标"><a href="#常见的用户数据指标" class="headerlink" title="常见的用户数据指标"></a>常见的用户数据指标</h3><p>用户数据指标主要从多个关键视角对用户进行剖析，包括新增用户数、存量用户活跃度（如 DAU、MAU、WAU）、用户健康度（留存率、LT、粘性）以及用户渠道来源。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412151802668.png" alt="图片3 常见的用户数据指标"></p><p><font color=#FF6A6A> <strong>1. 新增用户数</strong></font></p><p>新增用户数反映特定时间段内新加入产品的用户数量。在实际场景中，对于新用户的分析，通常与用户渠道来源共同使用，用于分析渠道的表现，评估渠道投放的效果。</p><p>其典型的流程是：用户通过渠道包打开渠道页面后，点击跳转应用商店下载应用，然后用户启动应用激活进一步完成注册。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412151803813.png" alt="图片4 渠道投放用户注册流程"></p><p><font color=#FF6A6A> <strong>2. 活跃用户数</strong></font></p><p>DAU（日活跃用户数）、MAU（月活跃用户数）、WAU（周活跃用户数）则是衡量存量用户活跃度的关键指标。</p><p>以一款短视频应用为例，DAU 反映了每天有多少用户打开并使用该应用进行浏览、拍摄、分享等操作；MAU 则展示了在一个月内活跃用户的规模，通过对比不同月份的 MAU 数据，可洞察用户群体的长期活跃度趋势；WAU 则在周维度上对用户活跃情况进行了监测，有助于发现用户在一周内的使用规律与波动情况。</p><p><font color=#FF6A6A> <strong>3. 留存率</strong></font></p><p>留存率是评估用户忠诚度与产品粘性的核心指标之一。例如，某电商平台的次日留存率为 30%，意味着在新注册用户中，有 30% 的用户在第二天仍会再次访问该平台。较高的留存率通常表明产品或服务具有较强的吸引力与用户价值，能够有效留住用户。</p><p>实际工作中，不同公司或数据类产品对于留存的定义有所差异，具体的算法有：</p><p>算法 1（7 日日留存）：主流的是按照当日活跃用户且第 n 日仍活跃的用户与当日活跃用户比算作留存率，以衡量渠道投放的业务使用这种算法是合适的，避免了其他日数据的干扰。</p><p>算法 2（7 日内留存）：以 n 日内只要活跃一天的用户即算作 n 日留存，使用于应用活跃较为集中在某一天且周期较长的业务， 为了让数据更加合理会采用该种方案。</p><p>算法 3（7 日日留存，新增当日算做 0 天留存率为 100%）：某些公司或平台存在首日留存率的概念，按照 0 天留存，1 天留存，2 天留存的方式，区别于次日留存，3 日留存，7 日留存等。</p><p><font color=#FF6A6A> <strong>4. LT（生命周期总价值）</strong></font></p><p>LT即用户生命周期(Life Time)，用于衡量用户的活跃情况，如2月29日的LT3 &#x3D; 2.02代表2月29日新增的用户在3日内平均活跃了2.02天。</p><p><font color=#FF6A6A><strong>5. 粘性（日活&#x2F;月活）</strong></font></p><p>日活&#x2F;月活是表示用户参与度的一个常用指标，它是每日活跃用户与每月活跃用户的比率，用百分比来表示。通常认为，日活&#x2F;月活在 20％ 以上的 app 是不错的，超过 50％ 的被形容为世界级。</p><p>适用场景：对消费类和底层的 SaaS 产品来说，这个指标非常有用，但是除了这种日常使用的消息&#x2F;社交类产品外，其实对其他类别都不太有用。这些产品当然很有价值，但他们不是唯一有价值的产品。</p><h3 id="行为数据指标"><a href="#行为数据指标" class="headerlink" title="行为数据指标"></a>行为数据指标</h3><p>行为数据指标基于业务不同在具体场景上也会有所差异，但其核心框架大体一致。主要从行为次数（PV、UV）、行为深度（次数深度或链路深度）、停留多久（时长）以及路径走通率（转化率）几个维度展开。</p><p>举个例子：多少个用户进入首页访问了多少次、访问次数中多少次打开商品详情、进一步多少人下单、多少人购买。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412151803564.png" alt="图片5 电商购物流程"></p><p><font color=#FF6A6A> <strong>1. PV（页面浏览量）</strong></font></p><p>PV（页面浏览量，Page View），一定时间内某个页面的浏览次数，用户每打开一个网页可以看作一个PV。如，某一个网页1天中被打开10次，那么PV为10。</p><p><font color=#FF6A6A><strong>2. UV（独立访客数）</strong></font></p><p>UV（独立访客数，Unique Visitor），一定时间内访问某个页面的人数。例如，某一个网页1天中被1个人打开过10次，那么UV是1。虽然这位用户在1天中打开该网页10次，但是这位用户都只能算一个人，所以UV是1，而不是10。</p><p>PV（页面浏览量）与 UV（独立访客数）是衡量用户与产品界面交互频率的基础指标。</p><p><font color=#FF6A6A><strong>3. 行为深度</strong></font></p><p>对于行为深度的衡量，主要有两种口径类型，分为基于次数的深度以及基于链路的链路深度。基于次数的深度，如在某社交 APP 应用中，用户与用户间的聊天次数可直观反映其对聊天对象的喜爱深度。</p><p>另一种是页面链路的深度，它记录了用户为完成某一特定行为所经历的页面跳转次数与路径。通过分析链路深度，可发现流程中的瓶颈环节，提出优化页面布局与交互设计，提升用户体验与转化率。</p><p>例如，在电商购物流程中，用户从首页浏览商品，到加入购物车，再到填写收货信息、完成支付，这一系列操作所经过的页面步骤即为页面链路深度。</p><p><font color=#FF6A6A><strong>4. 停留时长</strong></font></p><p>用户在产品内某一行为的停留时长，直接反应用户对该行为的感兴趣程度。</p><p>例如，在一款在线视频平台上，用户观看某部电影的平均时长为 90 分钟，而平台上另一部电影的平均观看时长仅为 30 分钟，这表明前者更受用户喜爱与关注，平台可据此调整影片推荐权重，优先推荐高观看时长的优质内容。</p><p><font color=#FF6A6A> <strong>5. 转化率</strong> </font></p><p>转化率则是衡量用户在一系列行为过程中，从一个行为阶段成功转化至下一个行为阶段的比例情况。</p><p>以电商平台为例，商品详情页的浏览转化率（从浏览详情页到加入购物车的比例）、购物车转化率（从加入购物车到提交订单的比例）、支付转化率（从提交订单到完成支付的比例）等一系列转化率指标，能够精准定位用户在购物流程中的流失环节，为优化营销策略与产品功能提供明确方向。</p><hr><h3 id="业务数据指标"><a href="#业务数据指标" class="headerlink" title="业务数据指标"></a>业务数据指标</h3><p>业务数据指标从多个维度全面衡量企业的业务运营状况，包括总量指标（GMV、目标达成数）、人数指标（付费人数、完成人数）、人均指标（ARPU&#x2F;ARPPU&#x2F; 人均次数 &#x2F; 人均访问时长）、健康程度指标（付费率及完成率）以及被消费视角相关指标。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412151803336.png" alt="图片6 常见的业务数据指标"></p><p><font color=#FF6A6A> <strong>1.GMV</strong></font></p><p>GMV是描述交易的金额总规模，它涵盖了所有产品在特定时间段内的销售总额，包括实际支付金额、退款金额等。</p><p>例如，某电商平台在 “双 11” 期间的 GMV 突破 500 亿元，这一数据直观展示了平台在该购物狂欢节期间的整体销售规模与市场影响力。</p><p><font color=#FF6A6A> <strong>2. 付费人数</strong> </font></p><p>付费人数统计了在特定时间段内实际支付费用的用户数量，是衡量企业收入来源的重要指标之一。</p><p>例如，一款在线音乐平台的付费人数达到 100 万，表明有 100 万用户认可并愿意为平台的音乐服务付费，这为平台的盈利状况提供了直接依据。</p><p> <font color=#FF6A6A> <strong>3. ARPU及ARPPU</strong></font></p><p>ARPU人均付费&#x3D;GMV&#x2F;总用户数，人均付费在游戏行业也叫ARPU （Average Revenue Per User），在电商行业也叫客单价。</p><p>ARPPU付费用户人均付费（Average Revenue Per Paying User&#x3D;GMV&#x2F;付费人数，这个指标用于统计付费用户的平均收入。</p><p><font color=#FF6A6A><strong>4. 付费率&#x2F;复购率</strong></font></p><p>付费率&#x3D;付费人数&#x2F;总用户数。付费率展示了用户群体中付费用户的占比情况。例如，某App产品有100万注册用户，其中10万用户有过消费，那么该产品的付费率&#x3D;付费人数（10万）&#x2F;总用户数（100万）&#x3D;10%。</p><p>复购率是指重复购买频率，用于反映用户的付费频率。复购率指一定时间内，消费两次以上的用户数&#x2F;付费人数。例如，微信收账管理小程序可以帮助商家统计通过微信转账的用户。</p><p><font color=#FF6A6A> <strong>5.  被消费视角</strong></font></p><p>消费视角相关指标则关注企业产品或服务在市场中的被消费情况与受欢迎程度。例如，知乎内文章被阅读次数、分享次数等，区别于用户阅读次数，属于被消费视角下的指标。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文以业务中常见的高频指标进行切入，期望引导大家对数据以及指标有一个初步的认知。</p>]]></content>
      
      
      <categories>
          
          <category> 数据体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指标体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>埋点体系:数据采集的关键技术</title>
      <link href="/2024/12/13/%E5%9F%8B%E7%82%B9%E4%BD%93%E7%B3%BB-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
      <url>/2024/12/13/%E5%9F%8B%E7%82%B9%E4%BD%93%E7%B3%BB-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>数字化时代，数据已成为企业决策和发展的核心驱动力。而埋点体系作为获取用户行为数据的重要手段，对于企业深入了解用户需求、优化产品体验、制定精准营销策略具有不可替代的作用。本文将详细介绍埋点体系的相关知识，包括其定义、作用、采集技术以及技术方案的选择等内容.</p><span id="more"></span><p><strong>本文大纲</strong></p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412152201227.png" alt="image-20241215220140124" style="zoom: 33%;" /><h2 id="一、埋点体系概述"><a href="#一、埋点体系概述" class="headerlink" title="一、埋点体系概述"></a>一、埋点体系概述</h2><h3 id="（一）埋点的定义"><a href="#（一）埋点的定义" class="headerlink" title="（一）埋点的定义"></a>（一）埋点的定义</h3><p>埋点，简单来说，是一种用于采集用户行为数据的技术手段。它通过在应用程序（APP）或网站页面中嵌入特定的代码片段，实现对用户各种操作行为的监测和数据收集。在 APP 中，通常借助软件开发工具包（SDK）来实现埋点功能；而在网站页面上，则主要依靠 JavaScript 代码来完成。这些埋点代码就像隐藏在系统中的 “探测器”，能够精准地捕捉用户的一举一动，如用户在 APP 中的点击、滑动、浏览等操作，以及在网站上的页面访问、表单提交、链接点击等行为。通过这些数据的收集，企业能够深入了解用户的行为模式、兴趣偏好和使用习惯，为后续的数据分析和决策提供有力支持。</p><h3 id="（二）埋点的作用"><a href="#（二）埋点的作用" class="headerlink" title="（二）埋点的作用"></a>（二）埋点的作用</h3><ol><li><strong>助力用户运营</strong>：在大数据时代，基于用户行为数据的运营策略已成为企业成功的关键。埋点能够提供详细的用户行为信息，帮助运营团队深入了解用户的需求和行为特征，从而制定更加精准、个性化的运营方案，提高用户参与度和忠诚度。</li><li><strong>传递产品价值</strong>：运营的核心目标之一是将产品的价值有效地传递给用户。通过埋点收集用户对产品功能的使用情况和反馈，企业可以了解用户对产品价值的感知程度，进而优化产品设计和功能，确保产品能够更好地满足用户需求，实现产品价值的最大化传递。</li><li><strong>深入了解用户需求</strong>：要实现精准的用户运营，首先必须深入了解用户。埋点数据为企业提供了一个窗口，使企业能够实时观察用户的行为，分析用户的行为路径和偏好，从而洞察用户的潜在需求，为产品改进和创新提供依据。</li><li><strong>基于行为判定意图</strong>：用户的言语表达往往具有一定的主观性和模糊性，而其行为则更能真实地反映其内心的需求和意图。埋点通过记录用户的实际操作行为，为企业提供了客观、准确的判断依据，帮助企业更好地理解用户的行为动机，从而提供更符合用户期望的产品和服务。</li><li><strong>实现行为数据采集</strong>：作为一种专门用于采集用户行为数据的技术，埋点填补了企业在用户行为数据获取方面的空白。这些行为数据与业务数据相互补充，共同构成了企业数据体系的重要组成部分，为企业的数据分析和决策提供了丰富的数据资源。</li></ol><h2 id="二、埋点采集技术"><a href="#二、埋点采集技术" class="headerlink" title="二、埋点采集技术"></a>二、埋点采集技术</h2><h3 id="（一）Web-端（浏览器）日志采集"><a href="#（一）Web-端（浏览器）日志采集" class="headerlink" title="（一）Web 端（浏览器）日志采集"></a>（一）Web 端（浏览器）日志采集</h3><ol><li><strong>页面浏览日志</strong>：当用户在浏览器中加载页面时，页面浏览日志会记录下这一行为。它主要用于统计页面的访问量（Page View，PV）和独立访客数（Unique Visitors，UV）等基础指标，为企业提供了对网站流量和用户访问情况的初步了解。这些数据对于评估网站的受欢迎程度、分析用户来源和流量趋势具有重要意义，是企业优化网站内容和结构的重要依据。</li><li><strong>页面交互日志</strong>：在页面加载完成后，用户与页面进行的各种交互操作，如鼠标移动、点击按钮、输入信息等，都会被页面交互日志记录下来。这些数据能够反映用户在页面上的行为特征和兴趣点，帮助企业了解用户对页面内容的关注程度、对交互元素的反应，从而发现潜在的体验优化点，提升用户满意度。</li><li><strong>其他事件日志</strong>：除了上述两种常见的日志类型外，针对一些特定场景，还会有其他类型的采集日志。例如，曝光日志用于记录页面上特定元素（如广告、重要内容区域）的曝光情况，帮助企业评估广告投放效果和内容展示效果；用户在线状态检测日志则可以实时跟踪用户的在线时长、登录时间等信息，为企业提供用户活跃度和参与度的相关数据。</li></ol><h3 id="（二）APP-移动端日志采集"><a href="#（二）APP-移动端日志采集" class="headerlink" title="（二）APP 移动端日志采集"></a>（二）APP 移动端日志采集</h3><ol><li><strong>页面浏览事件</strong>：用户在 APP 内打开或刷新页面时，会触发页面浏览事件的记录。这有助于企业统计各个页面的访问频率，了解用户在 APP 内的浏览路径和偏好，从而优化页面布局和导航设计，提高用户的浏览体验，引导用户更深入地探索 APP 的功能和内容。</li><li><strong>区域曝光事件</strong>：当 APP 页面内的某个区域（如特定模块、广告位等）被用户看到时，区域曝光事件会被记录。通过统计区域曝光次数，企业可以评估不同区域的吸引力和重要性，了解用户对页面内容的关注分布，进而优化页面内容展示策略，提高重要信息的曝光率，增强用户对关键内容的关注度。</li><li><strong>点击事件</strong>：用户在 APP 上的每一次点击操作都会被点击事件记录。这包括按钮点击、链接点击、菜单选择等各种点击行为。点击事件数据能够直接反映用户的操作意图和兴趣点，帮助企业分析用户对不同功能和内容的点击偏好，优化交互设计，提高用户操作的便捷性和效率，同时也为精准营销提供了有力支持。</li></ol><h2 id="三、埋点技术方案"><a href="#三、埋点技术方案" class="headerlink" title="三、埋点技术方案"></a>三、埋点技术方案</h2><h3 id="（一）代码埋点（自定义埋点）"><a href="#（一）代码埋点（自定义埋点）" class="headerlink" title="（一）代码埋点（自定义埋点）"></a>（一）代码埋点（自定义埋点）</h3><ol><li>客户端埋点<ul><li><strong>原理</strong>：由前端开发人员根据具体需求，手动在前端业务代码中插入数据采集代码。当用户在前端执行相应行为时，这些代码会被触发，从而实现数据的采集。例如，在电商 APP 的商品详情页，前端开发人员可以在 “加入购物车” 按钮的点击事件处理函数中添加代码，记录用户点击该按钮的时间、商品 ID、用户 ID 等信息。</li><li>优点<ul><li><strong>高度定制化</strong>：能够根据业务需求精确地定义要采集的数据内容和时机，满足各种复杂的业务场景和数据分析要求，实现个性化的数据采集。</li><li><strong>行为与业务数据整合</strong>：可以方便地将用户行为数据与业务数据（如商品信息、用户订单数据等）进行关联和整合，为深入分析用户行为与业务之间的关系提供了可能。</li></ul></li><li>缺点<ul><li><strong>数据延迟与丢失</strong>：数据采集后通常需要等待一定时间才会上报，这期间可能会因网络问题、设备故障等原因导致数据丢失，数据丢失率一般在 5% - 10% 左右。</li><li><strong>依赖客户端发版</strong>：每添加或修改一个埋点，都需要发布新的客户端版本，这对于用户来说可能意味着频繁的更新，而且老版本的用户将无法获取最新的埋点数据，导致数据采集不全面。</li><li><strong>开发工作量大</strong>：需要前端开发人员投入大量时间和精力进行埋点代码的编写和维护，随着业务的发展和埋点需求的增加，开发成本会不断上升。同时，过多的埋点代码也会增加代码的复杂性，给后续的代码维护和管理带来困难。</li></ul></li></ul></li><li>服务端埋点<ul><li><strong>原理</strong>：服务端开发人员将埋点采集代码添加到后端服务器代码中。当用户通过前端操作向服务端请求数据时，服务端根据预先设定的规则触发埋点代码，采集相关数据。例如，当用户在 APP 中提交订单时，服务端在处理订单请求的过程中触发埋点代码，记录订单信息、用户信息、提交时间等数据。</li><li>优点<ul><li><strong>按需精准采集</strong>：可以根据业务逻辑和数据分析需求，在服务端精确地控制数据采集的时机和内容，确保采集到的数据具有针对性和有效性。</li><li><strong>实时准确上报</strong>：数据在服务端采集后能够立即上报，避免了客户端埋点中数据延迟和丢失的问题，保证了数据的准确性和完整性。</li><li><strong>行为与业务数据深度整合</strong>：由于服务端可以直接访问业务数据，因此能够更方便地将用户行为数据与各种业务数据进行深度整合，为全面分析用户行为与业务流程之间的关系提供了有力支持。</li></ul></li><li>缺点<ul><li><strong>前端行为采集受限</strong>：对于纯前端操作且不触发服务端接口请求的行为（如部分页面内的交互操作），服务端无法进行数据采集，导致数据采集不全面。</li><li><strong>开发与协作复杂</strong>：需要服务端开发人员参与埋点代码的开发，涉及前后端开发团队的协作。在实际操作中，容易出现沟通不畅、协作困难等问题，导致埋点漏埋或错误。同时，埋点开发工作量较大，需要投入较多的人力和时间成本。</li></ul></li></ul></li></ol><h3 id="（二）全埋点"><a href="#（二）全埋点" class="headerlink" title="（二）全埋点"></a>（二）全埋点</h3><ol><li><strong>原理</strong>：全埋点通过在 APP 内引入专门的 SDK，实现对用户行为数据的自动采集。SDK 会在后台自动监测和记录用户的各种操作行为，无需开发人员手动添加埋点代码。例如，SDK 可以自动记录用户在 APP 内的页面浏览时间、点击事件、滚动行为等常见操作，无需针对每个具体行为单独编写埋点代码。</li><li>优点<ul><li><strong>快速部署与简便操作</strong>：接入 SDK 后，即可自动开始采集数据，无需开发人员进行复杂的埋点代码编写工作，大大节省了开发时间和成本，尤其适用于快速迭代的项目或对数据采集需求不太明确的初期阶段。</li><li><strong>数据全面覆盖</strong>：能够采集页面上可见元素的各种操作行为数据，提供了较为全面的数据视角，有助于发现一些潜在的用户行为模式和问题。</li></ul></li><li>缺点<ul><li><strong>数据精准性与相关性不足</strong>：由于采用自动化采集，无法区分有效行为和无效行为，会采集大量与业务分析无关的数据，导致数据存储和处理成本增加，同时也降低了数据分析的效率和准确性。例如，用户的误操作、快速浏览等行为数据也会被一并采集，增加了数据噪音。</li><li><strong>动态与复杂场景适应性差</strong>：对于动态生成的页面内容、复杂的交互逻辑或页面不可见的行为（如后台运行的任务、某些特定条件下触发的操作），全埋点技术往往无法准确采集相关数据，限制了其在复杂业务场景中的应用。</li><li><strong>数据治理困难</strong>：大量无差别采集的数据难以进行有效的管理和治理，随着数据量的不断增长，会给数据存储、传输和分析带来巨大压力，影响系统性能和数据分析的效果。</li></ul></li></ol><h3 id="（三）可视化埋点"><a href="#（三）可视化埋点" class="headerlink" title="（三）可视化埋点"></a>（三）可视化埋点</h3><ol><li><strong>原理</strong>：可视化埋点借助专门的可视化工具（如 Google Analytics、Mixpanel、Amplitude 等）来实现。数据分析人员通过设备连接到用户行为分析工具的数据接入管理界面，在页面上直接选择需要埋点的元素，工具会自动生成相应的埋点代码并下发采集请求，从而实现数据的采集。例如，在一个在线教育平台的课程页面上，数据分析人员可以使用可视化埋点工具轻松地为 “开始学习” 按钮添加点击事件埋点，无需编写代码。</li><li>优点<ul><li><strong>操作便捷高效</strong>：通过可视化界面进行埋点操作，无需编写代码，降低了对开发人员的技术依赖，业务人员或数据分析人员即可轻松完成埋点设置，大大提高了埋点的效率和灵活性。</li><li><strong>实时可视化反馈</strong>：在设置埋点后，可以立即在可视化界面上看到数据的采集情况和相关报表，方便实时监测和验证埋点效果，及时调整埋点策略。</li><li><strong>节约存储与传输成本</strong>：默认情况下不进行数据上报，只有在可视化选择需要采集的数据后才触发埋点，避免了不必要的数据采集和传输，有效节约了存储和传输资源。</li></ul></li><li>缺点<ul><li><strong>历史数据缺失</strong>：只能采集在可视化埋点设置之后产生的数据，无法获取历史行为数据，对于需要对历史用户行为进行分析的场景不太适用，限制了数据分析的深度和广度。</li><li><strong>覆盖场景有限</strong>：虽然能够满足一些常见的用户行为采集需求（如点击、展示等），但对于与业务逻辑紧密相关的复杂行为和属性信息的采集能力有限，无法满足深度定制化的数据分析要求。</li><li><strong>依赖工具平台</strong>：需要依赖特定的可视化埋点工具平台，不同工具的功能和适用场景可能存在差异，企业在选择工具时需要综合考虑自身需求和工具的特点，同时也可能面临工具成本、数据安全等方面的问题。</li></ul></li></ol><h2 id="四、埋点技术方案的选择"><a href="#四、埋点技术方案的选择" class="headerlink" title="四、埋点技术方案的选择"></a>四、埋点技术方案的选择</h2><p>在选择埋点技术方案时，企业需要综合考虑多方面因素，根据自身的发展阶段、业务特点和技术能力来做出合适的决策。</p><h3 id="（一）起步阶段"><a href="#（一）起步阶段" class="headerlink" title="（一）起步阶段"></a>（一）起步阶段</h3><p>对于处于起步阶段的企业，业务相对简单，数据量不大，且尚未进入精细化运营阶段。此时，可以优先考虑无埋点技术或自定义埋点技术。无埋点技术能够快速部署，以较低的成本获取一些基本的用户行为数据，帮助企业初步了解用户行为模式。自定义埋点技术虽然开发成本相对较高，但能够根据业务需求进行定制化采集，为后续的数据分析和业务发展奠定基础。在这个阶段，企业可以根据具体情况灵活选择，或者结合使用两种技术，以满足不同的需求。</p><h3 id="（二）发展阶段"><a href="#（二）发展阶段" class="headerlink" title="（二）发展阶段"></a>（二）发展阶段</h3><p>随着企业的发展，业务复杂度逐渐增加，数据量也逐步变大。此时，自定义埋点技术成为较为合适的选择。尽管其开发工作量较大，但它能够提供高度定制化的数据采集，满足企业对复杂业务场景下用户行为数据的深入分析需求。通过将行为数据与业务数据进行深度整合，企业可以更好地理解用户行为与业务流程之间的关系，发现业务中的问题和机会，为产品优化和业务决策提供有力支持。在实际工作中，大多数企业在发展阶段都会采用自定义埋点技术，并根据业务发展不断优化和完善埋点体系。</p><h3 id="（三）成熟阶段"><a href="#（三）成熟阶段" class="headerlink" title="（三）成熟阶段"></a>（三）成熟阶段</h3><p>当企业进入成熟阶段，流量巨大，业务复杂度高。此时，企业可以根据具体情况选择单独使用有埋点技术（如自定义埋点或可视化埋点），或者结合无埋点技术来构建全面、高效的埋点体系。例如，对于核心业务流程和关键用户行为，可以采用自定义埋点技术进行精确采集和深度分析；对于一些通用的、大规模的用户行为数据采集，可以结合无埋点技术，以降低开发成本和提高数据采集效率。同时，可视化埋点技术也可以在某些特定场景下发挥作用，如快速验证新功能的用户反馈、进行临时的数据分析需求等。通过综合运用多种埋点技术，企业能够在保证数据质量和分析深度的前提下，提高数据采集的效率和灵活性，充分挖掘用户行为数据的价值，为企业的持续发展提供有力支撑。</p><p>总之，埋点体系是企业实现数据驱动决策的重要基础设施。不同的埋点技术方案各有优劣，企业应根据自身实际情况进行合理选择，构建适合自己的埋点体系，从而更好地利用用户行为数据，提升产品竞争力，实现业务的可持续发展。在未来，随着技术的不断发展和业务需求的持续变化，埋点体系也将不断演进和完善，为企业提供更加精准、高效的数据支持。</p>]]></content>
      
      
      <categories>
          
          <category> 数据体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 埋点体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载:认知负荷才是最重要的</title>
      <link href="/2024/10/30/%E8%AE%A4%E7%9F%A5%E8%B4%9F%E8%8D%B7%E6%89%8D%E6%98%AF%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84/"/>
      <url>/2024/10/30/%E8%AE%A4%E7%9F%A5%E8%B4%9F%E8%8D%B7%E6%89%8D%E6%98%AF%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>这世上有如此多的“流行语”和“最佳实践”，但是让我们把注意力转向更基础的方面。即——开发人员在浏览代码时所感受到的“困惑程度”。</p><p>困惑是以时间和金钱为代价的。困惑是由高<em>认知负荷</em>造成的。这不是什么花哨的抽象概念，而是一种<strong>人类的基本限制因素</strong>。</p><p>由于我们花在阅读和理解代码上的时间远远多于编写代码的时间，所以我们应该不断地问自己，我们是否在代码中嵌入了过多会给人带来认知负荷的内容。</p><span id="more"></span><blockquote><p>原文地址: <a href="https://github.com/zakirullin/cognitive-load/tree/main">https://github.com/zakirullin/cognitive-load/tree/main</a><br>原文作者: Artem Zakirullin</p></blockquote><h2 id="认知负荷-Cognitive-load"><a href="#认知负荷-Cognitive-load" class="headerlink" title="认知负荷(Cognitive load)"></a>认知负荷(Cognitive load)</h2><blockquote><p>“认知负荷”（Cognitive load）指的是开发人员为了完成一项任务而需要进行思考的量。</p></blockquote><p>在阅读代码时，人们会将诸如变量值、控制流逻辑和调用序列等内容记在脑海里。通常情况下，一般人在<a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BF%86/5197761">工作记忆</a>中大约可以保存<a href="https://github.com/zakirullin/cognitive-load/issues/16">四个这样的部分</a>。一旦达到这个临界值，理解事物就变得更加困难。</p><p><em>假设我们被要求对一个完全不熟悉的项目进行修复工作。并被告知在此之前，有一位非常聪明的开发人员在项目中编写了代码。采用了许多复杂高级的架构、花哨的库和先进的技术。换句话说</em>，<strong>项目的前任开发者给我们带来了很高的认知负荷。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412302151603.png" alt="Cognitive Load"></p><p>我们应该尽可能地减少项目中会给人带来认知负荷的内容。</p><h2 id="认知负荷的类型-Types-of-cognitive-load"><a href="#认知负荷的类型-Types-of-cognitive-load" class="headerlink" title="认知负荷的类型(Types of cognitive load)"></a>认知负荷的类型(Types of cognitive load)</h2><p><strong>内在的</strong> - 源于任务本身所固有的难度。它是软件开发的核心要素，且这种难度无法降低。</p><p><strong>与任务无关的</strong> - 由信息的呈现方式导致。通常由与任务并无直接关联的因素引发，比如那些聪明人的 “骚操作”。并且这种类型的认知负荷是可以避免的。我们将在下文着重关注这一类型的认知负荷。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412302151224.png" alt="Intrinsic vs Extraneous"></p><p>接下来让我们直接看一些“与任务无关的”认知负荷的具体实例。</p><hr><p>我们将认知负荷的“困惑程度”定义如下：</p><p><code>🧠</code>: 刚初始化的“工作记忆”，此时不存在认知负荷</p><p><code>🧠++</code>: 在“工作记忆”中放入了两项内容，认知负荷有所增加（<code>+</code>越多，负荷越多）</p><p><code>🤯</code>:在“工作记忆”中放入了超过4项内容，致使“工作记忆” 出现 “溢出” 状况</p><blockquote><p>我们的大脑实际要更加复杂而神秘，这里只是运用这个简单模型对认知负荷的困惑程度进行简要描述。</p></blockquote><h2 id="复杂的条件控制-Complex-conditionals"><a href="#复杂的条件控制-Complex-conditionals" class="headerlink" title="复杂的条件控制(Complex conditionals)"></a>复杂的条件控制(Complex conditionals)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> val &gt; someConstant <span class="comment">// 🧠+</span></span><br><span class="line">    &amp;&amp; (condition2 || condition3) <span class="comment">// 🧠+++, 前一个条件必须是 true, c2 和 c3 中的任意一个应该为 true</span></span><br><span class="line">    &amp;&amp; (condition4 &amp;&amp; !condition5) &#123; <span class="comment">// 🤯, 然后我们就被这个地方整懵逼了</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多层嵌套的-ifs-Nested-ifs"><a href="#多层嵌套的-ifs-Nested-ifs" class="headerlink" title="多层嵌套的 ifs (Nested ifs)"></a>多层嵌套的 ifs (Nested ifs)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> isValid &#123; <span class="comment">// 🧠+, 这一步我们目前只关心 isValid 这一个变量（是否有效）</span></span><br><span class="line">    <span class="keyword">if</span> isSecure &#123; <span class="comment">// 🧠++, 这一步我们要同时关心 isValid 和 isSecure 两个变量（是否有效并且安全）</span></span><br><span class="line">        stuff <span class="comment">// 🧠+++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>和“提早返回”（先判断条件不满足时直接返回）做对比：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !isValid</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !isSecure</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 🧠, 我们不用去关心已经返回的东西，走到这一步代表所有校验已经通过</span></span><br><span class="line"></span><br><span class="line">stuff <span class="comment">// 🧠+</span></span><br></pre></td></tr></table></figure><p>我们可以只专注于要执行的主要逻辑，从而使“工作记忆”从各种先决条件中解放出来。</p><h2 id="多继承噩梦-Inheritance-nightmare"><a href="#多继承噩梦-Inheritance-nightmare" class="headerlink" title="多继承噩梦 (Inheritance nightmare)"></a>多继承噩梦 (Inheritance nightmare)</h2><p>我们接到要求，要针对管理员用户对某些内容进行修改 <code>🧠</code>：</p><p><code>AdminController extends UserController extends GuestController extends BaseController</code></p><p>噢，一部分的功能代码在<code>BaseController</code>，让我们来看看：<code>🧠+</code></p><p>在<code>GuestController</code> 中引入了基本的角色机制：<code>🧠++</code></p><p>在<code>UserController</code> 中修改了部分内容：<code>🧠+++</code></p><p>终于，我们来到了<code>AdminController</code>，让我们开始编码吧！：<code>🧠++++</code></p><p>Oh，等下，这里还有一个<code>AdminController</code>，它继承自<code>SuperuserController</code>。如果修改了<code>AdminController</code>，那么其它继承自它的类中的逻辑就会被破坏，所以我们要先了解一下<code>SuperuserController</code>：<code>🤯</code></p><p>通过组合不同的类来实现功能，而不是过度依赖继承。关于这一点，这里就不详细阐述了——这里有很多<a href="https://www.youtube.com/watch?v=hxGOiiR9ZKg">参考资料</a>。</p><h2 id="存在数量过多的小方法，类或模块-Too-many-small-methods-classes-or-modules"><a href="#存在数量过多的小方法，类或模块-Too-many-small-methods-classes-or-modules" class="headerlink" title="存在数量过多的小方法，类或模块(Too many small methods, classes or modules)"></a>存在数量过多的小方法，类或模块(Too many small methods, classes or modules)</h2><blockquote><p><code>下述方法、类和模块是可以相互替换的</code></p></blockquote><p>诸如 “方法应该少于 15 行代码” 或 “类应该很小” 之类的观点，经实践证明是存在一定错误的。</p><p><strong>深模块</strong>「Deep module」- 具有简单的接口却实现复杂的功能</p><p><strong>浅模块</strong> 「Shallow module」- 其接口相对于自身所提供的微小功能而言相对复杂</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412302152013.png" alt="Deep module"></p><p>倘若项目中存在过多的 “浅模块”「Shallow module」，项目就会变得晦涩难懂。<strong>因为人们不仅要记住每个模块所承担的职责，还要记住它们之间的所有交互关系</strong>。为了弄明白“浅模块”「Shallow module」的用途，我们首先得查看所有与之相关的模块的逻辑。<code>🤯</code></p><blockquote><p><a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/3230616">信息隐藏</a>至关重要，当然我们并不会在“浅模块”「Shallow module」中隐藏大量复杂性。</p></blockquote><p>我有两个业余项目，每个项目都有约 5千行代码。第一个项目包含 80 个“浅类”「shallow class</p><p>」，而第二个项目仅有 7 个“深类”「deep class」，我已经有一年半没对这两个项目进行维护了。</p><p>有一次我回过头来维护项目，我发现要理清第一个项目中那 80 个类之间的所有交互关系，简直难如登天。在我开始编码之前，我不得不重新构建大量的认知负荷。另一方面，我能迅速理解第二个项目，因为它只有几个有着简单接口的“深类”「deep class」。</p><blockquote><p>在各种组件当中，最优秀的是既能够提供强大的功能表现，又具有简单易用的接口设计的组件 。</p><p>「The best components are those that provide powerful functionality yet have simple interface.」</p><p><strong>John K. Ousterhout</strong></p></blockquote><p>UNIX I&#x2F;O 的接口非常简单。它只有五个基本调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">open(path, flags, permissions)</span><br><span class="line">read(fd, buffer, count)</span><br><span class="line">write(fd, buffer, count)</span><br><span class="line">lseek(fd, offset, referencePosition)</span><br><span class="line">close(fd)</span><br></pre></td></tr></table></figure><p>这个接口的现代实现「modern implementation」有<strong>数十万行代码</strong>。尽管其实现复杂，但因为其具有简单的接口，所以使用起来很便捷。</p><blockquote><p>这个“深模块”「deep module」的示例源于 John K. Ousterhout 的 <a href="https://web.stanford.edu/~ouster/cgi-bin/book.php">软件设计的哲学【A Philosophy of Software Design】</a>一书。这本书不仅阐述了软件开发中复杂性的本质，而且是对 Parnas 颇具影响力的论文 <a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf">分解系统模块的标准【On the criteria to be used in decomposing systems into modules】</a>的最大诠释。这两本书都是必读之物。其他相关读物：<a href="https://qntm.org/clean">可能是时候停止推荐清洁代码了【It’s probably time to stop recommending Clean Code】</a>、<a href="https://copyconstruct.medium.com/small-functions-considered-harmful-91035d316c29">被认为有害的小函数【Small Functions considered Harmful】</a>。</p></blockquote><p>P.S. 如果你认为我们是在支持那种承担过多责任、臃肿不堪的被称为 “上帝对象” 「God objects」的事物，那你就误解我们了。</p><h2 id="浅模块和单一职责原则-Shallow-modules-and-SRP"><a href="#浅模块和单一职责原则-Shallow-modules-and-SRP" class="headerlink" title="浅模块和单一职责原则(Shallow modules and SRP)"></a>浅模块和单一职责原则(Shallow modules and SRP)</h2><p>很多时候，我们最终会遵循“一个模块应该只负责一件事”这一模糊的原则，进而创建出大量的“浅模块”「Shallow modules」。可这个模糊的“一件事”究竟是什么？比如实例化一个对象算是“一件事”，对吗？如此看来，像<a href="https://minds.md/benji/frameworks">MetricsProviderFactoryFactory</a>这种名称复杂的事物似乎并无不妥。然而，这类事物的类名和接口比其完整实现更令人费解，这到底是一种怎样的抽象呢？恐怕某些地方存在一些问题。</p><blockquote><p>在“浅组件”「Shallow components」之间来回切换会使人疲惫不堪，而<a href="https://blog.separateconcerns.com/2023-09-11-linear-code.html">线性思维</a>对人类来说是更自然的思维方式。</p></blockquote><p>我们对系统进行调整和改变，其目的在于满足用户以及利益相关方的需求。并且我们有责任对他们履行应尽的义务。</p><blockquote><p>一个模块应当只专注于为一个特定的用户或者利益相关方服务，并且只对这一个对象负责。</p></blockquote><p>这便是单一职责原则的全部内涵。简单来说，如果我们在某个地方引入了一个 bug，随后有两个不同业务模块的人员都来投诉，那就意味着我们违反了这个原则。这与我们在模块中做了多少事情无关。</p><p>但就目前而言，这种解释是弊大于利的。因为即便是同一个人，对于同一条规则也可能有不同的理解方式。解释“单一职责原则”的更好方法是考量其带来了多少认知负荷。要记住“一个模块的变化会引发不同业务流的连锁反应”这一点，是需要一定心智负担的。以上。</p><h2 id="过多的“浅微服务”-Too-many-shallow-microservices"><a href="#过多的“浅微服务”-Too-many-shallow-microservices" class="headerlink" title="过多的“浅微服务”(Too many shallow microservices)"></a>过多的“浅微服务”(Too many shallow microservices)</h2><p>前述的“浅 - 深模块原理”「shallow-deep module principle」与规模无关，而且，我们还能够把这个原理运用到微服务架构当中。过多的“浅微服务”「shallow microservices」并无益处——行业发展趋势正朝着“宏服务”方向发展，即服务不那么“浅”「shallow」（等同于“深”「deep」）。有一种堪称最糟糕且最难修复的现象，那就是“分布式整体”「distributed monolith」，它通常是过度细化拆分颗粒度所导致的结果。</p><p>我曾经为一家初创公司提供咨询服务，一个仅有五名开发人员的团队推出了包含 17 个(!)微服务的产品。它们的进度比计划落后了将近10个月，并且距离正式发布上线还有很长的路要走。每当有新需求出现，就会涉及4个或者更多的微服务需要修改。在进行集成联调时，诊断问题的难度也是急剧上升。上线所需时间和开发人员的认知负荷都高得令人难以接受。<code>🤯</code></p><p>这是应对新系统不确定性的正确方式吗？一开始就期望找到正确的逻辑边界是极为困难的。关键在于要尽量推迟决策时间，因为越到后期，可供参考的信息就越多，从而能更好地做出决策。如果我们预先确定网络层的设计方案，之后再想修改这个设计就会变得极其艰难。然而，该团队使用此架构的唯一理由是：“FAANG（脸书、亚马逊、苹果、网飞和谷歌）这些公司已经证实了微服务架构是行之有效的”。<em>醒醒吧，别再做不切实际的美梦了</em>。</p><p><a href="https://en.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate">Tanenbaum-Torvalds 辩论</a>指出 Linux 的单体结构「monolithic design」设计是有缺陷并且过时的，应该用微内核架构取而代之。确实，从理论以及美学方面综合考虑，微内核设计似乎更优越。但事实上————三十年过去了，基于微内核的 GNU Hurd 仍在开发中，而采用单体结构的 Linux 无处不在。当前页面由 Linux系统支持的，你的智能茶壶也是由 Linux系统提供支持的。（单体结构的 Linux）。</p><p>经过精心设计且拥有真正隔离模块的单体系统，在很多情况下会比由众多微服务组成的架构更加灵活。同时，维护这样的单体系统所需的认知成本要低得多。只有在单独部署的需求至关重要的情况下，例如扩展开发团队，才应该去考虑在模块之间添加网络层，而这个网络层在未来可能会演变成微服务。</p><h2 id="具有强大特性和功能的语言-Feature-rich-languages"><a href="#具有强大特性和功能的语言-Feature-rich-languages" class="headerlink" title="具有强大特性和功能的语言(Feature-rich languages)"></a>具有强大特性和功能的语言(Feature-rich languages)</h2><p>在我们特别喜爱的某种编程语言推出新的功能特性时，我们往往会兴奋不已。随后，我们会花些时间去学习这些新特性，并在编编码时运用他们。</p><p>要是新特性众多，我们可能会花费半小时去尝试几行代码以使用这些特性，这着实有些浪费时间。然而更糟的是，当你日后再回过头来看这些代码时，你将不得不再次从头梳理整个思考的过程！</p><p><strong>你不但需要全面理解一个复杂的程序，还得弄清自己当初为何认为在这个程序中使用某个特性来解决问题是合理、可行的。</strong><code>🤯</code></p><p>这些内容是Rob Pike提出的。</p><blockquote><p>通过限制可选事物的数量来降低认知过程中的认知负荷。</p></blockquote><p>使用语言特性并无不妥，前提是它们彼此<em>正交「orthogonal」</em>【互独立、不相关】【在这里表示语言特性之间相互独立，不会相互干扰或冲突。】</p><details>  <summary><b>一位拥有20年C++经验的工程师的想法 ⭐️</b></summary>  <br>  前几日，当我浏览我的 RSS 阅读器时，留意到 “C++” 标签下竟有约三百篇未读文章。从去年夏天至今，我未曾读过一篇有关 “C++” 的文章，而这种感觉棒极了！<br><br>  到目前为止，我使用C++已达 20 年之久，这几乎占据了我人生三分之二的时光。我的大部分经验都耗费在处理它那些最为晦涩难懂的部分上（比如各种各样的未定义行为）。这是一种无法复用的经验，如今要将这些经验全部抛开，感觉有些奇妙。<br><br>  举个例子，你能想象吗？<code>||</code>在<code>requires ((!P<T> || !Q<T>))</code> 和 <code>requires (!(P<T> || Q<T>))</code>中有不同的含义。第一种情况是约束析取「constraint disjunction」，第二种情况则是常见的逻辑或「logical OR」运算符，并且它们的行为并不一致。<br><br>  在 C++20 之前，对于普通类型「trivial type」，不能简单地分配空间后直接使用<code>memcpy</code>复制一组字节 —— 这样不会启动对象的生命周期。在 C++20 中，这个问题得到了解决，但语言的认知负荷却不降反增。<br><br>  认知负荷在不断增加，即便问题已经得到了处理。作为专业人士，我需要了解哪些问题被修复了、何时修复以及修复之前的情况。当然，C++ 擅长对遗留代码提供支持，但这也意味着<b>我们会面临</b>那些遗留代码拥有的遗留问题。例如，上个月我的一位同事向我询问了 C++03 中的一些代码行为。<code>🤯</code><br><br>  曾经有 20 种初始化方式。然后统一初始化语法被添加了进来。现在我们有 21 种初始化方式。顺便问一下，有人还记得从初始化列表中选择构造函数的规则吗？是关于以信息损失最小的方式进行隐式转换，<i>但是如果</i>值是静态已知的，那么……<code>🤯</code><br><br>  <b>这种增加的认知负荷并非源于手头的业务任务，也不是领域内在的复杂性所致。仅仅是由于历史原因而存在</b>（<i>外在认知负荷</i>）<br><br>  我不得不制定一些规则。比如，如果某行代码不是很明显易理解，并且我需要记住特定标准时，那么最好不要那样编写代码。顺带一提，标准大概有 1500 页长。<br><br>  <b>我绝不是在指责 C++。</b>我热爱这种语言。只是我现在有些累了。</details><h2 id="业务逻辑和HTTP状态码-Business-logic-and-HTTP-status-codes"><a href="#业务逻辑和HTTP状态码-Business-logic-and-HTTP-status-codes" class="headerlink" title="业务逻辑和HTTP状态码(Business logic and HTTP status codes)"></a>业务逻辑和HTTP状态码(Business logic and HTTP status codes)</h2><p>在后端，我们返回以下内容：</p><p><code>401</code> 表示jwt令牌已经过期</p><p><code>403</code> 表示访问权限不足</p><p><code>418</code> 则是一种趣味设定，表示服务器拒绝冲泡咖啡，因为它其实是个茶壶。「I’m a teapot」</p><p>前端开发人员利用后端的 API 来实现登录功能时，不得不暂时在大脑中承担以下认知负荷：</p><p><code>401</code> 表示jwt令牌过期&#x2F;&#x2F; <code>🧠+</code>，好吧只是暂时在脑子里记一下。</p><p><code>403</code> 表示访问权限不够&#x2F;&#x2F; <code>🧠++</code></p><p><code>418</code> 「I’m a teapot」&#x2F;&#x2F; <code>🧠+++</code></p><p>前端开发人员将（希望）在他们这边引入某种 “数字状态 -&gt; 含义” 字典，这样后续的开发人员就无需在脑海中重现构建这种映射关系了。</p><p>接着，QA人员参与到项目中：“嘿，我收到了<code>403</code>状态码，这是令牌过期了还是权限不足呢？”</p><p><strong>QA 人员无法直接开展测试工作，因为他们首先得重新梳理后端人员创建的认知负荷。</strong></p><p>为什么要在我们的工作记忆中保留这种自定义映射呢？更好的做法是从 HTTP 传输协议中抽象出业务详细信息，并直接在响应正文中返回具有自描述性质的代码，比如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jwt_has_expired&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如此一来，前端开发人员的认知负荷：<code>🧠</code>（刚初始化的“工作记忆”，此时没有认知负荷）</p><p>QA 人员的认知负荷：<code>🧠</code></p><p>同样的规则适用于各种涉及数字的情况，（无论在数据库中还是其他任何地方）。<strong>自描述字符串是一种更好的选择</strong>。毕竟，现在早已不是需要为仅有 640K 内存的计算机优化内存使用的时代了。</p><blockquote><p>人们常常花费时间在 “401” 和 “403” 的含义区别上争论不休，并且依据各自的理解来做出决定。每当有新的开发人员加入，他们需要建立新的思维过程。或许你已经记录了代码的 “设计决策原因”（ADRs）清单，以便新人理解当初你们做的决定。但到头来，这些可能都没什用。我们虽然能够明确地把错误划分成“用户相关”和“服务器相关”的类型。但在这两种类型之外，错误的归属和原因就变得模糊不清了。</p></blockquote><p>P.S. 区分 “认证”「authentication」 和 “授权” 「authorization」通常是一种精神负担。我们可以使用更简单的术语，如 <a href="https://ntietz.com/blog/lets-say-instead-of-auth/">“登录”「login」 和 “权限”「permissions」</a>来降低认知负荷。</p><h2 id="滥用DRY「Do-not-repeat-yourself」原则-Abusing-DRY-principle"><a href="#滥用DRY「Do-not-repeat-yourself」原则-Abusing-DRY-principle" class="headerlink" title="滥用DRY「Do not repeat yourself」原则(Abusing DRY principle)"></a>滥用DRY「Do not repeat yourself」原则(Abusing DRY principle)</h2><p>不要重复编写相同的代码 —— 这是你在软件工程师的学习和工作过程中，被反复灌输的重要原则之一。它植根于我们的观念当中，以至于我们对代码冗余几乎零容忍，哪怕只有几行的重复代码也不行。总体而言，它是一个很好的基本原则，但过度遵循它可能会带来过多的认知负荷，令我们不堪重负。</p><p>当前，人们构建软件时通常基于逻辑分离的组件。这些一般分布在多个代码库中，代表着不同的服务。在你努力消除重复的过程中，可能会使原本不相关的组件变得紧密耦合。这样一来，后续对某个部分的修改可能会在其他看似毫无关联的地方引发意想不到的后果。同时，这也会削弱在不影响整个系统的前提下替换或修改单个组件的能力。<code>🤯</code></p><p>事实上，即使在单模块软件中也会出现类似的问题。你可能会依据自己主观感觉上的相似性（但长远来看可能并不存在）来过早地提取通用功能。而这样做可能会产生不必要的抽象，进而使得软件变得难以修改或扩展。</p><p>Rob Pike 曾经说过：</p><blockquote><p>适当的复制要优于不必要的依赖。「A little copying is better than a little dependency」</p></blockquote><p>我们并不想重新发明那些已经很完善的东西，比如功能强大的 “轮子” 。正因如此，我们愿意引入大型且复杂的库，即使只是为了使用其中一些我们自己本可以轻松编写出来的小函数。</p><p><strong>你所依赖的所有项目都如同你的代码。</strong> 当出现问题时，浏览跟踪 10 层以上的堆栈来找出问题所在，是一件痛苦的事。</p><h2 id="与框架紧密耦合-Tight-coupling-with-a-framework"><a href="#与框架紧密耦合-Tight-coupling-with-a-framework" class="headerlink" title="与框架紧密耦合(Tight coupling with a framework)"></a>与框架紧密耦合(Tight coupling with a framework)</h2><p>框架中存在着许多 “魔力”。如果我们过于依赖框架，<strong>就会迫使所有后续参与开发的人员首先去学习这种 “魔力”</strong>。而这一过程可能耗时数月之久。虽然框架可以帮助我们在短短几天内启动 MVP【最小可行产品】，但长远来看，它们往往会徒增不必要的复杂性和认知负荷。</p><p>更糟的是，在某些情况下，当出现一个与现有架构不匹配的新需求时，框架很可能会对该需求的实现构成极大阻碍。自此，人们会在当前框架基础上开辟新的分支，并维护一个定制版本。设想一下，一个新加入的成员，为了能够开展工作，需要承受多大的认知负荷（即学习这个定制版本的框架）。<code>🤯</code></p><p><strong>但这绝不意味着我们提倡所有东西都从零开始开发！</strong></p><p>我们可以采用不受特定框架束缚的方式来编写代码。例如，业务逻辑不应该被放置在框架内部；相反，它应该通过调用框架所提供的组件来实现。我们可以在核心业务逻辑之外搭建一个框架，用来处理一些通用功能。这样一来，其他开发人员就能够像使用类库一样调用这个框架。这样做能够让新的开发者从一开始就能投入工作，而不必先去了解和框架相关的复杂内容。</p><blockquote><p><a href="https://minds.md/benji/frameworks">为什么我讨厌“框架”「Why I Hate Frameworks」</a></p></blockquote><h2 id="六边形-洋葱架构-Hexagonal-Onion-architecture"><a href="#六边形-洋葱架构-Hexagonal-Onion-architecture" class="headerlink" title="六边形&#x2F;洋葱架构(Hexagonal&#x2F;Onion architecture)"></a>六边形&#x2F;洋葱架构(Hexagonal&#x2F;Onion architecture)</h2><p>在工程学领域，所有这些东西都能带来某种令人兴奋之感。</p><p>多年来，我一直热衷于提倡洋葱架构。在诸多项目中，我都运用了这一架构，并且还积极鼓动其他团队也采用。然而，结果却是项目复杂性大幅增加，光是文件数量就翻了一番。很多时候，我们感觉自己在编写大量的“胶水代码”。随着需求的持续变更，我们不得不对多层抽象结构进行修改，整个开发过程变得枯燥、乏味。<code>🤯</code></p><p>从一个调用跳转到另一个调用，不断地阅读和分析以确定问题所在——这是快速解决问题必备的重要要求。在使用这种洋葱架构多层解耦的情景下，在寻找故障具体位置过程中，可能需要追踪众多看似毫无关联的线索，而且这些线索呈指数级增长的。每一次这样的跟踪都会占用我们有限的工作记忆空间。<code>🤯</code></p><p>这种架构乍一看在直觉上是合理的，但每次当我们在项目中尝试应用时，总会发现其弊大于利。最终，我们彻底放弃了洋葱架构，转而支持被广泛认可的传统依赖倒置原则。如此一来我们<strong>无需学习端口 &#x2F; 适配器概念，也不用引入不必要的水平抽象层，从而避免了承受与之相关的不必要的认知负荷。</strong></p><blockquote><p>需知，不要为了架构而盲目添加抽象层。只有当你出于实际需求且需要合理扩展时才考虑添加。**<a href="https://blog.jooq.org/why-you-should-not-implement-layered-architecture">抽象层并非毫无代价的【Layers of abstraction aren’t free of charge】</a>，它们会占据我们的工作记忆空间**</p></blockquote><p>倘若你认为这种分层方式能够让你迅速地更换数据库或者其他的依赖对象，那就大错特错了。更改存储往往会引发诸多问题，相信我们，对数据访问层进行抽象往往是最不该考虑的事情。即便是在最好的情况下，抽象或许能节省 10% 的迁移时间（如果有的话），但真正棘手的是数据模型无法兼容、通信协议问题、分布式系统挑战和<a href="https://www.hyrumslaw.com/">隐式接口</a>问题。<strong>所以，如果这种架构在未来不能带来回报，我们又为什么要为其承担高认知负荷的代价呢？</strong> 而且，在大多数情况下，未来可能根本不会出现更换某些核心组件的需求。</p><p>虽然这些分层架构促使应用程序从“以传统数据库为中心”向“不依赖基础设施”「 infrastructure-independent」转变，使应用的核心业务逻辑独立于外部事物。但这种理念并非创新之举。</p><p>这些架构并非最基础的架构，它们是在更基础的架构基础上，因主观和偏见而产生的。我们为何要遵循这些主观偏见呢？更好的做法是遵循依赖倒置原则、重视认知负荷和信息隐藏这些基础架构理念。【<a href="https://github.com/zakirullin/cognitive-load/discussions/24">讨论</a>】</p><h2 id="领域驱动设计-DDD"><a href="#领域驱动设计-DDD" class="headerlink" title="领域驱动设计(DDD)"></a>领域驱动设计(DDD)</h2><p>尽管领域驱动设计「DDD」常常遭受误解，但其在某些方面的确有卓越之处。</p><p>人们通常说的 “我们用 ‘DDD’ 写代码”，这种说法其实是有些奇怪的，因为 DDD 是和“问题空间「problem space」”相关的，而不是和“解决方案空间「solution space」”相关的。</p><blockquote><p>译注：</p><ul><li><p>problem space: 问题空间，简单理解就是当前环境下业务所面临的一系列问题和背后的需求。</p></li><li><p>solution space: 解决方案空间，则是针对问题空间的解决方案，它思考的是如何设计实现软件系统以解决这些问题，它属于工程设计实施阶段，通常是技术专家主导的解决方案设计和实现。</p></li></ul></blockquote><p>无处不在的语言、领域、有界上下文「bounded context」、聚合、事件风暴「event storming」等概念都属于问题空间的范畴。它们旨在协助我们洞察领域并确定其边界。DDD 能够让开发人员、领域专家和业务人员使用一种统一的语言来实现高效沟通。然而，我们往往侧重于特定的文件夹结构、服务、存储库之类的解决方案空间技术，却忽略了 DDD 在问题空间方面的价值。</p><p>我们对DDD的阐释很有可能具有独特性和主观性。如果我们依照这种理解来构建代码（即如果我们制造了很多无关的认知负荷），那么未来的开发人员注定要失败。<code>🤯</code></p><h2 id="示例-Examples"><a href="#示例-Examples" class="headerlink" title="示例(Examples)"></a>示例(Examples)</h2><ul><li>我们的架构是标准的 CRUD 应用架构，是<a href="https://danluu.com/simple-architectures/">基于Postgres 的 Python 单体应用</a></li><li>Instagram 如何在仅有 <a href="https://read.engineerscodex.com/p/how-instagram-scaled-to-14-million">3 名工程师</a> 的情况下，将用户规模扩展到的 1400 万的呢？</li><li>我们喜爱的公司 “哇，这些人 <a href="https://kenkantzer.com/learnings-from-5-years-of-tech-startup-code-audits/">聪明绝顶</a>” ，却在很大程度上遭遇了失败。  </li><li>有一个功能连接着整个系统。如果你想知道系统是如何运作的 - <a href="https://www.infoq.com/presentations/8-lines-code-refactoring">请阅读</a></li></ul><p>这些架构相当枯燥，也很容易理解，任何人都能轻松掌握，无需耗费太多脑力。</p><p>安排初级开发人员参与架构审查。他们会助力你识别出那些对心智要求颇高的代码。</p><h2 id="熟悉的项目中的认知负荷-Cogitive-load-in-familiar-projects"><a href="#熟悉的项目中的认知负荷-Cogitive-load-in-familiar-projects" class="headerlink" title="熟悉的项目中的认知负荷(Cogitive load in familiar projects)"></a>熟悉的项目中的认知负荷(Cogitive load in familiar projects)</h2><blockquote><p>问题在于，熟悉并不等同于简单。二者给人的<em>感觉</em>看似是一样的 —— 都能让人不用费太多脑力就能轻松地在代码之间穿梭 —— 但原因却截然不同。你所使用的每一个 看似“聪明”（实则是“自我放纵”）和非惯用的技巧，都会让其他人在学习时备受折磨。一旦他们完成学习，他们使用代码的难度便会降低。因此，要认识到如何去简化自己已经熟悉的代码并非易事。这就是我为何要让 “新来的孩子” ，趁着在代码对他而言还没变得过于僵化之前，对代码进行审视！</p><p>很可能之前的作者，是逐步造就了这一巨大混乱的代码。而你是第一个试图一次性理解它的人。</p><p>在我的课堂上，我曾描述过我们有一天见到的一个庞大的 SQL 存储过程，其巨大的 WHERE 子句中包含了数百行条件语句。有人问，怎么会有人能把它弄得如此糟糕。我告诉他们：“当只有两三个条件语句时，再添加一个似乎没有影响。当有二三十个条件语句时，再另添加一个看起来也没差！”</p><p>除了你有意为之的选择之外，代码库并不会受到任何 “简化之力”的作用。简化需要付出努力，然而人们却经常无暇顾及。</p></blockquote><p>如果你已经将这个项目的心理模型内化到长期记忆中，你就不会承受高认知负荷。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412302152104.png" alt="img"></p><p>需要学习的心智模型越多，新开发人员开始投入工作所需的时间就越长。</p><p>一旦有新人加入你的项目，就尝试去衡量他们的困惑程度（结对编程或许会有所帮助）。倘若他们持续困惑的时间超过 40 分钟，——意味着你的代码存在需要改进之处。</p><p>若你的项目能保持较低的认知负荷，那么新员工在入职后的最初几个小时内，就能为公司的代码库贡献力量。</p><h2 id="结论-Conclusion"><a href="#结论-Conclusion" class="headerlink" title="结论(Conclusion)"></a>结论(Conclusion)</h2><p>想象一下，我们在第二章中推断的并非真实情况。倘若如此，那么我们刚刚否定的结论，以及上一章中我们认为有效的结论，或许也不是正确的。<code>🤯</code></p><p>你感觉到了吗？你不仅需要在文章中来回跳转才能理解其含义（浅模块「shallow modules」！），而且段落总体上也很难理解。我们刚刚在你的脑海中制造了不必要的认知负荷。<strong>请不要对你的同事这样做。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412302152430.png" alt="img"></p><p>我们应当减少一切超出工作本身所带来的认知负担。</p><hr><details>  <summary><b>认知负担与干扰因素(Cognitive load and interruptions)</b></summary>  <img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412302153832.jpeg"><br></details><details>  <summary><b>编码原理和经验(Coding principles and experience)</b></summary>  <img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412302153285.png"><br></details>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 认知负荷 </tag>
            
            <tag> 技术债务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法论-学习的方法</title>
      <link href="/2024/07/13/%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2024/07/13/%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>从认知科学的角度来看，大脑的特性对学习有着深远影响。其奖励系统倾向于即时利益，使得人们在面对长远目标的学习任务时，容易缺乏动力。同时，大脑处理信息的方式也决定了学习效率，例如频繁切换任务会损耗认知资源，影响学习效果。此外，学习环境、个人心态以及学习方法的合理性等因素，都在不同程度上左右着学习的成效。</p><span id="more"></span><h2 id="一、让学习成为一件开心和享受的事情，而非排斥和延误"><a href="#一、让学习成为一件开心和享受的事情，而非排斥和延误" class="headerlink" title="一、让学习成为一件开心和享受的事情，而非排斥和延误"></a>一、让学习成为一件开心和享受的事情，而非排斥和延误</h2><ul><li><p>增加正向反馈</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Q:为什么很多人有很远大的目标和理想，但每到学习时动力不足或无法坚持？</span><br><span class="line">A:主要因为远大理想的实现，需要很久才能得到反馈和奖赏，而人的大脑，只喜欢看到眼前利益，这与个人意志关系不大，主要与大脑存在的奖励系统有关，其更愿意获取立即得到的好处，而非延迟满足，很多人减肥也是同样的问题。</span><br></pre></td></tr></table></figure></li><li><p>减少负向峰值</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">人们对一切人、事、物的感受，主要是由峰值和终值两个因素决定。峰值是指这段体验中的最高峰，包括正向和负向；终值是指这段体验结束时给你的感觉。 </span><br><span class="line"></span><br><span class="line">Q:如何避免出现负向的峰值？</span><br><span class="line">A:在学习的过程中，穿插安排喜欢且擅长的环节，而不是一直死磕艰难的任务，这是保持愉悦和高效学习的重要方法。</span><br><span class="line">避免长时间的学习，最好的是工作与休息相结合，考虑使用番茄时钟法，工作45分钟后，休息10分钟的方式。</span><br><span class="line"></span><br><span class="line">Q:如何避免出现负向终值？</span><br><span class="line">A:在制定计划的时候，量力而行，不要制定完不成的:A:在制定计划的时候，量力而行，不要制定完不成的计划</span><br><span class="line">详细记录当天具体的时间使用情况、事情完成情况，将学习成果具象化，从每天的学习中获取正反馈，提升自己的学习态度，让努力学习这件事情，坚持下去。</span><br></pre></td></tr></table></figure></li><li><p>避免同时处理太多类型任务</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大脑处理不同事情，是需要思考及回忆事情的上下文环境的，频繁的切换处理事情，就会造成学习效率的下降。这跟电脑cpu处理任务一样，切换任务本身也是有损耗。</span><br><span class="line">同时，过多的事情，也会给自身造成大小不一的心里压力，试想一下，每天完成10件事情与完成3件事情的差异。</span><br><span class="line">通常重要的事情，我认为3件就已经很好了，当然也要根据自己的事情情况，合理安排任务的数量。</span><br></pre></td></tr></table></figure></li><li><p>调整认知，不要以某种标准框架限制自己，认知做好每一步，注重做事本身</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">学习时候，不要以某种标准框架限制自己，不要总对自己的表现评头论足，更不必急着追求某种结果，而是踏踏实时做好每一步，注重做事本身，将努力变成习惯，最终必将有所收获。</span><br><span class="line">举个例子：如果你很纠结自己的睡眠，想着，我一定要在 10 分钟之内睡着，我一定要以仰卧的姿势入睡。那完了，你很可能睡不着了，你会发现睡觉成了一件压力很大的事情。</span><br><span class="line">心理学界有个概念，叫做“成就目标”，其包括“掌握目标”和“成绩目标”两种类型，前者是指“掌握知识和提高能力”,后者是指“好名次和好成绩”。</span><br><span class="line">如果一个人把“掌握目标”作为努力的重心，TA 会明白，遇到问题和遭受失败，是很正常的，它们是成长过程的一部分。任何事情、任何能力的发展，都是螺旋式上升的过程，对自己，对事情，你要有足够的容错空间。</span><br><span class="line">以“掌握目标”为导向，才能真正达成“成绩目标”。也就是说，专注于耕耘，会让你在心理上更愉悦，也会有更好的收获。</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、避免伪勤奋，若是宁愿不学"><a href="#二、避免伪勤奋，若是宁愿不学" class="headerlink" title="二、避免伪勤奋，若是宁愿不学"></a>二、避免伪勤奋，若是宁愿不学</h2><ul><li><p>伪勤奋是什么，如何避免花大量的时间去做容易得事情</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Q:伪勤奋和真勤奋是什么？</span><br><span class="line">A:伪勤奋：在完成事情过程中，只愿意去做自己习惯的，轻松地，而实际上这些事情，本身不会带来太大的学习收获和成长，这就是伪勤奋。</span><br><span class="line">真勤奋：需要客服困难，完成那些需要思考、做出努力和行为的的任务，才是真勤奋。当然任务难度设置也不宜太高，否则打击自信，稍微努力、踮踮脚就能做到的，</span><br><span class="line"></span><br><span class="line">举个例子：学习过程中，仅仅去看视频、而不去做其他，其实是错误的，实际上这仅仅是获取知识最简单的一步，对知识的记忆、应用、输出才是最重要的环节。</span><br></pre></td></tr></table></figure></li><li><p>功利学习，理解检测自己获得了什么，能解决什么问题</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">学到的东西，要立刻检测，监测自己有没有记住，监测自己会不会使用，能不能去解决现实问题，学习时，也可以自问自答的形式。</span><br><span class="line">比如想去做菜，只是购买食材、观看食谱，而不去真正的做一道菜，那真正用到的时候，肯定味道不怎么样。</span><br><span class="line">对于真正的勤奋来说，再功利主义也不为过，要看到反馈，要立刻看到反馈，一些不以检测和输出为目的的学习，都是耍流氓。</span><br></pre></td></tr></table></figure></li><li><p>复盘总结规律及发现不足，而不是傻学</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">学习这件事，不仅包括对知识的学习，还包括学习方法的学习，学会思考、观察、总结、反馈调整以及应用。</span><br><span class="line">明白自己是如何学习的，学习的怎么样，然后对方法进行针对性的调整和完善，有意识的知道自己接下来的努力方向。</span><br></pre></td></tr></table></figure></li><li><p>道德许可效应，让你原地徘徊，沉迷与已经努力的幻觉中</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Q:对于道德许可效应，我们应该怎么做？</span><br><span class="line">A:做某件事或实现某个目标时，只是付出了一些努力，距离完成还远着呢，就觉得自我良好，放纵自己，这就是道德许可效应。比如做了一些好的事情后，就会倾向于做一些坏的、堕落的事情，导致跑坏自己的努力。就像减肥这件事，每天坚持锻炼，锻炼一周后，自我安慰，我吃点巧克力把，放纵下自己。</span><br><span class="line"></span><br><span class="line">Q:如何避免道德许可效应，影响到自己？</span><br><span class="line">A:将要做的事情简单化，去掉所有花里胡哨的，不高形式主义，直接开始，在具体的实践过程和见习中，持续完成自己的准备工作。</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、检索式练习的方式学习"><a href="#三、检索式练习的方式学习" class="headerlink" title="三、检索式练习的方式学习"></a>三、检索式练习的方式学习</h2><ul><li><p>调整认知，以检索问答输出式来学习，让自己在重要场合也能正常发挥</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大部分人的学习模式，是先埋头苦读，再去考试，认为只要自己背下来，在用的时候，如考场上，就能解决任何问题。</span><br><span class="line">但事实真不是这样，考场更多是输出，而学习是在输入，考场确实在应用，将知识输出，需要主动且快速的回想知识点，并提取出来，很好的写或者表达出来。</span><br><span class="line">所以换种思维吧，在学习时候，就以问答这种边输入边输出方式锻炼提升自己；另外即用即学和即学即用，才能对知识点有透彻的理解和记忆，使用时，才能做到更为高效准确地调取，以及运用。</span><br><span class="line">“检索式练习”是最为有效的学习方式，它是指通过提问和主动回想的方式，去巩固知识点。你在回想知识点的时候，所付出的认知努力越大，学习和记忆的效果就越好</span><br></pre></td></tr></table></figure></li><li><p>知彼知己，百战不生，面对考试也是如此，提前做好准备</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">举个例子，准备某个考试前，需要做好往期考试题的研究和分析，明确出题范围和出题思路；再去分析考试，具体会用到哪些知识点，怎样才能快速提取，进一步去运用知识点；最后，就到了做计划时候了，明确学什么、怎么学。</span><br><span class="line">一种小技巧，找到标准答案，分析答案，明确答案为什么能获取高分，具备哪些因素好要素，满足了那些标准。</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、面对重要场合，如何保持心态，正常发挥"><a href="#四、面对重要场合，如何保持心态，正常发挥" class="headerlink" title="四、面对重要场合，如何保持心态，正常发挥"></a>四、面对重要场合，如何保持心态，正常发挥</h2><ul><li><p>减少失败心里作祟，直面及接受最坏情况，集中精力去解决问题</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">工作记忆是有限的</span><br><span class="line">通常解决问题时候，存在一个用于存放信息和加工信息的记忆系统，叫做“工作记忆”，类似电脑中的内存，虽然可以很快提取和处理内容，但其容量有限。当然其存储和处理信息越多，则代表着解决问题的能力越强。</span><br><span class="line">焦虑占用了工作记忆，导致发挥失常</span><br><span class="line">当我们在面对重要场合时之所以发挥失常，主要是因为过于担忧结果，纠结自己的表现，这样则相当于一部分工作记忆被焦虑占用，真正用于解决问题的容量则变少了，这就是发挥失常的本质原因。</span><br><span class="line">接受最坏情况，直面问题，并集中精力去解决问题而非焦虑</span><br><span class="line">卡瑞尔万灵公式，指的是唯有强迫自己面对最坏的情况，在精神上先接受了它以后，才会使我们处在一个可以集中精力解决问题的地位上。</span><br><span class="line">具体步骤三步走：</span><br><span class="line">1.反问自己，事情发生的最坏情况是什么</span><br><span class="line">2.接受这种最坏情况，提前感受失败后的心理</span><br><span class="line">3.面对失败，冷静下来分析该怎样改善最坏的情况</span><br><span class="line">我们都会不可避免地遭遇困难。困难并不可怕，可怕的是你不能接受事实，不能在困境中寻找方法，不能为解决困难付出努力。如果不能保持清醒，寻找方法，那就注定在困难中消沉下去。</span><br></pre></td></tr></table></figure></li><li><p>减少自我怀疑，与其怀疑学习方法对不对，不如花费时间验证下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在工作学习中，常常陷入自我怀疑，学习的方法，工作的方式等等，这占用了很多的工作记忆，影响学习效率。</span><br><span class="line">最好的解决办法就是限定一小时，用眼下的方法，去专注学习，若中间有更好的想法，记录下来，在一小时后，在花点时间对学习方法进行调整完善。不要着急，学习本身就是一个过程，先易后难，前期建立基本认知后，效率会逐步提高，学习的方法也会逐渐完善，记住学习就是一个复利的事情，匀加速状态。</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、避免走神，提升专注力，进入心流学习状态"><a href="#五、避免走神，提升专注力，进入心流学习状态" class="headerlink" title="五、避免走神，提升专注力，进入心流学习状态"></a>五、避免走神，提升专注力，进入心流学习状态</h2><ul><li><p>专注力是什么，如何让自己持续专注，重新专注更重要</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所谓专注力，主要体现在两方面，一方面、专注于做一件事若干时长的能力；另一方面、走神字后，如何重新恢复自己的专注力。而后者才是更为重要的能力。</span><br><span class="line">一个人专注的市场，其实是有限的，研究发现专注的市场一般在30-50分钟内，所以走神是正常的。</span><br><span class="line">故而，实际上，保持专注的能力才是我们需要提升的，也是在“专注-走神-重新专注-走神-继续专注”整个过程中，不断训练提升的。</span><br></pre></td></tr></table></figure></li><li><p>如何提升专注力，并提升专注时的效率</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">心理学界有一个概念，称作心流。积极心理学家米哈里·契克森米哈赖，把完全投入、十分专注于眼前行为时的心理状态,称为“心流”,并认为这是我们获得幸福的一种途径。可以帮助我们从忧虑感和压力中解脱出来。</span><br><span class="line">只有在“注意状态”下，我们才能对知识、概念、事物更加透彻的理解和学习，提升专注力，可以从以下几个方面来：</span><br><span class="line">互动要记关键词</span><br><span class="line">听课时，不要被动的听，要在心里默默重复老师某句话中的核心关键词</span><br><span class="line">笔听课时，主动的、有思考的、有取舍的记录笔记</span><br><span class="line">读书时，寻找关键语句划线，也是一种互动方式</span><br><span class="line">背诵东西时，仅仅默默重复是容易走神的，出生背诵或用笔写写画画</span><br><span class="line">带着问题去探索</span><br><span class="line">带着问题会让心更专注，学习时，可以想自己提问，比如这个知识点概念是什么，有什么用，能解决什么问题，与现实生活的什么问题类似或有联系？</span><br><span class="line">默念解焦虑</span><br><span class="line">默念就是不出声的对话，在心里一问一答的形式与自己对话，他能够帮助我们忘记恐惧和焦虑，全部注意力集中在当前的问题上，甚至可以在一定程度上做到超长发挥。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限流系统设计思路</title>
      <link href="/2024/06/23/%E9%99%90%E6%B5%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
      <url>/2024/06/23/%E9%99%90%E6%B5%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>在当今高并发的互联网环境中,限流系统扮演着至关重要的角色。请设计一个可靠、高效的限流系统,能够有效控制API的访问频率,防止系统被滥用或过载。你的设计应该能够适应不同的限流策略,并在分布式环境中保持一致性。此外,考虑如何处理突发流量,以及如何与现有的API网关无缝集成。<br>假设系统需要每秒处理10万次请求,并支持多种限流粒度(如按用户、IP或API端点)。请在你的设计中解释如何实现这些需求,并讨论可能面临的挑战及其解决方案。</p><span id="more"></span><p>💡提示1<br>在开始设计之前,仔细思考系统的核心需求。除了基本的限流功能,还需要考虑哪些非功能性需求?例如,系统的延迟要求、可用性目标等。</p><p>💡提示2<br>API设计是系统的门面,直接影响使用体验。思考如何设计既灵活又简洁的API,使其易于集成且能满足各种限流场景。</p><p>💡提示3<br>限流算法是系统的核心。固定窗口、滑动窗口、漏桶、令牌桶等算法各有特点,如何选择或组合使用这些算法来满足不同的限流需求?</p><p>💡提示4<br>在分布式环境中实现一致的限流是一个挑战。考虑使用分布式缓存或共识算法来解决这个问题。同时,思考如何在保证致性的同时不影响系统性能。</p><p>💡提示5<br>系统的可观测性和可维护性也很重要。设计一个健壮的监控和告警系统,使运维团队能够快速发现和解决问题。同时,考虑如何支持动态调整限流规则,以适应不断变化的业务需求。</p><hr><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li>功能性需求<ul><li><strong>多粒度限流</strong>：支持按用户、IP、API 端点等不同维度进行访问频率限制，精准控制各类请求来源和目标的流量。</li><li><strong>多种限流策略适配</strong>：可运用如固定窗口、滑动窗口、漏桶、令牌桶等不同限流算法，或者将它们组合使用，以应对不同业务场景下的限流需求，例如平滑流量、限制突发流量等。</li><li><strong>与 API 网关集成</strong>：能够无缝嵌入现有的 API 网关，在请求到达后端服务前进行限流判断，确保对业务系统的低侵入性和良好兼容性。</li><li><strong>处理突发流量</strong>：具备应对突发流量的能力，在短时间内出现大量请求时，可通过合理机制保证系统不会因过载而崩溃，同时尽量满足合法请求的处理。</li></ul></li><li>非功能性需求<ul><li><strong>低延迟</strong>：单个请求的限流判断处理时间应尽量短，保证整体系统响应速度，理想情况下将延迟控制在毫秒级别，以满足高并发场景下的高效处理需求。</li><li><strong>高可用性</strong>：系统需具备高可靠性，能在复杂的网络环境、硬件故障等情况下持续稳定运行，确保限流功能正常发挥，可用性目标设定在 99.9% 及以上。</li><li><strong>可扩展性</strong>：随着业务发展，请求量不断增加，系统应方便进行水平扩展，通过增加节点等方式轻松应对更高的负载压力，保障服务质量不受影响。</li><li><strong>可观测性与可维护性</strong>：设计完善的监控和告警系统，实时收集如请求流量、限流状态、系统资源使用等关键指标，且支持动态调整限流规则，便于运维团队及时发现并解决问题，同时能灵活适配业务变化。</li></ul></li></ul><h3 id="容量估算"><a href="#容量估算" class="headerlink" title="容量估算"></a>容量估算</h3><ul><li><strong>请求处理能力</strong>：已知系统需要每秒处理 10 万次请求，基于此，在硬件资源规划上，需考虑服务器的 CPU 核心数、内存大小以及网络带宽等因素。例如，选用多核高性能 CPU，配置足够的内存（如根据经验和测试预估每万次请求处理需占用一定内存量来综合确定总内存容量），确保网络带宽能够满足每秒 10 万次请求及相应响应数据的传输需求（考虑请求和响应数据的平均大小来估算带宽）。</li><li><strong>存储容量估算</strong>：对于存储限流规则、各维度请求统计数据、缓存数据等方面，要根据预计的限流规则数量、不同粒度下统计数据的保存时长（如按分钟、小时等统计的请求次数等数据保留一定时间范围）以及缓存的使用策略等来估算所需的数据库存储空间和缓存容量。比如，若有大量不同的 API 端点、用户和 IP 需要进行限流，相应的规则配置数据量会较大，需分配足够的数据库空间用于存储；同时，缓存要能容纳各限流维度的实时状态数据，防止频繁的缓存淘汰和写入对性能产生影响。</li></ul><h3 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h3><ul><li>规则配置 API<ul><li><code>POST /rate-limiting/rules</code>：用于创建新的限流规则，请求体中包含 <code>granularity</code>（限流粒度，取值如 <code>user</code>、<code>ip</code>、<code>api-endpoint</code> 等）、<code>algorithm</code>（限流算法，如 <code>fixed-window</code>、<code>sliding-window</code>、<code>leaky-bucket</code>、<code>token-bucket</code> 等）、<code>threshold</code>（限流阈值，根据不同算法和场景设定单位时间内的请求数量等限制条件）、<code>time-unit</code>（时间单位，如 <code>second</code>、<code>minute</code> 等）等参数，方便运维人员或自动化配置系统创建各种限流规则。</li><li><code>PUT /rate-limiting/rules/&#123;rule-id&#125;</code>：通过指定规则的 <code>rule-id</code>，可更新对应限流规则的部分或全部参数，如修改阈值、更换算法等，满足业务变化后对规则调整的需求。</li><li><code>DELETE /rate-limiting/rules/&#123;rule-id&#125;</code>：用于删除指定 <code>rule-id</code> 的限流规则，实现对不再需要的规则进行清理。</li></ul></li><li>状态查询 API<ul><li><code>GET /rate-limiting/status/&#123;granularity&#125;/&#123;identifier&#125;</code>：其中 <code>granularity</code> 表示限流粒度（如 <code>user</code>、<code>ip</code>、<code>api-endpoint</code> 等），<code>identifier</code> 为对应粒度下的具体标识（如用户 ID、IP 地址、API 端点名称等），通过此接口可获取特定限流维度的实时状态信息，包括当前请求次数、是否达到限流阈值、若采用令牌桶算法则返回剩余令牌数量等，便于运维人员实时掌握系统运行情况和限流效果。</li></ul></li><li>动态调整 API<ul><li><code>PATCH /rate-limiting/rules/&#123;rule-id&#125;</code>：针对已有的限流规则（通过 <code>rule-id</code> 指定），可对其关键参数进行部分修改，如在业务高峰期动态增加限流阈值、改变令牌桶的令牌生成速率等，无需重启系统即可实现对限流规则的灵活调整，以适应业务流量的实时波动。</li></ul></li></ul><h3 id="系统概要设计"><a href="#系统概要设计" class="headerlink" title="系统概要设计"></a>系统概要设计</h3><ul><li><strong>API 网关集成层</strong>：通过开发适配插件或中间件的形式，与现有的 API 网关进行对接，拦截发往后端服务的 API 请求，并将请求传递给限流处理层。同时，将限流处理的结果（允许或拒绝访问）及时反馈给客户端，确保整个过程对业务系统的透明性和无缝衔接。</li><li>限流处理层<ul><li><strong>规则获取模块</strong>：从规则配置存储中读取相应的限流规则，根据请求的不同限流粒度（用户、IP、API 端点等）查找匹配的规则，为后续限流判断提供依据。</li><li><strong>算法执行模块</strong>：依据获取到的规则中指定的限流算法（如固定窗口、滑动窗口、漏桶、令牌桶等），结合分布式缓存中存储的各限流维度的实时状态数据（如请求计数、令牌数量等），对请求进行限流判断，决定是否允许请求通过。在此过程中，可根据不同业务场景灵活组合使用算法，以达到最佳限流效果。</li><li><strong>突发流量处理模块</strong>：实时监测流入请求的流量情况，当检测到突发流量（通过与预设的流量阈值对比判断）时，启动相应的应对机制，如动态调整令牌桶参数（增加桶容量、加快令牌生成速率等）或者将请求放入流量缓冲队列，按照系统可承受的速率进行处理，避免系统过载。</li></ul></li><li><strong>规则配置存储层</strong>：采用数据库（如关系型数据库 MySQL 或非关系型数据库 MongoDB 等，根据实际需求选择）存储所有的限流规则信息，提供稳定、可靠的数据持久化服务，支持对规则的增删改查操作，同时要保障数据的一致性和完整性，方便运维人员进行规则管理。</li><li><strong>分布式缓存层</strong>：利用分布式缓存系统（如 Redis）存储各限流维度的实时状态数据，在分布式环境下，各个节点通过访问该缓存来保证限流判断的一致性。缓存需具备高性能读写能力，通过合理的缓存策略（如设置过期时间、缓存淘汰机制等）确保数据的时效性和有效性，同时要处理好缓存与数据库的数据同步问题，防止数据不一致。</li><li>监控与告警层<ul><li><strong>监控模块</strong>：收集并统计各类关键指标数据，包括各 API 端点、不同限流粒度下的请求流量（请求数量、请求速率等）、限流状态（触发次数、剩余令牌数量等）以及系统自身资源占用情况（CPU、内存、网络带宽等），将这些数据进行可视化展示（通过仪表盘等形式），方便运维人员直观了解系统运行状态。</li><li><strong>告警模块</strong>：根据预设的阈值和监控指标的异常变化情况（如请求量持续超标、系统资源紧张等），通过多种渠道（如邮件、短信、即时通讯工具等）及时向运维团队发送告警信息，以便快速响应和解决问题。</li></ul></li></ul><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    subgraph 客户端层</span><br><span class="line">        A[客户端请求] --&gt; B[API网关]</span><br><span class="line">    end</span><br><span class="line">    subgraph 限流处理层</span><br><span class="line">        B --&gt; C[限流中间件/插件]</span><br><span class="line">        C --&gt;|获取规则| D[规则配置中心]</span><br><span class="line">        C --&gt;|获取状态| E[分布式缓存]</span><br><span class="line">        C --&gt; F[限流算法引擎]</span><br><span class="line">        F --&gt;|允许请求| G[请求转发至后端服务]</span><br><span class="line">        F --&gt;|拒绝请求| H[返回限流响应至客户端]</span><br><span class="line">    end</span><br><span class="line">    subgraph 数据存储与监控层</span><br><span class="line">        D --&gt; I[关系型数据库]</span><br><span class="line">        E --&gt; J[分布式缓存集群]</span><br><span class="line">        K[监控与告警模块] --&gt;|收集数据| C</span><br><span class="line">        K --&gt;|收集数据| E</span><br><span class="line">        K --&gt;|收集数据| G</span><br><span class="line">        K --&gt;|触发告警| L[运维人员]</span><br><span class="line">    end</span><br><span class="line">    subgraph 后端服务层</span><br><span class="line">        G --&gt; M[后端业务服务]</span><br><span class="line">        M --&gt; N[响应返回至API网关]</span><br><span class="line">        N --&gt; B</span><br><span class="line">        B --&gt; O[响应返回至客户端]</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h4 id="请求数据流"><a href="#请求数据流" class="headerlink" title="请求数据流"></a>请求数据流</h4><!--TODO--><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><ul><li><strong>限流规则表</strong>：记录每条限流规则的详细信息，包括规则 ID、限流粒度（用户 ID、IP、API 端点等字段标识）、限流阈值（如每分钟请求次数数值）、限流策略（算法类型标识）、生效时间范围等字段，方便进行规则的管理和查询。</li><li><strong>访问计数表</strong>：针对不同的限流粒度分别记录其访问次数统计信息，包含限流维度标识（与限流规则表对应）、时间窗口（如按分钟划分的时间戳）、已访问次数等字段，用于实时判断是否达到限流条件。</li></ul><h4 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h4><ul><li><strong>令牌桶算法</strong>：适用于应对突发流量场景。系统以固定的速率往桶中放入令牌，每个请求需要获取一个令牌才能被处理，如果桶中没有令牌则表示达到限流阈值，请求被拒绝。令牌桶可以设置合适的桶容量，允许在短时间内积攒一定的令牌，从而应对突发的高流量请求，避免瞬间大量请求被全部拒绝。</li><li><strong>滑动窗口算法</strong>：相较于固定窗口算法，能更平滑地控制流量，避免窗口边界处的流量尖峰问题。将时间划分为多个小的时间窗口，统计每个窗口内的请求次数，通过滑动窗口的方式动态计算最近一段时间内的请求总量，判断是否超过限流阈值，更精准地实现限流，尤其适用于对流量控制精度要求较高的场景。</li><li><strong>组合使用</strong>：可以根据不同的 API 端点或者业务重要性等因素，灵活选择不同的算法或者组合使用。例如对于重要的核心 API 采用滑动窗口算法精确控制流量，对于一些允许一定突发流量的非关键 API 使用令牌桶算法，以提高系统整体的资源利用率和用户体验。</li></ul><h4 id="分布式实现"><a href="#分布式实现" class="headerlink" title="分布式实现"></a>分布式实现</h4><ul><li><strong>分布式缓存（如 Redis）</strong>：利用 Redis 的原子操作特性，将各限流维度下的访问计数等关键数据存储在 Redis 中，不同节点的限流模块在处理请求时，通过 Redis 进行数据的读写操作，保证在分布式环境下数据的一致性和准确性。例如，使用 Redis 的 INCR 命令对访问次数进行原子自增操作，然后与限流阈值比较来判断是否限流。</li><li><strong>分布式锁（如基于 Redis 的分布式锁）</strong>：在更新限流规则等涉及并发操作的场景下，使用分布式锁来保证同一时刻只有一个节点能进行规则的修改操作，避免数据不一致问题。同时，要注意合理设置锁的超时时间等参数，防止出现死锁情况。</li></ul><h3 id="技术选择与权衡取舍"><a href="#技术选择与权衡取舍" class="headerlink" title="技术选择与权衡取舍"></a>技术选择与权衡取舍</h3><ul><li><strong>接入层与 API 网关集成</strong>：选择与现有 API 网关适配性好的技术框架，如使用插件机制或者中间件方式进行集成，权衡是采用开源的网关插件还是自研的集成方案，考虑开源方案的社区支持和功能丰富度以及自研方案的定制性和安全性等因素。</li><li><strong>限流核心算法实现</strong>：选择高效、成熟的编程语言（如 Java、Go 等）来实现限流算法，Java 具有丰富的类库和生态，但相对内存占用可能稍高；Go 语言在高并发处理上性能优势明显且内存占用少，但生态相对没有 Java 那么丰富。权衡语言特性和团队技术栈来进行选择。</li><li><strong>数据存储</strong>：使用 Redis 作为分布式缓存，看重其高性能、支持多种数据结构以及原子操作等优点，但要注意其内存使用限制以及数据持久化策略的配置，避免数据丢失。搭配关系型数据库（如 MySQL）用于持久化重要配置和统计数据，权衡查询性能和数据一致性等方面的需求。</li></ul><h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><ul><li><strong>缓存故障</strong>：如果分布式缓存（如 Redis）出现故障，可设置缓存降级机制，临时从本地内存或者备用缓存中读取限流相关数据（可能数据不是最新的，但能保证基本限流功能），同时及时告警，让运维人员尽快修复 Redis 故障，恢复正常的数据同步和更新机制。</li><li><strong>算法异常</strong>：针对限流算法可能出现的边界情况或者逻辑错误导致的异常，如令牌桶算法中令牌数量计算错误等，在代码中添加完善的异常捕获和日志记录机制，方便定位问题。同时可以设置兜底的限流策略（如统一采用较为严格的固定阈值限流），防止因算法异常导致系统被过度请求冲击。</li><li><strong>网络故障</strong>：在接入层与 API 网关或者限流核心层与数据存储层等之间的网络出现问题时，启用网络重试机制（设置合理的重试次数和时间间隔），同时切换到备用网络链路（如果有配置）或者进行降级处理，保证系统能在一定程度上继续运行，减少对业务的影响。</li></ul><h3 id="扩展性和未来改进"><a href="#扩展性和未来改进" class="headerlink" title="扩展性和未来改进"></a>扩展性和未来改进</h3><ul><li><strong>横向扩展</strong>：随着业务发展，流量不断增加，可通过增加服务器节点的方式对限流系统进行横向扩展，在分布式架构下，只需要将新节点配置好接入到现有系统中，利用负载均衡机制（如 Nginx 等）均匀分配请求到各个节点，就能提升系统整体的处理能力，满足更高的并发请求需求。</li><li><strong>功能扩展</strong>：未来可以考虑增加更多的限流维度，如根据用户的地域、设备类型等进行限流，或者与身份认证、授权系统更深度结合，实现更精细化的访问控制。同时，进一步优化监控告警系统，增加更多维度的指标分析和智能告警功能，如根据流量趋势自动调整限流规则等，提升系统的自动化运维水平。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限流系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长期焦虑与虚无主义和享乐主义的关联</title>
      <link href="/2024/04/07/%E9%95%BF%E6%9C%9F%E7%84%A6%E8%99%91%E4%B8%8E%E8%99%9A%E6%97%A0%E4%B8%BB%E4%B9%89%E5%92%8C%E4%BA%AB%E4%B9%90%E4%B8%BB%E4%B9%89%E7%9A%84%E5%85%B3%E8%81%94/"/>
      <url>/2024/04/07/%E9%95%BF%E6%9C%9F%E7%84%A6%E8%99%91%E4%B8%8E%E8%99%9A%E6%97%A0%E4%B8%BB%E4%B9%89%E5%92%8C%E4%BA%AB%E4%B9%90%E4%B8%BB%E4%B9%89%E7%9A%84%E5%85%B3%E8%81%94/</url>
      
        <content type="html"><![CDATA[<p>在探讨长期焦虑的人为何容易陷入虚无主义或者享乐主义之前，我们先来理解一下焦虑本身。焦虑是一种对未来不确定性的担忧和不安，它可能源于生活中的各种压力，如工作、学业、人际关系等。当这种焦虑持续存在且得不到有效缓解时，就可能对人的心理状态产生深远的影响。</p><span id="more"></span><h3 id="一、虚无主义的内涵"><a href="#一、虚无主义的内涵" class="headerlink" title="一、虚无主义的内涵"></a>一、虚无主义的内涵</h3><p>虚无主义是一种哲学思潮，其核心观点是认为世界、人生没有客观的意义、价值和目的。在虚无主义者看来，一切传统的道德、信仰、价值观念都是虚假的或没有根基的。</p><ul><li><strong>价值的否定</strong>：虚无主义者质疑一切既有的价值体系，认为人类所追求的善良、正义、美等价值都是主观的建构，没有客观的真实性。例如，在战争和灾难的背景下，人们可能会对曾经坚信的道德准则产生怀疑，觉得所谓的善良在残酷的现实面前毫无意义。</li><li><strong>目的的缺失</strong>：人生被视为没有明确的目的或方向。没有一个超越性的目标来引导人们的行动，一切行为似乎都变得随机和无意义。就像一个人在漫长的人生旅途中，突然失去了前进的动力和目标，不知道自己为何而活，做任何事情都感觉没有意义。</li><li><strong>存在的荒诞感</strong>：虚无主义常常伴随着对世界存在的荒诞感。人们感到自己在一个毫无意义的世界中孤独地存在，一切努力和奋斗都显得徒劳无功。比如，加缪的小说《局外人》中的主人公默尔索，对周围的世界感到冷漠和疏离，体验到了存在的荒诞性。</li></ul><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412232139415.jpeg" alt="E2495760-844D-43DC-AC26-DD1B166BAEBA" style="zoom:50%;" /><h3 id="二、长期焦虑与虚无主义"><a href="#二、长期焦虑与虚无主义" class="headerlink" title="二、长期焦虑与虚无主义"></a>二、长期焦虑与虚无主义</h3><ol><li><strong>存在主义视角下的关联</strong><br>存在主义强调个体在面对世界的荒诞、无意义和自由时会产生焦虑。对于长期处于焦虑状态的人来说，他们可能会过度思考人生的意义和价值。在现实生活中，当他们无法找到明确的、令自己满意的答案时，或者面对无法控制的生活困境和压力，就会觉得一切都没有意义。例如，一个长期为工作压力而焦虑的人，可能会在不断的挫折和疲惫中开始质疑自己工作的目的，进而扩展到对整个生活的意义产生怀疑。这种对意义的追寻无果，最终可能导致他们陷入虚无主义的困境。</li><li><strong>认知失调理论的解释</strong><br>长期处于焦虑状态的人，其认知和现实之间往往存在较大的差距和冲突。他们可能对自己有很高的期望，但现实中却无法达到，这种认知上的不协调会导致心理上的不适和焦虑。为了缓解这种不适，有些人可能会选择否定一切价值和意义，认为所有的追求都是徒劳的。比如，一个学生一直期望在考试中取得优异成绩，但多次努力后仍未能如愿，长期的焦虑可能会让他觉得学习乃至整个生活都失去了意义，从而陷入虚无主义。</li><li><strong>精神分析理论的观点</strong><br>弗洛伊德认为，焦虑是自我在面对本我、超我和外部世界的冲突时产生的一种防御机制。长期焦虑可能意味着个体内心深处的冲突长期得不到解决，自我无法有效地应对这些冲突。在这种情况下，个体可能会对自己的存在和整个世界产生怀疑和否定，觉得一切都没有根基和意义。例如，一个人在童年时期经历了重大的创伤，长大后这种创伤可能会以焦虑的形式表现出来，并且在长期的焦虑中，他可能会逐渐陷入虚无主义，对生活失去信心。</li></ol><h3 id="三、享乐主义的内涵"><a href="#三、享乐主义的内涵" class="headerlink" title="三、享乐主义的内涵"></a>三、享乐主义的内涵</h3><p>享乐主义是一种主张追求快乐和享受的生活态度和价值观。享乐主义者认为，人生的目的就是追求尽可能多的快乐和满足感，避免痛苦和不快。</p><ul><li><strong>感官享受</strong>：强调通过满足感官需求来获得快乐，如美食、美酒、舒适的居住环境等。例如，一些人热衷于品尝各种美食，追求味蕾上的极致享受；或者购买豪华的家具和装饰品，营造舒适的生活空间。</li><li><strong>即时满足</strong>：注重当下的快乐，追求即时的满足感，而不太考虑长远的后果。比如，有些人可能会为了满足一时的购物欲望而过度消费，不顾自己的经济状况；或者沉迷于电子游戏、社交媒体等，以获得即时的娱乐和放松。</li><li><strong>快乐至上</strong>：将快乐视为最高的价值，认为其他的价值和目标都应该服从于追求快乐的目的。在享乐主义者看来，只要能够带来快乐，任何行为都是合理的。例如，一些人可能会为了追求快乐而放弃稳定的工作和生活，选择一种自由自在、充满刺激的生活方式。</li></ul><h3 id="四、长期焦虑与享乐主义"><a href="#四、长期焦虑与享乐主义" class="headerlink" title="四、长期焦虑与享乐主义"></a>四、长期焦虑与享乐主义</h3><ol><li><strong>马斯洛需求理论的分析</strong><br>当人长期处于焦虑状态时，会感觉自身安全和归属等较低层次的需求受到威胁。根据马斯洛的需求层次理论，个体在基本需求得不到满足或受到威胁时，会更加关注自身的即时感受和需求的满足，以缓解焦虑带来的痛苦和不安。因此，他们可能会通过追求物质享受、感官刺激等享乐方式来暂时忘却焦虑，获得心理上的慰藉和满足。比如，一个长期为经济问题而焦虑的人，可能会通过过度购物、享受美食等方式来缓解自己的焦虑。</li><li><strong>自我调节理论的阐释</strong><br>长期焦虑的人往往自我调节能力较差，难以有效地应对负面情绪。享乐主义的行为可以提供即时的快乐和满足感，成为他们逃避焦虑情绪的一种方式。例如，过度饮酒、暴饮暴食、沉迷于娱乐等行为都可以在短期内让人产生愉悦感，从而帮助他们暂时摆脱焦虑的困扰。然而，这种方式只是暂时的逃避，并不能真正解决焦虑问题，反而可能会使问题更加严重。</li><li><strong>习得性无助理论的解读</strong><br>当人长期处于无法控制的焦虑情境中时，会产生习得性无助感，认为自己无法改变现状，对未来失去信心和希望。在这种情况下，他们可能会放弃对长期目标和意义的追求，转而寻求当下的快乐和满足，陷入享乐主义的生活方式。比如，一个长期患有慢性疾病的人，可能会因为对疾病的无力感而陷入享乐主义，通过享受当下的生活来弥补对未来的绝望。</li></ol><h3 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h3><p>长期焦虑的人确实在一定程度上容易陷入虚无主义或享乐主义，但这并不是必然的结果。每个人的心理状态和应对方式都不同，还受到个体的性格、成长经历、社会支持等因素的影响。对于长期焦虑的人来说，重要的是要认识到自己的状态，并寻求适当的帮助和支持，如心理咨询、运动、社交等，以缓解焦虑，避免陷入虚无主义或享乐主义的陷阱。同时，我们也应该关注身边长期焦虑的人，给予他们理解和支持，帮助他们走出困境。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大厂搜推实践文章合集</title>
      <link href="/2023/08/19/%E5%A4%A7%E5%8E%82%E6%90%9C%E6%8E%A8%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86/"/>
      <url>/2023/08/19/%E5%A4%A7%E5%8E%82%E6%90%9C%E6%8E%A8%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>大厂搜推实践文章合集</p><span id="more"></span><h2 id="大厂实践文章"><a href="#大厂实践文章" class="headerlink" title="大厂实践文章"></a>大厂实践文章</h2><table><thead><tr><th>公司</th><th>内容</th><th>标签</th><th>时间</th></tr></thead><tbody><tr><td>淘宝</td><td><a href="https://mp.weixin.qq.com/s/zFb3wcfyAD-lAw3KBSEH9w">简单又高效：多场景近线召回在淘宝推荐中的最新范式</a></td><td>推荐</td><td>2024-10-31</td></tr><tr><td>小红书</td><td><a href="https://mp.weixin.qq.com/s/LS_Y3IpO5cyJ7keyeGF_9w">小红书去中心化内容分发技术</a></td><td>推荐</td><td>2024-10-29</td></tr><tr><td>淘宝</td><td><a href="https://mp.weixin.qq.com/s/8x6trg0QQ3L6d0KK-EmYZA">LAST——重排在线学习范式的全新可能</a></td><td>重排</td><td>2024-10-24</td></tr><tr><td>腾讯广告</td><td><a href="https://mp.weixin.qq.com/s/rNUvr1tHYd8jG4M5T5WHDw">腾讯广告基于长序列建模的落地实践</a></td><td>推荐</td><td>2024-10-17</td></tr><tr><td>腾讯广告</td><td><a href="https://mp.weixin.qq.com/s/ClmjgRzpNIVjX0PrikS3qg">腾讯广告基于混元大模型的生成式召回落地实践</a></td><td>召回</td><td>2024-10-14</td></tr><tr><td>淘宝</td><td><a href="https://mp.weixin.qq.com/s/ddLJozxOGmA7ag2eEgKKfA">多样性重排算法在淘宝首页信息流的创新应用</a></td><td>重排</td><td>2024-10-10</td></tr><tr><td>爱奇艺</td><td><a href="https://mp.weixin.qq.com/s/byDVm8MNu5HVo1iugXW6_g">在线深度学习：爱奇艺效果广告分钟级模型优化</a></td><td>广告</td><td>2024-10-10</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/9KBcHCjfNad_Fp3-SZrG3Q">全域用户建模在美团首页推荐的探索与实践</a></td><td>推荐</td><td>2024-10-10</td></tr><tr><td>小红书</td><td><a href="https://mp.weixin.qq.com/s/yApGxCGxjWnZQu8PoO9Qeg">小红书搜索：生成式检索的探索与实践</a></td><td>搜索</td><td>2024-10-05</td></tr><tr><td>爱奇艺</td><td><a href="https://mp.weixin.qq.com/s/K02gGawk_4Ej5rWlPxfAZQ">AI技术在爱奇艺视频搜索中的应用</a></td><td>搜索</td><td>2024-09-26</td></tr><tr><td>小红书</td><td><a href="https://mp.weixin.qq.com/s/tvaY4wAMf_kPjXCvHcXaUA">多模态对齐在小红书推荐的研究及应用</a></td><td>推荐</td><td>2024-09-23</td></tr><tr><td>网易云</td><td><a href="https://mp.weixin.qq.com/s/_zAAMtAtGFcrtwTwZ1R6jg">多模态推荐在网易云音乐社区的创新实践</a></td><td>推荐</td><td>2024-09-16</td></tr><tr><td>京东</td><td><a href="https://mp.weixin.qq.com/s/jN1OAKcRhJOt-qvPEE3gbg">京东健康基于大模型的生成式推荐在电商标品推荐的应用</a></td><td>推荐</td><td>2024-09-16</td></tr><tr><td>爱奇艺</td><td><a href="https://mp.weixin.qq.com/s/DU4uMuQ7WzU6bz1mAxsZug">爱奇艺广告智能算力探索与实践</a></td><td>广告</td><td>2024-09-12</td></tr><tr><td>京东</td><td><a href="https://mp.weixin.qq.com/s/fjZ2UosY3lvBMvXzqrOrZg">京东搜索重排：基于互信息的用户偏好导向模型</a></td><td>重排</td><td>2024-08-31</td></tr><tr><td>腾讯广告</td><td><a href="https://mp.weixin.qq.com/s/Y4ErK09-_TSJ2m6lC6UGCA">推荐模型中的辅助排序损失</a></td><td>推荐</td><td>2024-08-27</td></tr><tr><td>腾讯广告</td><td><a href="https://mp.weixin.qq.com/s/APaaHTYzRjEeE1pRTg0fXg">跨领域迁移学习在广告用户价值预估场景应用探索</a></td><td>广告</td><td>2024-08-26</td></tr><tr><td>淘宝</td><td><a href="https://mp.weixin.qq.com/s/DfHWs_773gErF6o0y9cw9Q">大语言模型改写技术在淘宝搜索中的应用</a></td><td>搜索</td><td>2024-08-22</td></tr><tr><td>快手</td><td><a href="https://mp.weixin.qq.com/s/Wy4t_rn2h45mDwVnGWk57A">推荐系统融合排序的多目标寻优技术</a></td><td>排序</td><td>2024-08-17</td></tr><tr><td>淘宝</td><td><a href="https://mp.weixin.qq.com/s/Exo3zDwyzrwHeiMBVOHPLg">淘宝全域空间下的自适应连续迁移学习</a></td><td>推荐</td><td>2024-08-15</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/LqkYvp-OFEpWCcRzEy1b5Q">信息流广告预估技术在美团外卖的实践</a></td><td>排序</td><td>2024-08-15</td></tr><tr><td>B站</td><td><a href="https://mp.weixin.qq.com/s/Kd9hqXkTsP5Zu8dnFQfDwA">B站搜索建库架构优化实践</a></td><td>搜索</td><td>2024-08-13</td></tr><tr><td>淘宝</td><td><a href="https://mp.weixin.qq.com/s/t9MxXW-Hbo1uT_PCyJoVuQ">触发式推荐场景的用户动态即时兴趣预估</a></td><td>推荐</td><td>2024-08-08</td></tr><tr><td>网易</td><td><a href="https://mp.weixin.qq.com/s/DBNNLe678gfZiOjf3Pm0ZQ">多场景多任务统一建模在网易云音乐的算法实践</a></td><td>排序</td><td>2024-08-07</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/XWMOSypjF9XrwqwZsEXF7g">展示广告预估技术最新突破：基于原生图文信息的多模态预估模型</a></td><td>排序</td><td>2024-08-02</td></tr><tr><td>小红书</td><td><a href="https://mp.weixin.qq.com/s/h-zChStPhB7-11YtV5J9fg">小红书搜索广告召回实践</a></td><td>召回</td><td>2024-08-01</td></tr><tr><td>淘宝</td><td><a href="https://mp.weixin.qq.com/s/J2GVJcZoL5tSbgWR0qzZGQ">认知推荐：基于LLM的首页推荐新范式</a></td><td>推荐</td><td>2024-08-01</td></tr><tr><td>小红书</td><td><a href="https://mp.weixin.qq.com/s/O9LueIBrh8AJ4omid-nBUA">小红书去中心化内容分发技术</a></td><td>排序</td><td>2024-07-31</td></tr><tr><td>腾讯广告</td><td><a href="https://mp.weixin.qq.com/s/dG_HVVTgQSmprezZnqzbCw">腾讯广告推荐算法优化实践</a></td><td>推荐</td><td>2024-07-17</td></tr><tr><td>淘宝</td><td><a href="https://mp.weixin.qq.com/s/TCcbyww79RryLvGfY_mPsA">淘宝“小时达”算法技术革新：精准匹配供需，重塑即时消费体验</a></td><td>推荐</td><td>2024-07-11</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/sCMsbMlcUlNHK0IOMQ3HkA">搜索广告召回技术在美团的实践</a></td><td>召回</td><td>2024-07-04</td></tr><tr><td>腾讯音乐</td><td><a href="https://mp.weixin.qq.com/s/xErp5lbsDWwCtRD8BUWuZw">音频表征大模型在QQ音乐歌曲冷启的应用与探索</a></td><td>冷启动</td><td>2024-06-30</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/5WDz015M3wY0ovdWqIHm7w">展示广告预估模型优势特征应用实践</a></td><td>排序</td><td>2024-06-13</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/VGs-J1EQneGIxFhask9WCQ">展示广告多模态召回模型：混合模态专家模型</a></td><td>召回</td><td>2024-05-29</td></tr><tr><td>百度</td><td><a href="https://mp.weixin.qq.com/s/6qanJ1tfV9AJF-Qbamezww">多域图大模型在百度推荐系统的实践与思考</a></td><td>图推荐</td><td>2024-05-09</td></tr><tr><td>百度</td><td><a href="https://mp.weixin.qq.com/s/_3CkflIJtsyndBqHhm8w3Q">百度推荐资源冷启动实践</a></td><td>冷启动</td><td>2024-05-09</td></tr><tr><td>小红书</td><td><a href="https://www.bilibili.com/video/BV1B142167Hu">小红书高时效推荐系统实践：从系统提效到内容冷启动</a></td><td>冷启动</td><td>2024-05-07</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/RCOcFFIYDylWg10ZG72_KA">百亿大规模图在广告场景的应用</a></td><td>图</td><td>2024-03-28</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/4gki0Ju82HnHV5Qze2faBw">大众点评内容搜索算法优化的探索与实践</a></td><td>搜索</td><td>2024-03-21</td></tr><tr><td>爱奇艺</td><td><a href="https://mp.weixin.qq.com/s/zyStqt3IYyhb_IXbMl8Dzg">稀疏大模型在爱奇艺广告排序场景中的实践</a></td><td>排序</td><td>2024-03-01</td></tr><tr><td>360</td><td><a href="https://mp.weixin.qq.com/s/Hy9yZ8yOF2FwQ9FIn3DQTw">360信息流推荐Mind召回</a></td><td>召回</td><td>2024-01-19</td></tr><tr><td>百度</td><td><a href="https://mp.weixin.qq.com/s/nly7Za8Ei29lx6HBuimBTQ">百度搜索Push个性化</a></td><td>搜索</td><td>2024-01-17</td></tr><tr><td>小红书</td><td><a href="https://www.bilibili.com/video/BV1fe41127m1">小红书推荐用户及内容冷启动实践</a></td><td>冷启动</td><td>2024-01-12</td></tr><tr><td>百度</td><td><a href="https://mp.weixin.qq.com/s/k78RRpvDrP3GlsdBV3B3sg">百度feed图模型演进</a></td><td>推荐</td><td>2024-01-11</td></tr><tr><td>百度</td><td><a href="https://mp.weixin.qq.com/s/JTNmYJNgoQr26fkT-Oy35g">百度推荐排序技术的思考与实践</a></td><td>推荐</td><td>2024-01-07</td></tr><tr><td>OPPO</td><td><a href="https://mp.weixin.qq.com/s/4TtGHY3Rc9Ui_1jkOKSx5Q">OPPO 广告召回算法实践与探索</a></td><td>召回</td><td>2023-12-30</td></tr><tr><td>美团</td><td><a href="https://www.bilibili.com/video/BV1N64y1H7mc">美团交易视频推荐探索与实践</a></td><td>推荐</td><td>2023-12-23</td></tr><tr><td>美团</td><td><a href="https://www.bilibili.com/video/BV1Yb4y137a3">内容搜索算法优化的探索与实践</a></td><td>搜索</td><td>2023-12-23</td></tr><tr><td>得物</td><td><a href="https://mp.weixin.qq.com/s/JX8adK0y-AtsoRRxx4734Q">粗排优化探讨｜得物技术</a></td><td>粗排</td><td>2023-12-20</td></tr><tr><td>百度</td><td><a href="https://mp.weixin.qq.com/s/YXPmZn3ujbBavFsmnf5Vzw">百度视频推荐跨域多目标预估与融合的实践和思考</a></td><td>推荐</td><td>2023-11-29</td></tr><tr><td>腾讯</td><td><a href="https://mp.weixin.qq.com/s/DSfo8AXIV_QMyBX4EOfe7A">AI大模型「改造」QQ浏览器搜索</a></td><td>搜索</td><td>2023-11-19</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/8Mg3lt4t2j5dtFKCsRet4g">HC^2：基于混合对比学习的多场景广告预估建模</a></td><td>广告</td><td>2023-11-15</td></tr><tr><td>阿里</td><td><a href="https://mp.weixin.qq.com/s/kRmTthX9jLB8sHC32UJWfw">融合复杂目标且支持实时调控的重排模型</a></td><td>召回</td><td>2023-11-14</td></tr><tr><td>网易</td><td><a href="https://mp.weixin.qq.com/s/EDkoe3nxvQ_24nxC8ktd7g">网易云音乐推荐系统的冷启动技术</a></td><td>冷启动</td><td>2023-11-10</td></tr><tr><td>华为</td><td><a href="https://mp.weixin.qq.com/s/c7xO71NEE2n-RbtRKItA">多任务和多场景在华为推荐系统中的应用</a></td><td>推荐</td><td>2023-11-09</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/Grd0PyAYmrlvc6SQLASFrg">BOMGraph：基于统一图神经网络的电商多场景召回方法</a></td><td>召回</td><td>2023-11-01</td></tr><tr><td>小红书</td><td><a href="https://www.bilibili.com/video/BV1Zz4y1P7Tx">小红书推荐系统创新性探索</a></td><td>冷启动</td><td>2023-10-31</td></tr><tr><td>爱奇艺</td><td><a href="https://mp.weixin.qq.com/s/brTPvcm6_yjwoXAme2kUdA">爱奇艺效果广告双出价优化历程</a></td><td>广告</td><td>2023-10-20</td></tr><tr><td>快手</td><td><a href="https://mp.weixin.qq.com/s/8MKoANEAw687FoeTasngpA">快手内容冷启动推荐模型实践</a></td><td>冷启动</td><td>2023-10-11</td></tr><tr><td>百度</td><td><a href="https://pan.baidu.com/s/1kTbebwkDuZOuKS7INW1Jew">百度推荐排序技术的思考(提取码:r5kv)</a></td><td>推荐</td><td>2023-08-26</td></tr><tr><td>新浪</td><td><a href="https://pan.baidu.com/s/1iR6tdrD93o35WPKyievo7w">推荐系统大模型启发的MemoNet(提取码:ckpa)</a></td><td>CTR预估</td><td>2023-08-26</td></tr><tr><td>网易</td><td><a href="https://pan.baidu.com/s/1PnE89HVWg379ax9ewP8ydQ">网易云音乐推荐的多模态冷启技术(提取码:x72d)</a></td><td>冷启动</td><td>2023-08-26</td></tr><tr><td>快手</td><td><a href="https://pan.baidu.com/s/1SbDA0t6DzevVcVEzttfydg">快手内容冷启动模型实践(提取码:cjbc)</a></td><td>冷启动</td><td>2023-08-26</td></tr><tr><td>百度</td><td><a href="https://pan.baidu.com/s/1nVoJCVUQZDGxlf05zhYuhw">百度视频推荐跨域多目标预估与融合的实践和思考(提取码:cva3)</a></td><td>多目标</td><td>2023-08-26</td></tr><tr><td>虎牙</td><td><a href="https://pan.baidu.com/s/1iU4LNm7qFAKUtkE65hVaYg">面向直播场景的虎牙排序算法实践(提取码:yhb8)</a></td><td>排序</td><td>2023-08-26</td></tr><tr><td>58同城</td><td><a href="https://pan.baidu.com/s/1LGmN8ZUajMBhnZ7vcOaRoA">深度学习在互联网房产推荐场景的算法实践(提取码:wcz7)</a></td><td>排序</td><td>2023-08-26</td></tr><tr><td>京东</td><td><a href="https://pan.baidu.com/s/1-NQEP8M4Y1GH1gzMGj7p-Q">图机器学习在京东视频召回中的应用(提取码:gfkx)</a></td><td>召回</td><td>2023-08-26</td></tr><tr><td>百度</td><td><a href="https://pan.baidu.com/s/1tzWEjphTt9EzTXqp4OfiRw">图模型在百度推荐系统的实践与思考(提取码:huaz)</a></td><td>推荐</td><td>2023-08-26</td></tr><tr><td>百度</td><td><a href="https://pan.baidu.com/s/12GAalYfn4TuHf-8dZ9qHLA">百度新资源冷启动实践(提取码:bji6)</a></td><td>冷启动</td><td>2023-08-26</td></tr><tr><td>蚂蚁</td><td><a href="https://pan.baidu.com/s/1AilbuaTQLtrHOegjK353_Q">图算法在蚂蚁集团营销推荐场景的应用(提取码:xvvi)</a></td><td>推荐</td><td>2023-08-26</td></tr><tr><td>百度</td><td><a href="https://mp.weixin.qq.com/s/Mpi7wZlHw3eKPJzj00CPMw">百度凤巢大模型与搜索广告满意度设计与实践</a></td><td>搜索</td><td>2023-08-13</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/RG_eOhxJxzdou06GfJVp3g">美团外卖推荐关于用户新颖体验优化的技术探索</a></td><td>推荐</td><td>2023-07-20</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/prLykt36ONu43V-twgfcOg">美团外卖智能陪伴型导购的探索与实践</a></td><td>Query推荐</td><td>2023-07-13</td></tr><tr><td>京东</td><td><a href="https://mp.weixin.qq.com/s/na90G1GqLoS41L_-NHpVKQ">京东搜索EE链路演进</a></td><td>搜索生态</td><td>2023-07-12</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/dDHdQFBoSTxIE_M_hPSh5w">基于特征自适应的多场景预估建模</a></td><td>多场景排序</td><td>2023-07-05</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/MRpoM1ucZIVdiXMcS4PiHQ">转化率预估新思路：基于历史数据复用的大促转化率精准预估</a></td><td>推荐</td><td>2023-06-28</td></tr><tr><td>腾讯</td><td><a href="https://mp.weixin.qq.com/s/ETJ-lkIKcxN6zIgH8FrTjw">对话双塔——腾讯视频中的粗排相关性模型</a></td><td>粗排相关性</td><td>2023-06-28</td></tr><tr><td>小米电商</td><td><a href="https://mp.weixin.qq.com/s/0GWkUFSC0geRZMpISx-4gg">多任务学习梯度冲突在电商场景的改进</a></td><td>多任务学习</td><td>2023-06-24</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/kMEYxeUPtJIbJ-X6NgHR2A">排序和准度联合优化：一种基于混合生成&#x2F;判别式建模的方案</a></td><td>排序</td><td>2023-06-21</td></tr><tr><td>小红书</td><td><a href="https://pan.baidu.com/s/1xQ5lqxYb_VvLxLIzDPgMHQ">语义模型在小红书社区搜索的应用(提取码:xfkv)</a></td><td>搜索</td><td>2023-06-17</td></tr><tr><td>蚂蚁</td><td><a href="https://pan.baidu.com/s/12Q_QisYd8GFq-pXX3g1x5w">支付宝搜索的Query理解与语义召回技术(提取码:p6gc)</a></td><td>召回</td><td>2023-06-17</td></tr><tr><td>阿里淘系</td><td><a href="https://mp.weixin.qq.com/s/YoQNDdsRE6LZWJXrRKubLw">Generator-Evaluator重排模型在淘宝流式场景的实践</a></td><td>重排</td><td>2023-06-09</td></tr><tr><td>得物</td><td><a href="https://mp.weixin.qq.com/s/Aj5rY1ziLqvPnZ6zNAHvFw">得物多场景统一推荐技术演进</a></td><td>推荐</td><td>2023-06-09</td></tr><tr><td>阿里</td><td><a href="https://mp.weixin.qq.com/s/0Cbc3aAYTeFqLDutLBXJmA">阿里解耦域适应无偏召回模型详解</a></td><td>召回</td><td>2023-06-04</td></tr><tr><td>Shopee</td><td><a href="https://mp.weixin.qq.com/s/4PO6EK3b4VCKO0ibd76C9w">多任务学习最新进展：基于神经元级共享的   CTR、CVR 多任务联合预估方法</a></td><td>推荐</td><td>2023-05-29</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/a2X08FZfMgMfzmucF0DZ_w">AdaSparse:   自适应稀疏网络的多场景CTR预估建模</a></td><td>精排</td><td>2023-05-10</td></tr><tr><td>得物</td><td><a href="https://mp.weixin.qq.com/s/J9gEmRWsjE8eZHpHvSHOlQ">得物App相关推荐价格体验优化</a></td><td>推荐</td><td>2023-05-10</td></tr><tr><td>阿里淘系</td><td><a href="https://mp.weixin.qq.com/s/e6Sqb6MAY5Bvzd7Pi8-zOg">淘宝内容化推荐场景下对多场景全域表征的思考与应用</a></td><td>推荐</td><td>2023-04-28</td></tr><tr><td>阿里飞猪</td><td><a href="https://mp.weixin.qq.com/s/M9RSzYiDvJ8L2Ux2VmFFRw">因果推断技术在飞猪保险模块推荐以及可解释性应用</a></td><td>推荐</td><td>2023-04-28</td></tr><tr><td>阿里淘系</td><td><a href="https://mp.weixin.qq.com/s/rdcqehk6l_GMF07YisHLFw">每日好店——店品排序探索模型升级</a></td><td>推荐</td><td>2023-04-24</td></tr><tr><td>微博</td><td><a href="https://mp.weixin.qq.com/s/wRi0YJLpru5M1My0H2Ww0w">微博推荐实时大模型的技术演进</a></td><td>推荐</td><td>2023-04-24</td></tr><tr><td>阿里健康</td><td><a href="https://mp.weixin.qq.com/s/hQgsT9xpQr2Ylb6_3uwfvQ">阿里可解释性推荐算法应用</a></td><td>推荐</td><td>2023-03-06</td></tr><tr><td>Shopee</td><td><a href="https://mp.weixin.qq.com/s/2JFY--9xDoMF5_2YCehwkg">Calibration4CVR：2018年关于“神经元级别共享的多任务CVR”的初探</a></td><td>推荐</td><td>2023-03-05</td></tr><tr><td>得物</td><td><a href="https://mp.weixin.qq.com/s/tX8fq3Az_n5NcnPlEpzA-Q">得物社区推荐精排模型演进</a></td><td>推荐</td><td>2023-01-11</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/LH4XI9DZXq77NvSvaoYfLQ">阿里妈妈展示广告召回之多场景建模算法</a></td><td>召回</td><td>2022-12-07</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/9HZZQCVd-bMRrR6mCanaog">大规模异构图召回在美团到店推荐广告的应用</a></td><td>召回</td><td>2022-11-24</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/6k8THshasaYfSaLr58O1NA">美团外卖搜索基于Elasticsearch的优化实践</a></td><td>搜索</td><td>2022-11-17</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/7bCrFHNeQ3_2kLlvzb5l3w">图技术在美团外卖下的场景化应用及探索</a></td><td>搜索</td><td>2022-09-08</td></tr><tr><td>得物</td><td><a href="https://mp.weixin.qq.com/s/URIjMVSA4gJ6EBWk4Tp6tA">得物分类TAB商品流多目标排序模型的演进</a></td><td>推荐</td><td>2022-07-01</td></tr><tr><td>得物</td><td><a href="https://mp.weixin.qq.com/s/oEcreSx5_XsN9x4Nkv7cOw">得物多兴趣召回模型实践</a></td><td>推荐</td><td>2022-05-18</td></tr><tr><td>得物</td><td><a href="https://mp.weixin.qq.com/s/3_RmSyl_3wIAH3lW_XKEyA">得物社区推荐多目标排序初探</a></td><td>推荐</td><td>2021-12-27</td></tr><tr><td>阿里</td><td><a href="https://mp.weixin.qq.com/s/IwzizxkRQbo1Kv28wVGQag">CMDM：基于异构序列融合的多兴趣深度召回模型在内容平台的探索和实践</a></td><td>召回</td><td>2021-12-07</td></tr><tr><td>爱奇艺</td><td><a href="https://mp.weixin.qq.com/s/gvFagKMgGKE2ZFic1znQWg">爱奇艺搜索排序算法实践</a></td><td>搜索</td><td>2021-07-30</td></tr><tr><td>爱奇艺</td><td><a href="https://mp.weixin.qq.com/s/JOQdyQDCFStWXdxTckUa5Q">多目标排序在爱奇艺短视频推荐中的应用</a></td><td>搜索</td><td>2021-06-25</td></tr><tr><td>爱奇艺</td><td><a href="https://mp.weixin.qq.com/s/T2G8L820haEbvXgryvEWHg">爱奇艺短视频推荐技术中多兴趣召回技术的演变</a></td><td>召回</td><td>2021-04-23</td></tr><tr><td>爱奇艺</td><td><a href="https://mp.weixin.qq.com/s/LZlskUK4dmOd5fLTZIATnQ">如何提升链路目标一致性？爱奇艺短视频推荐之粗排模型优化历程</a></td><td>粗排</td><td>2021-02-26</td></tr><tr><td>阿里淘系</td><td><a href="https://mp.weixin.qq.com/s/KX2gmEUme4Iy1PCR9PTrYg">淘宝个性化推荐中自适应与无监督的多场景模型建模实践</a></td><td>推荐</td><td>2023-04-10</td></tr><tr><td>阿里淘系</td><td><a href="https://mp.weixin.qq.com/s/DCiNgI1LL-uN4JmgQ5VSjQ">每日好店——淘宝店铺推荐系统实践</a></td><td>推荐</td><td>2023-04-07</td></tr><tr><td>小红书</td><td><a href="https://www.bilibili.com/video/BV1Km4y167ho">搜推系统召回阶段的前沿进展</a></td><td>召回</td><td>2023-04-03</td></tr><tr><td>阿里飞猪</td><td><a href="https://mp.weixin.qq.com/s/CFmp_FTHbf5l2ohUokTGgw">飞猪旅行场景下的实时用户理解服务</a></td><td>搜索</td><td>2023-04-01</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/v-GN1ors-bWutfsIJcZYbQ">多场景多任务学习在美团到店餐饮推荐的实践</a></td><td>推荐</td><td>2023-03-23</td></tr><tr><td>小红书</td><td><a href="https://mp.weixin.qq.com/s/1a2bl983bGKM713xI_3v_A">小红书高时效推荐系统背后的技术升级</a></td><td>推荐</td><td>2023-03-21</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/IoPZ-fUL0h1PVOA8uDXPJg">代码开源！阿里妈妈展示广告Match底层技术架构最新进展</a></td><td>召回</td><td>2023-03-14</td></tr><tr><td>阿里妈妈</td><td><a href="https://mp.weixin.qq.com/s/-klZWT30J41xPQfOqlWiNA">贝叶斯分层模型应用之直播场景打分校准</a></td><td>精排</td><td>2023-03-14</td></tr><tr><td>腾讯音乐</td><td><a href="https://zhuanlan.zhihu.com/p/611877625">粗排上不了COLD？我们提出了异构三塔粗排</a></td><td>粗排</td><td>2023-03-07</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/SwR1-mAtqjwsnJVy3UiMnA">交互式推荐在外卖场景的探索与应用</a></td><td>推荐</td><td>2023-02-16</td></tr><tr><td>小红书</td><td><a href="https://mp.weixin.qq.com/s/EabcwCtSPEmFOjRATVVORQ">小红书广告智能创意能力构建过程详解</a></td><td>广告</td><td>2023-02-16</td></tr><tr><td>快手</td><td><a href="https://mp.weixin.qq.com/s/SsgVqei9sL5y7N1GUXOJLg">快手精排模型实践</a></td><td>精排&amp;CXR预估</td><td>2023-02-01</td></tr><tr><td>阿里健康</td><td><a href="https://mp.weixin.qq.com/s/or9DT2HlVPnUFBsqAEv6Uw">领域知识增强的预训练语言模型在药电商搜索领域的实践</a></td><td>搜索</td><td>2023-01-30</td></tr><tr><td>京东</td><td><a href="https://mp.weixin.qq.com/s/Rmgh-ynoWU4uerh_4jL4YA">京东零售在电商搜索场景下的数据科学实践</a></td><td>搜索</td><td>2023-01-29</td></tr><tr><td>阿里达摩院</td><td><a href="https://mp.weixin.qq.com/s/oRxn2PQdh3_giCPkrJpQaQ">基于预训练语言模型的行业搜索的应用和研究</a></td><td>搜索</td><td>2023-01-28</td></tr><tr><td>阿里飞猪</td><td><a href="https://mp.weixin.qq.com/s/AyMmfixX8rXUgGIf94uBkw">深度召回在飞猪旅行推荐系统中的探索和实践</a></td><td>召回</td><td>2023-01-25</td></tr><tr><td>腾讯QQ浏览器</td><td><a href="https://mp.weixin.qq.com/s/rF9wC2qecPHDcn8fy6KIuA">QQ浏览器搜索相关性技术演进</a></td><td>搜索相关性</td><td>2023-01-18</td></tr><tr><td>小米</td><td><a href="https://mp.weixin.qq.com/s/_lEeyyxhGHg5ZOtrpf2epQ">小米电商算法秘籍：移花接木-新模型如何热启动快速超越线上旧模型</a></td><td>推荐&amp;CXR预估</td><td>2023-01-11</td></tr><tr><td>阿里健康</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247621853&idx=1&sn=61378cddef3e7b9579b00f92d4e3c609&chksm=fbd6aeb1cca127a76b85c8af5ba05d2b9f482252d176be3c6b42a8081bd4589f96c6178e066f&scene=27#wechat_redirect">阿里健康医药电商搜索相关性实践</a></td><td>搜索相关性</td><td>2023-01-11</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247487662&idx=1&sn=f3f28448bc605c8022cc84c3093f6562&chksm=ea2e6788dd59ee9e1111e3352363aa86bb8abdaa92f8167df62c201783bee38647912691ebe9&mpshare=1&scene=1&srcid=0117adz8z5uuqKd4JsFiqBky&sharer_sharetime=1673958834277&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">云音乐评论内容理解技术</a></td><td>内容理解</td><td>2023-01-10</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650490509&idx=1&sn=0881c47b13cf7d97a1f91e7b5830c58d&chksm=83978e95b4e007830bcd4bae627b02b275baf60b453035a711e43f4ff604c5389ed089ef2c45&scene=27#wechat_redirect">深度统一粗排在淘宝主搜索的优化实践</a></td><td>粗排</td><td>2023-01-06</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247487588&idx=1&sn=099b6105ef6f4e06df3ec6ace9cea168&chksm=ea2e6742dd59ee54d426895b8c2c335e7bed3027da1302da81eea829e26bb1600c7d149f29f6&mpshare=1&scene=1&srcid=0117wGK8qD3vbVGyqHjrC0m2&sharer_sharetime=1673958824881&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">云音乐视频搜索优化之旅</a></td><td>搜索</td><td>2023-01-04</td></tr><tr><td>快手</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247618221&idx=1&sn=bbbb4acd59fa304fd9941138d03a5b03&chksm=fbd6bcc1cca135d72d19924659d0ba226d516409c975610d077e64705d351b2c0b82ee46da4f&scene=27#wechat_redirect">金雅然：因果推断主要技术思想与方法总结</a></td><td>因果推断</td><td>2022-12-26</td></tr><tr><td>度小满</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247617404&idx=1&sn=a21ed8b66d98c7f2c32605a8ed5b6e7c&chksm=fbd6b910cca13006bf965630fcacedaf4ef4342b5b85f2a2728b83ff2e671fc2422c6d9a8583&scene=27#wechat_redirect">因果推断在度小满金融场景的应用探索</a></td><td>因果推断</td><td>2022-12-22</td></tr><tr><td>小红书</td><td><a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTc2MzczNg==&mid=2247486087&idx=1&sn=fa6b75242336d49fb780ab63c63ce4e5&chksm=cfe7a870f89021667d5056c587fdd9aafa025de8443fe9496f5321ff729b93536545324235b9&mpshare=1&scene=1&srcid=0117WqeEpkGzXEGbrlQ2qUP5&sharer_sharetime=1673957656684&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">小红书广告投放机制详解，如何用算法实现全站自动化投放</a></td><td>广告</td><td>2022-12-15</td></tr><tr><td>小米</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247614845&idx=1&sn=0e8c26b62cd8e2ffe5c54e6e3ee28a5d&chksm=fbd6b311cca13a07f68d47ac22d2ebc0f2fad1e082809bd0ccc8f68a5bc6f298e2bc16fa0ec1&scene=27#wechat_redirect">小米电商推荐算法CVR模型实践</a></td><td>精排&amp;CXR预估</td><td>2022-12-07</td></tr><tr><td>bilibili</td><td><a href="http://mp.weixin.qq.com/s?__biz=Mzg3Njc0NTgwMg==&mid=2247492039&idx=1&sn=1395b05f9f13d2ec5f094098335f0fb2&chksm=cf2f24e2f858adf401be214e3c00a17e71b4580afa3bb7c2e479fbdd196abaced8836c4bfc04&mpshare=1&scene=1&srcid=01173Yirag3aRdwVVXpLoC6m&sharer_sharetime=1673957819680&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">百亿数据个性化推荐：弹幕工程架构演进</a></td><td>推荐</td><td>2022-11-25</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649774611&idx=1&sn=50784f8f205424ac315c214eecde370d&chksm=beccc96889bb407e2fd0af67766bebc8e01a6619ac8356dba71efeb165c450b97c7a5561d5ef&scene=27#wechat_redirect">带你走进   Redis</a></td><td>工程相关</td><td>2022-11-22</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247487245&idx=1&sn=e60203a06dfbbd736ba5085554a8e86a&chksm=ea2e782bdd59f13d0cf199247081e406ef3352c2e211fe24be3aa851d996f37d412bb232f6ea&mpshare=1&scene=1&srcid=0117PDLkxZZZqZuhvqAb5zCN&sharer_sharetime=1673958990974&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">机器学习模型在云音乐指标异动预测的应用实践</a></td><td>数据科学</td><td>2022-11-18</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247609347&idx=1&sn=277d03dd9bbd978c2d6fa564e6ea3583&chksm=fbd69e6fcca117797939d7386d642cd99eca8bbe9d25b02e3fcf5245eb871faf4fcf9bffc5bc&scene=27#wechat_redirect">因果推断在腾讯游戏中的应用</a></td><td>因果推断</td><td>2022-11-12</td></tr><tr><td>小红书</td><td><a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTc2MzczNg==&mid=2247485593&idx=1&sn=80a57bc832565f38dfea8ce396975c3b&chksm=cfe7aa6ef890237880872ebe8ff471a9642104d84a6a3463ba4ea81a304f15fde179c437e741&mpshare=1&scene=1&srcid=0117HHDQtSslzh1IBwT4tYom&sharer_sharetime=1673957674492&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">首次解密小红书“种草”机制：大规模深度学习系统技术是如何应用的</a></td><td>推荐</td><td>2022-11-11</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247607759&idx=2&sn=793f2f26ca50fdcdd5e1805c540a8844&chksm=fbd697a3cca11eb5b0967e15bd56f2adfb8691d96e78a6b5115dd7bf96c30078ddaa9ed6eee4&scene=27#wechat_redirect">网易严选跨域多目标算法演进</a></td><td>多目标&amp;多任务</td><td>2022-11-01</td></tr><tr><td>NVIDIA</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247607015&idx=1&sn=640758c804a49c7fee278066b85203df&chksm=fbd6908bcca1199d272fe7ca3e6c7cde7dcdb43f33fbfc319fca414f76f5f3dc97ca443cb178&scene=27#wechat_redirect">NVIDIA   Merlin HugeCTR 推荐系统框架介绍</a></td><td>精排&amp;CXR预估</td><td>2022-10-31</td></tr><tr><td>快手</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247605093&idx=1&sn=32663a66325e7d0f5d8e4164ead40cc4&chksm=fbd6e909cca1601feba78e308e77e54d4860e7a08b5407c02cab0be27ec555f83647d2933209&scene=27#wechat_redirect">快手异质性因果效应模型构建及应用</a></td><td>因果推断</td><td>2022-10-29</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247603217&idx=1&sn=a170a798db5c190fef89b28a4c157aa1&chksm=fbd6e67dcca16f6b0e825f6818c40b67e38827aba0686d1a8221eda050b81196c45bf62ab643&scene=27#wechat_redirect">阿里   DeepRec 大规模稀疏模型训练推理引擎（文末附PPT下载）</a></td><td>工程相关</td><td>2022-10-21</td></tr><tr><td>小红书</td><td><a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTc2MzczNg==&mid=2247485120&idx=1&sn=d34d4cca4ad1ec00b1772d9ca4f7da5e&chksm=cfe7a437f8902d21404e7e184f8da18d6ed8b3056af83574060dbfedac20677b490b04c796fc&mpshare=1&scene=1&srcid=0117Of6uG80CLb3wppixoYYu&sharer_sharetime=1673957705690&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">上干货！小红书“薯条”业务竞价策略及最优公式详解</a></td><td>广告</td><td>2022-10-19</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247599652&idx=1&sn=7e548fdf373404f9e28a68ed60ed5fdf&chksm=fbd6f448cca17d5eb554161219b8c926861540ebf6a6c405e0d9397f7a857109adfef6712b38&scene=27#wechat_redirect">预训练语言模型压缩、双塔蒸馏在美团上的落地实践</a></td><td>召回</td><td>2022-10-10</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247598912&idx=1&sn=f9b89d6ab0e471ad3d0a5274c521fd76&chksm=fbd6f12ccca1783a70ecc2434b5614bad885fe8a4070a7b028432034c472a36763c0624d4abb&scene=27#wechat_redirect">知识图谱在美团搜索酒旅场景认知中的应用</a></td><td>搜索</td><td>2022-09-30</td></tr><tr><td>腾讯QQ浏览器</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247597380&idx=1&sn=4db0d3fe68ca96bdf1f5304e3bf27efe&chksm=fbd6cf28cca1463eda0a8c82b5d5bac1c52980c18c4b3503ae7ba1f785b28a486d4e1569a730&scene=27#wechat_redirect">搜索场景下的智能实体推荐</a></td><td>搜索</td><td>2022-09-26</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247597321&idx=1&sn=250130a92dc6fa4fcded1633faa5c908&chksm=fbd6cf65cca1467362fe21eaef511502e03412b93fbef8256174d3ce5f90360ed7c112c1ea0a&scene=27#wechat_redirect">美团基于知识图谱的个性化新闻推荐系统</a></td><td>推荐</td><td>2022-09-25</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247595912&idx=1&sn=d6d805fca059e98542d139238a64de65&chksm=fbd6c5e4cca14cf266926db0859a3f06611e4ec36c359ccc6f1ad3a1689b6d77edcb3eb5a553&scene=27#wechat_redirect">腾讯图神经网络与推荐预训练模型</a></td><td>推荐&amp;图网络</td><td>2022-09-19</td></tr><tr><td>蚂蚁</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247595831&idx=1&sn=6527aef4ce07e8ce2867af62d27338cb&chksm=fbd6c55bcca14c4d83907a730d8ab95cef14a86ae7d3e834c41aaea74bedb38cd73cdfc7f35e&scene=27#wechat_redirect">图机器学习在蚂蚁集团推荐业务中的应用</a></td><td>推荐&amp;图网络</td><td>2022-09-18</td></tr><tr><td>华为</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247594776&idx=1&sn=494824ef9ea3be55df7fe98211c3964e&chksm=fbd6c174cca148623cfada0a0539a0d33b173d01bbf36fef508f4f9c2a1618bc856785651ac3&scene=27#wechat_redirect">华为图神经网络在推荐系统中的应用</a></td><td>推荐&amp;图网络</td><td>2022-09-10</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247593010&idx=1&sn=f9384194319269e7a79ba8e577830ce4&chksm=fbd6de5ecca1574819e4184b92b5167e1317cc226ba1673f57f22cf544bd30b6cc55a97f6bce&scene=27#wechat_redirect">推荐算法中的特征工程</a></td><td>推荐&amp;特征工程</td><td>2022-08-30</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650472691&idx=1&sn=0de2198074b629ad7c9605a7a3d7d683&chksm=8397c8ebb4e041fde5b09d0496f18224248a922b5559f5722c914c856fda59d3f9283834f292&scene=27#wechat_redirect">连续迁移学习跨域推荐排序模型在淘宝推荐系统的应用</a></td><td>推荐&amp;跨域</td><td>2022-08-30</td></tr><tr><td>虎牙</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247592677&idx=2&sn=3cae00c17a89b7f34b65bd835a553491&chksm=fbd6d889cca1519fba25525dbff8f189be084c6a0bd4a30489aa5facde7038bcd663617ce393&scene=27#wechat_redirect">虎牙直播用户增长中台算法与工程实践</a></td><td>用增</td><td>2022-08-27</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247591189&idx=1&sn=b6d191ff2cf27e4c9bfef945683bfb4a&chksm=fbd6d779cca15e6f195c83f5c873a5ecb364478c75282dd6bde34986a089e0b443ec659724fd&scene=27#wechat_redirect">吴喆：全民K歌直播推荐系统详解</a></td><td>推荐</td><td>2022-08-22</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247486879&idx=1&sn=6ed863ec4ebb4a43fd5303dc31283e96&chksm=ea2e7ab9dd59f3af6c20ff794907160342ea844097f787a8b6761872cbe2a047a43272b542bb&mpshare=1&scene=1&srcid=0117V5aFvFP5Ddjfi2srfCOV&sharer_sharetime=1673959633475&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">云音乐播放页直播推荐实战</a></td><td>推荐</td><td>2022-08-17</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651770506&idx=2&sn=53df7e69852b53b8e9a78704250a3f59&chksm=bd1217c78a659ed1fe25caf2f387dd5adf7543c0d18aa9404a68dedc4393d3f75bdbc08d0097&mpshare=1&scene=1&srcid=0117rkw4ucCVdx40VXlSeHoB&sharer_sharetime=1673956974542&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">美团搜索粗排优化的探索与实践</a></td><td>粗排</td><td>2022-08-11</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649772002&idx=1&sn=7ab50931711fa4cebae08db9b132ade5&chksm=beccdc9989bb558f3223ecfec306aacfa4c17cdd49dab60bc6bd70be72b61d79d319c4e7b025&scene=27#wechat_redirect">一文搞懂   Redis 架构演化之路</a></td><td>工程相关</td><td>2022-07-26</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247586109&idx=1&sn=0ee0886b4f9249baf93439835d5d0268&chksm=fbd62351cca1aa47003a2abcd486f152e3eb2a70de6313764c24518b8ff41e0e1a654aef8bd3&scene=27#wechat_redirect">无量深度学习系统在腾讯推荐类业务的应用</a></td><td>推荐</td><td>2022-07-08</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651769715&idx=2&sn=2d6c3eb9d9646374b5f789fcf4282794&chksm=bd12123e8a659b2841fd12d873d3f7087f300b3bf8b6cbd9136728fc1231655eb573cf97f4e0&mpshare=1&scene=1&srcid=0117Xd442BpulsuEWGrZhqzJ&sharer_sharetime=1673957035636&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">大众点评搜索相关性技术探索与实践</a></td><td>搜索相关性</td><td>2022-07-06</td></tr><tr><td>蚂蚁</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247584814&idx=1&sn=0905e790e129fc69071ee35b033580f0&chksm=fbd63e42cca1b7544faa0cb1e8bced4ba70991deb29679987616565a0e7e66e31ca926b65538&scene=27#wechat_redirect">蚂蚁超大规模商家知识图谱构建及其融合应用</a></td><td>知识图谱</td><td>2022-07-01</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247486528&idx=1&sn=af5d722949e17ef6388582cb79d8db39&chksm=ea2e7b66dd59f27040aeffc48f0dea150e5bc52a4e3d1b3cba7f1c9cf4ad4588d7e0c5e1a0de&mpshare=1&scene=1&srcid=0117qiTM67fWa7TSJSplzmZm&sharer_sharetime=1673959054283&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">云音乐FeatureStore建设与实践</a></td><td>推荐&amp;特征工程</td><td>2022-06-29</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5MzY4NzE3MA==&mid=2247502484&idx=1&sn=72e86c400261dceb2526e4de6759e73f&chksm=a691b97991e6306fea07ccc0fe69fc2c21e41d6dcf5696b0558d38a06773799073a78e227bfd&scene=27#wechat_redirect">揭秘京东广告精排百分位AUC提升技术方案</a></td><td>精排&amp;CXR预估</td><td>2022-06-29</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247583653&idx=1&sn=5dc8cfa18b3a48103ba104470df2be45&chksm=fbd635c9cca1bcdf262951910a8b0808d395a5a00f34e47c38adcf6e8eac1c8c1a61780ba514&scene=27#wechat_redirect">章凡：飞猪基于因果推断技术的广告投后归因</a></td><td>因果推断</td><td>2022-06-27</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247583047&idx=1&sn=e1d82adf00fc6259a3750228d6979b4c&chksm=fbd6372bcca1be3dc6577ef0b2b3d671f12ab72ef7347202df175e19132433d4aefdeb97505f&scene=27#wechat_redirect">吕豪：京东搜索EE场景排序链路升级实践</a></td><td>搜索</td><td>2022-06-24</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651769148&idx=2&sn=f046a03fe1a02abf525c065963ae4038&chksm=bd1210718a65996725b53e639b2b6c3b51eb28f9ac53152a1c695746cf1c15d202535ee5f71f&mpshare=1&scene=1&srcid=0117F7qqsflxxpqhdQ1SngCz&sharer_sharetime=1673957044472&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">端智能在大众点评搜索重排序的应用实践</a></td><td>重排</td><td>2022-06-16</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247486449&idx=1&sn=489c7b0383800ddcc36a9a72af81f3c3&chksm=ea2e7cd7dd59f5c15d2ed2adcd1db35f89d92c8390ed956f0b298a658def93410a4c6668f715&mpshare=1&scene=1&srcid=0117rJEidptu50XAatgGRbHk&sharer_sharetime=1673958981682&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">云音乐预估系统建设与实践</a></td><td>精排&amp;CXR预估</td><td>2022-06-15</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5MzY4NzE3MA==&mid=2247502213&idx=1&sn=fc146301867e6dcfc1c76eb4ead978d0&chksm=a691ba6891e6337e86096af1a44fc35fbbf5ec1c3af779b4bf84d00dc5738ceb80acfadd3df4&scene=27#wechat_redirect">微信开源大规模embedding训练推理框架</a></td><td>召回</td><td>2022-06-15</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247577711&idx=1&sn=d4dc3ecc9fc9c63aa0a7746237156800&chksm=fbd60203cca18b153440f5ea638f0f409fa953c06ce8bcf1b23878664617dc206947ca7e4fa8&scene=27#wechat_redirect">张鸿志：美团大脑百亿级知识图谱的构建及应用进展</a></td><td>知识图谱</td><td>2022-06-03</td></tr><tr><td>快手</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247577501&idx=1&sn=0abd962b316235700f4050fcc8968a3b&chksm=fbd61df1cca194e7df8a414a8055df18e3592e0b59a1f941afb05005221e8e168f99a8d18b62&scene=27#wechat_redirect">快手牛亚男：基于多Domain多任务学习框架和Transformer，搭建快手精排模型</a></td><td>精排&amp;CXR预估</td><td>2022-06-01</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650464730&idx=1&sn=c5aa5396fc7c7a2eabb7990c6ce0d178&chksm=839629c2b4e1a0d491b314e5d6437ca87083de35cfa3791cf00a3fbd559641159cd0d350d057&scene=27#wechat_redirect">SIGIR2022   | 流行度偏差如何利用？探索解耦域适应无偏召回模型</a></td><td>召回</td><td>2022-05-31</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650464165&idx=1&sn=76193b6fc997e3d1d842c6ebe2dbf317&chksm=839617bdb4e19eabccf0bd4bc71d89e97cb17def86abb812a562b4019d379525e33ff7339152&scene=27#wechat_redirect">多模态技术在淘宝主搜召回场景的探索</a></td><td>召回</td><td>2022-05-27</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247576281&idx=2&sn=097528a2c3a4ba819eab3cd122df990b&chksm=fbd618b5cca191a394aec5846ce48720d95e3e6ea153c0770452a0eec447309383b3bf99e453&scene=27#wechat_redirect">陈宏申：浅谈京东电商商品文案挖掘难点与优化实践</a></td><td>文案挖掘</td><td>2022-05-25</td></tr><tr><td>华为</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247575814&idx=1&sn=c20d71bcf94a88a3e791885edb1af421&chksm=fbd61b6acca1927c038e60999db375f0192b322e72bf094e764a295f36ec217d8651d4a41a2c&scene=27#wechat_redirect">华为朱杰明：预训练模型在信息流推荐中的应用与探索</a></td><td>推荐</td><td>2022-05-22</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247486273&idx=1&sn=b0866d0b104de68bb5866b879df5baf5&chksm=ea2e7c67dd59f57161d5651396274ac15cd9af031995650a7e349710e983ed1a20d4f2a74fbd&mpshare=1&scene=1&srcid=0117G8EkbjLIyTRHBJSunt4X&sharer_sharetime=1673959041521&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">NUMA架构下的预估系统性能优化</a></td><td>工程相关</td><td>2022-05-19</td></tr><tr><td>小红书</td><td><a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTc2MzczNg==&mid=2247484208&idx=1&sn=b250b40543a4f8c2c28827587dd62d02&chksm=cfe7a1c7f89028d118599648db1037bddaa7f0eefed08abb3e8fc10699c1421441c3517166bc&mpshare=1&scene=1&srcid=0117OKUhDuwgjxulTmbfCefn&sharer_sharetime=1673957661497&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">小红书信息流推荐多样性解决方案</a></td><td>推荐</td><td>2022-05-18</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650462657&idx=1&sn=5e7ba268bb213b97e373c09ef8063234&chksm=839611d9b4e198cf0735bee5a88e32efbfdbaab402b6f5a74be1986304608f73bb87ecd72c23&scene=27#wechat_redirect">深度粗排在天猫新品中的实践</a></td><td>粗排</td><td>2022-05-18</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650462450&idx=1&sn=48c33f93cae32d6bf5ea6d8dfd0cb12b&chksm=839610eab4e199fcf614def6a660424a04196208d4acaf10ea653ca2920018f21226eb87cc42&scene=27#wechat_redirect">内容推荐场景中自监督学习的应用</a></td><td>推荐</td><td>2022-05-17</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5MzY4NzE3MA==&mid=2247501313&idx=1&sn=8f41c67db2b9fd8d016863c4bef7174f&chksm=a691b5ec91e63cfaaf84c2872a0a33f8736d5077711b5f10fdca7e2f5578b6a61d915a985f0a&scene=27#wechat_redirect">主题与交互式推荐技术在飞猪个性化分发中的实践</a></td><td>推荐</td><td>2022-05-16</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247574417&idx=1&sn=87ba745e7e1180fc6f85349428a890e9&chksm=fbd611fdcca198eba7ba7f339556911ae27b4058e0ae27581f793280ac0fc34fbc4e49e4a23f&scene=27#wechat_redirect">杨玉基：知识图谱在美团推荐场景中的应用</a></td><td>推荐</td><td>2022-05-16</td></tr><tr><td>腾讯QQ浏览器</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247574304&idx=1&sn=142635ea47eb0bf24b4feaab967f6d04&chksm=fbd6114ccca1985aecefcc46ade6d4d878bc6109205c2b4f8d5802ef9a484aee4a2c12fffed7&scene=27#wechat_redirect">李晓亮：腾讯搜索词推荐算法探索实践</a></td><td>搜索</td><td>2022-05-15</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247572115&idx=1&sn=e77ece68da5e843e620599cd9bc35ad9&chksm=fbd668ffcca1e1e90ee71c122a5c379051ef0ed6e9cb1460ffd8692c5066803524c6c4472480&scene=27#wechat_redirect">如何提升推荐系统的可解释性？京东智能推荐卖点技术全解析！</a></td><td>推荐</td><td>2022-05-07</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247571544&idx=2&sn=c298c717bb79092cb8ea7adf718cf64b&chksm=fbd66a34cca1e3222d5ab2f54185cea9732528721b3f0ad3df83dc15e14a30b1d6c6f64fafa2&scene=27#wechat_redirect">多任务学习模型ESMM原理与实现</a></td><td>精排&amp;CXR预估</td><td>2022-05-06</td></tr><tr><td>华为</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247570937&idx=1&sn=aa619fe9ca5ce9b655368d11bed4f42a&chksm=fbd66795cca1ee830ab6c13d90dcd0a465f4c0f1e871c207db97f588b228f8f9ad7feec48d96&scene=27#wechat_redirect">点击率预测模型Embedding层的学习和训练</a></td><td>精排&amp;CXR预估</td><td>2022-05-04</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247570552&idx=2&sn=6f5c88fc386de39080c8ab16ec415a28&chksm=fbd66614cca1ef02422ec1a182101aabfed8939a077d3825c9cc2efc2664364592ba949e59e3&scene=27#wechat_redirect">序列特征在推荐算法中的应用</a></td><td>推荐</td><td>2022-04-28</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247486194&idx=1&sn=48db3322795a4931f30c760017aaf9bc&chksm=ea2e7dd4dd59f4c2e568ddb5bd3a17fdf9c42701995b42d33252c0182341a1a909cf66be862d&mpshare=1&scene=1&srcid=0117Q0TI5TIkAQKoTGlkapeK&sharer_sharetime=1673958944207&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">CIKM   2021 | 云音乐提出与模型无关的冷启动推荐框架: MAIL</a></td><td>冷启动</td><td>2022-04-27</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247569807&idx=2&sn=8d133978b9c78529d6c83c756c4a242d&chksm=fbd663e3cca1eaf58e2fe5d7c88430ada4ffac92e7a96082906c03666d3fdc28548c59c1078f&scene=27#wechat_redirect">深度解析开源推荐算法框架EasyRec的核心概念和优势</a></td><td>工程相关</td><td>2022-04-26</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247569443&idx=1&sn=c683867e850188217bcdce54b9243feb&chksm=fbd6624fcca1eb59366b793686f378217d677a394378e65bc5b24963d10fff77461618203f74&scene=27#wechat_redirect">腾讯邱东洋：深度模型推理加速的术与道</a></td><td>工程相关</td><td>2022-04-22</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247569405&idx=2&sn=fb25b857a2355631e7236ad538b7db1a&chksm=fbd67d91cca1f48793667b8211a67d91087a206fddfe15cb3a81fca07a74db96dd206452cca7&scene=27#wechat_redirect">杨旭东：冷启动推荐模型DropoutNet深度解析与改进</a></td><td>冷启动</td><td>2022-04-21</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247485997&idx=1&sn=382ec987f91b1e9da9c9b99b4c26c927&chksm=ea2e7d0bdd59f41d9da9b6df7c4973eaab7a9d594cfd5250ca3128a9aaf7dee4a540485a616c&mpshare=1&scene=1&srcid=0117LxLqRhvnFtyKC08DdoKa&sharer_sharetime=1673958844890&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">从跨模态和上升通道谈富媒体内容的冷启动</a></td><td>冷启动</td><td>2022-04-20</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650458750&idx=1&sn=263bc286f3bf0711380b4c15d746ecdc&chksm=83960266b4e18b702e68a2e6fc1537d412aae05c8679b2f93fd6cd8d9c2e15647af2decf2625&scene=27#wechat_redirect">生成式重排在内容推荐中的应用实践</a></td><td>重排</td><td>2022-04-19</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247569004&idx=1&sn=819194c1427369349458d65a4d372f4b&chksm=fbd67c00cca1f5165aa04c2a247b70ab435f3d38f95f3b737ee0613ef13da7d465e6cc3f72a4&scene=27#wechat_redirect">刘童璇：阿里巴巴稀疏模型训练引擎DeepRec</a></td><td>工程相关</td><td>2022-04-17</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247485981&idx=1&sn=ca9f4b56e4225c26e1e477ad47e5ce71&chksm=ea2e7d3bdd59f42dfa7ed40277d8db305544f59fccdae53b81be9f6010a0ee94bc102e6172d5&mpshare=1&scene=1&srcid=0117vy6KkfZbqSewnRXKH9LX&sharer_sharetime=1673958897941&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">冷启动算法系列-云音乐歌曲冷启动初探</a></td><td>冷启动</td><td>2022-04-13</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650457465&idx=1&sn=0fab7290a4e7dc9e951da5c2fc6404f9&chksm=83960d61b4e18477d070f49f47f4dd27d6feae11e2b940439a5833d9c1d78fc629fb1f4811f1&scene=27#wechat_redirect">商品序列建模在新用户承接上的应用实践</a></td><td>精排&amp;CXR预估</td><td>2022-04-06</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247567877&idx=1&sn=1c8d1f781bd72fdf063f05694f8ff001&chksm=fbd67869cca1f17ff2d6a98f51c5b61792db7aeac74a8f1503155851e4f59e5dc69f0342f47f&scene=27#wechat_redirect">阿里巴巴展示广告智能拍卖机制的演进之路</a></td><td>广告</td><td>2022-04-06</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247567823&idx=2&sn=97cccbf605536b1b02b56485e6b6d3f2&chksm=fbd67ba3cca1f2b5fbae4f27941220e719144f7cb7fc1399c63d95c42d43ece6dbd649a6fcc1&scene=27#wechat_redirect">5G+智能时代的多模搜索技术</a></td><td>搜索</td><td>2022-04-05</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247567741&idx=1&sn=6406f8181482a6be57eb0a752173fa1a&chksm=fbd67b11cca1f2076580fb3e08d635033bdb03fa7fd195f6b6e07d231d3c7b52b03f3fe02996&scene=27#wechat_redirect">QQ音乐推荐召回算法的探索与实践</a></td><td>召回</td><td>2022-04-03</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247485890&idx=1&sn=16486343e1cebcf9b77352826c5c307e&chksm=ea2e7ee4dd59f7f2559e53c5f174e1541f1b940257e8af9027416ebd38ea4e643c583d1a6a5e&mpshare=1&scene=1&srcid=01175jUTYWcRHTuTLYsLKiuB&sharer_sharetime=1673958857324&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">云音乐隐性关系链的探索与实践</a></td><td>冷启动</td><td>2022-03-31</td></tr><tr><td>阿里淘系</td><td><a href="https://mp.weixin.qq.com/s/fN9s5Ml4GjGK2xLOeAUN4w">淘宝逛逛召回算法实践总结</a></td><td>召回</td><td>2022-03-29</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650457145&idx=1&sn=569530d4129f0ba122b79ddd66e6e742&chksm=83960c21b4e18537aa1edaead0ecf40f1e74aec662f1bc69d8a166b55085862d16211aa661a6&scene=27#wechat_redirect">Gradient   Normalization在多任务学习中的优化实践</a></td><td>多目标&amp;多任务</td><td>2022-03-29</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247567452&idx=1&sn=4da4f736bb462d213f5c275181201f29&chksm=fbd67a30cca1f326d7e08bf37270fd446cd82d693b1054611a8f2e76bfdee328863eada422d4&scene=27#wechat_redirect">李翔：美团到店综合知识图谱的构建与应用</a></td><td>知识图谱</td><td>2022-03-28</td></tr><tr><td>哈啰出行</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247567308&idx=1&sn=bf4cb94e1cf1ce58e01e5a9a1d9fabd1&chksm=fbd675a0cca1fcb643835a48add91625fda1f9dd22f6fde80e23310355ec144e93cb4f642e8c&scene=27#wechat_redirect">周冰倩：广告主视角下的信息流广告算法探索</a></td><td>广告</td><td>2022-03-27</td></tr><tr><td>快手</td><td><a href="http://mp.weixin.qq.com/s?__biz=Mzg2NzU4MDM0MQ==&mid=2247484777&idx=1&sn=8e258fae7c3c04d483dca1a74b5b6d46&chksm=ceb825b3f9cfaca56b9879bd8b621dd99ec89d5322a5cc17da49c76a629bce9c24c75a486155&mpshare=1&scene=1&srcid=0117cYykpg2l8QoQuZOe3Tvk&sharer_sharetime=1673959147851&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">王晓伟：图神经网络在快手推荐召回中的应用和挑战</a></td><td>推荐&amp;图网络</td><td>2022-03-23</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650455296&idx=1&sn=06621faf40213e4e56a3211a88a6e234&chksm=83967518b4e1fc0e38716b43f07fb863fa12b2f1ac1e8b2afb2ef0d062f091b3e375dde8f0f3&scene=27#wechat_redirect">基于特征全埋点的精排ODL实践总结</a></td><td>工程相关</td><td>2022-03-22</td></tr><tr><td>小米</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247566960&idx=1&sn=e8cc6cc5f3a1f7de5eac0dee97debb6b&chksm=fbd6741ccca1fd0ad16036ace153dc09b06649e9235bc89f2eda09f87c1aeee9e713f073b6c0&scene=27#wechat_redirect">崔世起：小米小爱同学无效Query识别</a></td><td>搜索</td><td>2022-03-20</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247566913&idx=1&sn=2d203186459c22eb14d54745cecdd83e&chksm=fbd6742dcca1fd3ba5b947fa2914bef7b218e957c94b458a12824c0fd0802cb616051bbcad80&scene=27#wechat_redirect">QQ音乐推荐系统算法架构实践</a></td><td>推荐</td><td>2022-03-19</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649769274&idx=1&sn=a46fc1574ecbf5cfddd1f40af9cb1b4f&chksm=beccd64189bb5f57f80799fd2ea51c7669942254a2223dea55fe7d2bfa5762410a784dec8e2f&scene=27#wechat_redirect">微信全文搜索技术优化</a></td><td>搜索</td><td>2022-03-14</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247566783&idx=1&sn=7f693e5b57988166ec07017f32ff2b97&chksm=fbd677d3cca1fec550f381173c195aef54aab536ce429cb823d9c62c7ca2a66cde9eb09c30ca&scene=27#wechat_redirect">王冬月：京东推荐算法精排技术实践</a></td><td>精排&amp;CXR预估</td><td>2022-03-14</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247566714&idx=1&sn=fcccd4847149cb3496d10e2d4975c30a&chksm=fbd67716cca1fe00735a96213bcd8d208d15654acb63ce8fd1e0dc0c383d8352c89ced76327f&scene=27#wechat_redirect">蒋能学：网易云音乐广告算法实践</a></td><td>广告</td><td>2022-03-12</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651766855&idx=2&sn=3f501731584e8cdf6fa7d22fafc9d469&chksm=bd12190a8a65901cfbad1590c49044afdf81c4df281e23dab813c51acddbace87bf93a78202d&mpshare=1&scene=1&srcid=0117wolSN0KkwClWlrLhbYd9&sharer_sharetime=1673957140359&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">异构广告混排在美团到店业务的探索与实践</a></td><td>广告&amp;混排</td><td>2022-03-10</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650454966&idx=1&sn=a5721d265ed07138fdad3c8e1d06b727&chksm=839673aeb4e1fab8164ef508bfeddc4f4cfc2c76d8163cf209c871df94a0c3fb0b1fd7f9c9b6&scene=27#wechat_redirect">GNN在轻应用内容推荐中的召回实践</a></td><td>召回</td><td>2022-03-10</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247566529&idx=1&sn=aaedccdf162508b78b35b99b5262e47e&chksm=fbd676adcca1ffbbd669a3190c4b96561686716a2c03f813cbf71c5af8313e20eab654116c9c&scene=27#wechat_redirect">张菡：深度学习下的京东搜索召回技术</a></td><td>召回</td><td>2022-03-09</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzI1NTg3NzcwNQ==&mid=2247485614&idx=1&sn=07571004c063b7563fa83f0b38e4f9b0&chksm=ea2e7f88dd59f69e24c15d4cfee263f4dab871a8a5bc6a8ca798d76265497e418ff2c393229c&mpshare=1&scene=1&srcid=0117kMMwZFauG8GEMkGxRgkM&sharer_sharetime=1673958791203&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">实时增量学习在云音乐直播推荐系统中的实践</a></td><td>推荐&amp;增量学习</td><td>2022-03-09</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247566515&idx=2&sn=45d7744b256ca6a4f3871126e6c343a9&chksm=fbd676dfcca1ffc9008e4af615655bc243a502bef76ec9aa73cfa961f005a5ceddbf85135020&scene=27#wechat_redirect">超越I2I和向量内积，淘宝新一代召回范式：PDN模型</a></td><td>召回</td><td>2022-03-08</td></tr><tr><td>虎牙</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247566074&idx=1&sn=8c6b37aa60324b26561a5d3fae6ae9b7&chksm=fbd67096cca1f98057c70929be491b04a58704d04ddf4896e77947b5927c62aea546610e1e73&scene=27#wechat_redirect">李茶：虎牙直播推荐系统架构详解</a></td><td>推荐</td><td>2022-03-02</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650453241&idx=1&sn=d30e011ac9e416aab54eb76378b43f39&chksm=83967ce1b4e1f5f79ce2067171d9c6336269edb47c88992ba765376438534ba13a6b83da287f&scene=27#wechat_redirect">冷启动系统优化与内容潜力预估实践</a></td><td>冷启动</td><td>2022-03-01</td></tr><tr><td>哈啰出行</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247565994&idx=1&sn=6d57d32a8d2d81d6540a5e0219d14528&chksm=fbd670c6cca1f9d034eb1a94314e838a09e843c65143995e0d133bc612596ba3817f73f99507&scene=27#wechat_redirect">董彦燊：因果推断在哈啰出行的实践探索</a></td><td>因果推断</td><td>2022-02-28</td></tr><tr><td>贝壳</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247565976&idx=1&sn=a651d09cdd08268b1424c854790e3a59&chksm=fbd670f4cca1f9e25c39dea866a2b3c4ffeb954ad078e46404656f464f45eb4081307b8476cd&scene=27#wechat_redirect">王志勇：贝壳CVR转化率预估模型实践</a></td><td>精排&amp;CXR预估</td><td>2022-02-26</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247565886&idx=1&sn=fbce6bf0053fc396ec28ef96b70b4549&chksm=fbd67052cca1f944934c670f15d55771cd9287962d642fb0ce39208d5bd769c35bd7692ab481&scene=27#wechat_redirect">赵鑫：强化学习在京东广告序列推荐中的应用</a></td><td>广告</td><td>2022-02-24</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650452759&idx=1&sn=9405ae3c91460fb6ad0e85389de5414c&chksm=83967b0fb4e1f219afa071fd46547c54a189ff468dcf9fd33ea6b6f9ae8fefcd2df7cf1007aa&scene=27#wechat_redirect">行为稀疏场景下的图模型实践</a></td><td>召回</td><td>2022-02-22</td></tr><tr><td>快手</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247565718&idx=1&sn=5d5e7b94caa839ccf85e0b119de3ba64&chksm=fbd673facca1faecf357c3478bb5d0859c0e3a9f25110e8a1ba17a561b24ec8094ab07640988&scene=27#wechat_redirect">赵炜琪：因果推断在快手推荐场景的应用探索</a></td><td>因果推断</td><td>2022-02-21</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247565711&idx=2&sn=7f04ddc36909ebe7301775eda5fd577e&chksm=fbd673e3cca1faf50348726147937c20283f2b8c65f5f033852feeb2e9f7e4ed7c8d06c2190c&scene=27#wechat_redirect">微信强化学习推荐模型的知识蒸馏探索之路</a></td><td>推荐</td><td>2022-02-20</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649768292&idx=1&sn=354dfe8a3186fd265dbe434738ef5599&chksm=beccd21f89bb5b093f7a7ee15b4ea54e0035b445f9835d5cd8835c8d4dd460a2303bdc2eb61a&scene=27#wechat_redirect">一篇详文带你入门   Redis</a></td><td>工程相关</td><td>2022-02-18</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247565613&idx=2&sn=f71fdb23b678e962f4cb9e4373d0f3c9&chksm=fbd67341cca1fa57fc35cbd6f260f27f9b058fe2d815aee5e0249b0f4e9c97e4e7a035460105&scene=27#wechat_redirect">熊飞：”猜你去哪”飞猪用户旅行意图预测</a></td><td>搜索</td><td>2022-02-18</td></tr><tr><td>虾皮</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE5MDgwMQ==&mid=2247486658&idx=1&sn=0ee241fe1d39ca49fa027df3157c2011&chksm=c27f487cf508c16a391b504cb12557a1e3b7b59e63c668f41b2956cddabd417d35d27a51b596&mpshare=1&scene=1&srcid=01178Hqxu4n7E06o8irFWJnX&sharer_sharetime=1673956927457&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">下拉推荐在   Shopee Chatbot 中的探索和实践</a></td><td>推荐</td><td>2022-02-17</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651766615&idx=2&sn=89b1399f902ce8b01d2e5dc45c11ec43&chksm=bd12661a8a65ef0c8ac325db5450c1ce7e62dfeb87120569aca449afdbcc24a1e0a112eadbe6&mpshare=1&scene=1&srcid=0117flm3zao0X73AS87VEsRA&sharer_sharetime=1673957162379&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">美团搜索中查询改写技术的探索与实践</a></td><td>搜索</td><td>2022-02-17</td></tr><tr><td>美图</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5MzY4NzE3MA==&mid=2247499655&idx=1&sn=0af7ce51790e7de995b989250af545ac&chksm=a6918c6a91e6057ca610820f4207531dd77de9541a534ab6df033691b21023d2c6a5d3736e70&scene=27#wechat_redirect">多媒体内容理解在美图社区的应用实践</a></td><td>内容理解</td><td>2022-02-16</td></tr><tr><td>快手</td><td><a href="http://mp.weixin.qq.com/s?__biz=Mzg2NzU4MDM0MQ==&mid=2247484702&idx=1&sn=33891737a46268a28d6676ca1e2e8212&chksm=ceb825c4f9cfacd2b0cb6ff6106940043d708260b561285cc7459a17bd65d3d16e3ddce95707&mpshare=1&scene=1&srcid=0117GxgZME41q4MyG15aaS66&sharer_sharetime=1673959171765&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">将因果关系估计引入推荐系统、提升推荐模型效果，快手新研究被WWW22接收</a></td><td>因果推断</td><td>2022-02-14</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247564687&idx=1&sn=2825449485d6fae3ae2005c822ce8dc1&chksm=fbd64fe3cca1c6f5277e84d19e723e2ff4e165ced14d94d53bf93ce73878943ec9d7c0f005d3&scene=27#wechat_redirect">QQ音乐排序模型优化</a></td><td>推荐</td><td>2022-02-14</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247562574&idx=1&sn=2c5c787485131673da963e4a1ca8610a&chksm=fbd64722cca1ce34155e3c4507bea25b4debca0c0cbcb88871bcc3f6637efa4c7452d24ec092&scene=27#wechat_redirect">苏永浩：Embedding技术在商业搜索与推荐场景的实践</a></td><td>召回</td><td>2022-02-11</td></tr><tr><td>快手</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247562529&idx=1&sn=6bae7191d8f711d68c1520f4e8a28c7a&chksm=fbd6474dcca1ce5b112eb645ff15d173c7054d2343b16e4d3674201c4481314fa9297b90b0b7&scene=27#wechat_redirect">渠江涛：重排序在快手短视频推荐系统中的演进</a></td><td>重排</td><td>2022-02-10</td></tr><tr><td>快手</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247562443&idx=1&sn=e648c2b1fcd04c94fe39c74176b5d5d5&chksm=fbd646a7cca1cfb135acbd3ee5e460e846dd7851c24f5b8ed2b30556d967f5ad2ae54862f6b7&scene=27#wechat_redirect">李翱：因果学习在用户增长中的实践</a></td><td>因果推断</td><td>2022-02-07</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247562403&idx=1&sn=b639f10eabbc85c33cb47773f6e7f927&chksm=fbd646cfcca1cfd94d90c73d665d9a056bf90e40b8c9857d5f5476f6ae8f1eb41fff5302508f&scene=27#wechat_redirect">刘德华：标签推荐与“猜你想找”算法实践</a></td><td>推荐</td><td>2022-02-05</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247562398&idx=1&sn=a4a75e80defd853797980fc99a09b6b3&chksm=fbd646f2cca1cfe4fab6870c681e40db76cd1b0bebdd55f93034ed812ac1ac1f38908a2a6d59&scene=27#wechat_redirect">腾讯音乐知识图谱搜索实践</a></td><td>搜索</td><td>2022-02-04</td></tr><tr><td>一点资讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247562297&idx=1&sn=38d236570827c2d8422dbfe1fbc93819&chksm=fbd64655cca1cf43815128dc9a8b7adf5efe1d6779fa7feb60ad9f1414767cf57623cbbd41f1&scene=27#wechat_redirect">郭沛东：图模型在信息流推荐的原理和实践</a></td><td>推荐&amp;图网络</td><td>2022-01-28</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650451312&idx=1&sn=a9bf674c661cb9f4ea5b9a1a86b874ac&chksm=83966568b4e1ec7eb52f139edd3ede3df3fb6b23f4a4951be6b66db1390264b58e4a5ee43329&scene=27#wechat_redirect">推荐场景下融合多模态信息的内容召回模型</a></td><td>召回</td><td>2022-01-26</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247562067&idx=2&sn=9a47510cfb928f3d0001428f3a1f7555&chksm=fbd6413fcca1c829d11e66edf61b8cfa7b0b735ac3425fb3f67cfdfb041f9dbc5d247f06391b&scene=27#wechat_redirect">多序列融合召回在新用户冷启动上的应用</a></td><td>召回</td><td>2022-01-23</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247561697&idx=2&sn=9db06881ce75388999f96276289f2bf2&chksm=fbd6438dcca1ca9b4c7c1f40224c735499a6bacc952640d4a1f3cb1233d3a5e2b53c2ec983aa&scene=27#wechat_redirect">ZEUS：淘宝多场景推荐排序模型</a></td><td>推荐</td><td>2022-01-19</td></tr><tr><td>贝壳</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247561513&idx=1&sn=5b818890be25a6b346041bcd45f9b5c7&chksm=fbd64345cca1ca5395f1cd95f1cc0d0f9b4bcbd330f26e2fea657424bde76bd74b57bf989720&scene=27#wechat_redirect">周玉驰：因果分析在贝壳的探索实践</a></td><td>因果推断</td><td>2022-01-17</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247561463&idx=1&sn=264c42e7c9207cd57e0f13937985a869&chksm=fbd6429bcca1cb8d461a43081195f95972c08d8055680d0b7fed174734abf042162f673d0913&scene=27#wechat_redirect">腾讯音乐多模态音乐匹配技术与应用</a></td><td>搜索</td><td>2022-01-15</td></tr><tr><td>阿里淘系</td><td><a href="https://www.bilibili.com/video/BV1QS4y1j7yK">大淘宝技术“搜索算法”专场①：淘宝搜索召回、个性化搜索排序</a></td><td>搜索</td><td>2022-01-14</td></tr><tr><td>阿里淘系</td><td><a href="https://www.bilibili.com/video/BV1GY411h7MH">大淘宝技术“搜索算法”专场②：电商搜索相关性、电商知识图谱</a></td><td>搜索</td><td>2022-01-14</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650450365&idx=2&sn=cac748e80be91c0ef674b0f5cffd8892&chksm=839661a5b4e1e8b39164b66b6d3c34f673353b623f8e77d8588488696992dad60f205192d56a&scene=27#wechat_redirect">直播预告   | 1月13日下午，“搜索算法”专场②：电商搜索相关性、电商知识图谱</a></td><td>搜索</td><td>2022-01-12</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650450321&idx=2&sn=f80e1432c9d601cdead700c4a2f4c9c6&chksm=83966189b4e1e89fff4e286b3543aaa4caa1a897bcd65f49754d6a35735e04299cac329102a2&scene=27#wechat_redirect">直播预告   | 1月12日下午，“搜索算法”专场①：淘宝搜索召回、个性化搜索排序</a></td><td>搜素</td><td>2022-01-11</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650447143&idx=1&sn=28572b3214b41042573190f918fec5e2&chksm=8396553fb4e1dc299959b25ebba018de65a0ad01f764cff9be3691be7a28efe20bc494af76a0&scene=27#wechat_redirect">7种经典推荐算法模型的应用</a></td><td>推荐</td><td>2021-12-30</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247560198&idx=1&sn=d6245b5ad0e0a45828d8a5a3d42565b3&chksm=fbd65e6acca1d77c4219211313cf049d7c3b3f1380137f4a4057180e3453ac286cc90489f3a2&scene=27#wechat_redirect">赵学敏：京东商品图谱构建与实体对齐</a></td><td>知识图谱</td><td>2021-12-29</td></tr><tr><td>网易</td><td><a href="https://zhuanlan.zhihu.com/p/448175622?utm_medium=social&utm_oi=32492828491776&utm_psn=1598782592987373568&utm_source=wechat_session">网易云音乐广告CTR预估模型演进过程</a></td><td>精排&amp;CXR预估</td><td>2021-12-21</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650445597&idx=1&sn=3cf659eb6888d315eef88a40ca01b35e&chksm=83965f05b4e1d613ae13a009563d6ddd5cefe111249309968461b388dba2b9fceb6c059014f9&scene=27#wechat_redirect">多序列融合召回在新用户冷启动上的应用</a></td><td>冷启动</td><td>2021-12-21</td></tr><tr><td>阿里淘系</td><td><a href="https://www.bilibili.com/video/BV1QP4y1n7vD">大淘宝技术“推荐算法”PART   1</a></td><td>推荐</td><td>2021-12-20</td></tr><tr><td>阿里淘系</td><td><a href="https://www.bilibili.com/video/BV1CL411j7sP">大淘宝技术“推荐算法”PART   2</a></td><td>推荐</td><td>2021-12-20</td></tr><tr><td>阿里淘系</td><td><a href="https://www.bilibili.com/video/BV1Bg411w7ib">大淘宝技术“推荐算法”PART   3</a></td><td>推荐</td><td>2021-12-20</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247559222&idx=1&sn=9bd74ce22471f24c67ede5664e3d52ca&chksm=fbd65a5acca1d34c479c885f71f9c936be3dcacdf07a6b93804497ce2a80e6e1dbbd6c2ccb01&scene=27#wechat_redirect">沈冰阳：强化学习在推荐冷启动优化中的实践探索！</a></td><td>冷启动</td><td>2021-12-17</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650445349&idx=1&sn=bb8ad24cef7f34bd46fe35d0cb370958&chksm=83965e3db4e1d72ba530d9f06acaa2d0432338935e9585e530958dba2d42f20971047b0b0c78&scene=27#wechat_redirect">内容推荐场景下多模态语义召回的若干实践</a></td><td>召回</td><td>2021-12-14</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650445139&idx=1&sn=c43febc0a43bf5b4165d06cceffd873c&chksm=83965d4bb4e1d45d50fd46a3776bf9ebfe78477c45a872aba220ff37aa331fda2fe07874c803&scene=27#wechat_redirect">深度粗排模型的GMV优化实践：基于全空间-子空间联合建模的蒸馏校准模型</a></td><td>粗排</td><td>2021-12-13</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247558984&idx=1&sn=b43d63234470d398222d969bd832ceb4&chksm=fbd65524cca1dc3237395c3d5971388533d363d8d8ea0ac15ab7ae1fe1f976e04b35abe4a17a&scene=27#wechat_redirect">阿里新一代召回技术：从TDM到二向箔的新突破！</a></td><td>召回</td><td>2021-12-13</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247558876&idx=2&sn=9661f9e62d675dc9c6c1e1755166f475&chksm=fbd654b0cca1dda662a444099587fb756253ff670453f1093fbdab68caffd9ce31c3864a86c6&scene=27#wechat_redirect">祝凯文：推荐算法在商业化场景中的探索实践</a></td><td>推荐</td><td>2021-12-12</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650443071&idx=1&sn=b61d6b1fdcf0c61bccb3988dd2516616&chksm=83964527b4e1cc31a67ced58e4a1559d8214f5a560258aaac51223c393ec829d3d2ede1faadb&scene=27#wechat_redirect">2021召回技术在内容推荐的实践总结</a></td><td>召回</td><td>2021-11-30</td></tr><tr><td>阿里淘系</td><td><a href="https://www.bilibili.com/video/BV16M4y1P71Y">阿里淘系技术：算法黑科技</a></td><td>搜索</td><td>2021-11-29</td></tr><tr><td>快手</td><td><a href="http://mp.weixin.qq.com/s?__biz=Mzg2NzU4MDM0MQ==&mid=2247484410&idx=1&sn=6eb90265ecadfd8a6239142e82d2791e&chksm=ceb82320f9cfaa3605c0808a6cc59e1272e4bd66966707bfea69c443bf6f94e7f084d0fb68d0&mpshare=1&scene=1&srcid=0117gma2C2J5yABFspK8xOMO&sharer_sharetime=1673959158573&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">「繁星」：快手搜索在向量检索方向的探索和实践</a></td><td>召回</td><td>2021-11-29</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247557961&idx=2&sn=cfaf7721b9c7892654fb6d22fc3dcb9a&chksm=fbd65125cca1d83361018b1cb258acf75919d79989f306bb031eb61a86aa60e38423ce26b7a3&scene=27#wechat_redirect">QQ音乐推荐系统的精细化调控</a></td><td>推荐</td><td>2021-11-28</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650442614&idx=1&sn=9f70b34865023eb21948da0e1048caa8&chksm=8396436eb4e1ca7838bee45c86575fd55a5ab4890d00ab39c8a79f9d7152a19ed7c173139ebe&scene=27#wechat_redirect">GNN在下拉推荐的应用</a></td><td>推荐</td><td>2021-11-24</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765674&idx=1&sn=55f3a13f9b2ecc1b0c28a76e76b35727&chksm=bd1262e78a65ebf12783a6b593cef4f8fe0a5b1f41eac019ce707ff01cc9c307e6febcefc634&mpshare=1&scene=1&srcid=0117VHqucNGNj19mtFAk5cYg&sharer_sharetime=1673957152451&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">美团搜索多业务商品排序探索与实践</a></td><td>搜索</td><td>2021-11-18</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247557338&idx=2&sn=ab7ae767a2504d9cde93552d35d402fd&chksm=fbd652b6cca1dba0bac36a18cd430d38d30d76f1f9112bde9fc42e8c723eb4a3a71c50fdcafa&scene=27#wechat_redirect">阿里飞猪林睿：从核心因子预估&gt;实体识别，如何实现文本和空间的搜索相关性？</a></td><td>搜索相关性</td><td>2021-11-16</td></tr><tr><td>字节跳动</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247556442&idx=1&sn=61144058d5ac801109ca343d4480295d&chksm=fbd7af36cca02620de8ad397ef047fc8f1dfc896c6a44c935e79f19eccea6194e471f6252283&scene=27#wechat_redirect">字节跳动高伟豪：训练目标不一致？损失无法学习？深度召回解难题！</a></td><td>召回</td><td>2021-11-10</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247555956&idx=1&sn=9495f84c782e741e7609b5e0ba8b9833&chksm=fbd7a918cca0200eb0d1aba6a17889b91b0235df7edc6e5b4c611aabc464357d445f2c6ee132&scene=27#wechat_redirect">美团王庆：当老板对指标进行灵魂拷问时，该如何诊断分析？</a></td><td>其他</td><td>2021-11-04</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247555887&idx=1&sn=72e77940abd250906cf42e03c8027c18&chksm=fbd7a943cca020551709b8e89bfc1c5c494fae68beb2d87d14cbea17f83455524443539469f6&scene=27#wechat_redirect">京东李欣如：从单目标排序到多目标模型，显著提升多业务效果！</a></td><td>多目标&amp;多任务</td><td>2021-11-02</td></tr><tr><td>百度</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247555532&idx=1&sn=df29d507d23d2431687d85b3ac865763&chksm=fbd7aba0cca022b615356a849cc9b60c32e0461d8d50328f5024408e0a4acda5ecb688600234&scene=27#wechat_redirect">基于用户出行意图建模的百度异地POI推荐</a></td><td>推荐</td><td>2021-10-29</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247554796&idx=1&sn=e96ad50dfbf4e2b54cfff9ee3ee122b7&chksm=fbd7a480cca02d96c66772353c5e4b54fc80d2577775337a53b6d916e753c2cf08af9d858be3&scene=27#wechat_redirect">阿里飞猪推荐算法探索实践</a></td><td>推荐</td><td>2021-10-21</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649765103&idx=1&sn=7da591618dfacca5314f77634861bd1e&chksm=becca79489bb2e82f1d4bb047b759a75c98257980e09514ebf83f72177a5aafec7945e340f8c&scene=27#wechat_redirect">一文搞懂CTR建模</a></td><td>精排&amp;CXR预估</td><td>2021-10-18</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5MzY4NzE3MA==&mid=2247496575&idx=1&sn=ea69970e5ce1e56683c0dfb5491e4c63&chksm=a691809291e60984f7e09ea5912be01f732fad486f8c1439152d6744b745c0989c8a5a38c713&scene=27#wechat_redirect">多目标排序在58同城房源推荐中的实践探索</a></td><td>多目标&amp;多任务</td><td>2021-10-18</td></tr><tr><td>蜻蜓FM</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247554470&idx=1&sn=2ff40b9e09a4424c850059053a065178&chksm=fbd7a7cacca02edca60d87ea1be7ec4ec489d1688a67e4451e8c8cb42f8d4da0027cbc4abe8e&scene=27#wechat_redirect">蜻蜓FM实时推荐系统的发展和演进</a></td><td>推荐</td><td>2021-10-14</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765021&idx=1&sn=3ac05ac64f650bcedd4f75d5aa715771&chksm=bd1260508a65e9462f356aab0fc0df37e4860628f3f404db9099b8195991bfd9a4542c35dd80&mpshare=1&scene=1&srcid=0117FB6mPZqwGWEVytjcUxEH&sharer_sharetime=1673957236741&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">广告深度预估技术在美团到店场景下的突破与畅想</a></td><td>精排&amp;CXR预估</td><td>2021-10-14</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247554157&idx=1&sn=cec38d80b7d75845c6af5bca7bf9087b&chksm=fbd7a601cca02f17ff5c1c5baee827ca106761579fdacc03e082e8034978a4860bf7d4c63dc3&scene=27#wechat_redirect">阿里广告技术新突破：面向最终目标的全链路一致性建模</a></td><td>广告</td><td>2021-10-11</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247553674&idx=1&sn=93fd72425a2e1fc8a1aaaa48075a7f09&chksm=fbd7a0e6cca029f099db1ee7f6d44e0bc32ad91f21d661573be58e8e2d323aa822c37fa0219d&scene=27#wechat_redirect">广义多目标算法探索实践</a></td><td>多目标&amp;多任务</td><td>2021-10-04</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247551834&idx=2&sn=98052911088d340991cec0c6c804f389&chksm=fbd7b936cca03020aaae4b4c5820e678017589affa19dedfe4fea56059c10c6922380ea65a6c&scene=27#wechat_redirect">多目标排序在二手房推荐系统的实践探索</a></td><td>多目标&amp;多任务</td><td>2021-09-19</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247550322&idx=2&sn=5f46d888ca18541b9b3d9929cdbb369f&chksm=fbd7b71ecca03e089c2a6c7996fef0b640af5f8ea79c000418847847e69276d07035bc483370&scene=27#wechat_redirect">淘宝直播全屏页重排算法实践</a></td><td>重排</td><td>2021-09-04</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247549101&idx=2&sn=08fab37f73d47f7215e0a5f8fd1ad24c&chksm=fbd7b2c1cca03bd716dcd437fabd34bdf9fb802dbef59e18039dede88511ff113864352b1172&scene=27#wechat_redirect">阿里妈妈广告创意优选</a></td><td>广告</td><td>2021-08-27</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650433549&idx=1&sn=7e352d215146a445ea47a566a4aa8411&chksm=8396a015b4e12903e30ea108bb8fd4c963d4b0af6bd691a869ec77220211427084a60ce57cf1&scene=27#wechat_redirect">SIGKDD2021   | 淘宝搜索向量化召回实践</a></td><td>召回</td><td>2021-08-25</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247547626&idx=2&sn=3954ffc136544fd683b1629c9df8a978&chksm=fbd78886cca0019084a7b35ed0fa21e5f753a22d172c4b63dbe756d2b5581242fdf8c7280fe8&scene=27#wechat_redirect">微信看一看如何过滤广告文章？</a></td><td>广告</td><td>2021-08-14</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247547435&idx=1&sn=d629f799eb85ac8e90c6962cd424d7ee&chksm=fbd78847cca00151fdd192d1152aaae4cc7ec1b7a1a67487f4e5619070475020b8fc0fb83de1&scene=27#wechat_redirect">朱小强｜屠龙少年与龙：漫谈深度学习驱动的广告推荐技术发展周期</a></td><td>广告</td><td>2021-08-10</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650433132&idx=1&sn=d3d9df3adbb8533eaa2f60f80dd8fc2f&chksm=8396ae74b4e12762ac17b45a41e0e4b98d2cb3493eb6e44b0e338d3b594f685efa43bff5a4ce&scene=27#wechat_redirect">淘宝视频的跨模态检索</a></td><td>搜索</td><td>2021-08-09</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247547345&idx=1&sn=343a931f247a2ebc0e53b40298b0bb17&chksm=fbd78bbdcca002abce76f5c4bf6aca9d44e45bf9e16ee219ac33620521b9e2c81186c1933ad8&scene=27#wechat_redirect">阿里妈妈展示广告预估校准技术演进之路</a></td><td>广告</td><td>2021-08-09</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247547245&idx=1&sn=e5d4731f4b0b665057786318c6fac68c&chksm=fbd78b01cca00217b66667d41cdbee41ebce14a58d8c9f99ce48838ffd4713560e78919e6ede&scene=27#wechat_redirect">多类目MoE模型在京东电商搜索中的应用</a></td><td>搜索</td><td>2021-08-07</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650433059&idx=1&sn=7282fc6987a94b5d32d88ffc513dcc15&chksm=8396ae3bb4e1272d3cc9a73ce8b2cd7aa6914c80958e57b13bcdba379fdbe755ac7d304547f3&scene=27#wechat_redirect">淘宝视频内容标签的结构化分析和管理</a></td><td>内容理解</td><td>2021-08-06</td></tr><tr><td>微拍堂</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247547145&idx=1&sn=de1b92402bf93a5777ab0e7faac3dd57&chksm=fbd78b65cca0027348e33d8be4c044b190a25129cbd12cad5dedef08f90c87e42796a1fd14f5&scene=27#wechat_redirect">深度召回在文玩个性化推荐中的实践</a></td><td>召回</td><td>2021-08-04</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247547084&idx=1&sn=7bcfbba74623c84bcc850bd042c279b6&chksm=fbd78aa0cca003b6726344ce152f7ddcb1fae15932c262c042b43783260b1b7b69ce15524cdc&scene=27#wechat_redirect">FAE：阿里广告归因分析与用户增长分析引擎</a></td><td>广告</td><td>2021-08-03</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247546914&idx=1&sn=b553a4d0cb60b9220b967970f9b54b13&chksm=fbd78a4ecca00358b84bd7d41eda415ea50169fe7b23bb27009bc526ccabe7dd9cdbf1707411&scene=27#wechat_redirect">美团商品知识图谱的构建及应用</a></td><td>知识图谱</td><td>2021-07-31</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5MzY4NzE3MA==&mid=2247495242&idx=1&sn=c739912e3f2116eb000255ae368b3c07&chksm=a6919da791e614b17afc52b99157ac735a66990946b42ca9ae437f96c112f8cd08d4cbfca128&scene=27#wechat_redirect">阿里1688直播推荐算法实践</a></td><td>推荐</td><td>2021-07-28</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650432692&idx=1&sn=db725557ba260b82ca2601d578687916&chksm=8396acacb4e125baa2f9fb61e7b30015e9bfaf7cc327734ce6193e0e6378dcc9637486eb6935&scene=27#wechat_redirect">2021年，算法工程师必备的能力是什么？</a></td><td>其他</td><td>2021-07-26</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247546474&idx=2&sn=ada65eaa15c7beef9c2f70f586d8dfbf&chksm=fbd78406cca00d10b2532ffe6c937ef216cfa96c90efaf91901233d8dbd1be11aa396a5bfafd&scene=27#wechat_redirect">淘宝详情页分发推荐算法总结：用户即时兴趣强化</a></td><td>推荐</td><td>2021-07-24</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247546358&idx=2&sn=b8b5605be6321a2e3291733aafc45053&chksm=fbd7879acca00e8c8f1891dbc01322991153e72a45a7b468a2c5a160acb1300ecc44843be1cf&scene=27#wechat_redirect">阿里妈妈流量反作弊算法实践</a></td><td>广告</td><td>2021-07-23</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247545833&idx=1&sn=9feb4b0a4b6ab469a434df7696efaadd&chksm=fbd78185cca00893a23e1a61d49c0d5e86e291450a1d8444c171fbd0a07d9365ae358d021175&scene=27#wechat_redirect">58同城CRM多目标排序算法</a></td><td>多目标&amp;多任务</td><td>2021-07-17</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247545777&idx=2&sn=bf9ee1e9d70148449f0643532fca9db6&chksm=fbd781ddcca008cbbec49ba2d0a31fd36f7390828ac5e9ebce831a2a787d29f18cdd38c93732&scene=27#wechat_redirect">阿里妈妈在线分流   AB Test</a></td><td>数据科学</td><td>2021-07-16</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247545585&idx=1&sn=d45b4e3909c2f1677d9900d8f07718a1&chksm=fbd7809dcca0098b70f8213ac4c86badf8921cc680a462d98fd52ee3a84f5d2ffb23187a49ec&scene=27#wechat_redirect">全民K歌直播推荐算法实践</a></td><td>推荐</td><td>2021-07-12</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247545317&idx=2&sn=acbd7df8a7554d92cb086febf4f3c0bd&chksm=fbd78389cca00a9f3fd3d3bbca7b61447c82566a5185db052cbac8241adc1164bc81685e2701&scene=27#wechat_redirect">多业务建模在美团搜索排序的实践</a></td><td>搜索</td><td>2021-07-10</td></tr><tr><td>丁香园</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247544207&idx=2&sn=4adac4d8c43122374905f236634e2b0e&chksm=fbd79fe3cca016f5f2896aa33cebd1442569f73aa8c807d4c0a0ac8753898e42fa736552bf1d&scene=27#wechat_redirect">丁香园基于Milvus的向量召回应用</a></td><td>召回</td><td>2021-07-02</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247543721&idx=2&sn=c4a4a98515f9f33be4b505977acb4499&chksm=fbd799c5cca010d3f62d23492016a42221f2cad319507541e6ce52a6d4c41bd19608ab267979&scene=27#wechat_redirect">美团外卖美食知识图谱的迭代及应用</a></td><td>知识图谱</td><td>2021-06-20</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247543682&idx=1&sn=49bb76a0dd3eb1263a1e5e204c95857e&chksm=fbd799eecca010f8fd2ec7376d7b304f6bf88c7dee9cd7305c9c9bcf7fdc3e6bc3ad22184207&scene=27#wechat_redirect">拼接召回在飞猪交通域的实践</a></td><td>召回</td><td>2021-06-18</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247543460&idx=2&sn=833b99ad67ff1914b94453aaa1e752c8&chksm=fbd798c8cca011de8743b244e2a39159e26691a963d6a046280b6dbdd6bd7e6f38ae4df53e33&scene=27#wechat_redirect">针对多目标推荐任务，微信看一看用PAPERec框架逼近帕累托最优</a></td><td>多目标&amp;多任务</td><td>2021-06-15</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247543441&idx=2&sn=2d283f1e03d1731d8a06a8f7b2115872&chksm=fbd798fdcca011eb3135738e25b4aef91b2a7305641c2ae505268a01e665014c1a77fe30583a&scene=27#wechat_redirect">阿里妈妈搜索广告CTR模型的“瘦身”之路</a></td><td>精排&amp;CXR预估</td><td>2021-06-14</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247543407&idx=2&sn=5ef8d7ada9e6060d0f88c303602b3db5&chksm=fbd79803cca01115ac9ea59e34afb653d3d9f1f7fd2857f77d6252cd0cd62aa1f47d7434a93e&scene=27#wechat_redirect">用于看一看list-wise推荐系统的HRL-Rec模型简述   | AAAI-2021</a></td><td>推荐</td><td>2021-06-13</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650431219&idx=1&sn=0b66e25d6693363d34cafbb6abc72fa8&chksm=839696ebb4e11ffd2dc45c654d5e6b254625719b6a4e01ce4186218c3f147dd3dd5398590680&scene=27#wechat_redirect">工业界常用的推荐系统模型有哪些？</a></td><td>推荐</td><td>2021-06-07</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247542308&idx=1&sn=822ad9c80b39f9fd281573f2deb610ac&chksm=fbd79448cca01d5e9697b7a943cb550483685ddfe10222abf4612aa29007481d35b11a461b85&scene=27#wechat_redirect">大规模图算法在京东广告的实践</a></td><td>广告</td><td>2021-06-02</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247542213&idx=2&sn=d0708ac37e8805c8ff385600bc3888e1&chksm=fbd797a9cca01ebfccee12ef66cf7b9dc19753e960dbf1de254520c050e7131740b382f34ac8&scene=27#wechat_redirect">阿里妈妈搜索广告CTR模型演进</a></td><td>精排&amp;CXR预估</td><td>2021-06-01</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247542183&idx=1&sn=4f844163c99f7ee554554b4be1e31512&chksm=fbd797cbcca01edde5bd80a9ab67ff22a250ab98d473694105a83b9ae242f8867fcbf11a4d38&scene=27#wechat_redirect">阿里飞猪个性化搜索排序探索实践</a></td><td>搜索</td><td>2021-05-31</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650430647&idx=1&sn=de550537683d9444813a16703d60780e&chksm=839694afb4e11db952c355a6b1f6f9bad00e713de7a5f9bbe847a5dbc0cddd4cabc3c604ca47&scene=27#wechat_redirect">5大经典排序算法在淘宝“有好货”场景的实践</a></td><td>推荐</td><td>2021-05-28</td></tr><tr><td>蜻蜓FM</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247541942&idx=1&sn=60eeeb4a69f817d2cff29750f8b7fbdb&chksm=fbd796dacca01fcc8ff53c481fb219368b24b48b4e44c068f588b9d1921742ef973663cf23c6&scene=27#wechat_redirect">蜻蜓FM信息流推荐探索与实践</a></td><td>推荐</td><td>2021-05-26</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650430600&idx=1&sn=313876949aa19b5d38e4f9363abf7b27&chksm=83969490b4e11d86ca19aea8c1e9034577051dac13f5ce04a3e241b3732dbc75d65f35cc1be2&scene=27#wechat_redirect">分钟级在线深度学习在手淘信息流排序模型中的探索与实践</a></td><td>推荐</td><td>2021-05-26</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5MzY4NzE3MA==&mid=2247494303&idx=1&sn=b1d8d66bd590e66158b5ce745f2dc6ea&chksm=a691997291e610645cd6962a33c83945ddbc42a1630ac48bbef53bad9f22239a6db81a20a7cd&scene=27#wechat_redirect">微信视频号推荐算法挑战赛baseline分享</a></td><td>推荐</td><td>2021-05-23</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247541722&idx=2&sn=828032935a3f384d75fbc54a1396cf12&chksm=fbd791b6cca018a021c5e53221b684aba588f03176e3b9cc2b839b6820f8c8766b79a074e4fc&scene=27#wechat_redirect">你真的懂点击率（CTR）建模吗？</a></td><td>精排&amp;CXR预估</td><td>2021-05-20</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247541692&idx=1&sn=478e62d4865aa51a84f1d89ef0d862c0&chksm=fbd791d0cca018c6e5445ee84e6bccfc698d72d68e23e8b989ce3ff428c722ce019254ad6281&scene=27#wechat_redirect">因果推断在阿里飞猪广告算法中的实践</a></td><td>因果推断</td><td>2021-05-19</td></tr><tr><td>爱奇艺</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247541265&idx=1&sn=5446849bfdf0f0ce571e5eac412dd04b&chksm=fbd7907dcca0196bb199142242773bf89fb3393c6a9e594a8ecead15ef20b86d2456faa05280&scene=27#wechat_redirect">爱奇艺短视频推荐：多兴趣召回篇</a></td><td>召回</td><td>2021-05-15</td></tr><tr><td>滴滴</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247541235&idx=2&sn=eeb61de139b90caa87add3aacf39ed29&chksm=fbd7939fcca01a89391bc124f54ccf8e58baca2b597b54b39ba3c9dbd3c5b9bdac6e5fb6809f&scene=27#wechat_redirect">滴滴连续因果森林模型的构造与实践</a></td><td>因果推断</td><td>2021-05-13</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247541036&idx=1&sn=136c52347a6e6fde29d9f7604df4d0e8&chksm=fbd79340cca01a5618af600e66f2dd392cdd0fe8615cacf3d20ec55e0167a7108dfd6c0859f1&scene=27#wechat_redirect">Query理解在美团搜索中的应用</a></td><td>搜索</td><td>2021-05-07</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650428919&idx=1&sn=2a687d967536d65d31f026243b74479a&chksm=83969defb4e114f9ecf975a4b55836e0be86748cd76cc1cf3e3e2db6344478925c4c454ace32&scene=27#wechat_redirect">MIND   - 基于动态路由的用户多向量召回</a></td><td>召回</td><td>2021-04-26</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650428918&idx=1&sn=3d1b828d0bc685a357a13a607cad365c&chksm=83969deeb4e114f81484cb3c0216c0a6cdf55ae2d6dc824963fd7ee2cb2b09978a906aabda1c&scene=27#wechat_redirect">SIGIR2021   | 超越I2I和向量内积，淘宝新一代召回范式：PDN模型</a></td><td>召回</td><td>2021-04-25</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247540489&idx=1&sn=56258f5ebcff70e17e6d026aba8fd059&chksm=fbd7ed65cca06473cd2ff831b68672ec1b19f43b993c6bcd8d7fd5c3bfbffe6898f2a6a79855&scene=27#wechat_redirect">阿里定向广告智能投放技术体系</a></td><td>广告</td><td>2021-04-24</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247539967&idx=2&sn=6c386bbb663d5c15432c4b319e7cab15&chksm=fbd7ee93cca06785618c0a96e69fb9ec45af73e9a1bcfa4cf03e33c2e14b81409702676b878e&scene=27#wechat_redirect">没什么是一次排序解决不了的，如果有，那就One   more time</a></td><td>推荐</td><td>2021-04-17</td></tr><tr><td>腾讯看点</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649757741&idx=1&sn=b77ae57ee2c7ab4c9621ec4cfbca1a85&chksm=becc8b5689bb0240959c0bbd40a104f0646b235f09e89cf20a01099d9d4bdc8843bd499f3d8c&scene=27#wechat_redirect">腾讯   QQ 看点图文多目标推荐实践经验</a></td><td>多目标&amp;多任务</td><td>2021-04-09</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649757740&idx=1&sn=51e5809fcf1b2f148dfd284d4628c57a&chksm=becc8b5789bb0241136a70f726c94007f8b61d62bc87a6d4f09ca8d8d80eff5382c735fae685&scene=27#wechat_redirect">微信看一看实时相关推荐介绍</a></td><td>推荐</td><td>2021-04-08</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247538234&idx=1&sn=8626d27fd350c9f3008fdb5944cfb608&chksm=fbd7e456cca06d40a769a4241877a3beb494e94a6a548687ca3b449510a7320f26d30db979ab&scene=27#wechat_redirect">全民K歌推荐后台架构</a></td><td>工程相关</td><td>2021-04-02</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247537974&idx=1&sn=116f1bcaa683ea35587b0483d9599d4d&chksm=fbd7e75acca06e4c560519cac81cb324be3737b524beca1a249ac114dbfa99109e1fb71361f7&scene=27#wechat_redirect">全民K歌内容挖掘与召回</a></td><td>召回</td><td>2021-04-01</td></tr><tr><td>陌陌</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247536974&idx=1&sn=77201e9ee0390fa0652424e67e6b2b2e&chksm=fbd7e322cca06a34698caf1c601871fcfd3e39f19e947fc871fb57760fc6d8f9f00c0e5e9c8b&scene=27#wechat_redirect">模型化召回在陌陌社交推荐的应用和探索</a></td><td>召回</td><td>2021-03-20</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650423941&idx=1&sn=de554547923b2a5bed291727600c6756&chksm=83968a9db4e1038ba8f117a02555969fd1d5c8999c988219a64de43ab300ca838ead9520ab73&scene=27#wechat_redirect">超长用户行为建模在躺平家居内容推荐中的应用实践</a></td><td>推荐</td><td>2021-03-18</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247536094&idx=1&sn=b5fa05a617b40d0af80f5d2c13933e26&chksm=fbd7ffb2cca076a4139ee592d1bc6884cc3e778f588c89048ebbe0ac1b07f3e659013e230842&scene=27#wechat_redirect">深度排序模型在淘宝直播的演进与应用</a></td><td>推荐</td><td>2021-03-17</td></tr><tr><td>腾讯音乐</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247534298&idx=1&sn=21ad88daaedaf33566862e27efc29f5e&chksm=fbd7f4b6cca07da043296b689ededb9923057f68e551c2af0f73a805bf4b38f6c9279b019d84&scene=27#wechat_redirect">腾讯音乐：全民K歌推荐系统架构及粗排设计</a></td><td>粗排</td><td>2021-03-08</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247533960&idx=2&sn=6c73cfb81818554c26add442a3fc92af&chksm=fbd7f7e4cca07ef24457e2a9894e99204c895785202d72257d531b773760b8d1e21df9f08858&scene=27#wechat_redirect">阿里飞猪主题与交互式推荐技术实践</a></td><td>推荐</td><td>2021-03-04</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247533885&idx=1&sn=4bacb967f194d00e69798f9a3b0eeed2&chksm=fbd7f751cca07e47e466094605201bfcc5feff89e273a1aa59b64d5aeb6ffb0b2aaee9a99678&scene=27#wechat_redirect">京东搜索在线学习探索实践</a></td><td>搜索</td><td>2021-03-01</td></tr><tr><td>爱奇艺</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247533568&idx=1&sn=2b8c694ff43bb451ff1e70b49a7bd97b&chksm=fbd7f66ccca07f7a29d0eb0389cd4231707d6588219af0fff94b22e43d8106161172aff9f16c&scene=27#wechat_redirect">爱奇艺短视频推荐：粗排篇</a></td><td>粗排</td><td>2021-02-27</td></tr><tr><td>快手</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247533308&idx=1&sn=f25852e94c1f0c3535312961342b2933&chksm=fbd7f090cca07986161d65abbf1f8bdc7858775a75de302f591c31ed992e9816682d44e6b311&scene=27#wechat_redirect">多目标排序在快手短视频推荐中的实践</a></td><td>多目标&amp;多任务</td><td>2021-02-24</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247530926&idx=1&sn=43527db30cd5d0584a8f112426d8720f&chksm=fbd7cbc2cca042d4c0620396c3acc6752c8b6a9f5c7980a9f7ac44a72c040e0d0763ced31606&scene=27#wechat_redirect">阿里粗排技术体系与最新进展</a></td><td>粗排</td><td>2021-02-21</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247529736&idx=1&sn=d24b824c6ff0841a851f123800b87ea4&chksm=fbd7c764cca04e722b39cc29e05eb4e5009ea9f66a5b0e502653c8086a56defb1dec257893aa&scene=27#wechat_redirect">EdgeRec：边缘计算在推荐系统中的应用</a></td><td>推荐</td><td>2021-02-17</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247529654&idx=1&sn=77b68c348d19685b57523056b8762c8c&chksm=fbd7c6dacca04fcc3edf402e37fef4bc7eacfad21a99c37e28131501fbbe3a74033ded30732b&scene=27#wechat_redirect">阿里深度树匹配召回体系演进</a></td><td>召回</td><td>2021-02-15</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247529612&idx=1&sn=57e147d705ba3faebb8acb91e18c5bc6&chksm=fbd7c6e0cca04ff616575d710a545f98e79db90394e76b9d5f5f3589124efa8a88d6f99aaed1&scene=27#wechat_redirect">多目标推荐场景下的深度学习实践</a></td><td>多目标&amp;多任务</td><td>2021-02-13</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247529074&idx=1&sn=877e42d49b4474eb488a32ec3b5e9108&chksm=fbd7c01ecca04908f40d3907a719b850cbf1cfb87afb83e4cc62e8255b7714bd65504d639e54&scene=27#wechat_redirect">5大经典排序算法在淘宝“有好货”场景的实践</a></td><td>推荐</td><td>2021-02-11</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247528876&idx=2&sn=717b0426ccbcc168d0fa9fbad3fc2c8a&chksm=fbd7c3c0cca04ad662db295c96894f85b89a36d074565a326a53ad9d8870944bce48da2be748&scene=27#wechat_redirect">深度学习在搜索排序业务中的应用</a></td><td>搜索</td><td>2021-02-10</td></tr><tr><td>蘑菇街</td><td><a href="https://zhuanlan.zhihu.com/p/344165004">基于ESMM模型的MTL多目标优化实践——用户活跃度影响排序机制——蘑菇街首页信息流推荐</a></td><td>多目标&amp;多任务</td><td>2021-02-08</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650418474&idx=1&sn=6b1e3ff914e68607c006a07a5b880296&chksm=8396e532b4e16c24734511e21872e995f5191943628eca791eb819a3899cfd6904996d09f461&scene=27#wechat_redirect">MMoE算法在家居内容推荐中的应用与实践</a></td><td>多目标&amp;多任务</td><td>2021-02-05</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247523713&idx=1&sn=06a41fb141e2fcdd0b723874f5090481&chksm=fbd72fedcca0a6fbb4f4b89720e379bde71a9f25579e2886b7629ad3e7f4f7eb7b550ca9e9f5&scene=27#wechat_redirect">阿里飞猪搜索技术的应用与创新</a></td><td>搜索</td><td>2021-02-03</td></tr><tr><td>Hulu</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247522939&idx=1&sn=8dfedad371667ef3ebd5621cbb882a25&chksm=fbd72817cca0a1015e484b805bd5ef5c9442b47e1f45a9643cfc56bbc7a5787bad19ae4d1351&scene=27#wechat_redirect">Hulu在Content   Embedding的探索与实践</a></td><td>召回</td><td>2021-01-29</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247522902&idx=1&sn=55111acdfdc00dc59fc0fb10dfe9e0dc&chksm=fbd7283acca0a12c23a5b77a2413c25956a63c348c48f9fe01787d3d155d5fbcd183a0f09e90&scene=27#wechat_redirect">想为特征交互走一条新的路</a></td><td>精排&amp;CXR预估</td><td>2021-01-27</td></tr><tr><td>Facebook</td><td><a href="https://zhuanlan.zhihu.com/p/348595873">Facebook’s   News Feed ranking algorithm</a></td><td>推荐</td><td>2021-01-26</td></tr><tr><td>知乎</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247522599&idx=1&sn=24ab674235a3bc1a3b9944894bb6715f&chksm=fbd72b4bcca0a25d7287bf4ad0ec5becdb1ceb800966c9f7cf1ecacf807187f3a5a9d13f71a0&scene=27#wechat_redirect">知乎搜索排序模型的演进</a></td><td>搜索</td><td>2021-01-25</td></tr><tr><td>知乎</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247520759&idx=1&sn=4aaab934ad388ce03d3af0a3e812ce9e&chksm=fbd7239bcca0aa8d37d22880608f7704c51104f79b5bee016a7b4692dc3340e983dae0c0fa31&scene=27#wechat_redirect">知乎搜索文本相关性与知识蒸馏</a></td><td>搜索相关性</td><td>2021-01-15</td></tr><tr><td>蘑菇街</td><td><a href="https://zhuanlan.zhihu.com/p/338515054">基于ESMM模型的多目标优化实践——蘑菇街商城篇</a></td><td>多目标&amp;多任务</td><td>2021-01-08</td></tr><tr><td>贝壳</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247519854&idx=2&sn=b373b930f2409b56c3d27193f8b7fd1f&chksm=fbd73c02cca0b514bf784919121c46963cdca4aa944336dfeb8c5b7f5b5211de0b746f4eee23&scene=27#wechat_redirect">贝壳用户偏好挖掘的思考与实践</a></td><td>偏好挖掘</td><td>2021-01-07</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247519343&idx=1&sn=4f23cfbc240fcaac5d05a6411362a3fa&chksm=fbd73e03cca0b715ff529d524b1d36efc4a7c52c904fdc07f5858ce06943de1e4acd381b0ae5&scene=27#wechat_redirect">算力经济时代：阿里展示广告引擎的”柔性”变形之路</a></td><td>广告</td><td>2021-01-04</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247518591&idx=2&sn=483cec95afbfc61aa0b6736ebae47b3c&chksm=fbd73b13cca0b205887dfa2e03a092cb9bda9b2f22e823ea378ef96cf24a9a75775c47f9f170&scene=27#wechat_redirect">Angel图神经网络算法在推荐场景下的实践</a></td><td>推荐&amp;图网络</td><td>2020-12-31</td></tr><tr><td>soul</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247518142&idx=1&sn=6c7484ca8f4d55fc96e2e8a87ab4cbb5&chksm=fbd735d2cca0bcc4d56252639dd615aee574a520cc37ce7d6401cc7ef44f7e8f9b79739e78f9&scene=27#wechat_redirect">灵魂匹配：陌生社交Soul的增长机制</a></td><td>用增</td><td>2020-12-26</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247517980&idx=2&sn=bc82b69449a005f76284a475c46a7ec2&chksm=fbd73570cca0bc66302d7bdb893e4c391197004baf376a0fa3e52ad68052ba7bc66ee0e0a723&scene=27#wechat_redirect">Angel推荐算法在游戏推荐中的应用</a></td><td>推荐</td><td>2020-12-24</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5MzY4NzE3MA==&mid=2247489906&idx=2&sn=ef3edb0c5ea102b92beaf3731f928af3&chksm=a6926a9f91e5e389230aa102870b24102d73e7073c75c5bfd997f8d8b8d6b9b14808326ff011&scene=27#wechat_redirect">序列检索系统在淘宝首页推荐重排中的实践（附重排经典论文合集）</a></td><td>重排</td><td>2020-12-18</td></tr><tr><td>蘑菇街</td><td><a href="https://zhuanlan.zhihu.com/p/337649676">蘑菇街增量学习番外篇三：deepFM的动态正则实践</a></td><td>推荐</td><td>2020-12-18</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247517708&idx=1&sn=d44835c9bc1099aeb6b6c40b8c32fad5&chksm=fbd73460cca0bd769dfa2a3379649c14b78528cfb8e9df0fa3807bbcf6cef3f9324a52a83a97&scene=27#wechat_redirect">序列检索系统在淘宝首页信息流重排中的实践</a></td><td>重排</td><td>2020-12-17</td></tr><tr><td>蘑菇街</td><td><a href="https://zhuanlan.zhihu.com/p/270354109">蘑菇街增量学习番外篇一：动态正则之tensorflow中div转mod设计（含代码实现）</a></td><td>推荐</td><td>2020-12-17</td></tr><tr><td>蘑菇街</td><td><a href="https://zhuanlan.zhihu.com/p/329877052">蘑菇街增量学习番外篇二：优化器设计理论篇（AdamW、AdaDeltaW、FTRL）</a></td><td>推荐</td><td>2020-12-17</td></tr><tr><td>丁香园</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247517070&idx=2&sn=367376c143ca8f5e526b33d93518ea16&chksm=fbd731e2cca0b8f4c97ea4f22464c6ee101e853f2a95b8159763c72e723d8902843a13970bf9&scene=27#wechat_redirect">再谈搜索中的Query扩展技术</a></td><td>搜索</td><td>2020-12-14</td></tr><tr><td>贝壳</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247516794&idx=1&sn=a3f2243dfba429f3956514c2e00aca1b&chksm=fbd73016cca0b900bce56933e86d12237c7ca5e7ada3532d104e18e5a03d60167683b23aaa38&scene=27#wechat_redirect">贝壳商业化算法中台架构实践</a></td><td>工程相关</td><td>2020-12-10</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651755958&idx=2&sn=bb2a7e9e3817d9993a9137dfeb6b5ec4&chksm=bd124cfb8a65c5ed3453a6473b556df1968e9f983da94bcab6610f718bfed2b37be5bd3ad7ae&mpshare=1&scene=1&srcid=0117wmg82Cvm9SxD2roqqbzV&sharer_sharetime=1673957290926&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">ICDM论文：探索跨会话信息感知的推荐模型</a></td><td>推荐</td><td>2020-12-10</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247516481&idx=2&sn=fe9b5f5d0caaa8c142abdb1803336c8f&chksm=fbd7332dcca0ba3b3d27055d9325be56b0fc54106cd0d36ad3a3ac88ce1c3d0e49ff1ebb5c33&scene=27#wechat_redirect">浅谈微信AI在通用图像搜索领域的探索</a></td><td>搜索</td><td>2020-12-09</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649754988&idx=1&sn=e1d382f8337b5b29085f7e495e85cd0d&chksm=becc9e1789bb1701c6dffa631ae135217240fb436bbc542b36af7a8b6a64b2c7c6f3bb988ce8&scene=27#wechat_redirect">微信AI从识物到通用图像搜索的探索揭秘</a></td><td>搜索</td><td>2020-12-04</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247513875&idx=1&sn=75f718e9c7a27e37a753bd7d7e3c1fd1&chksm=fbd7057fcca08c690d7b5aab77ff92a374e8f88b722815c421e0d69d1fecad73fec888969a7c&scene=27#wechat_redirect">信息流推荐的用户增长机制</a></td><td>用增</td><td>2020-12-02</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247513629&idx=2&sn=afba7c17c3f59a9ad04598584aaf181a&chksm=fbd70471cca08d67fd0a4feb6febf613746e1bce6b03e72f6a47c82886f9008e4d1a0dec2683&scene=27#wechat_redirect">主流Embedding技术解析</a></td><td>召回</td><td>2020-12-01</td></tr><tr><td>NVIDIA</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247513593&idx=2&sn=376de870c28403fa35087e438a4e6279&chksm=fbd70795cca08e838ee482038a321031db6f4725accb631d92587f111a856ea7217a7727b083&scene=27#wechat_redirect">Merlin：基于深度学习的推荐系统框架</a></td><td>推荐</td><td>2020-11-29</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247512282&idx=2&sn=7174703572f4609d8cc471de41f84762&chksm=fbd702b6cca08ba085c7c2e84b47c4cea10be3400790a6ada49bf1e19e6dd2f996b89685a534&scene=27#wechat_redirect">美团本地生活场景的短视频分析</a></td><td>其他</td><td>2020-11-22</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247512229&idx=1&sn=fe8430b49e6d5fd73e0f9c5cd9d0aaf6&chksm=fbd702c9cca08bdf665cb5628d380e25073dd18366372ff75243f0d9491760f6030a10aebc01&scene=27#wechat_redirect">网易云音乐推荐中的用户行为序列深度建模</a></td><td>精排&amp;CXR预估</td><td>2020-11-20</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247512107&idx=2&sn=ce7ce209d594b0574518e5b62a60998a&chksm=fbd70247cca08b5190e1b06ed87f036fc71c17bdda40fb80cbe69420ac7fe22f4eda2c554398&scene=27#wechat_redirect">阿里文娱深度语义搜索相关性探索</a></td><td>搜索相关性</td><td>2020-11-16</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247512053&idx=2&sn=0ab4ade5ee6c83f1f53a0e03583dc822&chksm=fbd71d99cca0948f7fb6e29943d559214fb55373287ee66cd7c786986f673b9d587ef1d6a3f2&scene=27#wechat_redirect">搜索query意图识别的演进</a></td><td>搜索</td><td>2020-11-15</td></tr><tr><td>蘑菇街</td><td><a href="https://zhuanlan.zhihu.com/p/271858727">蘑菇街首页推荐多目标优化之reweight实践：一把双刃剑？</a></td><td>多目标&amp;多任务</td><td>2020-11-13</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247511450&idx=2&sn=57ce9b8d1493fa72f4255dc9b0b866f2&chksm=fbd71ff6cca096e0f798537bcb9e75b88dd777013b7a9fc94b42fa5e7f7368347fb2c566643d&scene=27#wechat_redirect">要提升微信看一看推荐混排的长期收益？试试深度强化学习</a></td><td>推荐</td><td>2020-11-12</td></tr><tr><td>爱奇艺</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247511245&idx=2&sn=06e8909f8955594394daef5c43f1b538&chksm=fbd71ea1cca097b7373fa24f9d398b58747ef06c408bd798c1995a37a11132e66809306a2ba0&scene=27#wechat_redirect">TensorFlow   Ranking框架在爱奇艺海外推荐的实践与应用</a></td><td>工程相关</td><td>2020-11-09</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247511217&idx=2&sn=021d8fba7ab6decca283d95e5da00600&chksm=fbd71eddcca097cb5da1b73eee9cac0b07277be93fd08cadda170726459fa2a385d376c733bd&scene=27#wechat_redirect">ZeroSearch：腾讯新一代搜索引擎</a></td><td>工程相关</td><td>2020-11-08</td></tr><tr><td>蘑菇街</td><td><a href="https://zhuanlan.zhihu.com/p/265522400">文本相关性在蘑菇街搜索推荐排序系统中的应用</a></td><td>搜索相关性</td><td>2020-10-30</td></tr><tr><td>360</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247509951&idx=1&sn=04462583ebe942a12dc8260f7d909ae2&chksm=fbd715d3cca09cc52f5a2aff66e08ad655eb4dd6b7e035d9134a4afceca2c76d19feacf501ce&scene=27#wechat_redirect">360展示广告智能化演进</a></td><td>广告</td><td>2020-10-30</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247509607&idx=1&sn=341212c60824f8c636ee7e8b64a63d62&chksm=fbd7140bcca09d1d52dfb1c10c180feffe3641d2611b46497f08f9722a66cbd6b08436013be4&scene=27#wechat_redirect">“全能选手”召回表征算法实践</a></td><td>召回</td><td>2020-10-28</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247509524&idx=1&sn=a65fb689f9b013fe06c44f1e4b2e1b84&chksm=fbd71478cca09d6eadfa3c06c921a47681339c0fa42bd960d66057f07e436e31ed08e92dfeda&scene=27#wechat_redirect">腾讯增长技术：智能投放篇</a></td><td>广告</td><td>2020-10-26</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247509261&idx=1&sn=17a4b327f46ea40bdf4f7481f8739311&chksm=fbd71761cca09e778f3e05860d2e1333c0ba9e32c6854f1040991478f5965262ef1a0f849b4c&scene=27#wechat_redirect">阿里深度召回模型实践</a></td><td>召回</td><td>2020-10-23</td></tr><tr><td>爱奇艺</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247509245&idx=2&sn=e32f855fa4bcabdd98aef05acc540c17&chksm=fbd71691cca09f878448bf905db8e11119d4ad2482ab48132145ef3ba51fd868448499d73047&scene=27#wechat_redirect">爱奇艺视频精彩度分析算法及应用</a></td><td>其他</td><td>2020-10-22</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247509060&idx=1&sn=be61e643a3de80d8b0bd028cdb5b6827&chksm=fbd71628cca09f3e637db58ce5fc43254fa18ad16779cd6eaf6f1c2d70bbf9e787b420d4116e&scene=27#wechat_redirect">阿里新突破！动态网络表征学习在推荐领域的创新与实践</a></td><td>推荐&amp;图网络</td><td>2020-10-17</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247509016&idx=1&sn=aa4c859d268ca02ff869d0930f154463&chksm=fbd71674cca09f62c62bcc8fa9704df9d041c2c5271bdf4eb4bb9cf7e12bb407469e07868017&scene=27#wechat_redirect">Angel：深度学习在腾讯广告推荐系统中的实践</a></td><td>推荐</td><td>2020-10-14</td></tr><tr><td>丁香园</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247508936&idx=2&sn=78be7e9852a78ddf0da07198b6c7978b&chksm=fbd711a4cca098b245bcdba6932d42927a95ebf01fb949f3e4dbf8d74efc63e6c619357fc702&scene=27#wechat_redirect">医疗搜索中的query词权重算法探索</a></td><td>搜索</td><td>2020-10-13</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650411171&idx=1&sn=b05ff627563bb01d6d29e9482e7e5cc3&chksm=8396d8bbb4e151ad9353e25ab55df7dcb42181c74841db869b9b742994f97109cf423b998685&scene=27#wechat_redirect">推荐算法三视角:矩阵，图，时间线</a></td><td>推荐</td><td>2020-10-13</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247508674&idx=1&sn=098ce77e2947f6e7bb28e56f320d7633&chksm=fbd710aecca099b8e4facf74dc0de9c6023d022c701d012e181c6286295c7578601b5cf78979&scene=27#wechat_redirect">阿里强化学习重排实践</a></td><td>重排</td><td>2020-10-04</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247508638&idx=1&sn=97aa5c7ee4a7981942f40eed91853645&chksm=fbd710f2cca099e45307f0622d243ba543164c14131bbc8cb5a410b4a8ea974f9e1562b34cde&scene=27#wechat_redirect">Embedding在网易严选搜索推荐中的应用</a></td><td>召回</td><td>2020-10-01</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650411013&idx=1&sn=de621be8767a9e4e9c8de312ecfd5702&chksm=8396d81db4e1510b4a88441595810d48d6ab6c4a4d295fd7b543152603820e93deeba9b52c22&scene=27#wechat_redirect">内容推荐算法：异构行为序列建模探索</a></td><td>推荐</td><td>2020-09-27</td></tr><tr><td>美图</td><td><a href="https://zhuanlan.zhihu.com/p/259668668">美图个性化推送的 AI   探索之路</a></td><td>推荐</td><td>2020-09-26</td></tr><tr><td>蘑菇街</td><td><a href="https://zhuanlan.zhihu.com/p/256252184">蘑菇街推荐算法之迷——self   attention不如traditional attention？</a></td><td>推荐</td><td>2020-09-24</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650410892&idx=1&sn=69a89072e83f6ff2b9333622ad390fdd&chksm=8396c794b4e14e829b625fa26568dd112f94edbdc97ec4984a2daf5ee5187e2283c397e36d48&scene=27#wechat_redirect">向量召回在躺平APP的实践</a></td><td>召回</td><td>2020-09-22</td></tr><tr><td>百度</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247508089&idx=1&sn=456558fbe9754cb3b55c6af563504ed1&chksm=fbd71215cca09b03d3ea2fcc44fe511a44823ced8947375a3af9f925c41fbaafd9a38bddaba2&scene=27#wechat_redirect">同义变换在百度搜索广告中的应用</a></td><td>广告</td><td>2020-09-21</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247507741&idx=2&sn=7d147d3db65d445cd6e17fd943643ebf&chksm=fbd76d71cca0e467a1d6add9d396f1722534d13c9a6c7bacb644c92105f5830bb04a240360ee&scene=27#wechat_redirect">阿里跨域点击率预估混合兴趣模型</a></td><td>精排&amp;CXR预估</td><td>2020-09-18</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247507652&idx=1&sn=9d3333523ef629aa4286c0bdc669ca22&chksm=fbd76ca8cca0e5be2c9bd7e5e59c5919a7a601eeb5d25ec913877f2827262fe96e0c9d56e6ce&scene=27#wechat_redirect">腾讯信息流热点挖掘技术实践</a></td><td>热点挖掘</td><td>2020-09-16</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247507509&idx=1&sn=5f0db1f772d6d8c39016c54318bbc1b1&chksm=fbd76c59cca0e54f82bc64bd1480e1bf36eb1d3323eaf0ce48c9362cdf2665aaafde8c1943a2&scene=27#wechat_redirect">阿里新一代Rank技术</a></td><td>推荐</td><td>2020-09-14</td></tr><tr><td>360</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&mid=2247487550&idx=1&sn=68af975e460637783d0a860bfb2d694d&chksm=c29323aaf5e4aabc45b4f705d6c69583960fdae2638f2b3a5252f507ecfa088c92e1f72c6ad8&mpshare=1&scene=1&srcid=0117tJyokgtmE6m24zBKj7kA&sharer_sharetime=1673957367314&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">TensorNet——基于TensorFlow的大规模稀疏特征模型分布式训练框架</a></td><td>工程相关</td><td>2020-09-14</td></tr><tr><td>Airbnb</td><td><a href="https://zhuanlan.zhihu.com/p/239824669">搜索推荐广告排序艺术-Airbnb搜索结果多样性优化</a></td><td>搜索</td><td>2020-09-13</td></tr><tr><td>Airbnb</td><td><a href="https://zhuanlan.zhihu.com/p/238095817">搜索推荐广告排序艺术-Airbnb搜索深度学习排序算法进化</a></td><td>搜索</td><td>2020-09-12</td></tr><tr><td>腾讯看点</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649749269&idx=2&sn=deabfe04574815220abad87d9dc9d415&chksm=bed3646e89a4ed782643c014b20e5fb4b2fa114ba8280e168c9f9fbeeef85f6cf758c56fef4e&scene=27#wechat_redirect">腾讯看点投放系统介绍：推荐系统的进化伙伴</a></td><td>推荐</td><td>2020-09-07</td></tr><tr><td>BIGO</td><td><a href="https://mp.weixin.qq.com/s/xC2eT_15Rtqc6Rri8p9xLQ">万亿模型参数的训练</a></td><td>排序</td><td>2020-09-07</td></tr><tr><td>BIGO</td><td><a href="https://mp.weixin.qq.com/s/u5wiTKXyBic_ri4fvEDKqA">万亿模型参数的在线服务</a></td><td>排序</td><td>2020-09-07</td></tr><tr><td>蘑菇街</td><td><a href="https://zhuanlan.zhihu.com/p/212647751">蘑菇街首页推荐视频流——增量学习与wide&amp;deepFM实践（工程+算法）</a></td><td>推荐</td><td>2020-09-04</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247507022&idx=1&sn=aa4a99562a274b5fd07e5f987a5dc807&chksm=fbd76e22cca0e734f4bc319ec3b908b9b3f200bda80e20b8f65836aac4445bc6a14675aa174e&scene=27#wechat_redirect">阿里妈妈深度树匹配技术演进：TDM-&gt;JTM-&gt;BSAT</a></td><td>召回</td><td>2020-09-04</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247506940&idx=2&sn=df6d88efa9f45dc7e2e4592018979692&chksm=fbd76990cca0e08637035afb74fb94cfaec3250c81c8744f41ac6be316d2bee96db16c9fc56c&scene=27#wechat_redirect">深度学习在商业排序的应用实践</a></td><td>推荐</td><td>2020-09-03</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247506872&idx=1&sn=26b673e5594ec07b3e56b94983d04741&chksm=fbd769d4cca0e0c24f0f96ce2f1eb995065dfbdb17f99cb8bcaa15cbb878673040854a0c0b1b&scene=27#wechat_redirect">CSCNN：新一代京东电商广告排序模型</a></td><td>广告</td><td>2020-09-02</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649749174&idx=1&sn=ba2bc3de97799879b186feb66e60ec1c&chksm=bed365cd89a4ecdbefb2cf3b631090947788c02fa42323cd19a943aeaa6363ce4bca85e93a4d&scene=27#wechat_redirect">微信「看一看」   朋友在看的增强推荐系统</a></td><td>推荐</td><td>2020-08-31</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247506444&idx=1&sn=48bc7d6d70b336237137a3191894d711&chksm=fbd76860cca0e176d6ba80ef7b7815634578b8468d7e9177158f2426b6d1a27f7b701fbfa940&scene=27#wechat_redirect">淘宝搜索模型核心技术：用户建模篇</a></td><td>搜索</td><td>2020-08-29</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649749100&idx=2&sn=7b35927876b101deee529bdb2649b8fb&chksm=bed3651789a4ec017c9a7f563ab7e5aab406a5a75aa87a2b89851755605d9c0784ce1099d8cb&scene=27#wechat_redirect">10   分钟快速入门海量数据搜索分析引擎 Elasticearch</a></td><td>工程相关</td><td>2020-08-28</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247506358&idx=2&sn=0736cc1bc0d11f4f1ce99979697c29d6&chksm=fbd76bdacca0e2cc405e0f7b689a17f3d752b9fbd5087b0f06b14e24fb2008b6dd43bdd8153f&scene=27#wechat_redirect">从阿里的User   Interest Center看模型线上实时serving方法</a></td><td>工程相关</td><td>2020-08-27</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247506153&idx=1&sn=6ce4840ec9642deb8e1c97efdc727390&chksm=fbd76a85cca0e393c44815b55af12ceca91546d32b5aa6b6340cfb3bb4dbed94d88c5f741cb0&scene=27#wechat_redirect">阿里飞猪个性化推荐：召回篇</a></td><td>召回</td><td>2020-08-23</td></tr><tr><td>微博</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247505895&idx=1&sn=d449cd607a21e01805db245be8289de6&chksm=fbd7658bcca0ec9d27eb71a01e8b08711802f59cb0c04aa6059eb0d60b895212de8b8e0b5a38&scene=27#wechat_redirect">微博推荐算法实践与机器学习平台演进</a></td><td>推荐</td><td>2020-08-20</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247505774&idx=1&sn=63efc686d3dda67fa4631e5550560476&chksm=fbd76502cca0ec141440482e048196119101abd0a56dd5dba7c9a18f46ba8f0358e3a458408b&scene=27#wechat_redirect">阿里定向广告最新突破：面向下一代的粗排排序系统COLD</a></td><td>粗排</td><td>2020-08-18</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247505578&idx=1&sn=bc6f551bc83039cebe016ba87cdf8a46&chksm=fbd764c6cca0edd0befcbb887b5b15f10296de6cd6d92ed3382221fcb367c92079b99c895914&scene=27#wechat_redirect">阿里妈妈：基于动态背包的多场景广告序列投放算法</a></td><td>广告</td><td>2020-08-15</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247504918&idx=1&sn=d4cb633276121dc4f09329cf9d231539&chksm=fbd7667acca0ef6cc9d0f21d309b5b28b15f0452f43d33055a1b9562a9519ad36c032ab961f0&scene=27#wechat_redirect">EdgeRec：边缘计算在淘宝推荐系统中的大规模应用</a></td><td>工程相关</td><td>2020-08-05</td></tr><tr><td>BIGO</td><td><a href="https://mp.weixin.qq.com/s/3AMW-vUr2S9FBSDUr_JhpA">内容流多目标排序优化</a></td><td>排序</td><td>2020-08-03</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247504377&idx=1&sn=7ca002dd3bfd00a14c93a519b3765a04&chksm=fbd76395cca0ea83b55807543fde6e8fd7879af67d5a4079365493669752cdff06fac5d632c5&scene=27#wechat_redirect">多业务融合推荐策略实践与思考</a></td><td>多目标&amp;多任务</td><td>2020-07-29</td></tr><tr><td>BIGO</td><td><a href="https://mp.weixin.qq.com/s/364uvoiVmUrXhlM6W3yeGg">Graph Embedding在直播推荐召回的应用</a></td><td>召回</td><td>2020-07-23</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247504009&idx=2&sn=c3d07faaf34416790456eac5be094049&chksm=fbd762e5cca0ebf33eb7f3de1f9c1539ef5bf9fd7c8196bb85a9012ac7472f9c197b80ef8d56&scene=27#wechat_redirect">微信”看一看”个性化推荐：排序篇</a></td><td>推荐</td><td>2020-07-21</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247503968&idx=1&sn=d8fac671af39a87c9a74fb1aff327e41&chksm=fbd7620ccca0eb1aab16ab0e7d06e9c8975749808ca8d1191b442458280ea227b8ce4d90d865&scene=27#wechat_redirect">推荐系统   Embedding 技术实践总结</a></td><td>召回</td><td>2020-07-20</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247503484&idx=2&sn=e2a2cdd3a517ab09e903e69ccb1e9f94&chksm=fbd77c10cca0f50642dde47439ed919aa2e61b7ff57bc4cbaacc3acaac3c620a1ed6f92684ab&scene=27#wechat_redirect">微信”看一看”多模型内容策略与召回</a></td><td>召回</td><td>2020-07-17</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649747457&idx=1&sn=abfbd9e1c0889dda8c8511b44bbd6416&chksm=bed3637a89a4ea6c9be8915449ad6922da619d8ff0366272787bc93f149d7f36ae9e3ac2cc68&scene=27#wechat_redirect">微信「看一看」   推荐排序技术揭秘</a></td><td>推荐</td><td>2020-07-10</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247502918&idx=1&sn=b461d08b22a9fd8ca2e711bb501b7d7a&chksm=fbd77e2acca0f73ccb2e2dad23ce817a968a9d83fcb0f5c8edda7d6566e77c2ff8bdcd1145a7&scene=27#wechat_redirect">跨域推荐技术在58部落内容社区的实践</a></td><td>推荐</td><td>2020-07-09</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651752296&idx=1&sn=6c20fd97bfd9cc7e5557e40e867f123b&chksm=bd125e258a65d7335e7b649796248908d5a19c7d64f6f8935ab162c11539397feac3d830c3aa&mpshare=1&scene=1&srcid=0117uG6dCdQzn6ZP43n4Sclw&sharer_sharetime=1673957001505&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">BERT在美团搜索核心排序的探索和实践</a></td><td>推荐</td><td>2020-07-09</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247502849&idx=1&sn=a9d6b7f727f99e877cb2a4a601773725&chksm=fbd77e6dcca0f77bb63e12273c5befbe00c24fed18525ee0d040acdb95a84f3a8def26707277&scene=27#wechat_redirect">优酷视频元素内容召回系统：多级多模态引擎探索</a></td><td>召回</td><td>2020-07-08</td></tr><tr><td>阿里智能信息</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247502251&idx=1&sn=19eb9bd0a7ad487e12af897c38115783&chksm=fbd77bc7cca0f2d178792a9ab4e1468f9f2179a81dbdfb3f6c96b30bea5e25d6bd01b10faf9a&scene=27#wechat_redirect">机器学习在高德搜索建议中的应用优化实践</a></td><td>推荐</td><td>2020-06-27</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649747190&idx=1&sn=e850fae5360b7f1f4ee472dec70d5039&chksm=bed37d8d89a4f49b15da1394dbeb2f2934a1a2bb27aaa4e765fa6730a5658d5df2d076936122&scene=27#wechat_redirect">推荐系统   embedding 技术实践总结</a></td><td>召回</td><td>2020-06-24</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649747167&idx=1&sn=8020e285502d9f47c77dd0c257364580&chksm=bed37da489a4f4b2c7d7e4082f8c05d42ac3ebdf2a49027c60ab603e9d65871aecbb6bb786e2&scene=27#wechat_redirect">一文搞懂   SQL：基础知识和业务实践总结</a></td><td>工程相关</td><td>2020-06-22</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU5Mjc0MTM4NA==&mid=2247486983&idx=2&sn=f4b78f5507d299e34d8c0bc3fb73332d&chksm=fe1a5b60c96dd2763899db6db7a24a274593b4916732b8ddda97a40d2e37b4a476ab42baa18e&mpshare=1&scene=1&srcid=0117uqLWjE0PrSJaXfwrGQHE&sharer_sharetime=1673957934144&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">一文详解面向多级多模态场景的召回引擎</a></td><td>召回</td><td>2020-06-17</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247501908&idx=1&sn=2478b53f5a28eb4002bbfc9bef62001e&chksm=fbd77a38cca0f32ed9b04e6a2b38c3ce08c47f126863b1dafedefa5aa4d662d25d5537c384e2&scene=27#wechat_redirect">深度召回在招聘推荐中的挑战和实践</a></td><td>召回</td><td>2020-06-17</td></tr><tr><td>微博</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247501693&idx=1&sn=da35a37ce1bfc8b43a26572acb5792d3&chksm=fbd77511cca0fc07beabb02dc15cd0f2f7f5ee9f0840ba512a4b3a373f4a676cb7156692bf5f&scene=27#wechat_redirect">内容理解在新浪微博广告中的应用</a></td><td>内容理解</td><td>2020-06-12</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649747086&idx=1&sn=5d08665635003d57eba7bf9c2717fa66&chksm=bed37df589a4f4e35cac85f37c13cc30675c3285fba639bd657fd2dd7edbf35169de9777bcc1&scene=27#wechat_redirect">仅需少量视频观看记录，就可以精准推断你的习惯</a></td><td>用户挖掘</td><td>2020-06-10</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247501599&idx=1&sn=10c0eaa021ef4d7b39a82819bf4b0f66&chksm=fbd77573cca0fc658535625c70a550c297d10d8efcf6ca5640851d76e4cb0b051a9f5f6da62e&scene=27#wechat_redirect">Embedding技术在房产推荐中的应用</a></td><td>召回</td><td>2020-06-10</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU5Mjc0MTM4NA==&mid=2247486719&idx=1&sn=48936c1a140f25a374ea5eb12807e636&chksm=fe1a5998c96dd08e39875af88eded481ade7e8f555a01b4dd9df06ea7156cc2e29381bc3e2b5&mpshare=1&scene=1&srcid=0117uXZesx2FgCB5y1sCUTNd&sharer_sharetime=1673957837931&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">视频搜索太难了！阿里文娱多模态搜索算法实践</a></td><td>搜索</td><td>2020-06-08</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247501196&idx=1&sn=978b373e1278c709fc53036614a240ab&chksm=fbd777e0cca0fef630da6ed55518775e22afba1e74cd2e09701e055533146f29c71876ba77c4&scene=27#wechat_redirect">京东电商搜索中的语义检索与商品排序</a></td><td>搜索</td><td>2020-06-03</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU5Mjc0MTM4NA==&mid=2247486551&idx=1&sn=940a80be200e7fe0c1682405974039fc&chksm=fe1a5930c96dd026c1fa979b3989b13e21cecf8d451fd1448b0c534ff8f320ac41d48d0eba3a&mpshare=1&scene=1&srcid=01176HIzgCam1OfiESJDEnZd&sharer_sharetime=1673957847876&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">PPT+视频|   优酷视频元素内容召回系统：多级多模态引擎探索</a></td><td>召回</td><td>2020-05-28</td></tr><tr><td>爱奇艺</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247500273&idx=1&sn=c8cf8e7a0515e1aeb0022417a6aeda9f&chksm=fbd7739dcca0fa8b8e4fdef2e1d669118de87c1ce1f2f1444bfe314610423fa2a3cf0c8c214c&scene=27#wechat_redirect">爱奇艺深度语义表示学习的探索与实践</a></td><td>召回</td><td>2020-05-23</td></tr><tr><td>丁香园</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247500267&idx=2&sn=0a38ea1f7d4a96a632b129ffbabc2d2c&chksm=fbd77387cca0fa91abbd69ad1885c44d05ab578886102d36e9ea11d9c7c529ebc47dbfa36d61&scene=27#wechat_redirect">搜索中的Query扩展技术</a></td><td>搜索</td><td>2020-05-21</td></tr><tr><td>滴滴</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247499792&idx=1&sn=59b8acac6ea9abe508825146983a4910&chksm=fbd7727ccca0fb6a56c5d677b7b6737bef02c7715b67d368ee551677a4110e241a14e66cf012&scene=27#wechat_redirect">搜索相关性算法在   DiDi Food 中的探索</a></td><td>搜索相关性</td><td>2020-05-16</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247499645&idx=1&sn=a4d1e29381ab912861c3827399e22312&chksm=fbd74d11cca0c407e9149d5d80fba8b6b60e91b66a0688611dcbf6be2b89c2d136da181e0243&scene=27#wechat_redirect">深度时空网络、记忆网络与特征表达学习在   CTR 预估中的应用</a></td><td>精排&amp;CXR预估</td><td>2020-05-11</td></tr><tr><td>滴滴</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247499525&idx=1&sn=638746fcd82ed8ebadb947c5848d8363&chksm=fbd74d69cca0c47fe102231f40b946c7bb0ae968c44061592bf161eb722f6fa71ee6a40b8fdb&scene=27#wechat_redirect">基于强化学习的   Contextual Bandits 算法在推荐场景中的应用</a></td><td>推荐</td><td>2020-05-09</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247499470&idx=1&sn=6a6e80673353fb485a854ed2cffc5dcb&chksm=fbd74ca2cca0c5b4fb0622140eb9fa3cd15c860d06b24a4c7fc37e8b3db614af8c4ad9cbe0d3&scene=27#wechat_redirect">搜索中的   Query 理解及应用</a></td><td>搜索</td><td>2020-05-07</td></tr><tr><td>华为</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247499412&idx=1&sn=4bde0cbcf1d35fac55bda4733b0be356&chksm=fbd74cf8cca0c5ee48fd9e6448dddb2d885df8dffc11b4f9bce8952b4773a98ee7987b68ba7b&scene=27#wechat_redirect">华为高级研究员谢凌曦：下一代人工智能计算模型探索</a></td><td>其他</td><td>2020-04-30</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247499255&idx=1&sn=a7a6427c6c2bd74c728ef2d53c736814&chksm=fbd74f9bcca0c68d203296277c23e42f5a218d522bac4e23bfcfcde591be98e334e9f5cb67c8&scene=27#wechat_redirect">因果推断在阿里文娱用户增长中的应用</a></td><td>因果推断</td><td>2020-04-23</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247499175&idx=1&sn=1c398e92f0712e4e5f545759d0a85692&chksm=fbd74fcbcca0c6dd11a04b493827ffdda06c69f6013b95c74c54c14f596cab0f303751f9e14d&scene=27#wechat_redirect">阿里文娱搜索算法实践与思考</a></td><td>搜索</td><td>2020-04-20</td></tr><tr><td>携程</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247499139&idx=1&sn=c187e0108e9bd55b69e48d0c8de1887d&chksm=fbd74fefcca0c6f9290da7221b0d4b02a1d6a84913cf4950052b2050cd73e52b906d489f824e&scene=27#wechat_redirect">Bandit算法在携程推荐系统中的应用与实践</a></td><td>推荐</td><td>2020-04-19</td></tr><tr><td>美团</td><td><a href="https://mp.weixin.qq.com/s/Oixc46P9rQeiMDjI-0j0cw">Transformer   在美团搜索排序中的实践</a></td><td>搜索</td><td>2020-04-16</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247499010&idx=1&sn=138e92d3c22202b7b86c40d8f1bddd07&chksm=fbd74f6ecca0c678b3925526a0c1e4460521263444996eabe0e3224c2e38a243331520ad6f28&scene=27#wechat_redirect">广告CTR预估中用户行为学习和记忆建模</a></td><td>精排&amp;CXR预估</td><td>2020-04-13</td></tr><tr><td>阿里飞猪</td><td><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247486489&idx=2&sn=e03b23d476d9864cd417f81c02f6e62e&chksm=e9d01cd8dea795ceb3d95d80ddab98f689d18ded9c0adc2f8175c665666a1d252c8db1d40f3c&scene=27">阿里飞猪“猜你喜欢”推荐排序实践</a></td><td>推荐</td><td>2020-04-08</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498872&idx=1&sn=c7eb8e9147cb106b4122174981dce0b9&chksm=fbd74e14cca0c7027a2db1641d0e4e7bc16846035359684b702d462abdda8926ee7626bf4505&scene=27#wechat_redirect">CTR预估在动态样式建模和特征表达学习方面的进展</a></td><td>精排&amp;CXR预估</td><td>2020-04-08</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498811&idx=1&sn=b138758fe26502935492f0411b5cf66e&chksm=fbd74e57cca0c741e1a51c21aa66c6117df5afe400d1656ea58a153e9f0b5a5bcba0233a42df&scene=27#wechat_redirect">热点挖掘技术在微信看一看中的应用</a></td><td>热点挖掘</td><td>2020-04-05</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU5Mjc0MTM4NA==&mid=2247485289&idx=1&sn=6b7edf8bc492bedeb51bb4677bb7d890&chksm=fe1a520ec96ddb18448cdb6c94c13e8ea642c887dd107705a9e00bfa07027a1afcbe29aecdb1&mpshare=1&scene=1&srcid=0117KL0KphjR4Mu3kvl0fOWG&sharer_sharetime=1673957914555&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">让广告算法做你的增长黑客！阿里文娱工程师这么做</a></td><td>广告</td><td>2020-04-03</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498766&idx=2&sn=6169f19552682cc582746f6cf852905b&chksm=fbd74e62cca0c7745fdf1c6443f87e18dd85ecc943c7338b2cc1e6c06cd8bb6bae54444b397b&scene=27#wechat_redirect">揭秘微信”看一看”是如何为你推荐的</a></td><td>推荐</td><td>2020-03-31</td></tr><tr><td>360</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498637&idx=1&sn=a91d76109129fa42e5910c2e2b5f68ef&chksm=fbd749e1cca0c0f75c8a9dc06c16b8d9a53cdf57eb370c07424d88eefd1ddb66928dd1bf2f7f&scene=27#wechat_redirect">智能推荐算法在花椒直播中的应用</a></td><td>推荐</td><td>2020-03-26</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498613&idx=1&sn=77f53f7e1edd2dc579cc49b5db803ad4&chksm=fbd74919cca0c00fdae51accb916b42a29d98bf3eb745f42bd9f17d9c4352ef9129ad13a0e5d&scene=27#wechat_redirect">搜索中的深度匹配模型</a></td><td>搜索</td><td>2020-03-24</td></tr><tr><td>360</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&mid=2247487492&idx=1&sn=ba82daf0353c5eac7f6d9279e333546c&chksm=c2932390f5e4aa861692198be94febdac6fb05fc9909e4adc392f28e15b4dea9cf984f7579c9&mpshare=1&scene=1&srcid=0117ZsWh7O6AM8nXAR8xUfd0&sharer_sharetime=1673957379385&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">深度学习在花椒直播中的应用—推荐系统冷启动算法</a></td><td>冷启动</td><td>2020-03-24</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498610&idx=1&sn=803bff13e7f663a63358ffef96b4525e&chksm=fbd7491ecca0c008f45e48180991ff7f2ccb70b6640ea9d9534c9cb6c2ddc4346bc848c4a3f3&scene=27#wechat_redirect">深度学习在阿里B2B电商推荐系统中的实践</a></td><td>推荐</td><td>2020-03-23</td></tr><tr><td>美图</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498181&idx=1&sn=f3ee8fc793cc47d069913017f5aa7c74&chksm=fbd74ba9cca0c2bfef5fd5a07805b35cc90d15146899125e6bf21be2294a811e42d851cd2c06&scene=27#wechat_redirect">美图个性化推送的   AI 探索之路</a></td><td>推荐</td><td>2020-03-18</td></tr><tr><td>凤凰</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498125&idx=1&sn=52efbe5876151b48a917640f5f56c589&chksm=fbd74be1cca0c2f7b2f378a1b15339ef8697544c2b43bb9b51c7c9eaa79b6aea119d943786a9&scene=27#wechat_redirect">信息流推荐在凤凰新闻的业务实践 </a></td><td>推荐</td><td>2020-03-16</td></tr><tr><td>省钱快报</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498064&idx=1&sn=66db655be0bcc5e6ee0dc58f869ef6eb&chksm=fbd74b3ccca0c22aacea4a7aca9e803f4044f78ad056983484ebc5ab0c718773ebd4ee8204ea&scene=27#wechat_redirect">深度学习在省钱快报推荐排序中的应用与实践</a></td><td>推荐</td><td>2020-03-12</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498041&idx=1&sn=5c8b880a2be4075ee48388b27ce1a6e0&chksm=fbd74b55cca0c24382f3f10e6f2a8423e228c390339dc086d5f1fec034350e0574302587834a&scene=27#wechat_redirect">广告算法在阿里文娱用户增长中的实践</a></td><td>广告</td><td>2020-03-11</td></tr><tr><td>汽车之家</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247497757&idx=1&sn=fe521ea5a746be9ba0aa208506d716b8&chksm=fbd74a71cca0c3676f2681bb7917a12e77562d2c5b3d1e5def4a3eac3fc40bd57e12ef2548e5&scene=27#wechat_redirect">汽车之家推荐系统排序算法迭代之路</a></td><td>推荐</td><td>2020-02-28</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247497685&idx=1&sn=4af16b3d4d79ce2850b29717f7de1121&chksm=fbd745b9cca0ccaf7ab41fa2760befc0f0831d74e77c8ff430c4d31016efc1b21d27ac0cea1e&scene=27#wechat_redirect">阿里B类电商用户增长实践</a></td><td>用户增长</td><td>2020-02-26</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247497357&idx=2&sn=9991d229219e36be78c954b46da1f3e3&chksm=fbd744e1cca0cdf764c33163c35b524299a13d78e803abfcb5e4f88fbb72c26c7dfdf00547dd&scene=27#wechat_redirect">视频   | 广告算法在阿里文娱用户增长中的实践</a></td><td>用户增长</td><td>2020-02-11</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247497190&idx=1&sn=c210c40cd365312038c5248752f9e187&chksm=fbd7478acca0ce9c3848d2e699ee4193b9cf08473a3f700d04f8514fa247594cded254aee600&scene=27#wechat_redirect">阿里B2B：融合Matching与Ranking的个性化CTR预估模型</a></td><td>精排&amp;CXR预估</td><td>2020-02-05</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247497109&idx=2&sn=41f16c9b2a9513596553fcd9ff4bb6e2&chksm=fbd747f9cca0ceefffe34a2973623745034e7e94ee48b920b14282da022c9a30682e5dcdc7f5&scene=27#wechat_redirect">视频   | 阿里文娱搜索算法实践和思考</a></td><td>搜索</td><td>2020-02-03</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247496713&idx=1&sn=07bb184081bf8590db12e63ccda6bf22&chksm=fbd74665cca0cf73e625c403d61bb3f1f0fdfe680566927f1b1cda7cb54a7b9ce17418c9690b&scene=27#wechat_redirect">推荐系统中的深度匹配模型</a></td><td>推荐</td><td>2020-01-13</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649745235&idx=1&sn=d6031b0d45d1db8c61398e2d3b231bed&chksm=bed3742889a4fd3e3032cab8b95656b441d013d7b988a06f77d72aeb98315f4012bfd9b92b47&scene=27#wechat_redirect">一种全新的点击率建模方案</a></td><td>精排&amp;CXR预估</td><td>2020-01-10</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650405126&idx=1&sn=91a9e73ed4f2cc34ca1dac64144ae4d3&chksm=8395311eb4e2b808c516c1b4c9aac24ffe5e6ced9641370e73e6b13fc69512d6bb452a4bb1ba&scene=27#wechat_redirect">让机器读懂视频：亿级淘宝视频背后的多模态AI算法揭秘</a></td><td>召回</td><td>2020-01-09</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247496498&idx=1&sn=058af2101d4a1ceda1ec04b30daf4d69&chksm=fbd7415ecca0c8488706ee79480560df06943ede862fc76e0917f29b663b3f30b220c37fee78&scene=27#wechat_redirect">阿里淘外商业化广告工程架构实践</a></td><td>工程相关</td><td>2020-01-08</td></tr><tr><td>爱奇艺</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247496497&idx=2&sn=46afd0c464186e75ffb90b2af25bc3d6&chksm=fbd7415dcca0c84b056ed3b2aaa71c4469307e3a02e2766ae8f97f16c0bfe78b40e293868eaf&scene=27#wechat_redirect">个性化海报在爱奇艺视频推荐场景中的实践</a></td><td>推荐</td><td>2020-01-07</td></tr><tr><td>微博</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247496432&idx=1&sn=209510d8695aed74c65b2693d300e97b&chksm=fbd7409ccca0c98af6db5aaf452dd81b070f440326bdda5e505069608ddc3b448560c045a2f3&scene=27#wechat_redirect">机器学习在微博   O 系列广告中的应用</a></td><td>广告</td><td>2020-01-06</td></tr><tr><td>知乎</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247496409&idx=1&sn=7b2f5984d71454e1a2812321f6018cf8&chksm=fbd740b5cca0c9a37723c8c05b4e1cf95fd8678bc54e9b4591c09a7af06f2acf79e28276a502&scene=27#wechat_redirect">Query   理解和语义召回在知乎搜索中的应用</a></td><td>召回</td><td>2020-01-02</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649745156&idx=1&sn=744c59bceef156f5b9f84a28e3073708&chksm=bed3747f89a4fd69840a9c52dc8909d86c8f45ff7f634df48fc478860e43c62e1751ef04668e&scene=27#wechat_redirect">腾讯在信息流内容理解技术上的解决方案</a></td><td>内容理解</td><td>2019-12-31</td></tr><tr><td>贝壳</td><td><a href="https://mp.weixin.qq.com/s/bPjk1Rq19KmlPcfkYvVJVw">DeepFM在贝壳房源详情页推荐场景的实践</a></td><td>推荐</td><td>2019-12-30</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247496280&idx=1&sn=870b45e0f9bfda51a093ceabb9b51df2&chksm=fbd74034cca0c922893be32402905954f87d98ffa55aa879b45d9974870f29e15e2a1f5a1429&scene=27#wechat_redirect">MMoE算法在淘宝躺平推荐中的应用实践</a></td><td>多目标&amp;多任务</td><td>2019-12-27</td></tr><tr><td>360</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&mid=2247487444&idx=1&sn=21618afb5aacc0ea224afdbb1e4fa155&chksm=c2933c40f5e4b5569ab5b0dd73d9a5233eee75dab93b53d23b9541e9230193a2560ce90869a8&mpshare=1&scene=1&srcid=0117mZBwP4XZjMn1x1cMkohc&sharer_sharetime=1673957427902&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">ElasticSearch   介绍及使用方法</a></td><td>工程相关</td><td>2019-12-27</td></tr><tr><td>贝壳</td><td><a href="https://mp.weixin.qq.com/s/rp6H_HydTbKiSanijDZwBQ">wide&amp;deep   在贝壳推荐场景的实践</a></td><td>推荐</td><td>2019-12-18</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247496080&idx=1&sn=70f79a37a6000965fa96bccf893b9c40&chksm=fbd743fccca0caeadb59820801597c51353b0a4ba080d2caf66eccb6644102c2fe674ffcb378&scene=27#wechat_redirect">阿里妈妈点击率预估中的长期兴趣建模</a></td><td>精排&amp;CXR预估</td><td>2019-12-18</td></tr><tr><td>阿里文娱</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495736&idx=1&sn=080c985a2e373e04496bce5db3cb1069&chksm=fbd74254cca0cb42324938685381d67217f3cb14cb6da64576cac58238264605b5f7e64d34a6&scene=27#wechat_redirect">优酷   DSP 广告投放系统架构实践</a></td><td>广告</td><td>2019-12-06</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649744942&idx=1&sn=7efd84c1371d785d719de481e3e6d44a&chksm=bed3755589a4fc43a2caa01c6579f6d10e65959c529a3be90da6e3938a09886eb8bcbd607ef1&scene=27#wechat_redirect">浅谈微视推荐系统中的特征工程</a></td><td>推荐&amp;特征工程</td><td>2019-12-06</td></tr><tr><td>美图</td><td><a href="https://zhuanlan.zhihu.com/p/89401911">多任务学习在美图个性化推荐的近期实践</a></td><td>多目标&amp;多任务</td><td>2019-12-06</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495660&idx=1&sn=21a5b7e811d104162609d5fef993be79&chksm=fbd75d80cca0d496995ab1135ceb4734b90553a8fd82f4c970ed48212f3d0abd98f58e4e0864&scene=27#wechat_redirect">阿里妈妈新一代算法   JTM：如何优化大规模推荐？</a></td><td>召回</td><td>2019-12-04</td></tr><tr><td>百度</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495618&idx=1&sn=42b06177dec45f33c29ab25d73b639a9&chksm=fbd75daecca0d4b8a6ae5c4854c40cc05bd6c7b67ac6ab45f74c05d425aafae9d54699a09c19&scene=27#wechat_redirect">MOBIUS：百度凤巢新一代广告召回系统</a></td><td>召回</td><td>2019-11-29</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649744896&idx=1&sn=ac4361272c2d027631bbca9673b6dc10&chksm=bed3757b89a4fc6da6c516fde28c79c936e7b8dc4647fccebad77c616231c15a48102f28dd7e&scene=27#wechat_redirect">新一代海量数据搜索引擎   TurboSearch 来了！</a></td><td>工程相关</td><td>2019-11-28</td></tr><tr><td>腾讯微信</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495507&idx=1&sn=a1e0cf988d2e366be58faf1110e4d885&chksm=fbd75d3fcca0d429b33c5a49053dd99a03e603b3230e950d0109f3c9dbe7ede21e1fa2a86752&scene=27#wechat_redirect">RALM:   实时 Look-alike 算法在微信看一看中的应用</a></td><td>推荐</td><td>2019-11-25</td></tr><tr><td>360</td><td><a href="https://zhuanlan.zhihu.com/p/93060649">向量化召回在360信息流广告的实践</a></td><td>召回</td><td>2019-11-23</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649744830&idx=1&sn=950d79ac145ba6682fcfe096e0398c95&chksm=bed376c589a4ffd348ae826b7a855e034184629b798de48192443e727199ddb7a7c6bd594545&scene=27#wechat_redirect">Bing搜索核心技术BitFunnel原理</a></td><td>工程相关</td><td>2019-11-19</td></tr><tr><td>腾讯</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495039&idx=1&sn=35905df6cd4ef33d2ce505d284d3c8ad&chksm=fbd75f13cca0d605c17bf7a8b3b899b7798a590008625fcffbf00d77c2451249bbdc086d6b18&scene=27#wechat_redirect">推荐系统中模型训练及使用流程的标准化</a></td><td>工程相关</td><td>2019-11-04</td></tr><tr><td>360</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494825&idx=2&sn=92f59195e8e4e6b33af6dfa63df6a2b3&chksm=fbd75ec5cca0d7d36752d787d7fc0191b0ecccdb56bda335fa553635f241c20af1f768983f7d&scene=27#wechat_redirect">360展示广告召回系统的演进</a></td><td>召回</td><td>2019-10-24</td></tr><tr><td>爱奇艺</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494579&idx=1&sn=b5274f98c5cfae81d1af68944d3252df&chksm=fbd759dfcca0d0c9f8ab04bebee04b0d7fd6fdd3eae87d3ef475fb26e03b402999c31621d034&scene=27#wechat_redirect">爱奇艺效果广告的个性化探索与实践</a></td><td>广告</td><td>2019-10-17</td></tr><tr><td>美图</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494558&idx=1&sn=10a6332147d713230d0fa4dbf9cdc897&chksm=fbd759f2cca0d0e4f5d39887a86b1d6efae13ad0540dc191fdbc8bb29120d0081a90c97b35f6&scene=27#wechat_redirect">深度学习技术在美图个性化推荐的应用实践</a></td><td>推荐</td><td>2019-10-16</td></tr><tr><td>阿里智能信息</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494398&idx=1&sn=cd08a71c4a7ec9a2d81107603fc4c437&chksm=fbd75892cca0d184585075b3315fe0386d37c174995a5a4b27e02db4117a13897678dbcb52ed&scene=27#wechat_redirect">UC   信息流推荐模型在多目标和模型优化方面的进展</a></td><td>多目标&amp;多任务</td><td>2019-10-14</td></tr><tr><td>阿里智能信息</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494295&idx=1&sn=1218bfa026994967939fa676ed7dd5f9&chksm=fbd758fbcca0d1ede59b225e98add36cae74e9fd3006d42a054c73aaa4a87c75ef46684b9733&scene=27#wechat_redirect">UC   国际信息流推荐中的多语言内容理解</a></td><td>内容理解</td><td>2019-10-09</td></tr><tr><td>凤凰</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494020&idx=1&sn=df65908cdaf57d02eee8280d86d66949&chksm=fbd75be8cca0d2fe2d69d89a70eced34ba467acbf26fefe1bf40edea36a07e76406612383fd5&scene=27#wechat_redirect">OCPC   广告算法在凤凰新媒体的实践探索</a></td><td>广告</td><td>2019-09-25</td></tr><tr><td>阿里智能信息</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247493952&idx=1&sn=f32e43f0e834d12649a3a6272b85ede0&chksm=fbd75b2ccca0d23a224032d999dd52ca3fa53529abf78c2cf3d4f5e9d52ef3a691bcf76bbdd1&scene=27#wechat_redirect">浅谈   UC 国际信息流推荐</a></td><td>推荐</td><td>2019-09-23</td></tr><tr><td>58同城</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247493807&idx=1&sn=7d0b5d89e6fb604794049ac29ccf6ecd&chksm=fbd75ac3cca0d3d526d65b0b55f9f34f2b2ca6d086a4222440b817a4434c359e979331a75917&scene=27#wechat_redirect">58同镇下沉市场中的推荐技术实践</a></td><td>推荐</td><td>2019-09-18</td></tr><tr><td>微博</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247493747&idx=1&sn=3288e75a42a8e93bc7ce34b47b811b9b&chksm=fbd75a1fcca0d3092046e1c3b0d961ef99edc8323426fdd78eae3693119a726328db7f0dd246&scene=27#wechat_redirect">微博广告策略工程架构体系演进</a></td><td>工程相关</td><td>2019-09-16</td></tr><tr><td>快看漫画</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247493714&idx=1&sn=146ca2efa604b71b20ae166fb0cd6b85&chksm=fbd75a3ecca0d3280f88577c843d7ebf7c4b66f00134f2802e3863e17fa811eb8e328ca030a2&scene=27#wechat_redirect">快看漫画个性化推荐探索与实践</a></td><td>推荐</td><td>2019-09-12</td></tr><tr><td>滴滴</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247493496&idx=1&sn=16a9495c9a0452ef60e38bb129105b02&chksm=fbd75514cca0dc020fa508aa34e01a3c17949e70cbccd5531122556f14c7351d15da93775f17&scene=27#wechat_redirect">解读：滴滴“猜你去哪儿”功能的算法实现</a></td><td>推荐</td><td>2019-09-04</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247493262&idx=1&sn=c5c2b9827c5de1d1311673523c96e3e7&chksm=fbd754e2cca0ddf47163df7559a20bb85a45633ecdc57f168874819225dffb4db19449c00cdc&scene=27#wechat_redirect">推荐系统走向下一阶段最重要的三个问题</a></td><td>推荐</td><td>2019-08-28</td></tr><tr><td>360</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&mid=2247487361&idx=2&sn=36cb82dd07dafa41ddd7b983f2c44649&chksm=c2933c15f5e4b503af0ac18437085f8928b09261e379e4d5a0628a386f2cefd4cbccb110ab60&mpshare=1&scene=1&srcid=0117dqnVg0mxFOFbynlpzCf9&sharer_sharetime=1673957459189&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">深度学习在花椒直播的应用——Tensorflow   原理篇</a></td><td>工程相关</td><td>2019-08-28</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247492994&idx=1&sn=6a787521ad85f37339f880bba0cc5d63&chksm=fbd757eecca0def8ac32a1c60f49ec933096833b5b55860074fd5d305499adc85d9f833fa333&scene=27#wechat_redirect">阿里妈妈深度树检索技术（TDM）及应用框架的探索实践</a></td><td>召回</td><td>2019-08-16</td></tr><tr><td>京东</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247492901&idx=1&sn=e0241e72bb057ed300fef994721a2a3b&chksm=fbd75749cca0de5f029b880bbe53914dfd789452d35cde78097f00a75f789f2508e452bf1805&scene=27#wechat_redirect">京东电商推荐系统实践</a></td><td>推荐</td><td>2019-08-08</td></tr><tr><td>阿里淘系</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650403666&idx=1&sn=96be637d3fd89472d326f09596a48e2d&chksm=83953b4ab4e2b25c514fd36904d0bad493aab91bcd4f30c4b59762b6b1fbd0b2aaa0509a0d4b&scene=27#wechat_redirect">极测未来|淘宝”千人千面”内容下的智能评测技术与实践</a></td><td>推荐</td><td>2019-08-06</td></tr><tr><td>360</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&mid=2247487340&idx=1&sn=e96e5e1034462b3fed38c98aef1627ca&chksm=c2933cf8f5e4b5ee13fd52fbaeda37679d5766aea514099c720a4bb131340521583ba2fd2582&mpshare=1&scene=1&srcid=0117LVG4Py92aQ9dr3ohqsMG&sharer_sharetime=1673957323507&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">360搜索的百亿级网页搜索引擎架构实现</a></td><td>工程相关</td><td>2019-07-31</td></tr><tr><td>Hulu</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247492462&idx=1&sn=4f770371f0493448fab48af8750adb66&chksm=fbd75102cca0d81418aca45fe714c80838b5de34555cd561aec4d87cda710e56b744f953bbbc&scene=27#wechat_redirect">Hulu   在视频内容理解上的应用和最佳实践</a></td><td>内容理解</td><td>2019-07-26</td></tr><tr><td>360</td><td><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247484855&idx=2&sn=f0032b7a1611be3d87615f3aecc334de&chksm=e9d01576dea79c60aed6633bd1ff386a376c2bdb50aeaa35834644068f76a2a7f23649500fe1&scene=27#wechat_redirect">深度学习在360搜索广告   NLP 任务中的应用</a></td><td>搜索</td><td>2019-07-18</td></tr><tr><td>阿里</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247492047&idx=1&sn=7db1f1eaadfdac75c5a0ae0e3a7beea1&chksm=fbd753a3cca0dab5fe09c091fb36c0ae9ba9ae83af38593d333bbdf61d97ee137b1577611ec0&scene=27#wechat_redirect">阿里零售通智能导购推荐技术实践</a></td><td>推荐</td><td>2019-07-11</td></tr><tr><td>网易</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247491955&idx=1&sn=8d6258dd5330a86608191088ec5444a2&chksm=fbd7531fcca0da0945008445177aaaf07b72b61e990fd847e36a8f516eed0f0c93123409dddd&scene=27#wechat_redirect">网易新闻推荐：深度学习排序系统及模型</a></td><td>推荐</td><td>2019-07-08</td></tr><tr><td>居理新房</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247491927&idx=1&sn=5454d891f68f7c2d49cb453cf4c40f2d&chksm=fbd7533bcca0da2dc093950f0b2b95c4d525a6caf60fec117228be52afd2a498bb74812c0e92&scene=27#wechat_redirect">低频少样本长验证周期场景下的算法设计</a></td><td>推荐</td><td>2019-07-05</td></tr><tr><td>Hulu</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247491883&idx=1&sn=9a28cb03a2e34ec380cd5ff789b8f48d&chksm=fbd75347cca0da51e1257f4de6824e77546f3eeb1e78090cd11ec71841f31cc4cf8562ab3151&scene=27#wechat_redirect">基于行列式点过程的推荐多样性提升算法</a></td><td>推荐</td><td>2019-07-03</td></tr><tr><td>途家网</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247491647&idx=1&sn=787f20dad8e613c0f72142df6789d91d&chksm=fbd75253cca0db45abed1a13b555f358ce059b4e9477afaeb872cab12d4fc310f119d65f797a&scene=27#wechat_redirect">Embedding   技术在民宿推荐中的应用</a></td><td>召回</td><td>2019-06-25</td></tr><tr><td>Airbnb</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247491541&idx=1&sn=cd70f902ac265bfb36e95deac352f797&chksm=fbd4adb9cca324afc840c189ddae4f25ae5c1ee1b8405bd3d0c78c0293d87d85a516e1cfa1c0&scene=27#wechat_redirect">深度学习在   Airbnb 中的探索与应用</a></td><td>搜索</td><td>2019-06-21</td></tr><tr><td>阿里</td><td><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1675783003&ver=4336&signature=JXo7DrRlU7Hx9WJP0r7ozT7S1eVkuUt-AiIg21XL7Nz3OkHBzLWECkq4hTwtGtYY0NUnl5gLihW3hGnfr8dqXJIydi1e5uty4VX58eYccDtQI-jUVPhyMU9VvBdkCWkV&new=1">当你打开天猫的那一刻，推荐系统做了哪些工作？</a></td><td>推荐</td><td>2019-06-04</td></tr><tr><td>小米</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247490461&idx=1&sn=84a010d7fa0b0d29f25d87b57e2a29ee&chksm=fbd4a9f1cca320e721ab7c0f167ae5e56f0b00aae7995f8d5a9ad49125ae8d46e86095afd120&scene=27#wechat_redirect">小米移动搜索中的AI技术</a></td><td>搜索</td><td>2019-05-23</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247490293&idx=1&sn=4dcd1cf5f945c03c98ed3401afb7983d&chksm=fbd4a899cca3218f328a661da553b470e018eeeef2ca3bf2696140ef045f1805f89b8c3a596a&scene=27#wechat_redirect">阿里妈妈：电商预估模型的发展与挑战</a></td><td>精排&amp;CXR预估</td><td>2019-05-20</td></tr><tr><td>阿里飞猪</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247490057&idx=1&sn=d676c16816c16a27abe5ce69c15feafa&chksm=fbd4a865cca321735c0c0a700e6210f80fa10cfa16aed6e8068dd601853a6285aa7f4601f2ad&scene=27#wechat_redirect">POI   识别在飞猪搜索的探索与实践</a></td><td>搜索</td><td>2019-05-10</td></tr><tr><td>达观数据</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247488752&idx=1&sn=aaaed48b319d572990c93dc1e60a7ba2&chksm=fbd4a69ccca32f8a636b600a77504ab7689f8e90279ace41ae669268dba533e5b8ece9e7b2d3&scene=27#wechat_redirect">达观数据个性化推荐系统实践</a></td><td>推荐</td><td>2019-03-11</td></tr><tr><td>Hulu</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247488177&idx=1&sn=ce32c5e9eaf50c9d7f5f3f075d632fc3&chksm=fbd4a0ddcca329cbc93e4fded3b83d59c7ab30d64206a1cf80e63289f925635bcf7eba6651a5&scene=27#wechat_redirect">Hulu：视频广告系统中的算法实践</a></td><td>广告</td><td>2019-02-25</td></tr><tr><td>阿里妈妈</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247487620&idx=1&sn=b3162fec93608788430f7e52236d998e&chksm=fbd4a2e8cca32bfea69c4e418e38d0c8709d2fe3395f74f73aaf48815ec8a41fc0d130ae4a1e&scene=27#wechat_redirect">「回顾」阿里妈妈：定向广告新一代点击率预估主模型——深度兴趣演化网络</a></td><td>精排&amp;CXR预估</td><td>2019-01-28</td></tr><tr><td>搜狗</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247487590&idx=1&sn=792f7c3a1cb05bd3c89660c2ceff3fed&chksm=fbd4a20acca32b1c3a9eff018b9e3e96a31425cab16d4a7241e0258221320266007e9c3e70f0&scene=27#wechat_redirect">「回顾」深度学习新技术在搜狗搜索广告中的深化应用</a></td><td>广告</td><td>2019-01-23</td></tr><tr><td>美团</td><td><a href="https://tech.meituan.com/2019/01/17/dianping-search-deeplearning.html">大众点评搜索基于知识图谱的深度学习排序实践</a></td><td>搜索</td><td>2019-01-17</td></tr><tr><td>知乎</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247487240&idx=1&sn=f38e4a5cd73a2d2f1d52ee5eda418528&chksm=fbd4bd64cca334720629ba997aca98642bc1e1b25c422623ddf07e30cb9a5f5068cf22af0048&scene=27#wechat_redirect">「回顾」知乎推荐页Ranking经验分享</a></td><td>推荐</td><td>2018-12-28</td></tr><tr><td>爱奇艺</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247487111&idx=1&sn=0466151a7745795694ee6b66838ef263&chksm=fbd4bcebcca335fd6038ab853b9a73ce1147c953594df2aea6fd1c1db013191086f4c656f5d2&scene=27#wechat_redirect">「回顾」爱奇艺搜索排序模型迭代之路</a></td><td>搜索</td><td>2018-12-21</td></tr><tr><td>Airbnb</td><td><a href="https://zhuanlan.zhihu.com/p/52287783">Airbnb:   深度学习在搜索排序业务中的探索与演进（二）</a></td><td>搜索</td><td>2018-12-13</td></tr><tr><td>Airbnb</td><td><a href="https://zhuanlan.zhihu.com/p/52146789">Airbnb:   深度学习在搜索排序业务中的探索与演进（一）</a></td><td>搜索</td><td>2018-12-11</td></tr><tr><td>51信用卡</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247486677&idx=1&sn=8fba1b390945dea3d15574f1465575f0&chksm=fbd4beb9cca337afbfc433e2873efb13ae87ec226bdd7dd9e1bee159a82a0201a9186c0a8449&scene=27#wechat_redirect">「回顾」51信用卡的个性化推荐体系</a></td><td>推荐</td><td>2018-11-21</td></tr><tr><td>饿了么</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247486538&idx=1&sn=32498d028a74dce05ffa4a4eee66e4b5&chksm=fbd4be26cca33730d988a9bd19e5bcd8034fc3388ff468853bfcf5367a4dc446c1ffcff355f8&scene=27#wechat_redirect">「回顾」饿了么推荐算法演进及在线学习实践</a></td><td>推荐</td><td>2018-11-07</td></tr><tr><td>饿了么</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247486253&idx=1&sn=5730d5ab24b87a5985ffa5ff10d34c79&chksm=fbd4b941cca330577e3755aea84d9026aca36a55490e7f71c447d613fca0ba5be77c00067490&scene=27#wechat_redirect">回顾·外卖推荐算法中有哪些机制与手段？</a></td><td>推荐</td><td>2018-10-12</td></tr><tr><td>阿里淘系</td><td><a href="https://mp.weixin.qq.com/s/gaNs9Qg3j68034HDBRw0PA">7种经典推荐算法模型的应用</a></td><td>推荐</td><td>2018-09-16</td></tr><tr><td>阿里智能信息</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247485830&idx=1&sn=621393b30e179660de9b35d57da60752&chksm=fbd4bbeacca332fcfe9733a126f07386ad66c3a0381b5e0c2daa81c70d88d0d19048fad645c1&scene=27#wechat_redirect">回顾·神马搜索技术演进之路</a></td><td>搜索</td><td>2018-08-17</td></tr><tr><td>搜狗</td><td><a href="http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247485411&idx=1&sn=3ac29da8b7a81869bd33679531e2cfe3&chksm=fbd4b58fcca33c998652a1e1a84b4dee7b825df919e1c68702938ee24728121617ac30f85878&scene=27#wechat_redirect">回顾·搜狗信息流推荐算法交流</a></td><td>推荐</td><td>2018-07-02</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651746611&idx=1&sn=c9bf49b74c52ba3a091051772828fb54&chksm=bd12a87e8a6521689690ea992fe69ab4b37cbb3f77942e2900314033fdda361d9993af6698fa&mpshare=1&scene=1&srcid=0117WfBjqkaqVXB9LUCBJpti&sharer_sharetime=1673957092409&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">深度学习在美团点评推荐平台排序中的运用</a></td><td>推荐</td><td>2017-07-28</td></tr><tr><td>美团</td><td><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651746412&idx=1&sn=885e98dd829dabbe3858d6b2ea9f954f&chksm=bd12a9218a652037b31b32188ff61258bdae61b3ab8bc5d326ac6f9d199cb1d83260701ff3ec&mpshare=1&scene=1&srcid=0117bKvljgSQqp4W9Kz9mPdU&sharer_sharetime=1673957061139&sharer_shareid=c032e8bde4d276951619cca1ff0debb1#rd">美团点评旅游搜索召回策略的演进</a></td><td>召回</td><td>2017-06-16</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索策略 </tag>
            
            <tag> 推荐策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池拒绝策略相关故障的排查日志</title>
      <link href="/2023/05/16/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%97%A5%E8%AE%B0-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A6%E5%8F%91%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/"/>
      <url>/2023/05/16/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%97%A5%E8%AE%B0-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A6%E5%8F%91%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>背景: 线上现场池出现偶发性的RejectedExecutionException, 第一时间检查线程池配置后未发现有明显异常,  在尝试调大队列长度后问题得到解决,  本文记录了排故的心路历程以及故障的真实原因; 代码已脱敏.</p><span id="more"></span><h2 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">32</span>, <span class="number">32</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">16</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">16</span>; n++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// do something</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        c.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;&#125;</span><br><span class="line">            System.err.println(<span class="string">&quot;============== task done, batch &quot;</span> + i + <span class="string">&quot; ==============&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;============== all done ==============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码描述了一个批量任务的执行过程， 小循环会每次提交 16 个任务给线程池，一共执行 100 次小循环；  因为 countDownLatch 的存在， 可以保证每一次都会执行完 16 个任务后再放 16 个</p><p>根据八股文中所描述的线程池执行逻辑， 首先由核心线程执行， 然后其他任务进入阻塞队列等待，如果队列满了， 启用非核心线程，数量由最大线程配置项控制， 如果最大线程满了，则触发拒绝策略。 </p><p>代码中线程池配置核心线程数量等于32， 最大线程数量等于 32， 队列长度为 16， 因此根据八股理论， 这个线程池支持支持一次接收 32 + 16 &#x3D; 48 个任务， 最多支持同时执行 32 个任务。 </p><p>根据小学数学理论，我们知道 16 是小于 48 的 ，当前的线程池配置最多可以接收 3 批任务（1 批 16 个），  因此我认为正常不会触发线程池的拒绝策略， 起码不会在前3 批任务之前触发。</p><p>理论分析完毕， 上实操， idea， 启动！ </p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202402031922288.png" alt="image-20240203192216240"></p><h2 id="第一查"><a href="#第一查" class="headerlink" title="第一查"></a>第一查</h2><p>执行到第二批时，线程池就满了，触发了拒绝策略， 我的第一直觉是，任务之间交接出了问题， 线程池执行完一批任务之后，未完全释放线程时，下一批任务已经进来了，这个交接的阶段， 线程池的动作如果慢一点或者放任务的动作快一点， 就会导致线程池被打满，从而触发拒绝策略； </p><p>所以我把代码改成了这样来验证我的想法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;&#125;</span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">20</span>; n++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// do something</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        c.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;&#125;</span><br><span class="line">            System.err.println(<span class="string">&quot;============== task done, batch &quot;</span> + i + <span class="string">&quot; ==============&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;============== all done ==============&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当每一个小循环执行完毕后，间隔 100ms 再执行下一个小循环， 通过这种方法控制了任务提交的频率，ok，启动！</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202402031940071.png" alt="image-20240203194040027"></p><p>结果是它并没有像我想象的那样奏效； 接着我尝试了扩大主线程的睡眠时间， 从 500ms 一直扩大到 2000ms， 结果还是一样， 在执行了几批之后， 就会触发线程池的拒绝策略， 这里就可以排除我之前的猜想， 我当时的猜想认为这个交接的间隙应该是很短的，可能就是几十毫秒到几百毫秒， 当我把主线程的睡眠时间延长到秒级别依旧会触发拒绝策略的时候，这个猜想就已经没有继续排查的必要了。 </p><h2 id="第二查"><a href="#第二查" class="headerlink" title="第二查"></a>第二查</h2><p>第二个排查点就是CountDownLatch了， 我尝试将CountDownLatch的去掉来验证，将代码改造成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">20</span>; n++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// do something</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.err.println(<span class="string">&quot;============== task done, batch &quot;</span> + i + <span class="string">&quot; ==============&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;============== all done ==============&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>启动验证， 跑到第 36 批的时候，依旧是触发了拒绝策略，CountDownLatch并没有起到设想中的作用， 反而去掉CountDownLatch之后，跑的批次还变多了， 这就很奇怪了。<img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202402052116482.png" alt="image-20240205211640374"></p><p>尝试降低单批次提交任务的数量以及调高线程池的最大线程和阻塞队列长度，结果是， 后者起作用了 </p><p>当我降低单批次提交任务的数量时 ，代码修改成了这样 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">2</span>; n++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// do something</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.err.println(<span class="string">&quot;============== task done, batch &quot;</span> + i + <span class="string">&quot; ==============&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;============== all done ==============&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>每一批提交两个任务， 一共提交 100 批， 多次测试发现， 有些时候， 程序能够正常跑完， 有些时候又会触发拒绝策略；</p><p>调高线程池的最大线程和阻塞队列长度， 代码修改成了这样 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">32</span>, <span class="number">32</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">16</span> * <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">20</span>; n++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                         do something</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        c.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;&#125;</span><br><span class="line">            System.err.println(<span class="string">&quot;============== task done, batch &quot;</span> + i + <span class="string">&quot; ==============&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;============== all done ==============&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果是程序每次执行都能正常跑完， 不会再触发拒绝策略， 这里我的猜想又回到了第一查的时候， 我认为就是线程池有延时导致的，第一查中排除掉了任务提交间隙，线程池对上一批任务做收尾工作导致线程未及时释放的猜想， 那么线程池中还有哪些操作会产生延时或者说是间隙时间呢？ 源码之下无秘密， 第三查，启动！</p><h2 id="第三查"><a href="#第三查" class="headerlink" title="第三查"></a>第三查</h2><p>进入 ThreadPoolExecutor源码，我们通过 execute 方法向线程池提交了任务， execute方法有三个主要分支，</p><p> 一、通过 ctl 变量判断了当前的工作线程数量是否小于核心线程数， 如果小于则会新建一个线程来执行当前的任务，然后返回；<del>（ctl变量是一个AtomicInteger类型的原子整数，低29位表示线程池中当前活动的工作线程数（workerCount），高3位表示线程池的状态（RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED等））</del></p><p> 二、判断线程池是否在运行， 并且将任务添加到队列中成功，则再次判断线程池的状态，如果线程池停止并且移除任务成功， 则触发拒绝策略；如果任务已加入到了队列中，但是没有工作线程的，则会创建一个非核心线程来从队列中获取任务来执行。</p><p>三、尝试创建非核心线程来执行任务，如果新增线程失败，则触发拒绝策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了简化验证过程，我们将业务代码中线程池的参数和任务量调小， 使得 debug 更加可控，将代码调整为如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">2</span>; n++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                         do something</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;============== all done ==============&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过断点调试，可以发现在第一个 小循环执行完毕时， 线程池的工作线程就已经满了， 因此在第二个小循环执行时，会进入到execute 中第二个分支中，将任务放入队列中，这里的workQueue.offer()方法扮演了一个生产者的角色， 对应的workQueue.take()则是扮演的消费则的角色，take 方法从队列中取出并移除头元素，如果队列为空，则当前线程会被阻塞，直至有元素加入队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202403021437361.png" alt="image-20240302143739365"></p><p>图片是第二次小循环进入调试信息， 可以看到核心线程为 2，这是第一个小循环是创建的两个线程， 所以第二次小循环进入了第二个分支，调用了 workQueue 的 offer 方法将任务放入了队列， 此时 workQueue的 size &#x3D; 1； </p><p>接着 take 方法会从队列中拿走任务，然后 offer 方法会继续放入任务， 发现问题了么？ take 和 offer 两个方法之间， 是可能存在错位执行的可能性的， 而队列长度为 1， 如果发生了错位执行或者是时延， 那么队列长度就会超， 则就会触发拒绝策略， 这就是问题的触发点。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证方法很简单， 就是让 offer 方法睡一会，确保任务已被 take 方法拿走</p><p>将ArrayBlockingQueue复制一份，在 offer 方法中的 finally代码块中添加睡眠代码， 并将任务代码中的线程池队列设置为自定义的ArrayBlockingQueue</p><p> <img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202403021602547.png" alt="image-20240302145303623"></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202403052206979.png" alt="image-20240305220630658"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueueRyan</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">2</span>; n++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                         do something</span></span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;============== all done ==============&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行发现，不会再触发拒绝策略了</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202403021454182.png" alt="image-20240302145424131"></p><p>当将阻塞队列换成 没有改造过的ArrayBlockingQueue，则依旧会触发拒绝策略</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202403052224178.png" alt="image-20240305222413126"></p><p>至此，问题点已经可以确认了， 因为生产者消费者之间的错序，导致了队列中的任务没有被及时拿走，从而导致了积压，最后触发拒绝策略； 改造队列源码这种方法在开发中肯定是禁止的， 在日常开发中，我们可以通过调大队列的长度来解决这个问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>源码之下无秘密， 少看八股，多看源码， 别人总结的八股，看了背了，也总是似是而非，好像懂了又好像没懂，也无法运用自如。</p>]]></content>
      
      
      <categories>
          
          <category> 故障日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>即时编译JIT</title>
      <link href="/2023/05/11/%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91JIT/"/>
      <url>/2023/05/11/%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91JIT/</url>
      
        <content type="html"><![CDATA[<p>即时编译（Just-In-Time Compilation，简称JIT）是一种编译技术，它在代码即将首次执行时进行编译，因此得名“即时编译”。JIT是动态编译的一种特例。随着时间的发展，JIT的概念已经扩展，现在常被用来泛指动态编译；然而，狭义的JIT编译与更广泛的动态编译之间仍存在区别。动态编译（Dynamic Compilation）指的是在程序运行时进行编译，而静态编译（Static Compilation，也称事前编译，Ahead-Of-Time Compilation，简称AOT）则是在程序运行前完成编译。自适应动态编译（Adaptive Dynamic Compilation）也是一种动态编译技术，它先让程序以某种方式运行，收集信息后再进行编译，从而实现更高层次的优化。</p><span id="more"></span><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2024/PixPin_2024-11-26_14-36-55.png" style="zoom:50%;" /><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在某些商业虚拟机（如HotSpot）中，Java程序最初是通过解释器（Interpreter）解释执行的。当虚拟机发现某个方法或代码块被频繁调用时，这些代码就会被标记为“热点代码”。为了提高热点代码的执行效率，虚拟机会在运行时将这些代码编译成针对本地平台优化的机器码，这一过程由即时编译器（Just-In-Time Compiler，简称JIT编译器）完成。</p><p>即时编译器并不是Java虚拟机的必需组件。Java虚拟机规范并没有规定虚拟机内必须包含即时编译器，也没有对其实现方式提出具体要求。然而，即时编译器的性能和代码优化能力是衡量一个商业虚拟机优劣的重要指标之一，也是虚拟机技术实力的核心体现。除非特别说明，本文提到的编译器和即时编译器均指HotSpot虚拟机中的即时编译器，而虚拟机也特指HotSpot虚拟机。</p><h3 id="解释编译并存架构"><a href="#解释编译并存架构" class="headerlink" title="解释编译并存架构"></a>解释编译并存架构</h3><p>尽管并非所有Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商业虚拟机（如HotSpot）都同时包含解释器和编译器。解释器和编译器各具优势：</p><ul><li><strong>解释器</strong>：在程序需要迅速启动和执行时，解释器可以立即开始工作，避免编译所需的时间。</li><li><strong>编译器</strong>：随着程序运行时间的增长，编译器逐渐发挥作用，将越来越多的代码编译成本地代码，从而获得更高的执行效率。</li></ul><p>在内存资源有限的环境中（如嵌入式系统），可以使用解释器执行以节省内存；在其他情况下，可以利用编译执行来提升性能。此外，如果编译后的代码遇到罕见问题，系统还可以通过回退到解释执行来解决问题。</p><h3 id="编译的时间与空间开销"><a href="#编译的时间与空间开销" class="headerlink" title="编译的时间与空间开销"></a>编译的时间与空间开销</h3><h3 id="时间开销"><a href="#时间开销" class="headerlink" title="时间开销"></a>时间开销</h3><ul><li><strong>解释执行</strong>：输入的代码 → 解释器解释执行 → 执行结果</li><li><strong>JIT编译再执行</strong>：输入的代码 → 编译器编译 → 编译后的代码 → 执行 → 执行结果</li></ul><p>JIT编译后的代码执行速度通常比解释执行快，但这并不意味着编译过程本身比解释快。对于只执行一次的代码，解释执行通常更快，因为编译过程会带来额外的开销。只有对频繁执行的代码，JIT编译才能带来正向收益。</p><h3 id="空间开销"><a href="#空间开销" class="headerlink" title="空间开销"></a>空间开销</h3><p>编译后的代码通常比字节码大得多，膨胀比达到10倍是常见现象。因此，只有对频繁执行的代码进行编译才有意义，否则会显著增加代码占用的空间。</p><h3 id="不同的编译器"><a href="#不同的编译器" class="headerlink" title="不同的编译器"></a>不同的编译器</h3><p>HotSpot虚拟机内置了两个即时编译器：</p><ul><li>**Client Compiler (C1)**：适用于客户端应用，注重编译速度。</li><li>**Server Compiler (C2)**：适用于服务端应用，注重编译质量。</li></ul><p>虚拟机会根据自身版本和宿主机器的硬件性能自动选择运行模式，用户也可以通过“-client”或“-server”参数强制指定虚拟机运行在客户端模式或服务端模式。提供多个即时编译器的原因与提供多个垃圾收集器类似，都是为了适应不同的应用场景。</p><h3 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h3><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>热点代码是指在程序运行过程中被频繁调用的代码段，包括方法和循环体。这些代码的执行频率高，对程序的整体性能影响较大。</p><h3 id="识别热点代码"><a href="#识别热点代码" class="headerlink" title="识别热点代码"></a>识别热点代码</h3><p>JIT编译器通过以下方式识别热点代码：</p><ul><li><strong>基于计数器的热点探测</strong>：为每个方法和循环体设置计数器，统计其执行次数。当计数器超过一定阈值时，该代码段被标记为热点代码。</li><li><strong>基于采样的热点探测</strong>：周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，则认为这些方法是热点方法。</li></ul><p>在HotSpot虚拟机中，主要采用基于计数器的热点探测方法。每个方法有两个计数器：方法调用计数器和回边计数器。当计数器超过阈值时，会触发JIT编译。</p><h3 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h3><p>方法调用计数器用于统计方法被调用的次数。当一个方法被调用时，会先检查该方法是否有已编译的版本，如果有则优先使用编译后的版本。如果没有，则将调用计数器加1，并判断是否超过阈值。如果超过阈值，将向即时编译器提交编译请求。编译完成后，该方法的调用入口地址会被自动更新为新的版本。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2024/PixPin_2024-11-26_15-36-16.png" style="zoom:50%;" /><h3 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h3><p>回边计数器用于统计方法中循环体代码的执行次数。在字节码中，遇到控制流向后跳转的指令称为“回边”。回边计数器的值与方法调用计数器的值相加，当总和超过阈值时，也会触发JIT编译。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2024/PixPin_2024-11-26_15-39-18.png" style="zoom:50%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>即时编译技术通过动态编译热点代码，显著提升了程序的执行效率。HotSpot虚拟机中的即时编译器通过解释器与编译器并存的架构，结合基于计数器的热点探测方法，有效地识别和优化热点代码，从而在不同的应用场景中提供高性能的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES自定义搜索结果打分机制</title>
      <link href="/2022/11/07/ES%E8%87%AA%E5%AE%9A%E4%B9%89%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/11/07/ES%E8%87%AA%E5%AE%9A%E4%B9%89%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Elasticsearch 虽提供强大搜索功能，但默认排序在复杂业务场景下渐显局限。电商需综合商品热度、评分等因素排序；新闻平台看重时效性与权威性；企业知识管理系统要考虑文档重要性等。Function Score Query 应运而生，它允许开发者依据业务规则自定义打分机制，实现精准个性化排序，以满足多样化需求，提升用户搜索体验与业务竞争力。</p><span id="more"></span><p>ES的query结果中的存在一个相关度得分score,默认按照score从高到低排序</p><p>Function score query可以实现对最终score的自定义打分</p><h2 id="打分逻辑"><a href="#打分逻辑" class="headerlink" title="打分逻辑"></a>打分逻辑</h2><p>三个名词概念, 本文中将会用到</p><ul><li>ES的默认打分 def_score</li><li>函数打分值 fun_score</li><li>最终文档排序使用的打分  ult_score</li></ul><p>在不使用function score query的情况下  def_score 等于 ult_score</p><p>使用function score query后, ult_score的计算过程如下:</p><ol><li>执行query获取 def_score</li><li>执行自定义的打分函数,每个文档获取一个新的打分值,记为 fun_score</li><li>fun_score 和 def_score 按照某种计算方式(默认相乘),计算得出 ult_score</li></ol><p>基本使用方式:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;material_no&quot;</span><span class="punctuation">:</span> <span class="string">&quot;acti&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;boost_mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;multiply&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>计算方式由boost_mode定义</p><ul><li>multiply : 相乘（默认），ult_score &#x3D; def_score * fun_score</li><li>replace : 替换，ult_score &#x3D; fun_score</li><li>sum : 相加，ult_score &#x3D; def_score + fun_score</li><li>avg : 取两者的平均值，ult_score &#x3D; Avg(def_score, fun_score)</li><li>max : 取两者之中的最大值，ult_score &#x3D; Max(def_score, fun_score)</li><li>min : 取两者之中的最小值，ult_score &#x3D; Min(def_score, fun_score)</li></ul><h2 id="打分函数"><a href="#打分函数" class="headerlink" title="打分函数"></a>打分函数</h2><h3 id="权重-weight"><a href="#权重-weight" class="headerlink" title="权重 weight"></a>权重 weight</h3><p>基本使用:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;material_no&quot;</span><span class="punctuation">:</span><span class="string">&quot;acti&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span><span class="number">5</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这种方式会给所有匹配文档加权, 等于是将所有def_score进行了等比放大,并不会影响排序结果</p><p>通过filter去控制哪些文档进行加权</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="string">&quot;query:&quot;</span><span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;material_no&quot;</span><span class="punctuation">:</span><span class="string">&quot;acti&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;functions&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;brand_name&quot;</span><span class="punctuation">:</span><span class="string">&quot;西门子&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span><span class="number">5</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种情况下,只有brand_name 等于 西门子的文档的def_score会被加权, 这种方式可以让我们想要的文档排序是排到前面去</p><h3 id="随机打分-random-score"><a href="#随机打分-random-score" class="headerlink" title="随机打分 random_score"></a>随机打分 random_score</h3><p>random_score函数会生成 [0,1) 区间的随机数</p><p>基本使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;material_no&quot;</span><span class="punctuation">:</span><span class="string">&quot;acti&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;random_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这种情况下,每次的排序结果都会不同</p><p>如果在某些情况下需要同一用户的随机结果保持前后一致,可以通过为每个用户指定seed来实现</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;material_no&quot;</span><span class="punctuation">:</span><span class="string">&quot;acti&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;random_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;seed&quot;</span><span class="punctuation">:</span><span class="number">10</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这种写法可以实现我们上面的要求,但是es会报警告</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205262020259.png" alt="image-2022052682009192 PM"></p><p>大概意思为7.0之后,设置seed必须提供field参数</p><p>这是因为不设置field时,会使用Lucene doc ids作为随机源,会消耗大量内存</p><p>官方建议设置field为 _seq_no (索引序列号)</p><p>注意 : 如果索引进行了更新,则_seq_no也会进行更新,则随机数也会改变</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;material_no&quot;</span><span class="punctuation">:</span><span class="string">&quot;acti&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;random_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;seed&quot;</span><span class="punctuation">:</span><span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span><span class="string">&quot;_seq_no&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="字段值打分-field-value-factor"><a href="#字段值打分-field-value-factor" class="headerlink" title="字段值打分 field_value_factor"></a>字段值打分 field_value_factor</h3><p>使用文档中指定字段的值计算ult_score</p><p>比如brand表中有用于排序的sort字段,我们想要匹配文档按照sort字段进行排序,可以这么写</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;field_value_factor&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span><span class="string">&quot;sort&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;factor&quot;</span><span class="punctuation">:</span><span class="number">1.5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;missing&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;modifier&quot;</span><span class="punctuation">:</span><span class="string">&quot;ln&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>field : 指定字段</li><li>factor : 乘积因子, 与指定字段值相乘, 默认为1</li><li>missing : 缺省值, 如果field不存在,则使用missing值</li><li>modifier : 计算函数，为了避免分数相差过大，用于平滑分数,有如下几种<ul><li>none : 不处理，默认</li><li>log : 自然对数,   log(factor * field_value)</li><li>log1p :自然对数,  log(1 + factor * field_value)</li><li>log2p :自然对数 , log(2 + factor * field_value)</li><li>ln : 自然对数,    ln(factor * field_value)</li><li>ln1p : 自然对数,  ln(1 + factor * field_value)</li><li>ln2p : 自然对数,  ln(2 + factor * field_value)</li><li>square : 平方，   (factor * field_value)^2</li><li>sqrt : 开方，     sqrt(factor * field_value)</li><li>reciprocal : 倒数，1&#x2F;(factor * field_value)</li></ul></li></ul><p>在上面的写法中 , 假设文档A的 def_score &#x3D; 0.8 ,  sort &#x3D; 5</p><p>则 ult_score &#x3D; 0.8 *  ln( 1.5 * 5 ) &#x3D;  1.612</p><h3 id="衰减函数-decay-function"><a href="#衰减函数-decay-function" class="headerlink" title="衰减函数 decay_function"></a>衰减函数 decay_function</h3><p>以某一数值(日期,数值,位置)作为中心点, 按照设置的比例逐渐衰减</p><p>基本使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;gauss&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;origin&quot;</span><span class="punctuation">:</span><span class="string">&quot;2000-01-05&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;scale&quot;</span><span class="punctuation">:</span><span class="string">&quot;10d&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span><span class="string">&quot;5d&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;decay&quot;</span><span class="punctuation">:</span><span class="number">0.5</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>三种函数 :</p><ul><li>linear :线性函数</li><li>exp: 指数函数</li><li>gauss: 高斯函数</li></ul><p>参数含义:</p><ul><li>origin : 中心点 (数值, 日期 ,坐标 )</li><li>scale : 到中心点的距离</li><li>offset : 偏移量</li><li>decay: 衰减指数</li></ul><p>origin 等于 2000-01-05, scale 等于 10天</p><p>意味着 created_at 在 2000-01-01 到 2000-01-10  区间内的文档的权重为 1</p><p>created_at在 scale + offset &#x3D; 15天 之外的文档的权重为0.5</p><h3 id="script-score-脚本打分"><a href="#script-score-脚本打分" class="headerlink" title="script_score 脚本打分"></a>script_score 脚本打分</h3><p>自由度最高的一种打分函数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;script_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span><span class="string">&quot;Math.log(2+doc[&#x27;sort&#x27;].value)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用 doc[‘field_name’].value 引用指定字段的值</p><p>source可以设置为任意的算法</p><p>&lt;更新&gt;</p><p>去除硬编码, 使用params参数使脚本更灵活,使source不用重复编译</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;script_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span><span class="string">&quot;Math.log(&#x27;multiplier&#x27;+doc[&#x27;sort&#x27;].value)&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;multiplier&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>注意:脚本编译有频率限制,编译非常耗时,这是es的自我保护机制  ;  默认情况下，每 5 分钟最多可以编译 150 个脚本</p><p>调整方法:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;transient&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;script.max_compilations_rate&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;100/1m&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用存储脚本的API来存储和检索脚本  , 存储的脚本可缩短编译时间并加快搜索速度。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /_scripts/calc_score</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lang&quot;</span><span class="punctuation">:</span> <span class="string">&quot;painless&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Math.log(_score * 2) + params[&#x27;multiplier&#x27;]&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用存储的脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">POST product4/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;script_score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;calc_score&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;multiplier&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE _scripts/calc_score</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于IK分词器二开的一点归纳</title>
      <link href="/2022/06/12/%E5%9F%BA%E4%BA%8EIK%E5%88%86%E8%AF%8D%E5%99%A8%E4%BA%8C%E5%BC%80%E7%9A%84%E4%B8%80%E7%82%B9%E5%BD%92%E7%BA%B3/"/>
      <url>/2022/06/12/%E5%9F%BA%E4%BA%8EIK%E5%88%86%E8%AF%8D%E5%99%A8%E4%BA%8C%E5%BC%80%E7%9A%84%E4%B8%80%E7%82%B9%E5%BD%92%E7%BA%B3/</url>
      
        <content type="html"><![CDATA[<p>背景: IK 分词器作为一款广泛应用于中文文本处理的工具，在实际使用场景中，虽然提供了基本的分词功能，但随着业务需求的日益复杂和多样化，其原生功能逐渐显现出一定的局限性。例如，在特定领域的专业文本处理中，可能需要针对行业术语、品牌名称、产品型号等进行更精准的识别和分类；在大规模数据处理时，对分词效率和词典更新的实时性也提出了更高的要求。</p><p>为了满足这些不断增长的业务需求，提升文本处理的质量和效率，对 IK 分词器进行二次开发成为了一种必要的手段。通过深入研究 IK 分词器的源码，我们可以根据具体业务场景，定制个性化的分词逻辑，优化词典管理，改进分词算法，从而实现更符合实际需求的文本处理功能。</p><span id="more"></span><h3 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1.源码分析"></a>1.源码分析</h3><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205081924063.png" alt="image-20220508192403184" style="zoom:50%;" /><p>我们需要关注的是cfg , core , dic三个包 ，这其中包含了ik分词器的主类， 主配置类、词元类、 词典类等关键类，后续对ik分词器的改造也是围绕这三个包来展开的 </p><p>core包括了IK的分词器接口ISegmenter，分词器核心类IKSegmenter，语义单元类Lexeme，上下文AnalyzeContext，以及子分词器LetterSegementer(英文字符子分词器),CN_QuantifierSegmenter(中文量词子分词器),CJKSegmenter(中日韩字符分词器)，</p><p>dic包括了词典类Dictionary，词典树分段类DictSegmenter，用来记录词典匹配命中记录的类Hit</p><h5 id="1-词典初始化"><a href="#1-词典初始化" class="headerlink" title="1.词典初始化"></a>1.词典初始化</h5><p>在分词器IKSegmenter首次实例化时，默认会根据DefaultConfig找到主词典和中文量词词典路径，同时DefaultConfig会根据classpath下配置文件IKAnalyzer.cfg.xml，找到扩展词典和停止词典路径，可以在该配置文件中配置自己的扩展词典和停止词典。</p><p>找到词典路径后，初始化Dictionary.java，Dictionary是单例的。在Dictionary的构造函数中加载词典。Dictionary是IK的词典管理类，真正的词典数据是存放在DictSegment中，该类实现了一种树结构，如下图。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082209853.png" alt="image-20220508220918804"></p><p>比如,要对字符串”施耐德继电器”进行分词，首先拿到字符串的第一个字符’施’,在上面的词典树中可以匹配到’施’节点，然后拿到字符串第二个字符’耐’，从上一个节点’施’往下找，找到了’耐’节点，’耐’节点是一个非终点节点,继续往下找到’德’节点,’德’节点是终点节点,所以’施耐德’是一个词</p><p>Dictionary中默认有三个DictSegment对象,  _MainDict , _QuantifierDict , _StopWords , 分别是主词典, 中文量词词典, 停用词词典(停用词词典中的词在分词时将会被忽略)</p><p>Dictionary加载主词典，将主词典保存到它的_MainDict对象中，加载完主词典后，加载扩展词典，扩展词典同样保存在_MainDict中。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082117840.png" alt="image-20220508211711777"></p><p>fillSegment方法是DictSegment加载单个词的核心方法，charArray是词的字符数组，先是从存储节点搜索词的第一个字符，如果不存在则创建一个节点用于存储第一个字符，后面递归存储，直到最后一个字符。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082215674.png" alt="image-20220508221241534"></p><p>子节点如果存粹用map存储，会比较浪费空间，因此ik采用了一种折中的方式。就是根据子节点的数量对存储结构进行调整，如果子节点的数量小于等于3，则采用数组存储，如果子节点的数量大于3，采用map存储。其中的nodeState就是用来标记当前节点</p><p>因为HashMap需要预先分配内存，所以可能存在浪费现象；但是如果全用数组存，后续采用二分查找时无法获得O(1)的时间复杂度。所以这里采用了两种方式，子节点少时用数组存，子节点多时则迁移至HashMap。</p><h5 id="2-自定义词典"><a href="#2-自定义词典" class="headerlink" title="2.自定义词典"></a>2.自定义词典</h5><p>了解了主词典的加载流程,只需要照猫画虎就行, 自定义几个DictSegment对象,如_BrandDic  ,  _CategoryDic ,  _MaterialNoDic 等 , 在config文件夹中创建对应的dic文件 </p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082121508.png" alt="image-20220508212158446"></p><p>编写字典加载方法 </p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082123981.png" alt="image-20220508212308919"></p><p>在initial方法中调用加载方法,在Dictionary对象创建时会调用此方法,将对应字典加载入内存</p><h5 id="3-基于词典的切分"><a href="#3-基于词典的切分" class="headerlink" title="3.基于词典的切分"></a>3.基于词典的切分</h5><p>在 IK 分词器中，基于词典的切分是其核心功能之一。当对文本进行分词时，分词器会从文本的起始位置开始，逐个字符地与词典中的词条进行匹配。它会根据已加载的词典树结构，从根节点开始，沿着字符路径向下查找。例如，对于输入文本 “智能电网技术的发展”，分词器首先会获取 “智” 这个字符，然后在词典树中查找是否存在以 “智” 开头的词条。如果找到，会继续获取下一个字符 “能”，并在 “智” 节点的子节点中查找是否有 “能” 节点。以此类推，不断匹配字符，直到找到完整的词条或者无法继续匹配为止。</p><p>在这个过程中，IK 分词器会充分利用词典树的结构特点来提高匹配效率。由于词典树的存储结构根据子节点数量进行了优化，当子节点数量较少时使用数组存储，这样可以通过快速的顺序查找来定位字符；而当子节点数量较多时采用 Map 存储，通过键值对的方式能够更高效地查找字符。这种混合存储方式使得在不同情况下都能尽量减少查找时间，提高分词速度。</p><h5 id="4-分词模式"><a href="#4-分词模式" class="headerlink" title="4.分词模式"></a>4.分词模式</h5><p>IK 分词器提供了多种分词模式，以满足不同场景下的需求。其中最常见的有细粒度分词模式和粗粒度分词模式。</p><p>细粒度分词模式旨在尽可能细致地将文本切分成最小的语义单元。在这种模式下，分词器会对文本进行深度分析，将句子中的词语、短语甚至一些特定的组合都尽可能地拆分出来。例如，对于句子 “中国人民解放军是一支强大的军队”，细粒度分词可能会将其拆分为 “中国”“人民”“解放军”“是”“一支”“强大”“的”“军队” 等多个词元。这种模式适用于需要对文本进行详细语义理解和分析的场景，如文本挖掘、知识图谱构建等。</p><p>粗粒度分词模式则更注重将文本切分成较大的语义块，以获取更宏观的语义信息。在处理上述句子时，粗粒度分词可能会将其拆分为 “中国人民解放军”“是”“一支强大的军队” 等。这种模式在一些对文本整体语义把握更为重要，而不太关注细节词语的场景中较为适用，比如文档分类、主题提取等。</p><p>除了这两种基本模式外，IK 分词器还支持用户自定义分词模式。用户可以根据具体业务需求，通过调整分词器的配置参数或者编写自定义的分词规则，来实现符合自身业务特点的分词方式。例如，在特定领域的专业文档处理中，可以根据领域术语的特点定义专门的分词模式，使得分词结果更贴合业务需求，提高后续文本处理的准确性和效率。</p><h5 id="5-匹配定义词性"><a href="#5-匹配定义词性" class="headerlink" title="5.匹配定义词性"></a>5.匹配定义词性</h5><p>自定义的字典加载完成后,下一步就是使用词元匹配词典来确认词性,以品牌词典举例, 分词器在获取词元的时候会调用分词器主类IKSegmenter中的next()方法来获取下一个词元,并判断是否为停用词, <strong>我们可以在这里动一些手脚, 通过匹配词典,来判断当前词元的词性</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082130700.png" alt="image-20220508213052634"></p><p>isBrand()方法调用DictSegmenter中的match()方法,品牌词已经加载至一个字典树之内，所以整个过程也就是一个从树根层层往下走的一个层层递归的方式,首字符匹配到一个节点后,判断下面是否还有节点,有就继续往下匹配;匹配的结果一共三种UNMATCH（未匹配），MATCH（匹配）， PREFIX（前缀匹配）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配词段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> searchHit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Hit </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Hit <span class="title function_">match</span><span class="params">(<span class="type">char</span>[] charArray , <span class="type">int</span> begin , <span class="type">int</span> length , Hit searchHit)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(searchHit == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//如果hit为空，新建</span></span><br><span class="line">searchHit= <span class="keyword">new</span> <span class="title class_">Hit</span>();</span><br><span class="line"><span class="comment">//设置hit的其实文本位置</span></span><br><span class="line">searchHit.setBegin(begin);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//否则要将HIT状态重置</span></span><br><span class="line">searchHit.setUnmatch();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置hit的当前处理位置</span></span><br><span class="line">searchHit.setEnd(begin);</span><br><span class="line"></span><br><span class="line">       <span class="type">Character</span> <span class="variable">keyChar</span> <span class="operator">=</span> Character.valueOf(charArray[begin]);</span><br><span class="line"><span class="type">DictSegment</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用实例变量为本地变量，避免查询时遇到更新的同步问题</span></span><br><span class="line">DictSegment[] segmentArray = <span class="built_in">this</span>.childrenArray;</span><br><span class="line">Map&lt;Character , DictSegment&gt; segmentMap = <span class="built_in">this</span>.childrenMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//STEP1 在节点中查找keyChar对应的DictSegment</span></span><br><span class="line"><span class="keyword">if</span>(segmentArray != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//在数组中查找</span></span><br><span class="line"><span class="type">DictSegment</span> <span class="variable">keySegment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DictSegment</span>(keyChar);</span><br><span class="line"><span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> Arrays.binarySearch(segmentArray, <span class="number">0</span> , <span class="built_in">this</span>.storeSize , keySegment);</span><br><span class="line"><span class="keyword">if</span>(position &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">ds = segmentArray[position];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(segmentMap != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//在map中查找</span></span><br><span class="line">ds = (DictSegment)segmentMap.get(keyChar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//STEP2 找到DictSegment，判断词的匹配状态，是否继续递归，还是返回结果</span></span><br><span class="line"><span class="keyword">if</span>(ds != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(length &gt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//词未匹配完，继续往下搜索</span></span><br><span class="line"><span class="keyword">return</span> ds.match(charArray, begin + <span class="number">1</span> , length - <span class="number">1</span> , searchHit);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (length == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//搜索最后一个char</span></span><br><span class="line"><span class="keyword">if</span>(ds.nodeState == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//添加HIT状态为完全匹配</span></span><br><span class="line">searchHit.setMatch();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ds.hasNextNode())&#123;</span><br><span class="line"><span class="comment">//添加HIT状态为前缀匹配</span></span><br><span class="line">searchHit.setPrefix();</span><br><span class="line"><span class="comment">//记录当前位置的DictSegment</span></span><br><span class="line">searchHit.setMatchedDictSegment(ds);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> searchHit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//STEP3 没有找到DictSegment， 将HIT设置为不匹配</span></span><br><span class="line"><span class="keyword">return</span> searchHit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配成功则将当前词元的type设置为brand,没有匹配上则继续匹配其他词典,直至结束.</p><h5 id="6基于规则的歧义判断"><a href="#6基于规则的歧义判断" class="headerlink" title="6基于规则的歧义判断"></a>6基于规则的歧义判断</h5><p>在中文分词中，歧义判断是一个复杂且关键的环节。IK 分词器在进行分词时，经常会遇到一些可能产生歧义的情况。例如，对于句子 “从小学到大学”，既可以切分为 “从 &#x2F; 小学 &#x2F; 到 &#x2F; 大学”，也可以切分为 “从小 &#x2F; 学到 &#x2F; 大学”。</p><p>为了处理这些歧义，IK 分词器采用了基于规则的方法。它内置了一系列预先定义好的规则来对可能产生歧义的分词结果进行判断和调整。这些规则是基于对大量中文语言现象的分析和总结得出的。</p><p>其中一种常见的规则是基于词语的词性和语义搭配。例如，某些词语在特定的词性组合下更倾向于一种分词方式。如果 “从” 作为介词，后面更可能跟随一个表示地点或范围的名词短语，如 “小学”，那么在这种情况下，更倾向于将 “从小学” 作为一个整体，而不是将 “从小” 单独拆分出来。</p><p>另外，IK 分词器还会考虑词语在句子中的上下文信息。比如，当 “到” 前面是一个表示地点或时间范围的词语时，更有可能与前面的词语构成一个整体的语义单元。在 “从小学到大学” 这个句子中，根据上下文，“到大学” 更符合逻辑上的语义表达，所以会优先选择这种分词方式。</p><p>同时，IK 分词器在处理歧义时还会参考语言习惯和常见用法。对于一些常见的固定搭配或习惯用语，会按照约定俗成的方式进行分词。例如 “中华人民共和国”，会始终作为一个整体进行分词，而不会拆分成其他形式。</p><p>通过这些基于规则的歧义判断机制，IK 分词器能够在多种可能的分词结果中选择最符合语义逻辑和语言习惯的一种，从而提高分词的准确性和质量，为后续的文本处理任务提供更可靠的基础。在实际应用中，这些规则不断地根据新的语言现象和用户反馈进行优化和完善，以适应不断变化的中文语言环境和多样化的业务需求。例如，在处理一些新兴的网络用语或专业术语时，会及时更新规则，确保分词的有效性。</p><h3 id="2-热更新"><a href="#2-热更新" class="headerlink" title="2.热更新"></a>2.热更新</h3><p>基于数字资产保密条款, 热更新相关代码不予展示</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分词器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lucene分词器的基本原理</title>
      <link href="/2022/05/29/Lucene%E5%88%86%E8%AF%8D%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2022/05/29/Lucene%E5%88%86%E8%AF%8D%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>analysis, 中文意思分析,指的是es在文档发送之前对文档正文的执行过程,以添加到inverted index, 这一过程包含一下几个步骤:</p><ul><li>使用字符过滤器过滤字符,由char filter完成</li><li>分词,将input按指定的规则分割为多个token, 由tokanizer完成</li><li>token过滤, 将上一步的tokens按一定规则进行处理, 由token filter完成</li><li>存入索引</li></ul><span id="more"></span><p>经过 analyzer 处理过后的文档最终以 Inverted Index 的形式保存于 Elasticsearch 中：</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205180043961.png" alt="image-20220518124327931 AM"></p><p>上图中的analyzer, 一般称之为分析器, 由三个部分组成 </p><ul><li><p>char filter  字符过滤器,是处理文档正文或搜索输入的第一步, <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-htmlstrip-charfilter.html">官方文档</a></p></li><li><p>tokenizer   分词器, 顾名思义, 它的作用就是分词, 会输出一个token stream</p></li><li><p>filter   tokens过滤器,对token stream二次处理,token过滤器不允许更改每个token的位置或字符偏移量。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-synonym-tokenfilter.html#_wordnet_synonyms">官方文档</a>,  常用的有</p><ol><li>lowercase  将所有token转为小写</li><li>stop  将停用词从token流中删除</li><li>synonym 将同义词添加到token流中 </li><li>edge_ngram 指定最细粒度和最粗粒度,对token流进行二次分词</li></ol></li></ul><p>analyzer 是char filters、tokenizer和tokens filters的组合，tokenizer代表分词器，它负责将一串文本根据词典分成一个个的词，输出的是tokens数据流，一个analyzer有且只有一个tokenizer。token filter则是对分词之后的结果进行处理，例如大小写转换、关联同义词、去掉停用词、不同国家语言映射转换等，一个analyzer可以有0个或多个filter。</p><p><strong>analyzer 只作用于text 类型的字段，而对于 keyword 类型的字段，它将不被分析和分词。keyword 字段被用于精确匹配及聚合。</strong></p><p><strong>analyzer的使用场景</strong></p><p>1.建立索引的时候, 分析文档正文用于 indexing<br>2.搜索的时候, 分析input 用于searching</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205180118452.png" alt="image-20220518120153972 AM"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分词器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存一致性治理方案</title>
      <link href="/2022/05/10/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%B2%BB%E7%90%86%E6%96%B9%E6%A1%88/"/>
      <url>/2022/05/10/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%B2%BB%E7%90%86%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>缓存作为一种介于应用程序和数据库之间的中间层，能够有效地存储频繁访问的数据，减少对数据库的直接查询操作，从而显著提高系统的性能。它通过将热点数据临时存储在快速访问的存储介质（如 Redis）中，使得后续的相同请求可以直接从缓存中获取数据，避免了重复的数据库查询开销，大大缩短了数据的响应时间。</p><p>然而，缓存的引入虽然带来了性能上的提升，却也引发了一系列新的问题，其中最为关键的就是缓存与数据库之间的数据一致性问题。由于缓存和数据库是两个独立的存储系统，它们的数据更新操作可能无法实时同步，导致在某些情况下，缓存中的数据与数据库中的数据不一致。这种不一致性可能会给用户带来困惑，影响业务的正常运行，例如用户可能获取到过期或错误的数据，进而影响用户体验和业务决策的准确性。</p><p>因此，在设计和实现包含缓存的系统架构时，如何确保缓存与数据库之间的数据一致性成为了一个亟待解决的重要问题。这需要深入分析各种可能导致数据不一致的场景和原因，研究并制定有效的治理方案，在保证系统性能的前提下，尽可能降低数据不一致出现的概率，以满足业务对数据准确性和可靠性的要求。</p><span id="more"></span><h2 id="引入缓存"><a href="#引入缓存" class="headerlink" title="引入缓存"></a>引入缓存</h2><p>最简单的场景是, 业务在起步阶段, 流量很小, 读写请求直接操作数据库即可, 这时候的架构是这样的</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2022/202302191908059.jpg" alt="img" style="zoom:50%;" /><p>随着业务量的增长,  请求量越来越多, 每次请求都直接打到数据库的话, 会出现性能问题, 这时候, 缓存出现了 </p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2022/202302191909246.jpg" alt="img" style="zoom:50%;" /><p>常用的缓存中间件是Redis(还有其他优秀的中间件,但我没接触过), 加入缓存之后, 随之而来的一个问题是, 数据如何放入缓存 </p><p>db的数据直接全量刷入缓存, 不设置失效时间, 通过定时任务或者是DTS同步db的数据变动到缓存, 所有读请求走缓存</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2022/202302191912621.jpg" alt="img"></p><p>这种方案下, 读请求可以直接命中缓存, 性能高, 但是缓存利用率很低, 存在很多低读取的冷数据, 另外即使你的数据同步做的再好, 也不可能做到0延时的同步, 所以数据不一致肯定会出现</p><h2 id="利用率和一致性问题"><a href="#利用率和一致性问题" class="headerlink" title="利用率和一致性问题"></a>利用率和一致性问题</h2><p>先说利用率, 我们可以缓存热数据, 逻辑是这样</p><ul><li>所有写请求走db</li><li>读请求先走缓存, 未命中则从db读取</li><li>写入缓存, 设立失效时间</li></ul><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2022/202302191919415.jpg" alt="img"></p><p>随着时间的推移, 缓存中的冷数据都会过期, 并且没有读取请求就不会重建, 一段时候后, 缓存中的数据就都是热数据了.</p><p>再说一致性, 我们知道, 定时任务和DTS是不可能做到0延时的, 所以当接收到写请求, db和缓存需要一起更新, 这里会存在一个先后的问题</p><ol><li>db先更新, 缓存后更新</li><li>缓存先更新, db后更新</li></ol><p>因为操作分两步, 所以就会存在一成功,二失败的情况. </p><ol><li>db更新成功, 缓存更新失败, 则读请求打到缓存上, 响应的是旧值, 当旧缓存过期后, 才会重建新值的缓存, 用户层面的感受是, 更改未生效或者过了一段时间才生效.</li><li>缓存更新成功, db更新失败, 则读请求打到缓存上, 响应的是最新值, 过了一段时间, 缓存失效, 从db读取了旧值进行重建, 用户层面的感受是, 当时更改成功了, 但是过了一段时间又改回去了.</li></ol><p>先后问题先按住不表, 说下并发问题</p><p>场景: T1和T2两个线程, 同时更新同一条数据, 更新方案是 「先db,后缓存」, 那么会发生什么</p><ol><li>T1更新db x &#x3D; 1 </li><li>T2更新db     x &#x3D; 2</li><li>T2更新缓存  x &#x3D; 2</li><li>T1更新缓存     x &#x3D; 1</li></ol><p>最终结果 db  x &#x3D; 2 ,  缓存  x &#x3D; 1,  数据不一致了, 「先缓存,后db」的方案逻辑是一样的, 就不浪费笔墨了. </p><p>如何解决并发带来的数据不一致? 常用方案是分布式锁</p><p>线程更新数据之前, 需要先申请锁, 拿到锁的线程才允许进行更新动作, 否则阻塞或者返回失败后重试. </p><p>无论是先更新缓存还是先更新db, 都会导致利用率低的问题, 因为所有的写请求都无脑去更新缓存, 肯定会导致缓存中存在冷数据. 并且通过加锁来保证一致性, 会占用机器性能,降低响应速度, 这与引入缓存的初衷相悖.</p><h2 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h2><ol><li>先删除缓存, 后更新db</li><li>先更新db, 后删除缓存</li></ol><p>同样的,看下第二步失败的情景</p><ol><li>缓存删除后, db更新失败, 下一次读请求访问缓存, 会去db读取数据并重建缓存, 用户层面的感受是, 更改失败了 </li><li>db更新后, 缓存删除失败, 下一次读请求返回了缓存中的旧值, 只有当旧值失效, 新的读请求重建缓存后, 数据才一致 , 用户层面的感受是, 更改失败了, 但过了一段时间刷新看看又好了.</li></ol><p>再看并发问题 ,方案1在并发读写情况下</p><ol><li>T1删除了缓存 </li><li>T2读取缓存, 未命中, 从数据库读取了旧值重建缓存  x &#x3D; 1</li><li>T1更新了db       x &#x3D; 2</li></ol><p>最终结果 缓存 x &#x3D; 1,  db x &#x3D; 2, 数据不一致</p><p>方案2在并发读写的情况下</p><ol><li>缓存中无x的值</li><li>T1读取到数据库数据 x &#x3D; 1</li><li>T2更新db x &#x3D; 2</li><li>T2 删除了缓存</li><li>T1重建了缓存 x &#x3D; 1</li></ol><p>最终结果 db x &#x3D; 2, 缓存 x &#x3D; 1, 数据不一致, 但是这种情况概率很低, 因为它需要满足三个条件</p><ol><li>缓存刚好失效 , 对应第一步</li><li>读写并发 </li><li>更新数据库 + 删除缓存的耗时(3 , 4 步) 小于 读取数据库+ 重建缓存的耗时 (2, 5 步)</li></ol><p>理论上, 数据库写的耗时是会比读的耗时多的, 因为写需要加锁, 所以3, 4步 的耗时 大概率是大于 2, 5 步, 所以方案2在很大概率上是可以保证一致性的.</p><h2 id="如何确保两步都成功"><a href="#如何确保两步都成功" class="headerlink" title="如何确保两步都成功"></a>如何确保两步都成功</h2><p>无论是双更新还是删除缓存的方案, 只要第二步失败, 就会导致数据不一致, 如何保证第二步成功就是解决问题的关键</p><p>最简单的方案 : 重试 , 当第二步失败, 就发起重试, 但是无脑重试也会带来别的问题</p><ol><li>立刻重试, 大概是还是失败</li><li>重试次数过多, 占用线程资源</li></ol><p>看到这里估计有经验的开发第一反应就是异步</p><p>异步重试, 可以选择开一个专用的重试线程, 但我觉得更好的方案是MQ, 将重试请求扔到MQ中, 由专门的消费者来重试, 直到成功 , 这样就完美解决 1和2两个问题.</p><p>多说一句, 引入MQ一样会带来更多问题, 增加更多的维护成本, 这取决于你的系统对一致性要求高不高, 没有银弹, 只有取舍. </p><p>引入MQ后, 架构变成了这样 </p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202302192116646.jpg" alt="img"></p><p>另外一种方案, 订阅数据库binlog(阿里的canal), 再操作缓存</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202302192116922.jpg" alt="img"></p><p>至此, 我们的方案是 先更新db, 再删除缓存, 配合MQ或者是canal做重试 </p><h2 id="主从延迟和延迟双删"><a href="#主从延迟和延迟双删" class="headerlink" title="主从延迟和延迟双删"></a>主从延迟和延迟双删</h2><p>先删除缓存,后更新db的方案下, 是由于读线程重建了缓存而导致的不一致, 如果我们在读线程建立缓存之后, 写线程再去做一次删除动作, 则数据一致性就可以得到保证</p><p>在读写分离 + 主从延迟的情况下, 先更新db, 后删除缓存的方案, 还是会出现不一致</p><ol><li>T1更新主库 x &#x3D; 2</li><li>T1 删除缓存</li><li>T2 查询缓存, 未命中, 读取从库得到旧值  x &#x3D; 1</li><li>T2 将 x &#x3D; 1 写入缓存</li><li>从库从主库完成同步</li></ol><p>最终结果 db &#x3D; 2 , 缓存 &#x3D; 1,  这里就要引出延迟双删策略了</p><p>T1在执行完删除动作后, 可以先休眠一会, 然后再进行一次删除</p><p>或者T1在执行完删除动作后, 生成一条延时消息, 放入MQ, 由消费者延时删除缓存</p><p>两个关键 :</p><ol><li>T1的休眠时间或者是延时消息的延迟时间, 需要大于主从复制的延迟时间</li><li>T1的休眠时间或者是延时消息的延迟时间, 需要大于T2查db加写缓存的时间</li></ol><p>高并发的场景下, 这个延迟时间是很难估计的, 一般是凭经验设置, 比如1-5秒 , 尽可能的降低不一致的概率</p><h2 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h2><p>要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。</p><p>相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？</p><p>没错，<strong>性能</strong>。</p><p>一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。</p><p>而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。</p><p>所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。</p><p>虽然我们可以通过加「分布锁」的方式来实现，但我们也要付出相应的代价，甚至很可能会超过引入缓存带来的性能提升。</p><p>所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。</p><p>同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>提高系统的响应速度, 可以引入缓存</li><li>引入缓存后, 要考虑db和缓存的一致性问题 ,  有两种方案 <ol><li>双更新</li><li>更新db, 删除缓存</li></ol></li><li>双更新的方案在并发场景下无法保证一致性, 需要加分布式锁, 但是加锁会占用机器性能,降低响应速度, 这与引入缓存的初衷相悖.</li><li>采用先删缓存, 后更新db的方案, 在并发场景下会有不一致的情况, 解决方案是 延迟双删</li><li>采用先更新db , 后删除缓存的方案, 为了保证两步都执行成功, 可以使用MQ或者binlog订阅的方式进行重试 </li><li>在读写分离 + 主从复制的情况下, 采用先更新db, 后删除缓存的方案, 在并发场景下会有不一致的情况, 解决方案是 延迟双删</li></ol><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol><li>性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案</li><li>掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题</li><li>失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案</li><li>订阅变更日志的思想，本质是把权威数据源（例如 MySQL）当做 leader 副本，让其它异质系统（例如 Redis &#x2F; Elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据治理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一致性 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程的艺术阅读笔记-JMM篇</title>
      <link href="/2022/04/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JMM/"/>
      <url>/2022/04/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JMM/</url>
      
        <content type="html"><![CDATA[<p>因为可见性问题导致处理器不同核心看到的内存操作顺序不一致，从而看起来就像是指令被重排了一样</p><p>JMM在编译器重排阶段， 会禁止特定类型的编译器重排， 在处理器重排序阶段，通过在指令之间插入内存屏障来禁止特定类型的处理器重排， 从而确保了在不同的编译器和不同的处理器平台上，不会应为重排序规则不一致导致非预期的运行结果</p><p>现代处理器与内存进行数据交互，会先将数据写到自己的缓冲区中， 每个处理器都有自己的缓冲区， 这种特性就会导致缓冲区中的数据和内存的数据存在不一致， 例如核心A执行两条指令， 指令1是更新x的值， 指令2是读取y的值， 核心A更新了x并写入缓冲区，然后去主存读了y； 核心B执行两条指令， 指令1是更新y的值， 指令2是读取x的值， 核心B更新了y的值写入缓冲区， 然后去主存读了x的值， 因为两个核心的缓冲器都还未刷新，所以他们读到的都是旧值， 或者是只刷新了一个缓冲区； 这些都会导致在指令层面看起来就像是发生了指令重排一样， 其实核心是因为可见性问题，所以也会有人将这种现象称之为内存系统指令重排。</p><span id="more"></span><p>1.5开始， java开始使用jsr-133规范的内存模型 (jsr-133是java内存模型和线程规范，是JSR-176的一部分) jsr-133中引入了happens-before原则， 这是一种描述多个操作之间先后顺序关系的概念 ， 如果操作A happens-before 于操作B, 那么操作A的结果一定对操作B可见， 操作A和B可以是同一线程内的，也可以是不同线程之间的。</p><p>注意 happens-before 是一种偏序关系， 它只要求前一个操作的结果对后一个操作可见， 但不能保证前一个操作一定在后一个操作之前执行， 比如A happens-before B， B先执行，B在执行过程中需要读取A写入的数据， 那么happens-before是可以保证B读取到正确的数据的，但是不能保证A肯定在B之前执行。</p><p>如果A happens-before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。 这里的操作顺序指的是程序的逻辑执行流程</p><p>as-if-serial语义的意思是，在单线程环境下， 不管怎么重排序， 执行结果始终是不变的； 可以理解为看起来像是顺序执行的， 但其实可能已经被重排过了。</p><p>当程序中的操作存在控制依赖关系， 会影响指令序列执行的并行度， 因此，编译器和处理器会使用猜测执行来消除控制依赖对并行度的影响， 比如if(flag) {a &#x3D; a + b} ; 处理会提前执行a &#x3D; a + b , 并将结果临时保存在重排序缓冲中（Reorder Buffer）; 当flag为真时，就将计算结果写入到变量a中。</p><p>所以， 即使多个指令之间存在控制依赖关系， 编译器和处理器依旧会对它们进行重排序， 而在多线程环境下，这种重排是可能改变程序的预期运行结果的， 需要通过同步机制来约束， 比如锁 volatile 或者是 final 。 单线程下有as-if-serial规则， 所以不会改变运行结果。</p><p>顺序一致性内存模型是一个理想化的理论模型， 它的两大特性分别是 1.一个线程中的所有指令都必须按照顺序执行 ； 2.不管是否在同步环境下， 所有线程看见的指令执行顺序都是一致的， 每个操作都必须是原子执行并且立刻对所有线程可见</p><p>但是在JMM中， 是无法保证未同步的程序中，所有线程看见的执行顺序是一致的，而且也没法保证实时可见性， 因为这种特性会大大约束编译器和处理器的优化手段，JMM通过锁或者是一些同步原语来保证多线程环境下的执行结果； 并且在临界区内的指令，也是可能会被重排的， 这会很大提高程序的执行速度。</p><p>volatile的特性可以近似的看成通过锁操作对单个变量的读写操作做了同步， 对于单个变量的读写操作， volatile是可以确保原子性的， 注意，这里的原子性指的单个变量 ，比如在32位的设备中， 对于64位的long变量的写入， jmm会将其拆分为两个32位的写操作 ，也就是高低32位会被分开写入，这可能会导致字节撕裂现象，（jdk1.5之后， 对于这种64位的变量的读已经强制要求原子性，也就是读操作必须在单个总线事务中执行，已经很好的解决了字节撕裂的问题， 但是写操作依旧是可以拆分的） 而volatile可以确保这类操作的原子性， 但在多个变量之间或者是复合操作，volatile是无法保证原子性的， 比如a++，其实是三条指令， 分别是读取a，a+1 ， 写回a ； volatile是无法保证这三个操作是原子的。</p><p>根据happens-before原则， 一个volatile变量的写操作的结果可以被后续的volatile读操作看到，编译器会在编译中对volatile变量的写操作之后加上写内存屏障和在读操作之前加上读内存屏障，（看具体的策略， 最保守的策略会在读写操作的前后都加上屏障， 编译器会根据实际情况来优化， 在确保正确性的前提下提升执行效率） 写屏障会强制把写操作的结果刷入主存， 读屏障则会强制将主存中数据更新到本地内存， 确保了变量的可见性。 另外读屏障也可以确保读指令不被重排序到写操作之前， 写屏障也可以确保写指令不被重排序到读操作之前</p><p>如果你不需要确保整个临界区代码的原子性， 完全可以使用volatile来代替锁，更加轻量化，性能更好（没有上下文切换开销）</p><p>锁释放与volatile写有相同的内存语义（将数据刷入主存）， 锁获取与volatile读有相同的内存语义（从主存中读取数据更新本地内存）</p><p>JMM向程序员提供的happens-before规则来规范程序的内存可见性， 实际上JMM将happens-before要求禁止的重排序分为了两种，一种是会改变程序执行结果的重排序， 另一种是不会改变程序执行结果的重排序， 对于后一种重排序， JMM实际是允许的， 换句话说， happens-before的规则，和实际jmm执行的规则， 是有出入的</p><p>JMM遵循一个基本原则， 只要不改变程序的执行结果， 编译器和处理器怎么优化都行， 举个例子， 如果一个锁只会被单个线程访问，那么编译器会将这个锁消除掉， 称之为锁消除； 再比如， 如果一个volatile变量只会被单线程访问， 那么编译器就会把它当做一个普通变量来对待。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq延时队列实践</title>
      <link href="/2021/08/29/rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/08/29/rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>在许多业务场景中，任务的执行需要与时间紧密关联。例如，在电商领域，订单在生成后的一段时间内未支付则需要自动取消，以释放库存并管理订单状态；新店铺创建后若长时间未上传商品，需及时提醒商家以促进平台活跃度；企业财务系统中，账单在规定期限内未支付则要进行自动结算，确保财务流程的顺畅。这些场景的共同点是都涉及到在特定时间点或时间段后触发相应的操作，对时间的准确性和任务的可靠性要求极高。</p><p>传统的解决方案如定时任务，通过定期轮询数据库来检查任务是否满足执行条件。然而，在数据量较小且对时间精度要求不高的情况下，这种方式或许可行。但当面对大规模数据和高时效性要求时，定时任务的弊端就凸显出来。它需要频繁地查询数据库，这不仅会给数据库带来巨大的压力，影响系统的整体性能，还可能由于查询间隔的限制导致任务执行的延迟，无法满足业务对实时性的严格要求。例如，在电商大促期间，订单量可能瞬间暴增到数百万甚至上千万，如果使用定时任务来检查未支付订单，可能在一秒内无法完成所有订单的检查，导致部分订单未能及时关闭，影响库存管理和用户体验。</p><p>在这样的背景下，消息队列技术应运而生，为解决这类复杂的消息处理需求提供了新的思路和方法。RabbitMQ 作为一款功能强大的消息队列中间件，以其出色的可靠性、灵活性和扩展性，在众多企业的消息处理架构中占据重要地位。它能够实现消息的异步传输，解耦系统组件，提高系统的可伸缩性和响应能力。而延时队列作为 RabbitMQ 的一种特殊应用场景，能够精准地控制消息的延迟处理时间，为上述各种业务场景提供了更为高效、可靠的解决方案，成为企业构建复杂业务逻辑和优化系统性能的关键技术之一。</p><span id="more"></span><h3 id="一、本文大纲"><a href="#一、本文大纲" class="headerlink" title="一、本文大纲"></a>一、本文大纲</h3><p>以下是本文大纲：</p><p><a href="https://i.loli.net/2019/07/28/5d3d74d99699d43032.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047092.png" alt="1.png"></a></p><p>本文阅读前，需要对RabbitMQ以及死信队列有一个简单的了解。</p><h3 id="二、什么是延时队列"><a href="#二、什么是延时队列" class="headerlink" title="二、什么是延时队列"></a>二、什么是延时队列</h3><p><code>延时队列</code>，首先，它是一种队列，队列意味着内部的元素是<code>有序</code>的，元素出队和入队是有方向性的，元素从一端进入，从另一端取出。</p><p>其次，<code>延时队列</code>，最重要的特性就体现在它的<code>延时</code>属性上，跟普通的队列不一样的是，<code>普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理</code>，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。</p><p>简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p><h3 id="三、延时队列使用场景"><a href="#三、延时队列使用场景" class="headerlink" title="三、延时队列使用场景"></a>三、延时队列使用场景</h3><p>那么什么时候需要用延时队列呢？考虑一下以下场景：</p><ol><li>订单在十分钟之内未支付则自动取消。</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>账单在一周内未支付，则自动结算。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。</li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；发生店铺创建事件，十天后检查该店铺上新商品数，然后通知上新数为0的商户；发生账单生成事件，检查账单支付状态，然后自动结算未支付的账单；发生新用户注册事件，三天后检查新注册用户的活动数据，然后通知没有任何活动记录的用户；发生退款事件，在三天之后检查该订单是否已被处理，如仍未被处理，则发送消息给相关运营人员；发生预定会议事件，判断离会议开始是否只有十分钟了，如果是，则通知各个与会人员。</p><p>看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><p>更重要的一点是，不！优！雅！</p><p>没错，作为一名有追求的程序员，始终应该追求更优雅的架构和更优雅的代码风格，写代码要像写诗一样优美。【滑稽】</p><p>这时候，延时队列就可以闪亮登场了，以上场景，正是延时队列的用武之地。</p><p>既然<code>延时队列</code>可以解决很多特定场景下，带时间属性的任务需求，那么如何构造一个延时队列呢？接下来，本文将介绍如何用RabbitMQ来实现延时队列。</p><h3 id="四、RabbitMQ中的TTL"><a href="#四、RabbitMQ中的TTL" class="headerlink" title="四、RabbitMQ中的TTL"></a>四、RabbitMQ中的TTL</h3><p>在介绍延时队列之前，还需要先介绍一下RabbitMQ中的一个高级特性——<code>TTL（Time To Live）</code>。</p><p><code>TTL</code>是什么呢？<code>TTL</code>是RabbitMQ中一个消息或者队列的属性，表明<code>一条消息或者该队列中的所有消息的最大存活时间</code>，单位是毫秒。换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为“死信”（至于什么是死信，请翻看上一篇）。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。</p><p>那么，如何设置这个TTL值呢？有两种方式，第一种是在创建队列的时候设置队列的“x-message-ttl”属性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">6000</span>);</span><br><span class="line">channel.queueDeclare(queueName, durable, exclusive, autoDelete, args);</span><br></pre></td></tr></table></figure><p>这样所有被投递到该队列的消息都最多不会存活超过6s。</p><p>另一种方式便是针对每条消息设置TTL，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties.Builder();</span><br><span class="line">builder.expiration(<span class="string">&quot;6000&quot;</span>);</span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> builder.build();</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, properties, <span class="string">&quot;msg body&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><p>这样这条消息的过期时间也被设置成了6s。</p><p>但这两种方式是有区别的，<strong>如果设置了队列的TTL属性，那么一旦消息过期，就会被队列丢弃，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。</strong></p><p>另外，还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p><h3 id="五、如何利用RabbitMQ实现延时队列"><a href="#五、如何利用RabbitMQ实现延时队列" class="headerlink" title="五、如何利用RabbitMQ实现延时队列"></a>五、如何利用RabbitMQ实现延时队列</h3><p>前一篇里介绍了如果设置死信队列，前文中又介绍了TTL，至此，利用RabbitMQ实现延时队列的两大要素已经集齐，接下来只需要将它们进行调和，再加入一点点调味料，延时队列就可以新鲜出炉了。</p><p>想想看，<code>延时队列</code>，不就是想要消息延迟多久被处理吗，TTL则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就万事大吉了，因为里面的消息都是希望被立即处理的消息。</p><p>从下图可以大致看出消息的流向：</p><p><a href="https://i.loli.net/2019/07/28/5d3d743143ecc85643.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047108.png" alt="23.png"></a></p><p>生产者生产一条延时消息，根据需要延时时间的不同，利用不同的routingkey将消息路由到不同的延时队列，每个队列都设置了不同的TTL属性，并绑定在同一个死信交换机中，消息过期后，根据routingkey的不同，又会被路由到不同的死信队列中，消费者只需要监听对应的死信队列进行处理即可。</p><p>下面来看代码：</p><p>先声明交换机、队列以及他们的绑定关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.business.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_QUEUEA_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.business.queuea&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_QUEUEB_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.business.queueb&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_QUEUEA_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.business.queuea.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_QUEUEB_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.business.queueb.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.deadletter.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUEA_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.deadletter.delay_10s.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUEB_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.deadletter.delay_60s.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUEA_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.deadletter.queuea&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUEB_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.deadletter.queueb&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;delayExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(DELAY_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">deadLetterExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时队列A 延时10s</span></span><br><span class="line">    <span class="comment">// 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;delayQueueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayQueueA</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">        <span class="comment">// x-message-ttl  声明队列的TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">6000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DELAY_QUEUEA_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时队列B 延时 60s</span></span><br><span class="line">    <span class="comment">// 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;delayQueueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayQueueB</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">        <span class="comment">// x-message-ttl  声明队列的TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">60000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DELAY_QUEUEB_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列A 用于接收延时10s处理的消息</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterQueueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deadLetterQueueA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUEA_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列B 用于接收延时60s处理的消息</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterQueueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deadLetterQueueB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUEB_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时队列A绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayBindingA</span><span class="params">(<span class="meta">@Qualifier(&quot;delayQueueA&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@Qualifier(&quot;delayExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEA_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列B绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayBindingB</span><span class="params">(<span class="meta">@Qualifier(&quot;delayQueueB&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@Qualifier(&quot;delayExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEB_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列A绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingA</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueueA&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列B绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingB</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueueB&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                      <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，创建两个消费者，分别对两个死信队列的消息进行消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveA</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,死信队列A收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveB</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,死信队列B收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是消息的生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayMessageSender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg, DelayTypeEnum type)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> DELAY_10s:</span><br><span class="line">                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEA_ROUTING_KEY, msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DELAY_60s:</span><br><span class="line">                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEB_ROUTING_KEY, msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们暴露一个web接口来生产消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;rabbitmq&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQMsgController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DelayMessageSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;sendmsg&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg, Integer delayType)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到请求，msg:&#123;&#125;,delayType:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), msg, delayType);</span><br><span class="line">        sender.sendMsg(msg, Objects.requireNonNull(DelayTypeEnum.getDelayTypeEnumByValue(delayType)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备就绪，启动！</p><p>打开rabbitMQ的<a href="http://localhost:15672/">管理后台</a>，可以看到我们刚才创建的交换机和队列信息：</p><p><a href="https://i.loli.net/2019/07/28/5d3d54e15534398514.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047837.png" alt="2.png"></a></p><p><a href="https://i.loli.net/2019/07/28/5d3d54e17df8183993.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047418.png" alt="4.png"></a></p><p><a href="https://i.loli.net/2019/07/28/5d3d54e16952546955.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047065.png" alt="3.png"></a></p><p>接下来，我们来发送几条消息</p><p><a href="http://localhost:8080/rabbitmq/sendmsg?msg=testMsg1&delayType=1">http://localhost:8080/rabbitmq/sendmsg?msg=testMsg1&amp;delayType=1</a></p><p> <a href="http://localhost:8080/rabbitmq/sendmsg?msg=testMsg2&delayType=2">http://localhost:8080/rabbitmq/sendmsg?msg=testMsg2&amp;delayType=2</a></p><p>日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 16:02:19.813  INFO 3860 --- [nio-8080-exec-9] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:02:19 CST 2019,收到请求，msg:testMsg1,delayType:1</span><br><span class="line">2019-07-28 16:02:19.815  INFO 3860 --- [nio-8080-exec-9] .l.DirectReplyToMessageListenerContainer : SimpleConsumer [queue=amq.rabbitmq.reply-to, consumerTag=amq.ctag-o-qPpkWIkRm73DIrOIVhig identity=766339] started</span><br><span class="line">2019-07-28 16:02:25.829  INFO 3860 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:02:25 CST 2019,死信队列A收到消息：testMsg1</span><br><span class="line">2019-07-28 16:02:41.326  INFO 3860 --- [nio-8080-exec-1] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:02:41 CST 2019,收到请求，msg:testMsg2,delayType:2</span><br><span class="line">2019-07-28 16:03:41.329  INFO 3860 --- [ntContainer#0-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:03:41 CST 2019,死信队列B收到消息：testMsg2</span><br></pre></td></tr></table></figure><p>第一条消息在6s后变成了死信消息，然后被消费者消费掉，第二条消息在60s之后变成了死信消息，然后被消费掉，这样，一个还算ok的延时队列就打造完成了。</p><p>不过，等等，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有6s和60s两个时间选项，如果需要一个小时后处理，那么就需要增加TTL为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？？</p><p>嗯，仔细想想，事情并不简单。</p><h3 id="六、RabbitMQ延时队列优化"><a href="#六、RabbitMQ延时队列优化" class="headerlink" title="六、RabbitMQ延时队列优化"></a>六、RabbitMQ延时队列优化</h3><p>显然，需要一种更通用的方案才能满足需求，那么就只能将TTL设置在消息属性里了。我们来试一试。</p><p>增加一个延时队列，用于接收设置为任意延时时长的消息，增加一个相应的死信队列和routingkey：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.business.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_QUEUEC_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.business.queuec&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_QUEUEC_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.business.queuec.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.deadletter.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUEC_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.deadletter.delay_anytime.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUEC_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.deadletter.queuec&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;delayExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(DELAY_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">deadLetterExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时队列C 不设置TTL</span></span><br><span class="line">    <span class="comment">// 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;delayQueueC&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayQueueC</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEC_ROUTING_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DELAY_QUEUEC_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列C 用于接收延时任意时长处理的消息</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterQueueC&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deadLetterQueueC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUEC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时列C绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayBindingC</span><span class="params">(<span class="meta">@Qualifier(&quot;delayQueueC&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Qualifier(&quot;delayExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEC_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列C绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingC</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueueC&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                      <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEC_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加一个死信队列C的消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = DEAD_LETTER_QUEUEC_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveC</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,死信队列C收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次启动！然后访问：<a href="http://localhost:8080/rabbitmq/delayMsg?msg=testMsg1delayTime=5000">http://localhost:8080/rabbitmq/delayMsg?msg=testMsg1delayTime=5000</a> 来生产消息，注意这里的单位是毫秒。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 16:45:07.033  INFO 31468 --- [nio-8080-exec-4] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:45:07 CST 2019,收到请求，msg:testMsg1,delayTime:5000</span><br><span class="line">2019-07-28 16:45:11.694  INFO 31468 --- [nio-8080-exec-5] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:45:11 CST 2019,收到请求，msg:testMsg2,delayTime:5000</span><br><span class="line">2019-07-28 16:45:12.048  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:45:12 CST 2019,死信队列C收到消息：testMsg1</span><br><span class="line">2019-07-28 16:45:16.709  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:45:16 CST 2019,死信队列C收到消息：testMsg2</span><br></pre></td></tr></table></figure><p>看起来似乎没什么问题，但不要高兴的太早，在最开始的时候，就介绍过，如果使用在消息属性上设置TTL的方式，消息可能并不会按时“死亡“，因为RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列，索引如果第一个消息的延时时长很长，而第二个消息的延时时长很短，则第二个消息并不会优先得到执行。</p><p>实验一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 16:49:02.957  INFO 31468 --- [nio-8080-exec-8] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:49:02 CST 2019,收到请求，msg:longDelayedMsg,delayTime:20000</span><br><span class="line">2019-07-28 16:49:10.671  INFO 31468 --- [nio-8080-exec-9] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:49:10 CST 2019,收到请求，msg:shortDelayedMsg,delayTime:2000</span><br><span class="line">2019-07-28 16:49:22.969  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:49:22 CST 2019,死信队列C收到消息：longDelayedMsg</span><br><span class="line">2019-07-28 16:49:22.970  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:49:22 CST 2019,死信队列C收到消息：shortDelayedMsg</span><br></pre></td></tr></table></figure><p>我们先发了一个延时时长为20s的消息，然后发了一个延时时长为2s的消息，结果显示，第二个消息会在等第一个消息成为死信后才会“死亡“。</p><h3 id="七、利用RabbitMQ插件实现延迟队列"><a href="#七、利用RabbitMQ插件实现延迟队列" class="headerlink" title="七、利用RabbitMQ插件实现延迟队列"></a>七、利用RabbitMQ插件实现延迟队列</h3><p>上文中提到的问题，确实是一个硬伤，如果不能实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡，就无法设计成一个通用的延时队列。</p><p>那如何解决这个问题呢？不要慌，安装一个插件即可：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> ，下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。</p><p>接下来，进入RabbitMQ的安装目录下的sbin目录，执行下面命令让该插件生效，然后重启RabbitMQ。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>然后，我们再声明几个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedRabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.delay.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.delay.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay.queue.demo.delay.routingkey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">immediateQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">customExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNotify</span><span class="params">(<span class="meta">@Qualifier(&quot;immediateQueue&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Qualifier(&quot;customExchange&quot;)</span> CustomExchange customExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller层再添加一个入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;delayMsg2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delayMsg2</span><span class="params">(String msg, Integer delayTime)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到请求，msg:&#123;&#125;,delayTime:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), msg, delayTime);</span><br><span class="line">    sender.sendDelayMsg(msg, delayTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息生产者的代码也需要修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMsg</span><span class="params">(String msg, Integer delayTime)</span> &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, a -&gt;&#123;</span><br><span class="line">        a.getMessageProperties().setDelay(delayTime);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，再创建一个消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,延时队列收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切准备就绪，启动！然后分别访问以下链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/rabbitmq/delayMsg2?msg=msg1&amp;delayTime=20000</span><br><span class="line">http://localhost:8080/rabbitmq/delayMsg2?msg=msg2&amp;delayTime=2000</span><br></pre></td></tr></table></figure><p>日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 17:28:13.729  INFO 25804 --- [nio-8080-exec-2] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 17:28:13 CST 2019,收到请求，msg:msg1,delayTime:20000</span><br><span class="line">2019-07-28 17:28:20.607  INFO 25804 --- [nio-8080-exec-1] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 17:28:20 CST 2019,收到请求，msg:msg2,delayTime:2000</span><br><span class="line">2019-07-28 17:28:22.624  INFO 25804 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 17:28:22 CST 2019,延时队列收到消息：msg2</span><br><span class="line">2019-07-28 17:28:33.751  INFO 25804 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 17:28:33 CST 2019,延时队列收到消息：msg1</span><br></pre></td></tr></table></figure><p>第二个消息被先消费掉了，符合预期。至此，RabbitMQ实现延时队列的部分就完结了。</p><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>延时队列在需要延时处理的场景下非常有用，使用RabbitMQ来实现延时队列可以很好的利用RabbitMQ的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过RabbitMQ集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用Java的DelayQueu，利用Redis的zset，利用Quartz或者利用kafka的时间轮，这些方式各有特点，但就像炉石传说一般，这些知识就好比手里的卡牌，知道的越多，可以用的卡牌也就越多，遇到问题便能游刃有余，所以需要大量的知识储备和经验积累才能打造出更出色的卡牌组合，让自己解决问题的能力得到更好的提升。</p><p>但另一方面，随着时间的流逝和阅历的增长，越来越感觉到自己的能力有限，无法独自面对纷繁复杂且多变的业务需求，在很多方面需要其他人的协助才能很好的完成任务。也知道闻道有先后，术业有专攻，不会再狂妄自大，觉得自己能把所有事情都搞定，也将重心慢慢转移到研究如何有效的进行团队合作上来，我相信一个高度协调的团队永远比一个人战斗要更有价值。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq死信队列实践</title>
      <link href="/2021/08/28/rabbitmq%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/08/28/rabbitmq%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>RabbitMQ是流行的开源消息队列系统，使用erlang语言开发，由于其社区活跃度高，维护更新较快，性能稳定，深得很多企业的欢心。</p><p>为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。但由于对死信队列的概念及配置不熟悉，导致曾一度陷入百度的汪洋大海，无法自拔，很多文章都看起来可行，但是实际上却并不能帮我解决实际问题。最终，在官网文档中找到了我想要的答案，通过官网文档的学习，才发现对于死信队列存在一些误解，导致配置死信队列之路困难重重。</p><p>于是本着记录和分享的精神，将死信队列的概念和配置完整的写下来，以便帮助遇到同样问题的朋友。</p><span id="more"></span><h3 id="一、本文大纲"><a href="#一、本文大纲" class="headerlink" title="一、本文大纲"></a>一、本文大纲</h3><p>以下是本文大纲：</p><p><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140349282-672707323.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250041944.png" alt="img"></a></p><p>本文阅读前，需要对RabbitMQ有一个简单的了解，偏向实战配置讲解。</p><h3 id="二、死信队列是什么"><a href="#二、死信队列是什么" class="headerlink" title="二、死信队列是什么"></a>二、死信队列是什么</h3><p>死信，在官网中对应的单词为“Dead Letter”，可以看出翻译确实非常的简单粗暴。那么死信是个什么东西呢？</p><p>“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：</p><ol><li>消息被否定确认，使用 <code>channel.basicNack</code> 或 <code>channel.basicReject</code> ，并且此时<code>requeue</code> 属性被设置为<code>false</code>。</li><li>消息在队列的存活时间超过设置的TTL时间。</li><li>消息队列的消息数量已经超过最大队列长度。</li></ol><p>那么该消息将成为“死信”。</p><p>“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。</p><h3 id="三、如何配置死信队列"><a href="#三、如何配置死信队列" class="headerlink" title="三、如何配置死信队列"></a>三、如何配置死信队列</h3><p>这一部分将是本文的关键，如何配置死信队列呢？其实很简单，大概可以分为以下步骤：</p><ol><li>配置业务队列，绑定到业务交换机上</li><li>为业务队列配置死信交换机和路由key</li><li>为死信交换机配置死信队列</li></ol><p>注意，并不是直接声明一个公共的死信队列，然后所以死信消息就自己跑到死信队列里去了。而是为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然后为每个业务队列分配一个单独的路由key。</p><p>有了死信交换机和路由key后，接下来，就像配置业务队列一样，配置死信队列，然后绑定在死信交换机上。也就是说，死信队列并不是什么特殊的队列，只不过是绑定在死信交换机上的队列。死信交换机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、Fanout、Topic】。一般来说，会为每个业务队列分配一个独有的路由key，并对应的配置一个死信队列进行监听，也就是说，一般会为每个重要的业务队列配置一个死信队列。</p><p>有了前文这些陈述后，接下来就是惊险刺激的实战环节，这里省略了RabbitMQ环境的部署和搭建环节。</p><p>先创建一个Springboot项目。然后在pom文件中添加 <code>spring-boot-starter-amqp</code> 和 <code>spring-boot-starter-web</code> 的依赖，接下来创建一个Config类，这里是关键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUSINESS_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;dead.letter.demo.simple.business.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUSINESS_QUEUEA_NAME</span> <span class="operator">=</span> <span class="string">&quot;dead.letter.demo.simple.business.queuea&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUSINESS_QUEUEB_NAME</span> <span class="operator">=</span> <span class="string">&quot;dead.letter.demo.simple.business.queueb&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead.letter.demo.simple.deadletter.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUEA_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;dead.letter.demo.simple.deadletter.queuea.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUEB_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;dead.letter.demo.simple.deadletter.queueb.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUEA_NAME</span> <span class="operator">=</span> <span class="string">&quot;dead.letter.demo.simple.deadletter.queuea&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUEB_NAME</span> <span class="operator">=</span> <span class="string">&quot;dead.letter.demo.simple.deadletter.queueb&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;businessExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">businessExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BUSINESS_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">deadLetterExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列A</span></span><br><span class="line">    <span class="meta">@Bean(&quot;businessQueueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">businessQueueA</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//       x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BUSINESS_QUEUEA_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列B</span></span><br><span class="line">    <span class="meta">@Bean(&quot;businessQueueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">businessQueueB</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//       x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BUSINESS_QUEUEB_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列A</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterQueueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deadLetterQueueA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUEA_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列B</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterQueueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deadLetterQueueB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUEB_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列A绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">businessBindingA</span><span class="params">(<span class="meta">@Qualifier(&quot;businessQueueA&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@Qualifier(&quot;businessExchange&quot;)</span> FanoutExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列B绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">businessBindingB</span><span class="params">(<span class="meta">@Qualifier(&quot;businessQueueB&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@Qualifier(&quot;businessExchange&quot;)</span> FanoutExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列A绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingA</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueueA&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列B绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingB</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueueB&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                      <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里声明了两个Exchange，一个是业务Exchange，另一个是死信Exchange，业务Exchange下绑定了两个业务队列，业务队列都配置了同一个死信Exchange，并分别配置了路由key，在死信Exchange下绑定了两个死信队列，设置的路由key分别为业务队列里配置的路由key。</p><p>下面是配置文件application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">simple</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">          <span class="attr">default-requeue-rejected:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p>这里记得将<code>default-requeue-rejected</code>属性设置为false。</p><p>接下来，是业务队列的消费代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessMessageReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = BUSINESS_QUEUEA_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveA</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;收到业务消息A：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ack</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.contains(<span class="string">&quot;deadletter&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;dead letter exception&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            ack = <span class="literal">false</span>;</span><br><span class="line">            exception = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ack)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息消费发生异常，error msg:&#123;&#125;&quot;</span>, exception.getMessage(), exception);</span><br><span class="line">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = BUSINESS_QUEUEB_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveB</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到业务消息B：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后配置死信队列的消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterMessageReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveA</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到死信消息A：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveB</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到死信消息B：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，为了方便测试，写一个简单的消息生产者，并通过controller层来生产消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessMessageSender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        rabbitTemplate.convertSendAndReceive(BUSINESS_EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;rabbitmq&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQMsgController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BusinessMessageSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;sendmsg&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        sender.sendMsg(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切准备就绪，启动！</p><p>可以从RabbitMQ的管理后台中看到一共有四个队列，除默认的Exchange外还有声明的两个Exchange。</p><p><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140506771-319482381.jpg"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250041954.jpg" alt="img"></a><br><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140536938-1122765461.jpg"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250041939.jpg" alt="img"></a></p><p>接下来，访问一下url，来测试一下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/rabbitmq/sendmsg?msg=msg</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">收到业务消息A：msg</span><br><span class="line">收到业务消息B：msg</span><br></pre></td></tr></table></figure><p>表示两个Consumer都正常收到了消息。这代表正常消费的消息，ack后正常返回。然后我们再来测试nck的消息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/rabbitmq/sendmsg?msg=deadletter</span><br></pre></td></tr></table></figure><p>这将会触发业务队列A的NCK，按照预期，消息被NCK后，会抛到死信队列中，因此死信队列将会出现这个消息，日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">收到业务消息A：deadletter</span><br><span class="line">消息消费发生异常，error msg:dead letter exception</span><br><span class="line">java.lang.RuntimeException: dead letter exception</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">收到死信消息A：deadletter</span><br></pre></td></tr></table></figure><p>可以看到，死信队列的Consumer接受到了这个消息，所以流程到此为止就打通了。</p><h3 id="四、死信消息的变化"><a href="#四、死信消息的变化" class="headerlink" title="四、死信消息的变化"></a>四、死信消息的变化</h3><p>那么“死信”被丢到死信队列中后，会发生什么变化呢？</p><p>如果队列配置了参数 <code>x-dead-letter-routing-key</code> 的话，“死信”的路由key将会被替换成该参数对应的值。如果没有设置，则保留该消息原有的路由key。</p><p>举个栗子：</p><p>如果原有消息的路由key是<code>testA</code>，被发送到业务Exchage中，然后被投递到业务队列QueueA中，如果该队列没有配置参数<code>x-dead-letter-routing-key</code>，则该消息成为死信后，将保留原有的路由key<code>testA</code>，如果配置了该参数，并且值设置为<code>testB</code>，那么该消息成为死信后，路由key将会被替换为<code>testB</code>，然后被抛到死信交换机中。</p><p>另外，由于被抛到了死信交换机，所以消息的Exchange Name也会被替换为死信交换机的名称。</p><p>消息的Header中，也会添加很多奇奇怪怪的字段，修改一下上面的代码，在死信队列的消费者中添加一行日志输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;死信消息properties：&#123;&#125;&quot;, message.getMessageProperties());</span><br></pre></td></tr></table></figure><p>然后重新运行一次，即可得到死信消息Header中被添加的信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">死信消息properties：MessageProperties</span> <span class="string">[headers=&#123;x-first-death-exchange=dead.letter.demo.simple.business.exchange, x-death=[&#123;reason=rejected, count=1, exchange=dead.letter.demo.simple.business.exchange, time=Sun Jul 14 16:48:16 CST 2019, routing-keys=[], queue=dead.letter.demo.simple.business.queuea&#125;], x-first-death-reason=rejected, x-first-death-queue=dead.letter.demo.simple.business.queuea&#125;, correlationId=1, replyTo=amq.rabbitmq.reply-to.g2dkABZyYWJiaXRAREVTS1RPUC1DUlZGUzBOAAAPQAAAAAAB.bLbsdR1DnuRSwiKKmtdOGw==, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=dead.letter.demo.simple.deadletter.exchange, receivedRoutingKey=dead.letter.demo.simple.deadletter.queuea.routingkey, deliveryTag=1, consumerTag=amq.ctag-NSp18SUPoCNvQcoYoS2lPg, consumerQueue=dead.letter.demo.simple.deadletter.queuea]</span></span><br></pre></td></tr></table></figure><p>Header中看起来有很多信息，实际上并不多，只是值比较长而已。下面就简单说明一下Header中的值：</p><table><thead><tr><th align="left">字段名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">x-first-death-exchange</td><td align="left">第一次被抛入的死信交换机的名称</td></tr><tr><td align="left">x-first-death-reason</td><td align="left">第一次成为死信的原因，<code>rejected</code>：消息在重新进入队列时被队列拒绝，由于<code>default-requeue-rejected</code> 参数被设置为<code>false</code>。<code>expired</code> ：消息过期。<code>maxlen</code> ： 队列内消息数量超过队列最大容量</td></tr><tr><td align="left">x-first-death-queue</td><td align="left">第一次成为死信前所在队列名称</td></tr><tr><td align="left">x-death</td><td align="left">历次被投入死信交换机的信息列表，同一个消息每次进入一个死信交换机，这个数组的信息就会被更新</td></tr></tbody></table><h3 id="五、死信队列应用场景"><a href="#五、死信队列应用场景" class="headerlink" title="五、死信队列应用场景"></a>五、死信队列应用场景</h3><p>通过上面的信息，我们已经知道如何使用死信队列了，那么死信队列一般在什么场景下使用呢？</p><p>一般用在较为重要的业务队列中，确保未被正确消费的消息不被丢弃，一般发生消费异常可能原因主要有由于消息信息本身存在错误导致处理异常，处理过程中参数校验异常，或者因网络波动导致的查询异常等等，当发生异常时，当然不能每次通过日志来获取原消息，然后让运维帮忙重新投递消息（没错，以前就是这么干的&#x3D; &#x3D;）。通过配置死信队列，可以让未正确处理的消息暂存到另一个队列中，待后续排查清楚问题后，编写相应的处理代码来处理死信消息，这样比手工恢复数据要好太多了。</p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>死信队列其实并没有什么神秘的地方，不过是绑定在死信交换机上的普通队列，而死信交换机也只是一个普通的交换机，不过是用来专门处理死信的交换机。</p><p>总结一下死信消息的生命周期：</p><ol><li>业务消息被投入业务队列</li><li>消费者消费业务队列的消息，由于处理过程中发生异常，于是进行了nck或者reject操作</li><li>被nck或reject的消息由RabbitMQ投递到死信交换机中</li><li>死信交换机将消息投入相应的死信队列</li><li>死信队列的消费者消费死信消息</li></ol><p>死信消息是RabbitMQ为我们做的一层保证，其实我们也可以不使用死信队列，而是在消息消费异常时，将消息主动投递到另一个交换机中，当你明白了这些之后，这些Exchange和Queue想怎样配合就能怎么配合。比如从死信队列拉取消息，然后发送邮件、短信、钉钉通知来通知开发人员关注。或者将消息重新投递到一个队列然后设置过期时间，来进行延时消费.</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载:Java垃圾回收机制-对象管理与内存优化</title>
      <link href="/2020/11/22/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
      <url>/2020/11/22/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><span id="more"></span><h2 id="1-揭开-JVM-内存分配与回收的神秘面纱"><a href="#1-揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="1.揭开 JVM 内存分配与回收的神秘面纱"></a>1.揭开 JVM 内存分配与回收的神秘面纱</h2><p><strong>堆空间的基本结构：</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157744.png"></p><p>上图所示的 Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"> <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line"> uint age = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">   <span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">   total += sizes[age];</span><br><span class="line">     <span class="keyword">if</span> (total &gt; desired_survivor_size) &#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     age++;</span><br><span class="line">   &#125;</span><br><span class="line">   uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></blockquote><p>经过这次 GC 后，Eden 区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次 GC 前的“From”，新的”From”就是上次 GC 前的”To”。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202412151940936.png" alt="image-20241215194007796" style="zoom:50%;" /><h3 id="1-1-对象优先在-eden-区分配"><a href="#1-1-对象优先在-eden-区分配" class="headerlink" title="1.1 对象优先在 eden 区分配"></a>1.1 对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">byte</span>[] allocation1, allocation2;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//allocation2 = new byte[900*1024];</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方式运行：<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157760.png"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code><br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157707.png"></p><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157710.jpg"></p><p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">900</span>*<span class="number">1024</span>];</span><br></pre></td></tr></table></figure><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157052.jpg"></p><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation5 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="1.2 大对象直接进入老年代"></a>1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="1-3-长期存活的对象将进入老年代"><a href="#1-3-长期存活的对象将进入老年代" class="headerlink" title="1.3 长期存活的对象将进入老年代"></a>1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="1-4-动态对象年龄判定"><a href="#1-4-动态对象年龄判定" class="headerlink" title="1.4 动态对象年龄判定"></a>1.4 动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a href="https://github.com/Snailclimb/JavaGuide/issues/1199">issue1199</a> ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p>jdk8官方文档引用 ：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a> 。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157058.png"></p><p><strong>动态年龄计算的代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">  <span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">  total += sizes[age];</span><br><span class="line">  <span class="keyword">if</span> (total &gt; desired_survivor_size) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  age++;</span><br><span class="line">&#125;</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672">issue672</a>)：<strong>关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。</strong><br>如果你去 Oracle 的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p></blockquote><h3 id="1-5-主要进行-gc-的区域"><a href="#1-5-主要进行-gc-的区域" class="headerlink" title="1.5 主要进行 gc 的区域"></a>1.5 主要进行 gc 的区域</h3><p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p><blockquote><p><del><em>“老年代 GC（Major GC&#x2F;Full GC），指发生在老年代的 GC……”</em></del></p></blockquote><p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157143.png"></p><p><strong>总结：</strong></p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h2 id="2-对象已经死亡？"><a href="#2-对象已经死亡？" class="headerlink" title="2 对象已经死亡？"></a>2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157156.png"></p><h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGc</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ReferenceCountingGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line"><span class="type">ReferenceCountingGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line">objA = <span class="literal">null</span>;</span><br><span class="line">objB = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157162.png" alt="可达性分析算法 "></p><p>可作为 GC Roots 的对象包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="2-4-不可达的对象并非“非死不可”"><a href="#2-4-不可达的对象并非“非死不可”" class="headerlink" title="2.4 不可达的对象并非“非死不可”"></a>2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="2-5-如何判断一个常量是废弃常量？"><a href="#2-5-如何判断一个常量是废弃常量？" class="headerlink" title="2.5 如何判断一个常量是废弃常量？"></a>2.5 如何判断一个常量是废弃常量？</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del></p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/747">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762">reference</a>）</strong> ：</p><ol><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol></blockquote><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="2-6-如何判断一个类是无用的类"><a href="#2-6-如何判断一个类是无用的类" class="headerlink" title="2.6 如何判断一个类是无用的类"></a>2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a>3 垃圾收集算法</h2><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157177.png" alt="垃圾收集算法分类"></p><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157224.jpeg"></p><h3 id="3-2-标记-复制算法"><a href="#3-2-标记-复制算法" class="headerlink" title="3.2 标记-复制算法"></a>3.2 标记-复制算法</h3><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157338.png" alt="复制算法"></p><h3 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157406.png" alt="标记-整理算法 "></p><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a>4 垃圾收集器</h2><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157414.png" alt="垃圾收集器分类"></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157675.png" alt=" Serial 收集器 "></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157809.png" alt="ParNew 收集器 "></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><p><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p></li></ul><h3 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157818.png" alt="Parallel Scavenge 收集器 "></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 java -XX:+PrintCommandLineFlags -version 命令查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version &quot;1.8.0_211&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></table></figure><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p><h3 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4.Serial Old 收集器"></a>4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="4-6-CMS-收集器"><a href="#4-6-CMS-收集器" class="headerlink" title="4.6 CMS 收集器"></a>4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157917.png" alt="CMS 垃圾收集器 "></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="4.7 G1 收集器"></a>4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="4-8-ZGC-收集器"><a href="#4-8-ZGC-收集器" class="headerlink" title="4.8 ZGC 收集器"></a>4.8 ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><p>详情可以看 ： <a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li><a href="https://my.oschina.net/hosee/blog/644618">https://my.oschina.net/hosee/blog/644618</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Redis实现的分布式锁的可用性探索2</title>
      <link href="/2020/10/06/%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%8E%A2%E7%B4%A22/"/>
      <url>/2020/10/06/%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%8E%A2%E7%B4%A22/</url>
      
        <content type="html"><![CDATA[<p>在上篇文章中，我们深入探讨了 Redis 分布式锁的基本概念，包括其在分布式系统中的重要性以及与传统 JVM 锁的区别，并初步了解了 Redis 如何通过其原子操作特性实现简单的分布式锁逻辑。然而，在实际应用场景中，仅仅依靠 Redis 的基本命令来实现分布式锁存在诸多问题。</p><p>自定义 Redis 分布式锁在实现过程中面临着一些关键操作无法保证原子性的困境。例如，加锁操作通常需要执行 SETNX（设置键值对，当键不存在时）和 EXPIRE（设置键的过期时间）两个步骤，如果在这两个步骤之间发生系统故障或异常，可能导致锁无法正确设置或永远不会过期，从而引发死锁情况，使系统陷入瘫痪。解锁操作同样存在风险，非原子性的解锁可能导致不同节点之间误删对方的锁，造成数据混乱和并发冲突加剧。</p><p>除了原子性问题，锁续期也是一个不容忽视的挑战。在分布式系统中，业务执行时间往往是不确定的，如果锁的持有时间过短，业务未完成时锁就已过期，可能导致其他节点获取锁并执行相同的业务逻辑，破坏数据一致性；反之，若锁持有时间过长，又会降低系统的并发性能，影响系统整体效率。因此，如何根据业务实际执行时间动态地为锁续期，成为确保分布式锁有效性和系统稳定性的关键因素之一。</p><p>为了应对这些复杂的问题，提高 Redis 分布式锁的可靠性和实用性，Redisson 应运而生。Redisson 是一个功能强大的 Java 驻内存数据网格（In-Memory Data Grid），它在 Redis 基础上提供了一系列分布式对象和服务，其中包括高度优化和可靠的分布式锁实现。Redisson 不仅解决了自定义 Redis 分布式锁的原子性问题，通过使用 Lua 脚本将复杂的操作封装为原子操作，确保加锁、解锁和锁续期等操作的完整性和一致性，还提供了诸如锁自动续期、可重入锁、公平锁等丰富的特性，大大简化了分布式锁的使用难度，提高了分布式系统的开发效率和可靠性。通过深入研究 Redisson 分布式锁的实现原理，我们可以更好地理解和应用分布式锁技术，为构建健壮的分布式系统提供有力支持。</p><span id="more"></span><h2 id="自定义Redis分布式锁的弊端"><a href="#自定义Redis分布式锁的弊端" class="headerlink" title="自定义Redis分布式锁的弊端"></a>自定义Redis分布式锁的弊端</h2><p>在上一篇我们自定义了一个Redis分布式锁，用来解决多节点定时任务的拉取问题（避免任务重复执行）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604497239038-11bf2996-86c7-4672-8c14-97003ad03379-20210923224039242.png" alt="img"></p><p>但仍然存在很多问题：</p><ul><li>加锁操作不是原子性的（setnx和expire两步操作不是原子性的，中间宕机会导致死锁）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String lockKey, String value, <span class="type">long</span> expireTime, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.先setnx</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(lockKey, value);</span><br><span class="line">    <span class="keyword">if</span> (lock != <span class="literal">null</span> &amp;&amp; lock) &#123;</span><br><span class="line">        <span class="comment">// 2.再expire</span></span><br><span class="line">        redisTemplate.expire(lockKey, expireTime, timeUnit);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605942078377-4709a4b0-b840-46af-8790-eec570ccc526-20210923224051964.png" alt="img"></p><p>当然啦，高版本的SpringBoot Redis依赖其实提供了加锁的原子性操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试上锁：setNX + expire</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockKey    锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value      对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expireTime 过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeUnit   时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String lockKey, String value, <span class="type">long</span> expireTime, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 可以设置4个参数，一步到位</span></span><br><span class="line">        redisTemplate.opsForValue().set(lockKey, value, expireTime, timeUnit);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 Redis 2.6.12 版本开始（现在6.x了…）， <a href="http://doc.redisfans.com/string/set.html#set">SET</a> 命令的行为可以通过一系列参数来修改，也因为 <a href="http://doc.redisfans.com/string/set.html#set">SET</a> 命令可以通过参数来实现和 <a href="http://doc.redisfans.com/string/setnx.html#setnx">SETNX</a> 、 <a href="http://doc.redisfans.com/string/setex.html#setex">SETEX</a> 和 <a href="http://doc.redisfans.com/string/psetex.html#psetex">PSETEX</a> 三个命令的效果，所以将来的 Redis 版本可能会废弃并最终移除 <a href="http://doc.redisfans.com/string/setnx.html#setnx">SETNX</a> 、 <a href="http://doc.redisfans.com/string/setex.html#setex">SETEX</a> 和 <a href="http://doc.redisfans.com/string/psetex.html#psetex">PSETEX</a> 这三个命令。</p><ul><li>解锁操作不是原子性的（可能造成不同节点之间互相删锁）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605944419389-2d72efb4-3f0d-4082-9836-27729be483ca-20210923224114637.png" alt="img"></p><p>虽然上一篇设计的unLock()不是原子操作，但可以避免不同节点之间互相删锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unLock</span><span class="params">(String lockKey, String value)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取锁的value，存的是MACHINE_ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">machineId</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(lockKey);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(machineId) &amp;&amp; machineId.equals(value)) &#123;</span><br><span class="line">        <span class="comment">// 2.只能删除当前节点设置的锁</span></span><br><span class="line">        redisTemplate.delete(lockKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>畏难情绪作祟，不想考虑锁续期的问题，企图采用队列的方式缩减定时任务执行时间，直接把任务丢到队列中。但实际上可能存在任务堆积，个别情况下会出现：上次已经拉取某个任务并丢到Redis队列中，但由于队列比较繁忙，该任务还未被执行，数据库状态也尚未更改为status&#x3D;1（已执行），结果下次又拉取一遍，重复执行（简单的解决策略是：虽然无法阻止入队，但是出队消费时可以判断where status&#x3D;0后执行）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606004955240-09b70762-48c9-48db-b5ce-594f57f8037d-20210923224127881.png" alt="img"></p><p>引入Redis Message Queue会让系统变得更加复杂，我之前就因为使用了上面的模型导致各种偶发性的BUG，非常不好排查。一般来说，定时任务应该设计得简单点：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605943038778-2e521c6d-d2eb-4bf8-bfee-85386d52683f-20210923224137688.png" alt="img"></p><p>也就是说，绕来绕去，想要设计一个较完备的Redis分布式锁，必须至少解决3个问题：</p><ul><li><p>加锁原子性（setnx和expire要保证原子性，否则会容易发生死锁）</p></li><li><p>解锁原子性（不能误删别人的锁）</p></li><li><p>需要考虑业务&#x2F;定时任务执行的时间，并为锁续期</p></li></ul><p>如果不考虑性能啥的，加解锁原子性都可以通过lua脚本实现（利用Redis单线程的特性）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605945261112-585bd28f-7670-4518-af85-8440d044153b-20210923224146607.png" alt="img"></p><p>一次执行一个脚本，要么成功要么失败，不会和其他指令交错执行。</p><p>最难的是如何根据实际业务的执行时间给锁续期！虽然我们已经通过判断MACHINE_ID避免了不同节点互相删除锁：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605945347715-e77ca098-bd7a-4dee-beda-1e325c6247fa-20210923224152657.png" alt="img"></p><p>但本质上我们需要的是：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606005458029-94f26b64-780d-4324-910c-f36f7dd7ccaf-20210923224200340.png" alt="img"></p><p>本文我们的主要目标就是实现锁续期！</p><p>好在Redisson已经实现了，所以目标又变成：了解Redisson的锁续期机制。</p><h2 id="Redisson案例"><a href="#Redisson案例" class="headerlink" title="Redisson案例"></a>Redisson案例</h2><h3 id="Redisson环境搭建"><a href="#Redisson环境搭建" class="headerlink" title="Redisson环境搭建"></a>Redisson环境搭建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: # 见小册开头《阿里云服务账号》</span><br><span class="line">    password: # 见小册开头《阿里云服务账号》</span><br><span class="line">    database: 1</span><br><span class="line">    </span><br><span class="line"># 调整控制台日志格式，稍微精简一些（非必要操作）</span><br><span class="line">logging:</span><br><span class="line">  pattern:</span><br><span class="line">    console: &quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %thread - %msg%n&quot;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--大家也可以单独引入Redisson依赖，然后通过@Configuration自己配置RedissonClient--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就可以在test包下测试了~</p><h3 id="lock-方法初探"><a href="#lock-方法初探" class="headerlink" title="lock()方法初探"></a>lock()方法初探</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RLockTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::testLockOne).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::testLockTwo).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLockOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;bravo1988_distributed_lock&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;testLockOne尝试加锁...&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.info(<span class="string">&quot;testLockOne加锁成功...&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;testLockOne业务开始...&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">            log.info(<span class="string">&quot;testLockOne业务结束...&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            log.info(<span class="string">&quot;testLockOne解锁成功...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLockTwo</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;bravo1988_distributed_lock&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;testLockTwo尝试加锁...&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.info(<span class="string">&quot;testLockTwo加锁成功...&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;testLockTwo业务开始...&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">            log.info(<span class="string">&quot;testLockTwo业务结束...&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            log.info(<span class="string">&quot;testLockTwo解锁成功...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><p>2020-11-21 14:24:33 - Thread-3 - testLockTwo尝试加锁…</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne尝试加锁…</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; testLockOne()执行过程中，testLockTwo()一直阻塞 &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne加锁成功…</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne业务开始…</p><p>2020-11-21 14:25:23 - Thread-2 - testLockOne业务结束…</p><p>2020-11-21 14:25:23 - Thread-2 - testLockOne解锁成功…</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; testLockOne()执行结束释放锁，testLockTwo()抢到锁 &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>2020-11-21 14:25:23 - Thread-3 - testLockTwo加锁成功…</p><p>2020-11-21 14:25:23 - Thread-3 - testLockTwo业务开始…</p><p>2020-11-21 14:26:13 - Thread-3 - testLockTwo业务结束…</p><p>2020-11-21 14:26:13 - Thread-3 - testLockTwo解锁成功…</p><p>通过上面的代码，我们有以下疑问：</p><ul><li><p>lock()方法是原子性的吗？</p></li><li><p>lock()有设置过期时间吗？是多少？</p></li><li><p>lock()实现锁续期了吗？</p></li><li><p>lock()方法怎么实现阻塞的？又怎么被唤醒？</p></li></ul><p>先忘了这些，跟着我们走一遍lock()源码就明白了。</p><h3 id="lock-源码解析"><a href="#lock-源码解析" class="headerlink" title="lock()源码解析"></a>lock()源码解析</h3><p>lock()加锁，去除异常的情况，无非加锁成功、加锁失败两种情况，我们先看加锁成功的情况。</p><h3 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h3><p>我们从这段最简单的代码入手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RLockTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLockSuccess</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;bravo1988_distributed_lock&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;准备加锁...&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        log.info(<span class="string">&quot;加锁成功...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家跟着我们先打几个断点（SpringBoot2.3.4）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952885069-f4e16307-9030-4a38-b154-30cd4f7f5a74-20210923224243500.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952773563-dca85b18-f11c-4511-8fdb-a737075fb5fd-20210923224252102.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952860890-484897da-0ee6-45ea-8179-ddf6f357316a-20210923224340729.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952928238-e1dc233d-d877-423f-8561-f121c821d5c8-20210923224347621.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952952657-d35ba600-5996-4a67-adee-0c39535f728c-20210923224354124.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952984223-bf8c4bda-866f-406f-b7f8-c369b6d9b1ea-20210923224359530.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605953023756-2fc503b2-44bb-47c9-baf6-a095fef000e1-20210923224410403.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605953051967-7f6f6fb5-cfba-46a5-80d1-e83f19efb80c-20210923224418693.png" alt="img"></p><p>注意啊，把截图中能看到的断点都打上。</p><p>OK，接着大家自己启动DEBUG，感受一下大致流程，然后看下面的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redisson.lock()</span></span><br><span class="line">Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock(-<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了方便辨认，我直接把传进来的参数写在参数列表上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> leaseTime=-<span class="number">1</span>, TimeUnit unit=<span class="literal">null</span>, <span class="type">boolean</span> interruptibly=<span class="literal">false</span>)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 尝试上锁。上锁成功返回null，上锁失败返回ttl</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime=-<span class="number">1</span>, unit=<span class="literal">null</span>, threadId=<span class="number">666</span>);</span><br><span class="line">    <span class="comment">// 上锁成功，方法结束，回到主线程执行业务啦（后台有个定时任务在给当前锁续期）</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上锁成功就不走下面的流程了，所以这里直接省略</span></span><br><span class="line">    <span class="comment">// 略：加锁失败后续流程...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试上锁。上锁成功返回null，上锁失败返回【当前已经存在的锁】的ttl，方便调用者判断多久之后能重新获取锁</span></span><br><span class="line"><span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime=-<span class="number">1</span>, <span class="type">long</span> leaseTime=-<span class="number">1</span>, TimeUnit unit=<span class="literal">null</span>, <span class="type">long</span> threadId=<span class="number">666</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 有两次调用：1.tryAcquireAsync()返回Future 2.从Future获取异步结果（异步结果就是ttl）</span></span><br><span class="line"><span class="comment">    * 重点是tryAcquireAsync()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> get(tryAcquireAsync(waitTime=-<span class="number">1</span>, leaseTime=-<span class="number">1</span>, unit=<span class="literal">null</span>, threadId=<span class="number">666</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取过期时间（非重点）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> &lt;V&gt; V <span class="title function_">get</span><span class="params">(RFuture&lt;V&gt; future)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.get(future);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点，加锁后返回RFuture，内部包含ttl。调用本方法可能加锁成功，也可能加锁失败，外界可以通过ttl判断</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime=-<span class="number">1</span>, <span class="type">long</span> leaseTime=-<span class="number">1</span>, TimeUnit unit=<span class="literal">null</span>, <span class="type">long</span> threadId=<span class="number">666</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock()默认leaseTime=-1，所以会跳过if</span></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行lua脚本，尝试加锁并返回RFuture。这个方法是异步的，其实是把任务提交给线程池</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(</span><br><span class="line">                                            waitTime=-<span class="number">1</span>,</span><br><span class="line">                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=<span class="number">30</span>秒,</span><br><span class="line">                                            TimeUnit.MILLISECONDS, </span><br><span class="line">                                            threadId=<span class="number">666</span>, </span><br><span class="line">                                            RedisCommands.EVAL_LONG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回调方法，异步线程与Redis交互得到结果后会回调BiConsumer#accept()</span></span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 发生异常时直接return</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明加锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 启动额外的线程，按照一定规则给当前锁续期</span></span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回RFuture，里面有ttlRemaining</span></span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行lua脚本尝试上锁</span></span><br><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime=-<span class="number">1</span>, <span class="type">long</span> leaseTime=<span class="number">30</span>*<span class="number">1000</span>, TimeUnit unit=毫秒, <span class="type">long</span> threadId=<span class="number">666</span>, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大家去看一下evalWriteAsync()的参数列表，看看每个参数都代表什么，就能理解KEYS[]和ARGV[]以及整个脚本什么意思了</span></span><br><span class="line"><span class="comment">     * 如果你仔细看lua脚本，就会明白：加锁成功时返回ttlRemaining=null，加锁失败时返回ttlRemaining=xxx（上一个锁还剩多少时间）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 另外，我们自定义的Redis分布式锁采用了IdUtil生成节点id，和getLockName(threadId)本质是一样的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">            Collections.singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向Redis服务器发送脚本并返回RFuture，大家可以近似看成：往线程池提交一个任务，然后将异步结果封装到CompletableFuture</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RFuture&lt;T&gt; <span class="title function_">evalWriteAsync</span><span class="params">(String key, Codec codec, RedisCommand&lt;T&gt; evalCommandType, String script, List&lt;Object&gt; keys, Object... params)</span> &#123;</span><br><span class="line">    <span class="type">CommandBatchService</span> <span class="variable">executorService</span> <span class="operator">=</span> createCommandBatchService();</span><br><span class="line">    RFuture&lt;T&gt; result = executorService.evalWriteAsync(key, codec, evalCommandType, script, keys, params);</span><br><span class="line">    <span class="keyword">if</span> (!(commandExecutor <span class="keyword">instanceof</span> CommandBatchService)) &#123;</span><br><span class="line">        executorService.executeAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605956150610-2ce6fbe0-577a-4ab1-9540-a1d176038d02-20210923224433312.png" alt="img"></p><p>整个流程比较简单，只有两个难点：</p><ul><li>lua脚本写了啥</li><li>ttlRemainingFuture.onComplete()有什么作用</li></ul><h3 id="lua脚本解读"><a href="#lua脚本解读" class="headerlink" title="lua脚本解读"></a>lua脚本解读</h3><p>大家可以通过evalWriteAsync()的参数列表推导出KEYS、ARGV分别是什么：</p><p>KEYS[] &#x3D;&gt; Collections.singletonList(getName())</p><p>ARGV[] &#x3D;&gt; internalLockLeaseTime, getLockName(threadId)</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果不存在锁：&quot;bravo1988_distributed_lock&quot;</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 使用hincrby设置锁：hincrby bravo1988_distributed_lock a1b2c3d4:666 1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">    <span class="comment">-- 设置过期时间。ARGV[1]==internalLockLeaseTime</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">    <span class="comment">-- 返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line">    <span class="keyword">end</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果当前节点已经设置&quot;bravo1988_distributed_lock&quot;（注意，传了ARGV[2]==节点id）</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span> </span><br><span class="line">    <span class="comment">-- 就COUNT++，可重入锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">    <span class="comment">-- 设置过期时间。ARGV[1]==internalLockLeaseTime</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="comment">-- 返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">end</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 已经存在锁，且不是当前节点设置的，就返回锁的过期时间ttl</span></span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>总的来说，Redisson设计的分布式锁是采用hash结构：</p><p><strong>LOCK_NAME</strong>（锁的KEY）+ <strong>CLIENT_ID</strong>（节点ID）+ <strong>COUNT</strong>（重入次数）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605957127624-694aaebe-2293-4641-83e8-8649823ec961-20210923224458173.png" alt="img"></p><h3 id="回调函数的作用"><a href="#回调函数的作用" class="headerlink" title="回调函数的作用"></a>回调函数的作用</h3><p>之前我们已经学过CompletableFuture的回调机制：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605406493819-8575b4ca-57e6-4afc-aba7-4840bee68138-20210923224505808.png" alt="img">RFuture#onComplete()和它很相似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 发生异常时直接return</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明加锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 启动额外的线程，按照一定规则给当前锁续期</span></span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>onComplete()应该也是把回调函数推到stack中，方便后面异步线程弹栈执行。</p><p>至此，我们已经解决了之前的两个问题：</p><ul><li>lua脚本是什么意思（见注释）</li><li>ttlRemainingFuture.onComplete()有什么作用（设置回调函数，等会儿会有线程调用）</li></ul><p>虽然在CompletableFuture中已经强调过，这里还是要提一下：<strong>被回调的不是onComplete(BiConsumer)，而是****BiConsumer#accept()。</strong>主线程在调用onComplete(BiConsumer)时把它作为参数传入，然后被推入栈中<strong>：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BiConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> (ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 发生异常时直接return</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明加锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 启动额外的线程，按照一定规则给当前锁续期</span></span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redisson异步回调机制"><a href="#Redisson异步回调机制" class="headerlink" title="Redisson异步回调机制"></a>Redisson异步回调机制</h3><p>现在已经确定了尝试加锁后会返回RFuture，并且我们可以通过RFuture做两件事：</p><ul><li>通过RFuture获取ttlRemaining，也就是上一个锁的过期时间，如果为null则本次加锁成功，否则加锁失败，需要等待</li><li>通过RFuture设置回调函数</li></ul><p>现在疑问是：</p><ul><li><p>异步线程是谁，哪来的？</p></li><li><p>onComplete()设置的回调函数是干嘛的？</p></li><li><p>回调时的参数(ttlRemaining, e)哪来的？</p></li></ul><p>1、3两个问题非常难，源码比较绕，这里就带大家感性地体验一下，有兴趣可以自己跟源码了解。清除刚才的全部断点，只留下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958482130-e4ac51fd-c7c6-4a1c-9b8d-bc9ce3fab6a6-20210923224532665.png" alt="img"></p><p>再次DEBUG，线程会先到达return ttlRemainingFuture，随后回调BiConsumer#accept()：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958677303-5991020a-4ff9-4399-a71c-cefd1824931c-20210923224542928.png" alt="img"></p><p>回调时线程变了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958821470-c3a87de8-f677-4990-8a52-a42e572696d0-20210923224550800.png" alt="img"></p><p>大家有兴趣可以自己顺着调用栈逆推回去，还是比较复杂的，涉及到NIO、Promise等，源头还是在线程池，但其中又设计了Listeners的收集和循环唤醒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; RFuture&lt;T&gt; <span class="title function_">evalWriteAsync</span><span class="params">(String key, Codec codec, RedisCommand&lt;T&gt; evalCommandType, String script, List&lt;Object&gt; keys, Object... params)</span> &#123;</span><br><span class="line">    <span class="type">CommandBatchService</span> <span class="variable">executorService</span> <span class="operator">=</span> createCommandBatchService();</span><br><span class="line">    RFuture&lt;T&gt; result = executorService.evalWriteAsync(key, codec, evalCommandType, script, keys, params);</span><br><span class="line">    <span class="keyword">if</span> (!(commandExecutor <span class="keyword">instanceof</span> CommandBatchService)) &#123;</span><br><span class="line">        executorService.executeAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，目前为止我们只需要知道：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605959979086-b4d49fc5-a37b-4872-a0d4-3f9c5a560f9d-20210923224610738.png" alt="img"></p><p>我们虽然不知道onComplete()具体如何实现回调（比CompletableFuture复杂得多），但是我们知道锁续期和RFuture的回调机制相关！</p><h3 id="Redisson如何实现锁续期"><a href="#Redisson如何实现锁续期" class="headerlink" title="Redisson如何实现锁续期"></a>Redisson如何实现锁续期</h3><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605960740451-f70e601b-0432-44a1-8e3c-34ff56b3b1c9-20210923224618495.png" alt="img"></p><p>最终会进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 启动一个定时器：Timeout newTimeout(TimerTask task, long delay, TimeUnit unit);</span></span><br><span class="line"><span class="comment">    * 执行规则是：延迟internalLockLeaseTime/3后执行</span></span><br><span class="line"><span class="comment">    * 注意啊，每一个定时任务只执行一遍，而且是延迟执行。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 那么问题就来了：</span></span><br><span class="line"><span class="comment">    * 1.internalLockLeaseTime/3是多久呢？</span></span><br><span class="line"><span class="comment">    * 2.如果定时任务只执行一遍，似乎解决不了问题啊，本质上和我们手动设置过期时间一样：多久合适呢？</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 定时任务的目的是：重新执行一遍lua脚本，完成锁续期，把锁的ttl拨回到30s</span></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            <span class="comment">// 设置了一个回调</span></span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="comment">// 如果宕机了，就不会续期了</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果锁还存在（没有unLock，说明业务还没结束），递归调用当前方法，不断续期</span></span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 重新执行evalWriteAsync()，和加锁时的lua脚本比较类似，但有点不同</span></span><br><span class="line"><span class="comment">* 这里设置expire的参数也是internalLockLeaseTime</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 看来我们不得不去调查一下internalLockLeaseTime了！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">            Collections.singletonList(getName()),</span><br><span class="line">            internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你给renewExpirationAsync()打上断点，会发现每隔10秒，定时任务就会执行一遍：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969467749-64ac2a12-3b6d-4762-abf8-b457be9dc0e5-20210923224633703.png" alt="img"></p><p>联想到定时任务的delay是internalLockLeaseTime&#x2F;3，所以推测internalLockLeaseTime为30秒。</p><p>点击internalLockLeaseTime，很容易跳转到对应的字段：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969607142-5897d87e-0841-4647-8ad1-02b308a7e66c-20210923224640385.png" alt="img"></p><p>再顺着getLockWatchdogTimeout()跳转，很快就会发现</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969777097-2f955c29-3f28-4ce2-a12a-b76455fb1e1e-20210923224647544.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969804198-7d2b61c3-da1b-4de1-aecd-5777a4994ee5-20210923224657200.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969855073-00958650-adfb-49c5-972e-37e797f5f23d-20210923224708071.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969922018-f5dc76c3-0566-4d14-9018-1ea86f17ff1c-20210923224716263.png" alt="img"></p><p>确实是30秒。</p><p>梳理一下所谓的Watchdog锁续期机制：</p><ul><li>lock()第一次成功加锁时，设置的锁过期时间默认30秒，这个值来自Watchdog变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重点</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime=-<span class="number">1</span>, <span class="type">long</span> leaseTime=-<span class="number">1</span>, TimeUnit unit=<span class="literal">null</span>, <span class="type">long</span> threadId=<span class="number">666</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock()默认leaseTime=-1，所以会跳过if</span></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行lua脚本加锁，返回RFuture。第二个参数就是leaseTime，来自LockWatchdogTimeout！！！</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(</span><br><span class="line">                                            waitTime=-<span class="number">1</span>,</span><br><span class="line">                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=<span class="number">30</span>秒,</span><br><span class="line">                                            TimeUnit.MILLISECONDS, </span><br><span class="line">                                            threadId=<span class="number">666</span>, </span><br><span class="line">                                            RedisCommands.EVAL_LONG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回调方法</span></span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 发生异常时直接return</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明加锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 启动额外的线程，按照一定规则给当前锁续期</span></span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回RFuture，里面有ttlRemaining</span></span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行lua脚本上锁</span></span><br><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime=-<span class="number">1</span>, <span class="type">long</span> leaseTime=<span class="number">30</span>*<span class="number">1000</span>, TimeUnit unit=毫秒, <span class="type">long</span> threadId=<span class="number">666</span>, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    <span class="comment">// 略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onComplete()设置回调，等Redis调用回来后，异步线程回调BiConsumer#accept()，进入scheduleExpirationRenewal(threadId)，开始<strong>每隔internalLockLeaseTime&#x2F;3时间就给锁续期</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605961851949-8de820bf-97f6-4330-a580-da4003cc2123-20210923224729646.png" alt="img"></p><p>和加锁一样，执行lua脚本其实很快，所以这里的future.onComplete()虽说是异步，但很快就会被调用，然后就会递归调用renewExpiration()，然后又是一个TimerTask()，<strong>隔****internalLockLeaseTime&#x2F;3后又给锁续期。</strong></p><p><strong>也就是说，Redisson的Watchdog定时任务虽然只延迟执行一次，但每次调用都会递归，所以相当于：重复延迟执行。</strong></p><p>还记得之前学习CompletableFuture时我写的一行注释吗：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605970707587-a80fb37d-b89e-4742-b675-4bfe03ca8b0c-20210923224741535.png" alt="img"></p><p>也就是说，只要主线程的任务不结束，就会一直给锁续期。</p><p>锁释放有两种情况：</p><ul><li>任务结束，主动unLock()删除锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redisson.lock();</span><br><span class="line">task();</span><br><span class="line">redisson.unLock();</span><br></pre></td></tr></table></figure><ul><li>任务结束，不调用unLock()，但由于守护线程已经结束，不会有后台线程继续给锁续期，过了30秒自动过期</li></ul><p>上面我们探讨的都是加锁成功的流程，直接ttl&#x3D;null就返回了，后面一大坨都是加锁失败时的判断逻辑，其中涉及到：</p><ul><li><p>while(true)死循环</p></li><li><p>阻塞等待</p></li><li><p>释放锁时Redis的Publish通知（在后面的unLock流程会看到）</p></li><li><p>其他节点收到锁释放的信号后重新争抢锁</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975498344-dd4657b8-5442-4fcd-8693-9f5e81d09531-20210923224753386.png" alt="img"></p><p>整个过程还是非常复杂的，大家有精力可以自行百度了解，后面介绍unLock()时也会涉及一部分加锁失败相关内容。</p><h3 id="unLock-源码解析"><a href="#unLock-源码解析" class="headerlink" title="unLock()源码解析"></a>unLock()源码解析</h3><p>有了lock()的经验，unLock()就简单多了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975635261-dc6265a9-2950-433f-a7f1-d46445d0a01b-20210923224803834.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975844381-fff7bf1c-36e2-4f63-9fc8-f5af8ebc0e0a-20210923224809682.png" alt="img"></p><p>相信大家还是能推断出KEYS[]和ARGV[]，这里就直接给出答案了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 参数解释：</span></span><br><span class="line"><span class="comment">-- KEYS[1] =&gt; &quot;bravo1988_distributed_lock&quot;</span></span><br><span class="line"><span class="comment">-- KEYS[2] =&gt; getChannelName()</span></span><br><span class="line"><span class="comment">-- ARGV[1] =&gt; LockPubSub.UNLOCK_MESSAGE</span></span><br><span class="line"><span class="comment">-- ARGV[2] =&gt; internalLockLeaseTime</span></span><br><span class="line"><span class="comment">-- ARGV[3] =&gt; getLockName(threadId)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 锁已经不存在，返回null</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 锁还存在，执行COUNT--（重入锁的反向操作）</span></span><br><span class="line"><span class="keyword">local</span> counter = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>], <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- COUNT--后仍然大于0（之前可能重入了多次）</span></span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 设置过期时间</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- COUNT--后小于等于0，删除锁，并向对应的Channel发送消息（NIO），消息类型是LockPubSub.UNLOCK_MESSAGE（锁释放啦，快来抢~）</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line">    redis.call(<span class="string">&#x27;publish&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure><p>也就是说，当一个锁被释放时，原先持有锁的节点会通过NIO的Channel发送LockPubSub.UNLOCK_MESSAGE，告诉其他订阅的Client：我已经释放锁啦，快来抢啊！此时原本阻塞的其他节点就会重新竞争锁。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606010300656-f21b35bd-bd46-4f02-bf73-e2913664af28-20210923224832043.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606010321812-3803dd5d-3411-4060-84f1-2f797f56946e-20210923224838169.png" alt="img"></p><p>而所谓重入和反重入，简单来说就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁三次</span></span><br><span class="line">redisson.lock();</span><br><span class="line">redisson.lock();</span><br><span class="line">redisson.lock();</span><br><span class="line"><span class="comment">// 执行业务</span></span><br><span class="line">executeTask();</span><br><span class="line"><span class="comment">// 相应的，就要解锁三次</span></span><br><span class="line">redisson.unLock();</span><br><span class="line">redisson.unLock();</span><br><span class="line">redisson.unLock();</span><br></pre></td></tr></table></figure><p>实际开发不会这样调用，但有时会出现子父类方法调用或者同一个线程反复调用使用同一把锁的多个方法，就会发生锁的重入（COUNT++），而当这些方法执行完毕逐个弹栈的过程中就会逐个unLock()解锁（COUNT–）。</p><h3 id="lock-leaseTime-unit-：自定义过期时间、且不续期"><a href="#lock-leaseTime-unit-：自定义过期时间、且不续期" class="headerlink" title="lock(leaseTime, unit)：自定义过期时间、且不续期"></a>lock(leaseTime, unit)：自定义过期时间、且不续期</h3><p>lock()默认会开启定时任务对锁进行续期，但Redisson还提供了另一个lock方法：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605976920059-cd4945a2-0932-4cc6-a2b5-9beac14475f9-20210923224857619.png" alt="img"></p><p>两个lock()唯一的区别是，内部调用lock()时，一个传了leaseTime&#x3D;-1，另一个传了我们自己的leaseTime。对于外部调用者来说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisson.lock();</span><br><span class="line">redisson.lock(-<span class="number">1</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>这两种写法其实一样。</p><p>当然了，通常会传入有意义的leaseTime：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605977159145-10176f3a-8e5c-4d34-9f82-d5a9a684c15e-20210923224909434.png" alt="img"></p><p><strong>这种写法除了更改了锁的默认ttl时间外，还阉割了锁续期功能。</strong>也就是说，10秒后如果任务还没执行完，就会和我们手写的Redis分布式锁一样，自动释放锁。</p><p>为什么锁续期的功能失效了呢？留给大家自己解答，这里只给出参考答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重点</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime=-<span class="number">1</span>, <span class="type">long</span> leaseTime=-<span class="number">1</span>, TimeUnit unit=<span class="literal">null</span>, <span class="type">long</span> threadId=<span class="number">666</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock()默认leaseTime=-1，会跳过这个if执行后面的代码。但如果是lock(10, TimeUnit.SECONDS)，会执行if并跳过后面的代码。</span></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 其实和下面的tryLockInnerAsync()除了时间不一样外，没什么差别</span></span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但由于上面直接return了，所以下面的都不会执行！！</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(</span></span><br><span class="line"><span class="comment">                                            waitTime=-1,</span></span><br><span class="line"><span class="comment">                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=30秒,</span></span><br><span class="line"><span class="comment">                                            TimeUnit.MILLISECONDS, </span></span><br><span class="line"><span class="comment">                                            threadId=666, </span></span><br><span class="line"><span class="comment">                                            RedisCommands.EVAL_LONG);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 设置回调方法（不会执行！！）</span></span><br><span class="line"><span class="comment">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span></span><br><span class="line"><span class="comment">        // 发生异常时直接return</span></span><br><span class="line"><span class="comment">        if (e != null) &#123;</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 说明加锁成功</span></span><br><span class="line"><span class="comment">        if (ttlRemaining == null) &#123;</span></span><br><span class="line"><span class="comment">            // 启动额外的线程，按照一定规则给当前锁续期</span></span><br><span class="line"><span class="comment">            scheduleExpirationRenewal(threadId);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 不会执行！！</span></span><br><span class="line"><span class="comment">    return ttlRemainingFuture;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行lua脚本加锁</span></span><br><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime=-<span class="number">1</span>, <span class="type">long</span> leaseTime=<span class="number">30</span>*<span class="number">1000</span>, TimeUnit unit=毫秒, <span class="type">long</span> threadId=<span class="number">666</span>, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    <span class="comment">// 略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，直接执行lua加锁就返回了，没有机会启动定时任务和递归…</p><h3 id="tryLock-系列：让调用者自行决定加锁失败后的操作"><a href="#tryLock-系列：让调用者自行决定加锁失败后的操作" class="headerlink" title="tryLock()系列：让调用者自行决定加锁失败后的操作"></a>tryLock()系列：让调用者自行决定加锁失败后的操作</h3><p>之前我们已经观察到，如果多个节点都调用lock()，那么没获取到锁的节点线程会<strong>阻塞</strong>，直到原先持有锁的节点删除锁并publish LockPubSub.UNLOCK_MESSAGE 。</p><p>但如果调用者不希望阻塞呢？他有可能想着：如果加锁失败，我就直接放弃。</p><p>是啊，毕竟尝试加锁的目的可能完全相反：</p><ul><li>在保证线程安全的前提下，尽量让所有线程都执行成功</li><li>在保证线程安全的前提下，只让一个线程执行成功</li></ul><p>前者适用于秒杀、下单等操作，希望尽最大努力达成；后者适用于定时任务，只要让一个节点去执行，没有获取锁的节点应该fast-fail（快速失败）。</p><p>也就是说，节点获锁失败后，理论上可以有各种各样的处理方式：</p><ul><li><p>阻塞等待</p></li><li><p>直接放弃</p></li><li><p>试N次再放弃</p></li><li><p>…</p></li></ul><p><strong>但lock、****lock(leaseTime, timeUnit)替我们写死了：阻塞等待。</strong>即使lock(leaseTime, unit)，其实也是阻塞等待，只不过不会像lock()一样不断续期。</p><p>究其原因，主要是lock()这些方法对于加锁失败的判断是在内部写死的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605978662886-e09f2b51-ccb8-4fdb-b7f2-b2b162d0c57d-20210923224924265.png" alt="img"></p><p>而tryLock()方法则去掉了这层中间判断，<strong>把结果直接呈递到调用者面前，让调用者自己决定加锁失败后如何处理：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605978761456-207d8919-5a9e-451e-9460-3b4498f1b86c-20210923224932016.png" alt="img"></p><p>tryLock()直接返回true（加锁成功）和false（加锁失败），后续如何处理，全凭各个节点自己做出决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;bravo1988_distributed_lock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        <span class="comment">// 业务操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用立即结束，不阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样讲可能有点抽象，大家可以分别点进lock()和tryLock()，自行体会。总之，tryLock()中间少了一大块逻辑，因为它不插手结果的判断。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606181778959-3b05f3f9-ba72-4ada-9d4b-cb17f2871d91-20210923224943457.png" alt="img"></p><p>另外，tryLock()在加锁成功的情况下，其实和lock()是一样的，也会触发锁续期：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979113544-fd5fd678-27b0-4ee8-af1b-bb8e82b6cf5b-20210923224950350.png" alt="img"></p><p>如果你不希望触发锁续期，可以像lock(leaseTime, unit)一样指定过期时间，还可以指定加锁失败后等待多久：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLockSuccess</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;bravo1988_distributed_lock&quot;</span>);</span><br><span class="line">    <span class="comment">// 基本等同于lock()，加锁成功也【会自动锁续期】，但获锁失败【立即返回false】，交给调用者判断是否阻塞或放弃</span></span><br><span class="line">    lock.tryLock();</span><br><span class="line">    <span class="comment">// 加锁成功仍然【会自动锁续期】，但获锁失败【会等待10秒】，看看这10秒内当前锁是否释放，如果是否则尝试加锁</span></span><br><span class="line">    lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 加锁成功【不会锁续期】，加锁失败【会等待10秒】，看看这10秒内当前锁是否释放，如果是否则尝试加锁</span></span><br><span class="line">    lock.tryLock(<span class="number">10</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意哈，只传两个参数时，那个time其实是传给waitTime的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979480581-3f3ecda4-159e-475a-80d3-9854b1affea3-20210923225001508.png" alt="img"></p><p>我们之前操作的都是leaseTime，此时还是-1，也就是说如果加锁成功，还是会锁续期。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979506461-ae56c20c-6a92-44be-ac30-0944c8caaa47-20210923225007411.png" alt="img"></p><p>那waitTime是用来控制什么的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979722684-793f715f-e2ed-498f-98e1-68b8d69519e8-20210923225013679.png" alt="img"></p><p>简而言之：</p><ul><li>tryLock()加锁失败会立即返回false，而加了waitTime可以手动指定阻塞等待的时间（等一等，万一行呢）</li><li>leaseTime的作用没变，控制的是加锁成功后要不要续期</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606183066878-ce4cc7de-8cc1-4dd1-995a-b663df428550-20210923225020644.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612490364124-289ef177-9b03-4cc0-9168-f6270728cff9-20210923225025657.jpeg" alt="img"></p><p>至此，分布式锁章节暂时告一段段落。大家有兴趣的话，可以把上一篇花里胡哨的定时任务用Redisson改写，去掉Redis Message Queue（但定时任务最好还是用xxl-job等）。</p><h2 id="Redisson分布式锁的缺陷"><a href="#Redisson分布式锁的缺陷" class="headerlink" title="Redisson分布式锁的缺陷"></a>Redisson分布式锁的缺陷</h2><p>在哨兵模式或者主从模式下，如果master实例宕机，可能导致多个节点同时完成加锁。</p><p>以主从模式为例，由于所有的写操作都是先在master上进行，然后再同步给各个slave节点，所以master与各个slave节点之间的数据具有一定的延迟性。对于Redisson分布式锁而言，比如客户端刚对master写入Redisson锁，然后master异步复制给各个slave节点，但这个过程中master节点宕机了，其中一个slave节点经过选举变成了master节点，好巧不巧，这个slave还没同步到Reddison锁，所以其他客户端可能再次加锁。</p><p>具体情况，大家可以百度看看，解决方案也比较多。</p><p>还是那句话，但凡涉及到分布式，都没那么简单。有时引入一个解决方案后，我们不得不面对另一个问题。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Redis实现的分布式锁的可用性探索1</title>
      <link href="/2020/10/05/%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%8E%A2%E7%B4%A21/"/>
      <url>/2020/10/05/%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%8E%A2%E7%B4%A21/</url>
      
        <content type="html"><![CDATA[<p>在现代计算机系统中，随着多核处理器的广泛应用和分布式系统的蓬勃发展，多线程编程已成为常态。多线程环境下，资源共享带来了高效性，但同时也引发了一系列严峻的问题，其中最为突出的便是线程安全问题。当多个线程同时访问和操作共享数据时，数据的一致性和完整性面临巨大挑战，可能导致数据错误、程序异常甚至系统崩溃等严重后果。</p><p>在 Java 编程领域，传统的 JVM 锁机制，如 synchronized 关键字和 ReentrantLock，在单进程或单节点应用中有效地解决了线程安全问题。它们基于线程在同一 JVM 内存空间中运行的特性，通过互斥访问共享资源来确保数据一致性。然而，随着分布式系统的兴起，应用架构发生了根本性变化。分布式系统由多个独立的节点组成，这些节点可能分布在不同的服务器上，运行在各自独立的 JVM 中，彼此之间通过网络通信协作。在这种分布式环境下，JVM 锁机制的局限性逐渐显现。由于每个节点的 JVM 内存相互独立，无法实现跨节点的线程互斥，传统的锁机制无法保证分布式系统中共享资源的一致性访问。例如，在一个分布式电商系统中，多个节点可能同时处理订单操作，如果没有有效的分布式锁机制，可能会出现超卖等问题。</p><p>为了满足分布式系统对共享资源一致性访问的需求，分布式锁应运而生。它提供了一种在分布式环境下实现互斥访问的机制，确保在任何时刻，只有一个节点能够获取特定资源的锁，从而保证数据的一致性和完整性。Redis，作为一款高性能的内存数据库，以其出色的性能、丰富的数据结构和原子操作特性，成为了实现分布式锁的理想选择之一。其内存存储和快速读写能力使得获取和释放锁的操作能够高效执行，而原子操作保证了锁操作的完整性和可靠性。通过 Redis 实现分布式锁，可以有效地解决分布式系统中的并发冲突问题，为分布式应用的稳定运行提供有力支持。</p><span id="more"></span><h2 id="JVM锁"><a href="#JVM锁" class="headerlink" title="JVM锁"></a>JVM锁</h2><p>所谓JVM锁，其实指的是诸如synchronized关键字或者ReentrantLock实现的锁。之所以统称为JVM锁，是因为我们的项目其实都是跑在JVM上的。理论上每一个项目启动后，就对应一片JVM内存，后续运行时数据的生离死别都在这一片土地上。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1620095054769-ca64b8aa-6bd0-4bdc-a4da-cc7e5d181d24-20210924103005529.png" alt="图片.png"></p><h3 id="什么是锁、怎么锁？"><a href="#什么是锁、怎么锁？" class="headerlink" title="什么是锁、怎么锁？"></a>什么是锁、怎么锁？</h3><p>明白了“JVM锁”名字的由来，我们再来聊什么是“锁”，以及怎么“锁”。</p><p>有时候我们很难阐述清楚某个事物<strong>是什么</strong>，但很容易解释它<strong>能干什么</strong>，JVM锁也是这个道理。JVM锁的出现，就是为了解决线程安全问题。所谓线程安全问题，可以简单地理解为数据不一致（与预期不一致）。</p><p>什么时候可能出现线程安全问题呢？</p><p>当同时满足以下三个条件时，才可能引发线程安全问题：</p><ul><li><p>多线程环境</p></li><li><p>有共享数据</p></li><li><p>有多条语句操作共享数据&#x2F;单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）</p></li></ul><p>比如线程A、B同时对int count进行+1操作（初始值假设为1），在一定的概率下两次操作最终结果可能为2，而不是3。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604203263605-6b838677-f5b4-48cd-9298-2788c694aa15-20210924103020945.png" alt="image.png"></p><p>那么加锁为什么能解决这个问题呢？</p><p>如果不考虑原子性、内存屏障等晦涩的名词，加锁之所以能保证线程安全，核心就是“互斥”。所谓互斥，就是字面意思上的<strong>互</strong>相排<strong>斥</strong>。这里的“互相”是指谁呢？就是多线程之间！</p><p>怎么实现多线程之间的互斥呢？</p><p>引入“中间人”即可。</p><p>注意，这是个非常简单且伟大的思想。在编程世界中，通过引入“中介”最终解决问题的案例不胜枚举，包括但不限于Spring、MQ。在码农之间，甚至流传着一句话：没有什么问题是引入中间层解决不了的。</p><p>而JVM锁其实就是线程和线程彼此的“中间人”，多个线程在操作加锁数据前都必须征求“中间人”的同意：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612488996804-3ea7c557-98ae-4d76-aa5a-5933c1fe6026-20210924103037552.png" alt="图片.png"></p><p>锁在这里扮演的角色其实就是守门员，是<strong>唯一</strong>的访问入口，所有的线程都要经过它的拷问。在JDK中，锁的实现机制最常见的就是两种，分别是两个派系：</p><ul><li>synchronized关键字</li><li>AQS</li></ul><p>个人觉得synchronized关键字要比AQS难理解，但AQS的源码比较抽象。这里简要介绍一下Java对象内存结构和synchronized关键字的实现原理。</p><h3 id="Java对象内存结构"><a href="#Java对象内存结构" class="headerlink" title="Java对象内存结构"></a>Java对象内存结构</h3><p>要了解synchronized关键字，首先要知道Java对象的内存结构。强调一遍，是Java<strong>对象的内存结构</strong>。</p><p>它的存在仿佛向我们抛出一个疑问：如果有机会解剖一个Java对象，我们能看到什么？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604205724123-0a6ab812-080e-4626-8a35-db6b6a41bd04-20210924103057869.png" alt="image.png"></p><p>右上图画了两个对象，只看其中一个即可。我们可以观察到，Java对象内存结构大致分为几块：</p><ul><li><p>Mark Word（锁相关）</p></li><li><p>元数据指针（class pointer，指向当前实例所属的类）</p></li><li><p>实例数据（instance data，我们平常看到的仅仅是这一块）</p></li><li><p>对齐（padding，和内存对齐有关）</p></li></ul><p>如果此前没有了解过Java对象的内存结构，你可能会感到吃惊：天呐，我还以为Java对象就只有属性和方法！</p><p>是的，我们最熟悉实例数据这一块，而且<strong>以为只有这一块。</strong>也正是这个观念的限制，导致一部分初学者很难理解synchronized。比如初学者经常会疑惑：</p><ul><li><p>为什么任何对象都可以作为锁？</p></li><li><p>Object对象锁和类锁有什么区别？</p></li><li><p>synchronized修饰的普通方法使用的锁是什么？</p></li><li><p>synchronized修饰的静态方法使用的锁是什么？</p></li></ul><p>这一切的一切，其实都可以在Java对象内存结构中的Mark Word找到答案：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604208962907-39530cce-67a1-41ff-9855-13f3297d2c10-20210924103109319.png" alt="image.png"></p><p>Mark Word包含的信息还是蛮多的，但这里我们只需要简单地把它理解为<strong>记录锁信息</strong>的标记即可。上图展示的是32位虚拟机下的Java对象内存，如果你仔细数一数，会发现全部bit加起来刚好是32位。64位虚拟机下的结构大同小异，就不特别介绍。</p><p>Mark Word从有限的32bit中划分出2bit，专门用作锁标志位，通俗地讲就是标记当前锁的状态。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1620095815528-242114c7-277f-4777-ad33-9e38d4c62c27.png" alt="img"></p><p>正因为每个Java对象都有Mark Word，而Mark Word能标记锁状态（把自己当做锁），所以Java中任意对象都可以作为synchronized的锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(person)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(student)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所谓的this锁就是当前对象，而Class锁就是当前对象所属类的Class对象，本质也是Java对象。synchronized修饰的普通方法底层使用当前对象作为锁，synchronized修饰的静态方法底层使用Class对象作为锁。</strong></p><p>但如果要保证多个线程互斥，最基本的条件是它们<strong>使用同一把锁：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612489131320-62cceb64-2ba8-431d-985f-03cbe8f42df2-20210923220222012.png" alt="img"></p><p>对同一份数据加两把不同的锁是没有意义的，实际开发时应该注意避免下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Person.class)&#123;</span><br><span class="line">    <span class="comment">// 操作count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(person)&#123;</span><br><span class="line">    <span class="comment">// 操作count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 操作count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 操作count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized与锁升级"><a href="#synchronized与锁升级" class="headerlink" title="synchronized与锁升级"></a>synchronized与锁升级</h3><p>大致介绍完Java对象内存结构后，我们再来解决一个新疑问：</p><p>为什么需要标记锁的状态呢？是否意味着synchronized锁有多种状态呢？</p><p>在JDK早期版本中，synchronized关键字的实现是直接基于重量级锁的。只要我们在代码中使用了synchronized，JVM就会向操作系统申请锁资源（不论当前是否真的是多线程环境），而向操作系统申请锁是比较耗费资源的，其中涉及到用户态和内核态的切换等，总之就是比较费事，且性能不高。</p><p>JDK为了解决JVM锁性能低下的问题，引入了ReentrantLock，它基于CAS+AQS，类似自旋锁。自旋的意思就是，在发生锁竞争的时候，未争取到锁的线程会在门外采取自旋的方式等待锁的释放，谁抢到谁执行。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612489200273-6e3caa00-7625-42b7-9b03-e2a87ba09633-20210923220236604.png" alt="img"></p><p>自旋锁的好处是，不需要兴师动众地切换到内核态申请操作系统的重量级锁，在JVM层面即可实现自旋等待。但世界上并没有百利而无一害的灵丹妙药，CAS自旋虽然避免了状态切换等复杂操作，却要耗费部分CPU资源，尤其当可预计上锁的时间较长且并发较高的情况下，会造成几百上千个线程同时自旋，极大增加CPU的负担。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604463084016-ce0704e8-55d9-4035-9dda-15778b125560-20210923220242536.png" alt="img"></p><p>synchronized毕竟JDK亲儿子，所以大概在JDK1.6或者更早期的版本，官方对synchronized做了优化，提出了“锁升级”的概念，把synchronized的锁划分为多个状态，也就是上图中提到的：</p><ul><li><p>无锁</p></li><li><p>偏向锁</p></li><li><p>轻量级锁（自旋锁）</p></li><li><p>重量级锁</p></li></ul><p>无锁就是一个Java对象刚new出来的状态。当这个对象第一次被一个线程访问时，该线程会把自己的线程id“贴到”它的头上（Mark Word中部分位数被修改），表示“你是我的”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604211050450-4463b6fc-3864-4822-b6a5-e8ed98283b7c-20210924103138330.png" alt="image.png"></p><p>此时是不存在锁竞争的，所以并不会有什么阻塞或等待。</p><p>为什么要设计“偏向锁”这个状态呢？</p><p>其实大部分项目的大部分时候，某个变量都是单个线程在执行，此时直接向操作系统申请重量级锁显然没有必要，因为根本不会发生线程安全问题。</p><p>而一旦发生锁竞争时，synchronized便会在一定条件下升级为轻量级锁，可以理解为一种自旋锁，具体自旋多少次以及何时放弃自旋，JDK也有一套相关的控制机制，大家可以自行了解。</p><p>同样是自旋，所以synchronized也会遇到ReentrantLock的问题：如果上锁时间长且自旋线程多，又该如何？</p><p>此时就会再次升级，变成传统意义上的重量级锁，本质上操作系统会维护一个队列，用空间换时间，避免多个线程同时自旋等待耗费CPU性能，等到上一个线程结束时唤醒等待的线程参与新一轮的锁竞争即可。</p><h3 id="synchronized案例"><a href="#synchronized案例" class="headerlink" title="synchronized案例"></a>synchronized案例</h3><ul><li>同一个类中的synchronized method m1和method m2互斥吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290796058-a3bfc5f5-f6be-4543-8796-a2b170d36464-20210923220322058.png" alt="img"></p><p>t1线程执行m1方法时要去读this对象锁，但是t2线程并不需要读锁，两者各管各的，没有交集（不共用一把锁）</p><ul><li>同一个类中synchronized method m1中可以调用synchronized method m2吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290844351-21fa8f5e-80ac-400f-8033-88aad2dd6960-20210923220329432.png" alt="img"></p><p>synchronized是可重入锁，可以粗浅地理解为同一个线程在已经持有该锁的情况下，可以再次获取锁，并且会在某个状态量上做+1操作（ReentrantLock也支持重入）</p><ul><li>子类同步方法synchronized method m可以调用父类的synchronized method m吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290893998-8ba4a1e0-48a4-4789-9856-b5de2539ff7c-20210923220336563.png" alt="img"></p><p>子类对象初始化前，会调用父类构造方法，在结构上相当于包裹了一个父类对象，用的都是this锁对象</p><ul><li>静态同步方法和非静态同步方法互斥吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290932744-f6d63490-b46a-4c0e-b939-c0a54764f6be-20210923220344834.png" alt="img"></p><p>各玩各的，不是同一把锁，谈不上互斥</p><h2 id="Redis分布式锁的概念"><a href="#Redis分布式锁的概念" class="headerlink" title="Redis分布式锁的概念"></a>Redis分布式锁的概念</h2><p>谈到Redis分布式锁，总是会有这样或那样的疑问：</p><ul><li><p>什么是分布式</p></li><li><p>什么是分布式锁</p></li><li><p>为什么需要分布式锁</p></li><li><p>Redis如何实现分布式锁</p></li></ul><p>前3个问题其实可以一起回答，至于Redis如何实现分布式锁，我们放在下一篇。</p><p>什么是分布式？这是个很复杂的概念，我也很难说准确，所以干脆画个图，大家各花入各眼吧：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604211829338-3b84a9f8-b551-41ba-a83e-1428ea401e13-20210923220351203.png" alt="img"></p><p>分布式有个很显著的特点是，Service A和Service B极有可能并不是部署在同一个服务器上，所以它们也不共享同一片JVM内存。<strong>而上面介绍了，要想实现线程互斥，必须保证所有访问的线程使用的是同一把锁（JVM锁此时就无法保证互斥）。</strong></p><p>对于分布式项目，有多少台服务器就有多少片JVM内存，即使每片内存中各设置一把“独一无二”的锁，从整体来看项目中的锁就不是唯一的。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604292366085-77c2f620-9dce-417e-a714-e094c690b934-20210923220359938.png" alt="img"></p><p>此时，<strong>如何保证每一个JVM上的线程共用一把锁呢？</strong></p><p>答案是：把锁抽取出来，让线程们在<strong>同一片内存</strong>相遇。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604292683347-9f095018-1aa9-464d-848e-f26b2ae69a52-20210923220408318.png" alt="img"></p><p>但锁是不能凭空存在的，本质还是要在内存中，此时可以使用Redis缓存作为锁的宿主环境，这就是Redis能构造分布式锁的原因。</p><h3 id="Redis的锁长啥样"><a href="#Redis的锁长啥样" class="headerlink" title="Redis的锁长啥样"></a>Redis的锁长啥样</h3><p>synchronized关键字和ReentrantLock，它们都是实实在在已经实现的锁，而且还有标志位啥的。但Redis就是一个内存…怎么作为锁呢?</p><p>有一点大家要明确，Redis之所以能用来做分布式锁，肯定不只是因为它是一片内存，否则JVM本身也占有内存，为什么无法自己实现分布式锁呢？</p><p>我个人的理解是，要想自定义一个分布式锁，必须至少满足几个条件：</p><ul><li><p>多进程可见（独立于多节点系统之外的一片内存）</p></li><li><p>互斥（可以通过单线程，或者某种顺序机制）</p></li><li><p>可重入</p></li></ul><p>还有个条件，默认要支持：只有持有这把锁的客户端才能解锁</p><p>以上三点Redis都能满足。在上面三个条件下，其实怎么设计锁，完全取决于个人如何定义锁。就好比现实生活中，通常我们理解的锁就是有个钥匙孔、需要插入钥匙的金属小物件。然而锁的形态可不止这么一种，随着科技的发展，什么指纹锁、虹膜锁层出不穷，但归根结底它们之所以被称为“锁”，是因为都保证了“互斥”（我行，你不行）。</p><p>如果我们能设计一种逻辑，它能造成某个场景下的“互斥事件”，那么它就可以被称为“锁”。比如，某家很有名的网红店，一天只接待一位客人。门口没有营业员，就放了一台取号机，里面放了一张票。你如果去迟了，票就没了，你就进不了这家店。这个场景下，没票的顾客进不去，被锁在门外。此时，取票机造成了“互斥事件”，那么它就可以叫做“锁”。</p><p>而Redis提供了setnx指令，如果某个key当前不存在则设置成功并返回true，否则不再重复设置，直接返回false。这不就是编程界的取号机吗？当然，实际用到的命令可不止这一个，具体如何实现，请看下一篇~</p><p>这一篇从JVM锁聊到了Redis分布式锁，还介绍了Java的对象内存结构及synchronized底层的原理，相信大家对“锁”已经有了自己的感性认识。下一篇我们将通过分布式定时任务的案例介绍Redis分布式锁的使用场景。</p><p><strong>思考一个问题：分布式系统是否一定要分布式锁？</strong></p><p>分布式系统如果要加锁是否一定要使用分布式锁呢？</p><p>可能未必。</p><p>如果你需要的是写锁，那么可能确实需要分布式锁保证单一线程处理数据，而如果是为了防止缓存击穿（热点数据定时失效），那么使用JVM本地锁也没有太大关系。比如某个服务有10个节点，在使用JVM锁的情况下，即使某一时刻每个节点<strong>各自</strong>涌入1000个请求，虽然总共有1w个请求，但最终打到数据库的也只有10个，数据库层面是完全可以抗住这点请求量的，又由于本身是查询，所以不会造成线程安全问题。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查询执行计划分析与联合索引应用</title>
      <link href="/2020/08/19/%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8/"/>
      <url>/2020/08/19/%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>数据库应用开发中，SQL 查询性能直接影响系统的整体响应速度和用户体验。尽管开发人员在编写 SQL 语句时努力确保逻辑正确，但随着业务数据量的不断增加，查询效率问题逐渐凸显。</p><p>优化 SQL 查询已成为提高数据库性能的关键环节。而索引作为优化 SQL 的重要手段，其正确使用和理解对于提升查询性能至关重要。</p><p>本文将基于这些实际需求，深入介绍 Explain 工具的使用方法，详细分析联合索引的特性和应用场景，结合实际案例探讨 SQL 优化的技巧和策略</p><span id="more"></span><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>之前我们已经接触了一部分索引优化相关的概念，但更多的是我一个人在讲，大家被动地接收。如何验证文章所说的正确性，以及一条SQL是否真的用到了索引呢？</p><p>这个时候就该Explain上场了，使用方式有两种：</p><ul><li>借助Navicat等软件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610247075143-d475fc88-120c-4ca9-a27d-204b7d6ecf45-20210923214500198.png" alt="img"></p><ul><li>直接使用Explain命令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610247009784-07acd78b-aaf8-4cf6-ae50-6a83e381f027-20210923214507859.png" alt="img"></p><p>大家把它当做一个命令即可，是MySQL提供的专门用来分析SQL执行计划的，比如语句是否使用了关联查询、是否使用了索引、扫描行数等。使用场景一般是：</p><ul><li>当你发现某条SQL很慢时，可以借助Explain分析一下是否走索引</li><li>当你修改某条SQL后，借助Explain查看是否达到预期</li></ul><p>Explain有很多指标，重点看type、key、Extra：</p><table><thead><tr><th>列名</th><th>解释</th></tr></thead><tbody><tr><td>id</td><td>查询编号</td></tr><tr><td>select_type</td><td>查询类型：显示本行是简单还是复杂查询</td></tr><tr><td>table</td><td>涉及到的表</td></tr><tr><td>partitions</td><td>匹配的分区：查询将匹配记录所在的分区。仅当使用 partition 关键字时才显示该列。对于非分区表，该值为 NULL。</td></tr><tr><td><strong>type</strong></td><td>本次查询的表连接类型</td></tr><tr><td>possible_keys</td><td>可能选择的索引</td></tr><tr><td><strong>key</strong></td><td>实际选择的索引</td></tr><tr><td>key_len</td><td>被选择的索引长度：一般用于判断联合索引有多少列被选择了</td></tr><tr><td>ref</td><td>与索引比较的列</td></tr><tr><td>rows</td><td>预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确</td></tr><tr><td>filtered</td><td>按条件筛选的行的百分比</td></tr><tr><td><strong>Extra</strong></td><td>附加信息</td></tr></tbody></table><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><table><thead><tr><th>type 的值</th><th>解释</th></tr></thead><tbody><tr><td>system</td><td>查询对象表只有一行数据，且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况</td></tr><tr><td>const</td><td>基于主键或唯一索引查询，最多返回一条结果</td></tr><tr><td>eq_ref</td><td>表连接时基于主键或非 NULL 的唯一索引完成扫描</td></tr><tr><td>ref</td><td>基于普通索引的等值查询，或者表间等值连接</td></tr><tr><td>fulltext</td><td>全文检索</td></tr><tr><td>ref_or_null</td><td>表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值</td></tr><tr><td>index_merge</td><td>利用多个索引</td></tr><tr><td>unique_subquery</td><td>子查询中使用唯一索引</td></tr><tr><td>index_subquery</td><td>子查询中使用普通索引</td></tr><tr><td>range</td><td>利用索引进行范围查询</td></tr><tr><td>index</td><td>全索引扫描</td></tr><tr><td>ALL</td><td>全表扫描</td></tr></tbody></table><h3 id="possible-keys、key、key-len"><a href="#possible-keys、key、key-len" class="headerlink" title="possible_keys、key、key_len"></a>possible_keys、key、key_len</h3><p>possible_keys是MySQL预估会使用的索引（基本不用看），key才是最终实际选择的索引，可以结合key_len来推测联合索引的“使用率”。比如联合索引index(a,b,c)，假设每个索引长度为1，而key_len却是2，那么可以推测联合索引只用了前两个。</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>Extra是最难的，含义也最多，和索引覆盖、排序等都有关系。</p><table><thead><tr><th>Extra 常见的值</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td>Using filesort</td><td>将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</td><td>explain select * from t1 order by create_time;</td></tr><tr><td>Using temporary</td><td>需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时</td><td>explain select * from t1 group by create_time;</td></tr><tr><td>Using index</td><td>使用覆盖索引</td><td>explain select a from t1 where a&#x3D;111;</td></tr><tr><td>Using where</td><td>使用 where 语句来处理结果</td><td>explain select * from t1 where create_time&#x3D;‘2019-06-18 14:38:24’;</td></tr><tr><td>Impossible WHERE</td><td>对 where 子句判断的结果总是 false 而不能选择任何数据</td><td>explain select * from t1 where 1&lt;0;</td></tr><tr><td>Using join buffer (Block Nested Loop)</td><td>关联查询中，被驱动表的关联字段没索引</td><td>explain select * from t1 straight_join t2 on (t1.create_time&#x3D;t2.create_time);</td></tr><tr><td>Using index condition</td><td>先条件过滤索引，再查数据</td><td>explain select * from t1 where a &gt;900 and a like “%9”;</td></tr><tr><td>Select tables optimized away</td><td>使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</td><td>explain select max(a) from t1;</td></tr></tbody></table><p>Explain更详细的解释可以参考：<a href="https://www.bilibili.com/video/BV1KW411u7vy?p=20">https://www.bilibili.com/video/BV1KW411u7vy?p=20</a></p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>联合索引其实要比单列索引难很多，很多SQL优化原则都是针对万恶的联合索引搞出来的，比如大名鼎鼎的“最左匹配原则”。</p><p><strong>虽然联合索引容易引发各种问题，看起来不那么容易驯服，但它在提高索引利用率、加快分组、排序等方面却有着很大的作用，</strong>所以实际开发时，联合索引一般来说应该优于单列索引。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589537787486-ed93cbb6-a245-49eb-8e8f-42fe6ce51893-20210923214519728.png" alt="img"></p><p>我不知道大家是否好奇<strong>联合索引到底长啥样</strong>，反正我当初学习SQL优化时，就有很多的疑问：</p><ul><li><p>联合索引到底长啥样？</p></li><li><p>查询时是怎么检索的呢？</p></li><li><p>为什么对于联合索引index(a, b, c)，查询条件WHERE b&#x3D;1, c&#x3D;2无法利用索引呢？</p></li></ul><p>我们先回答第一、第二个问题，第三个问题我们分为三小节，专门讨论所谓的“最左匹配原则”。</p><p>联合索引到底长什么样呢？</p><ul><li>还是一棵树，不会因为是联合索引，就变成多棵树</li><li>索引节点会存储多列，比如原先单列索引的节点会存储[name, name, name…]，而多列索引的节点内会存储[[name, age], [name, age], [name, age]…]</li></ul><p>为了帮大家更好地理解联合索引，我们一起探讨一个问题：</p><p>当我们向建有联合索引的表中插入一条数据时，发生了什么？</p><p>假设现在数据库的记录是这样的(最底下是有序链表，即叶子节点的数据)：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610674696496-4561304d-995a-4035-812f-880cbf5f7a77-20210923214527578.png" alt="img"></p><p>除了主键索引，其他都是辅助索引，联合索引也不例外。所以，上图叶子节点的数据应该是id，但为了更直观，我画成name和age。</p><p>现在要往数据库插入一条数据(bravo, 18, “杭州”, “18255555556”)，插入时需要维护索引，所以需要沿着索引找到数据所在的位置并在叶子节点的表数据中插入：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589544348046-f14690a1-2d1a-44b2-a87e-592802d19765-20210923214533926.png" alt="img"></p><p><strong>插入数据的过程其实伴随着索引的维护，</strong>插入后整棵索引树就变成了这样：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589544632849-3010099d-1849-4dea-9817-dbd57d41b7ea-20210923214538925.png" alt="img"></p><p>通过分析上面数据的插入过程，你会发现，在插入时其实会进行索引比较，先比较name再比较age。<strong>换句话说，这样沿着索引比较后插入的数据，本身就是有序的，符合联合索引的顺序。</strong></p><p>比如班级排座位，老师按照两个条件综合排序，先按身高排，身高一样的，成绩好的坐后面。那么放学走出教室时，顺序自然就是先按身高排，矮的先出来，高的后出来，身高相同的成绩差的先出来。</p><p>所以，对于下面这条SQL：</p><p>SELECT 学生 FROM ‘三年二班’ ORDER BY 身高, 成绩</p><p>你认为MySQL还有排序的必要吗？直接把三年二班的学生从头数到尾拎出来即可。</p><p>这就是所谓的“索引能加快排序速度”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1594511066391-5c4d07d0-0020-4fc1-8242-c93bc1603177-20210923214545481.png" alt="img"></p><p>因为本身插入或更新时，都是按照某种规则维护的。当你ORDER BY的规则与维护索引的规则一致时（都是根据身高、成绩），此时索引就能加快排序，<strong>因为这个时候根本不用排序。</strong></p><p>所以记住，最快的排序就是不用排序，也就是利用索引排序。把对顺序的维护<strong>分散到</strong>每一次增删改的过程中，而不是查询时再匆忙从零开始排序。</p><h3 id="最左匹配原则：WHERE条件查询"><a href="#最左匹配原则：WHERE条件查询" class="headerlink" title="最左匹配原则：WHERE条件查询"></a>最左匹配原则：WHERE条件查询</h3><p>接着，让我们思考一下“为什么对于联合索引index(name, age)，条件WHERE age&#x3D;25无法利用索引”。</p><p>上面分析过，数据总是要经过索引比较后才插入，所以数据天然就是按索引顺序排列的。当我们拿着WHERE子句的条件（age&#x3D;25）顺着索引树比较时，是得不到正确的结果的。因为当初这棵树排序的第一个条件是name，而不是age。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589545510186-c162bc1b-fe5f-45a0-9a45-72227ee7934a-20210923214551939.png" alt="img"></p><p>由于整棵树的排序规则是“先根据name排列，再根据age排列”，你硬要直接拿age查询，最终结果可能会南辕北辙。还是以学生排座位举例，人家明明是<strong>先按照身高</strong>排序，<strong>再按照成绩</strong>排序，那么注定成绩不会成“递增”或“递减”的趋势（请观察右边分数列），而面对没有相关趋势的数据，我们只能遍历查找：</p><ul><li><p>180cm 98分</p></li><li><p>182cm 96分</p></li><li><p>182cm 97分</p></li><li><p>183cm 99分</p></li><li><p>184cm 93分</p></li><li><p>184cm 95分</p></li></ul><p>分数的相关趋势只有在“身高一致”这个前提下才会显现，是<strong>局部</strong>特征（绿色块、蓝色块的分数确实呈现某种趋势）：</p><ul><li><p>180cm 98分</p></li><li><p>182cm 96分</p></li><li><p>182cm 97分</p></li><li><p>183cm 99分</p></li><li><p>184cm 93分</p></li><li><p>184cm 95分</p></li></ul><p>当然，实际上MySQL在解析SQL时并不会真的像上面一样进行逻辑分析，而是直接进行语法匹配和成本预估，发现WHERE条件不符合联合索引的“最左匹配原则”时，直接放弃走索引，选择全表扫描。</p><p>那么，怎么才能利用index(name, age)这个联合索引呢？</p><p>把查询条件变成 WHERE name&#x3D;bravo, age&#x3D;18即可！此时它会先按照name比较，再按照age比较，刚好和联合索引的顺序一致，也就是和排序顺位一致：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589546040377-acd3e6b0-1a78-4d3d-9a0d-8d9cd6e4a17d-20210923214558226.png" alt="img"></p><p>也就是说，此时WHERE子句的条件顺序刚好能满足最左匹配原则。</p><p>假设联合索引是index(a, b, c)，来看几个最左匹配原则的案例：</p><ul><li><p>WHERE a, b, c ✔️</p></li><li><p>WHERE a, b ✔️（只能匹配a,b）</p></li><li><p>WHERE a, c ✔️（只能匹配a）</p></li><li><p>WHERE b, c（❌）</p></li></ul><p>上面WHERE a, c的查询过程是怎么样的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589618860739-a778f594-32c2-4bd0-8575-53788640d3a7-20210923214605529.png" alt="img"></p><p>也就是说，WHERE后条件如果能走索引，就能站在更高的地方判断条件是否符合，否则只能<strong>作为判断条件</strong>深入节点内部的数据逐个比对。</p><p>如果能走全部索引，就可以少几次比较，甚至可能少几次IO：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589557584392-8bb5a6fe-c7b9-4f87-ac48-07465eade3af-20210923214613726.png" alt="img"></p><p>另外，除了不能缺少联合索引中的查询字段外，还要注意尽量不要使用范围查询。</p><p>比如，联合索引是index(a, b, c)：</p><ul><li>WHERE a&#x3D;1, b&gt;2, c&#x3D;3 ✔️（只能匹配a, b）</li></ul><p>注意一下即可，毕竟真要做范围查询也不是我们能决定的，无非索引利用率低一些罢了。</p><h3 id="最左匹配原则：ORDER-BY"><a href="#最左匹配原则：ORDER-BY" class="headerlink" title="最左匹配原则：ORDER BY"></a>最左匹配原则：ORDER BY</h3><p>上面说过了，对于index(name, age)的索引树，最底层的数据本身就是先按name，再按age排序的。当ORDER BY的条件刚好是ORDER BY name, age时，直接查询即可，无需排序，因为数据在插入时就按索引顺序排好了。</p><p>现在我们反过来讨论，如果没有利用索引排序，或者无法利用索引排序时，会发生什么呢？</p><p>filesort！</p><p>所谓filesort是EXPLAIN命令中extra一列的某个指标，当extra出现filesort这个指标时，说明我们的SQL没有走索引排序，而是利用内存或磁盘自己重新排序。</p><p>那么，什么情况下会导致ORDER BY无法利用索引排序呢？</p><p>以联合索引index(name, age)为例，以下情况无法利用索引排序：</p><ul><li>ORDER BY age, name（字段顺序不一致）</li><li>ORDER BY name DESC, age ASC（字段排序方式不同步，DESC和ASC混着来）</li></ul><p>第一种情况：</p><p>因为索引里的数据是先按name、后按age排序的，而你想要先按age再按name排序，对不起，你自己对结果集重新排吧，我不管了。</p><p>特别要注意，对于联合索引index(a,b,c)，WHERE条件无论是a,b,c、a,c,b还是b,c,a…都没关系，比如女生找男朋友要身高180以上、长得帅的，如果你“反过来”，长得帅、身高180以上也是可以的。但是排序不同，顺序必须和联合索引一致，否则语义是不同的。比如，先按身高再按分数和先按分数再按身高是两种完全不同的排序策略，结果自然也不同。</p><p>大家不妨做个实验，对于(‘a’, 17),(‘a’, 16), (‘b’, 18), (‘c’, 18)，(‘d’, 15)先按name正序再按age正序的结果是：</p><ul><li><p>(‘a’, 16)</p></li><li><p>(‘a’, 17)</p></li><li><p>(‘b’, 18)</p></li><li><p>(‘c’, 18)</p></li><li><p>(‘d’, 15)</p></li></ul><p>而先按age正序再按name正序的结果是：</p><ul><li><p>(‘d’, 15)</p></li><li><p>(‘a’, 16)</p></li><li><p>(‘a’, 17)</p></li><li><p>(‘b’, 18)</p></li><li><p>(‘c’, 18)</p></li></ul><p>所以对于index(name, age)，ORDER BY age, name排序顺序与索引不一致，是无法利用索引排序的。</p><p>第二种情况：</p><p>维护索引时默认都是name ASC, name ASC排序，如果你需要name DESC，age ASC，对不起，你自己对结果集重新排吧，我不管了。</p><p>理由同上。</p><p>但以下情况仍可以利用索引排序：</p><ul><li>ORDER BY name DESC, age DESC（字段顺序和索引顺序一致即可，全部DESC或ASC都没关系）</li></ul><p>为什么ORDER BY name DESC, address DESC也能利用索引排序呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608985883366-5221f525-a2b1-4d49-a62d-44da6eb92008-20210923214621711.png" alt="img"></p><p>假设右边数据是联合索引自动排序的，而现在查询的排序规则是ORDER BY name DESC, age DESC。我们先尝试一下，如果右边的数据真的按ORDER BY name DESC, age DESC排序，会是什么样呢？</p><p><strong>其实就是左边数据倒过来！</strong></p><p>所以 ORDER BY name DESC, age DESC看起来好像无法利用索引，但其实索引数据反着来刚好符合期望的排序。</p><p>总之，大家应该理解为索引排序是“很消极”的：</p><p>反正索引当初就这么排的，如果你刚好想要这种排序，就直接拿数据即可。但你如果想要的排序不是我现有的这种，对不起，你自己爱咋整咋整，但我明确告诉你，<strong>重新排序会让整个查询变慢。</strong></p><p>说了这么多，我们来验证一下。</p><p>创建表：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589547567889-6a812a41-3b19-4536-a4d6-960327eff327-20210923214629930.png" alt="img"></p><p>给name、address加了联合索引。</p><p>共1000w数据：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548017233-53960dfe-8407-4c37-8f14-a930eb6bfadb-20210923214636772.png" alt="img"></p><p>先介绍两个简单的指标，具体的Explain命令后面介绍：</p><p>Extra列中，如果出现了Using filesort，说明没有走索引排序，也就是说本次查询自己额外做了排序。</p><p>ORDER BY name（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548043565-c2fabb16-a7eb-433b-acb2-bce7842152e2-20210923214645356.png" alt="img"></p><p>ORDER BY name, address（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548082945-066e09ba-8d76-4593-a252-1b20376dcb02-20210923214651758.png" alt="img"></p><p>ORDER BY  <code>name</code> DESC, address DESC（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548127165-ccb2ae5c-8bbe-4861-ba9f-481d263b4664-20210923214656860.png" alt="img"></p><p>Using index指的是索引覆盖，是个好消息，意味着本次查询不会回表。</p><p>索引失效案例：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548196364-2aeee667-a9b3-4f59-8289-f501a6b9b010-20210923214703042.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548223133-3f1b433d-430e-4110-831f-d49b6461481b-20210923214710565.png" alt="img"></p><p>当前叶子节点链表上的数据是按索引排的（先name后address），而SQL希望的排序方式是先address后name。既然不能有效利用索引的排序，只能把结果集取出来重新排序。</p><p><strong>总之，如果想利用索引排序，那么ORDER BY的顺序必须符合最左前缀原则，顺序完全一致，且DESC和ASC不能混用。</strong></p><p>OK，上面讲的都是ORDER BY本身的一些规则，接下来我们把战场扩大些，把WHERE也引进来。</p><p>当WHERE和ORDER BY搭配，就会产生一种“例外情况”：<strong>对于index(a,b,c)，SELECT * FROM table WHERE</strong> <strong>a</strong><strong>&#x3D;1 ORDER BY</strong> <strong>b,c****也是可以利用索引排序的。</strong></p><p>单独观察ORDER BY后面的字段，由于不符合“最左匹配原则”，理应不能走联合索引才对。</p><p>加入WHERE后怎么就可以了呢？</p><p>道理其实很简单，比如原本学生的排序是身高、体重、分数：</p><ul><li><p>180cm 65kg 98分</p></li><li><p>182cm 65kg 96分</p></li><li><p>182cm 65kg 97分</p></li><li><p>183cm 62kg 99分</p></li><li><p>184cm 63kg 93分</p></li><li><p>184cm 64kg 95分</p></li></ul><p>虽然ORDER BY b, c看起来不完整，但只要我定死身高为182（WHERE a&#x3D;182），那实际筛选出来的学生其实就是先按体重、再按分数排序的，也就是ORDER BY b, c。</p><p>当没有通过a过滤时，数据整体没有相关性，但被a过滤后，局部数据就呈现相关性。</p><p>但这个“例外”本身还有个例外，就是：WHERE的条件不能是范围查询。</p><p>比如：</p><p>SELECT * FROM table WHERE a&gt;1 ORDER BY b,c;</p><p>这条语句是无法利用联合索引index(a,b,c)排序的，理由同上面讲得一样，a&gt;1筛选出来的结果集并不能保证b,c是预期的顺序。</p><p>上面说过，WHERE height&#x3D;182 ORDER BY weight, score是可以走索引排序的，因为局部范围内能保证走索引排序，而WHERE height&gt;&#x3D;182 ORDER BY weight, score，显然就不满足索引排序。</p><ul><li><p>180cm 65kg 98分</p></li><li><p>182cm 65kg 96分</p></li><li><p>182cm 65kg 97分</p></li><li><p>183cm 62kg 99分</p></li><li><p>184cm 63kg 93分</p></li><li><p>184cm 64kg 95分</p></li></ul><h3 id="最左匹配原则：GROUP-BY"><a href="#最左匹配原则：GROUP-BY" class="headerlink" title="最左匹配原则：GROUP BY"></a>最左匹配原则：GROUP BY</h3><p>这个没什么好说的，GROUP BY其实可以看成两步：<strong>先排序，后归并。</strong></p><p>一般对于GROUP BY的优化，就是尽可能让它也走索引排序。当它和联合索引顺序一致时，GROUP BY会跳过排序，直接归并，从而达到优化的目的。</p><p>后面我们专门安排一个章节，汇总一下优化规则，上面的内容理解即可。</p><h2 id="联合索引的使用场景"><a href="#联合索引的使用场景" class="headerlink" title="联合索引的使用场景"></a>联合索引的使用场景</h2><p>GROUP BY没什么好讲的，可以理解为排序的基础上在进行归并，所以学习联合索引时，主要关注WHERE和ORDER BY即可。</p><h3 id="场景一：多条件查询，提高利用率"><a href="#场景一：多条件查询，提高利用率" class="headerlink" title="场景一：多条件查询，提高利用率"></a>场景一：多条件查询，提高利用率</h3><p>如果发现很多SQL的WHERE条件经常是多个相同的字段，比如SELECT xxx WHERE a,b,c、SELECT xxx WHERE a,b、SELECT xxx WHERE a,c等，此时可以考虑创建联合索引index(a,b,c)。</p><p>这里有几条规则需要注意：</p><ul><li><p>WHERE条件的书写顺序并不影响是否走联合索引。比如WHERE a,b,c和WHERE b,c,a都可以走index(a,b,c)</p></li><li><p>但WHERE b,c是不行的，因为缺少a，而WHERE a,c只能利用部分索引</p></li><li><p>创建索引时，最好把区分度高的排在前面（注意，我说的是创建索引的顺序，而不是WHERE条件的顺序）</p></li></ul><p>第三条需要大家再仔细品味一下，比如要给id_card和name建立联合索引，如果你建的是index(name, id_card)，就会浪费无畏的IO在name查找上：先找到全国同名同姓的，再根据id_card匹配。而如果创建index(id_card, name)，那么id_card是唯一的，区分度极高，基本就是一击必中。</p><h3 id="场景二：避免回表"><a href="#场景二：避免回表" class="headerlink" title="场景二：避免回表"></a>场景二：避免回表</h3><p>上一篇已经介绍过了，如果走辅助索引并回表，就会无端多一次对主键索引的扫描。比如对于只有主键索引和name索引的表执行以下SQL：</p><p>SELECT id, name, age FROM table name&#x3D;’xxxx’，</p><p>由于name索引只包含了id和name，而SELECT的列却是id、name、age，此时MySQL底层不得不回表，拿着id再跑一遍主键索引，把age给捞出来。</p><p>可行的解决办法是：添加联合索引index(name, age)，这样辅助索引上就同时包含id、name、age，可以直接返回。</p><p>当然啦，<strong>并不是只有联合索引才能使用索引覆盖，</strong>只要辅助索引上的字段满足SELECT的列即可，所以即使是单列索引index(name)，也是可以避免回表的，比如SELECT id, name FROM table WHERE name&#x3D;’xxx’。</p><p><strong>但大家要认识到，实际开发索引覆盖可遇不可求，基本还是回表的情况多一些。</strong>比如，即使你定了联合索引index(name, age)，但实际上却是要查询所有列怎么办？此时还是要乖乖回表（好歹走了辅助索引了，知足吧）。</p><h3 id="场景三：索引排序"><a href="#场景三：索引排序" class="headerlink" title="场景三：索引排序"></a>场景三：索引排序</h3><p>当你建了联合索引index(a,b,c)，那么每次增删改都会按这个顺序维护。如果查询是需要的顺序刚好是a,b,c，就可以直接返回数据，无需排序，美其名约“利用索引排序”。</p><p>有个比较特别的地方是，WHERE和ORDER BY可以“联手”玩转联合索引，比如对于index(a,b,c)，并不是只有WHERE a,b,c或者ORDER BY a,b,c才能利用联合索引，WHERE a&#x3D;1 ORDER BY b,c也是可以的~</p><p>讲完了这三个场景，再稍微注意一下联合索引失效的问题即可（只说两个最常用的）：</p><ul><li>最左匹配原则</li><li>注意范围查询，比如WHERE a&gt;1 and b&#x3D;2 and c&#x3D;3，那么就只能用到a啦</li></ul><h3 id="场景四：COUNT统计"><a href="#场景四：COUNT统计" class="headerlink" title="场景四：COUNT统计"></a>场景四：COUNT统计</h3><p>虽说一般大数据量不推荐直接使用COUNT函数，但绝大部分公司都是小公司，一张表不会很大，所以初期COUNT也无妨，但最好尽量走索引。比如要求统计天猫平台下的店主粉丝数量：</p><p>SELECT COUNT(*) FROM t_user_follow WHERE uid&#x3D;123 and platform&#x3D;6 and follow_status&#x3D;1;</p><p>此时最好建立联合索引index(uid, platform, follow_status)，速度会稍微快一些。</p><p>其实场景四不过是联合索引的一个特例，这里单独提出来，就是为了给大家提个醒：哦？COUNT也能用上联合索引啊！</p><h2 id="MySQL的架构图"><a href="#MySQL的架构图" class="headerlink" title="MySQL的架构图"></a>MySQL的架构图</h2><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589599142582-6d0f9da2-d57b-4816-bf63-707f9337fe9d-20210923214721874.png" alt="img"></p><p>看到那个查询优化器了吗，比如index(a,b,c)联合索引，即使我们写成 WHERE a&#x3D;1, c&#x3D;3, b&#x3D;2也能走全索引，就是因为它帮我们优化了顺序。</p><p>好了，虽然上面的内容不一定全部正确，但个人认为利大于弊，起码能让你快速、清晰地理解SQL优化的底层原理，相信大家对于市面上任意的SQL优化课程都能快速吸收。</p><p>如果要用一句话概括SQL优化，应该是下面这句：</p><p>所谓SQL优化，其实就是让查询优化器<strong>根据程序员的意愿</strong>选择匹配的执行计划，最终减少查询中产生的IO。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引的基础原理和创建原则</title>
      <link href="/2020/08/13/MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99/"/>
      <url>/2020/08/13/MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>数据库作为存储和管理数据的核心技术，广泛应用于各类信息系统中。随着数据量的不断增长以及业务复杂性的提高，数据库的性能优化成为至关重要的任务。</p><p>其中，索引作为一种能够显著提升查询效率的数据结构，在数据库操作中扮演着关键角色。然而，许多开发人员和数据库管理员对索引的理解仅停留在表面，未能深入掌握其底层原理和适用场景，导致在实际应用中无法充分发挥索引的优势，甚至可能因不当使用而影响数据库性能。</p><p>本文将从索引的类型、实现方式、创建时机、优缺点以及相关的优化原则等方面进行详细阐述，揭示索引背后的核心原理，为数据库性能优化提供坚实的理论基础。</p><span id="more"></span><h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><p>索引的分类可能有不同维度，这里不追求特别准确的分类，毕竟不是做学术，只要感性认识几种即可。</p><p>打开Navicat，尝试创建索引时会发现有4种索引类型可以选择：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589520399248-9a8373e7-567f-4ab5-9d74-f39ac0bb3332-20210923151215022.png" alt="img"></p><ul><li><p>全文索引</p></li><li><p>普通索引</p></li><li><p>空间索引</p></li><li><p>唯一索引</p></li></ul><p>普通索引就可以组织树结构了，而唯一索引在普通索引的基础上还要求索引列不能重复。比如，假设我们给student表的name列加了唯一索引，如果表中已经存在”张三”，那么再次插入”张三”将会报错。</p><p>MySQL这种关系型数据库并不适合进行全文检索（考虑Elastic Search），所以全文索引一般很少使用。</p><p>至于空间索引，我也不知道是什么。</p><p>实际开发常用的索引只有<strong>普通索引</strong>和<strong>唯一索引</strong>，其他的可以不用理会（主键索引其实相当于唯一索引+非NULL）。</p><h1 id="索引的实现方式"><a href="#索引的实现方式" class="headerlink" title="索引的实现方式"></a>索引的实现方式</h1><p>常见的索引实现方式有两种，通过B+树结构或hash算法实现。</p><p><strong>特别注意，这里虽然写的是”BTREE”，但MySQL确实使用的是B+Tree。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589533482892-ea6a7e77-c129-45e3-8519-827ae57c69c7-20210923151221445.png" alt="img"></p><p>这个概念，其实和上面“索引的类型”并不冲突。</p><p>比如，对于普通索引，我们可以使用B+树的结构组织索引，也可以使用hash算法实现。经过上一篇的学习，我们对B+树结构已经比较了解，所以这里单独聊一下hash索引。</p><p>所谓hash索引，其实就是利用<strong>哈希算法为索引列计算得到唯一的存储地址</strong>，一般来说这个地址是不会重复的（重复的情况被称为哈希冲突）。</p><p>举个燕十八老师说的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589533947057-755cdba3-b196-44cd-88c4-813dc6397463-20210923151227170.png" alt="img"></p><p>在墙上装一根弹性永不衰变的弹簧，每次拿不同的物件把弹簧压到极限后放开，不同的物件最终落点会不同。比如你上回存了一本书，那么下次想要找到这本书时，只需要拿一本<strong>一模一样的书</strong>重新弹一下，即可在本次落点处找到上次那本书。</p><p>数据库hash索引的设计也类似，假设你要存入id&#x3D;10086的数据，就需要通过hash算法对id进行计算，得到一个存储位置后写入数据。下次拿着id&#x3D;10086查询时，只要按同样的算法再次计算，就能马上找到对应的数据，是不是很快呢~</p><p>需要注意的是，弹簧的例子用来比喻hash算法虽然挺形象的，但可能会让人误以为越重的物品落点越近，越轻的物品落点越远，进而得出结论：hash索引可以进行范围查找。</p><p>其实并不是如此。</p><p>hash算法有个比较显著的特征：即使源数据具备一定的相关性，经过hash映射后得到的结果也会变得“很散”，没有规律可循。回到之前的例子中，你可以理解为重量并不是影响书本最终落点的唯一因素，书的材质、形状等都占有一定比例，最终体现到空气阻力上导致落点的不规则。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608951320970-75bcceba-6e55-4737-9e29-8a7da83502b6-20210923151233076.png" alt="img"></p><p>不知道大家还是否记得，在JavaSE阶段接触HashMap时，很多人会发现put的顺序和get的顺序并不一定相同。比如put的顺序是1000克、500克、300克，而get的顺序却是500克、300克、1000克。也就是说，经过hash计算后，数据的相关性会大大减弱。</p><p>所以，当你希望查找500g~1000g的书本时，就无法利用边界值进行范围查找。而B+树<strong>叶子节点是有序链表</strong>，范围查询非常方便。</p><p><strong>hash索引除了无法进行范围查找外，还不能进行模糊搜索。</strong></p><p>hash算法本身代表着精确定位，依赖于计算的入参得出“唯一”的值，所以无法进行模糊匹配。比如，你给我”bravo”，我可以计算唯一的hash值，你给我”bra%”，我会以为这人就叫”bra%”，也计算一个值，<strong>而****这个值代表着”bra%”计算得到的落点，而不是”所有以bra开头的数据”的落点</strong>，显然是不对的。</p><p>但B+树可以进行模糊搜索，你可以姑且认为因为它会顺着树查找，并在装有数据的节点内调用类似Java的String#startWith()方法进行比较。</p><p>hash索引的优劣势</p><ul><li>优势：速度非常快，只需一次计算即可得到地址，时间复杂度O(1)，而B+树是O(logn)</li><li>劣势：不支持模糊查询、范围查询、索引排序（本身就是不规则的，如何利用索引排序呢）</li></ul><p>最后，《实用小算法》中List转HashMap的操作其实就是借鉴了hash索引！</p><h1 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h1><p>索引的创建时机一般有两处：</p><ul><li>起初，建表时顺便建立索引</li><li>后期，修改表结构创建索引（一般都是这样，因为很难未卜先知，提前优化等于瞎优化）</li></ul><p>比如，一开始就创建索引：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589520661369-1d8b2328-8dca-4f08-8fb4-94df84b770b5-20210923151242400.png" alt="img"></p><p>这张表有两个索引：主键索引、auditor_id普通索引。</p><p>主键索引并不属于上面介绍的4种索引类型之一，但所谓的Primary Key可以看做 唯一索引 + NOT NULL约束。</p><p>后期如果需要添加索引，可以通过两种方式：</p><ul><li>SQL语句</li><li>Navicat图形界面</li></ul><p>利用SQL语句添加索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 1.添加PRIMARY KEY（主键索引） </span><br><span class="line">ALTER TABLE `table_name` ADD PRIMARY KEY (`column`) ;</span><br><span class="line">-- 2.添加UNIQUE(唯一索引) </span><br><span class="line">ALTER TABLE `table_name` ADD UNIQUE (`column`);</span><br><span class="line">-- 3.添加INDEX(普通索引) </span><br><span class="line">ALTER TABLE `table_name` ADD INDEX index_name (`column`);</span><br><span class="line">-- 4.添加FULLTEXT(全文索引) </span><br><span class="line">ALTER TABLE `table_name` ADD FULLTEXT (`column`);</span><br><span class="line">-- 5.添加联合索引 </span><br><span class="line">ALTER TABLE `table_name` ADD INDEX index_name (`column1`, `column2`, `column3`);</span><br></pre></td></tr></table></figure><p>在本案例中，可以写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `moneywithdraw` ADD INDEX idx_auditor_id (`auditor_id`);</span><br></pre></td></tr></table></figure><p>利用Navicat图形界面创建<strong>单列索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589521376561-1c62b92e-60ae-4d06-ad73-6cfa4c69101b-20210923151251589.png" alt="img"></p><p>利用Navicat图形界面创建<strong>联合索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589521546600-37ba8127-ad31-4f94-a137-e1986de9354f-20210923151256752.png" alt="img"></p><p>哦，对了，数据量太大的表，不要自己随便加索引，搞不好会锁表哦…后面有机会再说。总之，你可以“懂索引”，但要“动索引”前，最好三思。</p><h1 id="索引的好与坏"><a href="#索引的好与坏" class="headerlink" title="索引的好与坏"></a>索引的好与坏</h1><p>提到索引，很多人就会说：哦，索引能提高查询速度。一般这么说的人，可能学得还不错，但绝对还没有完全掌握索引的底层原理。</p><p>如果你认为索引的优势只是加快查询，那就太小看索引了。</p><p>索引的优势是：</p><ul><li><p>加快查询速度（包括关联查询）</p></li><li><p>加快排序速度（ORDER BY）</p></li><li><p>加快分组速度（GROUP BY）</p></li></ul><p>虽然加快排序、加快分组最终还是体现在加快查询速度上，但能主动意识到这一点算是一种突破。只有当你意识到索引能加快排序和分组，你才会在写ORDER BY和GROUP BY时有意识地利用索引分组和排序（最左匹配原则），从而写出更优的SQL。</p><p>索引的劣势：</p><ul><li><p>创建索引是需要付出代价的，主要体现在维护成本、空间成本和回表成本。也就是说<strong>索引能提高查询效率，但往往会降低增删改的速度</strong>（字典新增几百个字，需要额外编排目录吧，要多占几页纸吧）</p></li><li><p>如果使用了联合索引，还需要考虑索引失效问题（下篇介绍联合索引）</p></li><li><p>太多的索引会增加查询优化器的选择时间（选择太多也麻烦）</p></li></ul><h1 id="建索引的原则"><a href="#建索引的原则" class="headerlink" title="建索引的原则"></a>建索引的原则</h1><p>很多人觉得SQL优化才是重中之重，创建索引只需要一行代码即可，没什么大不了的。但现在你已经知道了索引的优势与劣势，你会明白“在合适的时候、合适的字段建立索引”是多么空泛的口号。创建索引的判断依据究竟是什么呢？</p><p>创建索引有4个大原则：</p><ul><li><p>索引并不是越多越好，联合索引应该优于多个单列索引</p></li><li><p>索引应该建立在区分度高的字段上</p></li><li><p>尽量给查询频繁的字段创建索引，避免为修改频繁的字段创建索引</p></li><li><p>避免重复索引</p></li></ul><p>第一个原则背后的原因是，实际上数据库一次查询只会选择<strong>一棵索引树</strong>（不包括回表），更专业的说法是每次查询只会选择一个执行计划。即使你给a,b,c,d,e,f,g…所有列都加了索引，SELECT xx, xxx FROM table WHERE …时，数据库也只会<strong>择优****选择</strong>一个执行计划进行查询。</p><p>需要注意的是，<strong>每建一个索引，就需要维护一棵索引树，</strong>所以索引绝对不是越多越好，不合适的索引会增加数据库的负担。比如，你已经搞了一个根据拼音查找汉字的目录，又想根据偏旁部首来，那没辙了，只能劳烦您自己再搞一个目录了。</p><p>看到这，你可能会反问：我靠，那MySQL也太笨了吧，为什么这么死心眼一次只利用一个索引？</p><p>比较粗浅的理由是：你根据拼音查完汉字以后，还会根据偏旁部首再查一遍吗？</p><p>比较正经的理由是：按我个人的理解，索引本身的出发点是“走完一遍索引后，数据库应该返回<strong>精确的结果</strong>或<strong>很小的结果集</strong>”，从成本上考虑，此时再走一遍索引还不如直接遍历结果集来得快。当然，要想一次索引就得到精确的结果集，着实需要下一番苦功夫。给哪个字段加索引好呢？我建议，应该尽可能给区分度高的字段添加索引。</p><p>什么是区分度很高？这就是建索引的第二个原则啦。比如，表中有100w学生数据，你如果在sex列加索引，那么根据sex大概只能过滤掉50w数据，剩下的结果集仍然很大，说明这个索引建得不太合适，区分度太低了。</p><p>第三个原则就是字面意思。比如一本字典根据内容编好目录以后，隔三差五地就有新词汇要往里面加，或者经常要修改汉字读音，一顿操作后必然要连累目录，只能重新编排啦。也就是说，为了保证目录能正确指向对应的汉字，每次增删改后都要额外多一个操作：重新修订目录。</p><p>总之要意识到索引在加快查询的同时几乎必然会对修改产生负担，所以创建索引并没有那么简单，它绝对是一门“平衡的艺术”。</p><p>第四个原则是，比如已经建立a索引，又建立index(a,b,c)联合索引，此时单列索引a就是冗余的，因为联合索引已经可以保证符合条件时会利用a索引。<strong>在物理存储上，a单列索引和index(a, b, c)是两个独立的B+树，</strong>重复的索引会增加维护成本。</p><p>以上四个原则，后面的内容还会重新提到。</p><h1 id="MySQL常用引擎"><a href="#MySQL常用引擎" class="headerlink" title="MySQL常用引擎"></a>MySQL常用引擎</h1><p>MySQL的引擎有很多种，但最常听到的就MyISAM和InnoDB，而实际开发几乎99%选择使用InnoDB，而且MySQL5.6还是哪个版本以后默认引擎就从MyISAM变成了InnoDB，所以这里着重介绍InnoDB，简略介绍MyISAM。</p><p>对于两种引擎的介绍，可以看：<a href="https://www.bilibili.com/video/BV1RE41187Yo?p=9">存储引擎简介</a></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589527342910-49ca1484-7ba5-4924-944f-d1008cd46e85-20210923151312836.png" alt="img"></p><p>这里主要想和大家讨论MyISAM和InnoDB在索引组织上的区别。大家应该都已经知道，MyISAM和InnoDB存储数据的方式是不同的。</p><p>MyISAM的每张表在存储时会分为3个文件：</p><ul><li><p>表结构</p></li><li><p>表数据</p></li><li><p>索引</p></li></ul><p>也就是说，表数据和索引是分别独立存储的。</p><p>而InnoDB的表数据在存储时只分为2个文件：</p><ul><li>表结构</li><li>表数据+索引</li></ul><p>需要注意的是，InnoDB所有表的数据和索引都在同一个文件里（见下一个小节）。</p><h1 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h1><p>对于BTREE索引而言，从数据的组织形式来看，索引又可以分为两大类：</p><ul><li>聚簇索引</li><li>非聚簇索引</li></ul><p>所谓聚簇索引，可以简单理解为索引和数据是“聚合”在一起的，而非聚簇索引的数据和索引是分开的。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589532501128-7bf641bd-946e-446b-9a0f-a581b3f13887-20210923151325454.png" alt="img"></p><p>根据InnoDB引擎的<strong>主键索引</strong>查询时无需回表，每一行完整的数据都直接挂在叶子节点下，可以直接返回。也就是说，对于InnoDB的<strong>主键索引</strong>而言，数据即索引，索引即数据。<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589586538060-89e3781c-22ed-4b16-a734-d5466af2d6aa-20210923151335790.png" alt="img"></p><p>MyISAM不是很重要，不提了。</p><p>InnoDB的索引也并不是都不需要回表，根据是否需要回表其实可以分为两类：主键索引、辅助索引（或者叫二级索引、普通索引）。</p><p>会什么要做这种区分呢？</p><p>假设一个场景：</p><p>新建一张表后，自然会产生主键索引。但后期发现name字段查询很频繁，于是加了name索引。</p><p><strong>如果name索引也和主键索引一样挂着数据，那么两个索引数据就会重复。想象一下，现在磁盘中有一颗叫name的树和一棵叫id的树，一个以name为节点，一个以id为节点，相同的是最底层叶子节点都挂着完整的表数据。也就是说，磁盘中存了两份一模一样的student数据。且不说数据冗余，更新时还可能产生数据不一致（要同步数据，确保多张表的数据一致性）。</strong></p><p>所以InnoDB的做法是，辅助索引只存储索引列+主键，必要时进行“回表”操作：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589536446002-5fddd16a-59f2-4928-b10e-088aaa01f927-20210923151343933.png" alt="img"></p><p>由于SELECT * FROM stu WHERE name&#x3D;’bravo’中，查询的数据是*，也就是整行数据。而上面的辅助索引只存了主键+name，所以必须回表：拿着主键再去跑一遍主键索引，最终返回整行数据。</p><p>现在，我们可以给MyISAM和InnoDB的索引分类做个简单的总结：</p><ul><li><p>MyISAM：非聚簇索引，需要回表</p></li><li><p>InnoDB：</p></li><li><ul><li>聚簇索引：主键索引，叶子节点是表数据，不需要回表</li><li>非聚簇索引：辅助索引（唯一索引、普通索引），叶子节点是主键，必要时需要根据主键回表查询</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608956710604-75cdbc20-a59e-473f-9e98-b963ac3cd49d-20210923151351478.png" alt="img"></p><p>InnoDB每张表只能有一个主键索引，辅助索引则可以有多个。表数据只有一份，挂在主键索引下面。</p><p>需要注意的是，如有可能，应该尽量避免回表。<strong>SQL优化的本质其实就是减少&#x2F;减小磁盘IO</strong>，而回表必然会增加磁盘IO次数。</p><p>举个例子，假设某张表总共就两棵索引树：主键索引+name辅助索引，两棵树高度都是3。由于只有主键索引下才挂着表数据，所以对于SELECT * FROM table WHERE name&#x3D;’xxx’来说，需要先走辅助索引取得id，再根据id走一遍主键索引。假设两棵树需要的数据都在第三层，那么这条SQL需要进行6次逻辑IO访问。而如果直接根据id查询，就可以直接走主键索引，IO次数为3。</p><p>所以，<strong>通常情况下</strong>辅助索引查询都是需要回表的，比主键索引查询多扫描一棵索引树（自身+主键索引），实际编写SQL时，应该尽量走主键索引。</p><p>那么，<strong>什么情况下</strong>辅助索引可以避免回表吗？</p><h1 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h1><p>索引覆盖这个名字，咋一听不知所云，所以很多初学者一直搞不明白什么意思，其实它最大的作用就是：避免回表。</p><p>下面通过一个案例来说明。</p><p>假设有个需求：前端需要支持<strong>根据用户名模糊搜索订单，</strong>而页面需要的字段如下。</p><table><thead><tr><th><strong>id</strong></th><th><strong>productName</strong></th><th><strong>price</strong></th><th><strong>userName</strong></th><th><strong>userAge</strong></th></tr></thead><tbody><tr><td>1</td><td>iphone12</td><td>5999</td><td>bravo1988</td><td>18</td></tr></tbody></table><p>一个可行的方案是：</p><ol><li><p>在t_user表中根据name搜索用户，得到user_id、user_name、user_age</p></li><li><p>在t_order表中根据user_id查询订单</p></li><li><p>在内存中根据user_id匹配order和user数据后返回</p></li></ol><p>由于t_user表此时的查询条件是user_name，为了加快t_user表的查询速度，可以给user_name加普通索引。但，这样真的好吗？我劝！不要犯这样的聪明，小聪明啊。</p><p>你要知道，此时我们从t_user表查询的可不止user_name，还有user_age和id。如果只是给user_name加了索引，那么此时磁盘中产生的索引树是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610162572296-97295d9c-ab7c-444b-a99a-6c8ea8f106eb-20210923151400366.png" alt="img"></p><p>这棵树的非叶子节点是user_name，叶子节点是id，<strong>也就是说从这棵树上我们只能得到user_name和user_id</strong>，至于user_age，MySQL底层只能跳出name索引树，然后跑到隔壁主键索引获取。整个过程被称为回表，而回表意味着多跑一趟。</p><p>此时我们可以给user_name和user_age加一个联合索引，这样就能产生所谓的“索引覆盖”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610162521710-d2586c99-f888-4db1-b713-3a69dc59028d-20210923151409810.png" alt="img"></p><p>当辅助索引上的字段完全满足本次查询的列时，就是所谓的索引覆盖，这是一个好消息，意味着不需要回表，查询效率将会大大提高。这也是为什么SQL优化原则中经常会强调：尽量只取必要的字段，避免SELECT *（提高索引覆盖的几率，查询的字段越多，几率越低）。</p><p>即使目前表中只有两个字段且已经索引覆盖，也不要写SELECT *。因为后期随着业务扩展，这张表会新增其他字段，此时SELECT *将不再覆盖索引！</p><p>为了方便记忆，大家可以把索引覆盖理解为 索引的字段 &gt;&#x3D; 查询需要的字段。比如联合索引的字段是index(a,b,c)，那么此时SELCT a, b就会发生索引覆盖，索引覆盖最大的好处是避免回表。</p><p>需要强调的是，覆盖索引和联合索引没有必然关系。比如我只给user_name加单索引，而我查询语句是</p><p>SELECT id, user_name FROM t_user WHERE name&#x3D;’bravo’;</p><p>此时也是索引覆盖。所以，<strong>能否索引覆盖不取决于索引单方面，需要查询配合。</strong></p><p>关于联合索引，我们放在下一篇介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络传输协议</title>
      <link href="/2020/07/29/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/07/29/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>在众多的传输层协议中，TCP（传输控制协议）和 UDP（用户数据报协议）无疑是最为重要和常用的两种协议。它们的设计目标和特性截然不同，以满足不同应用场景下的多样化需求。TCP 协议以其面向连接、可靠传输的特性，成为了许多对数据准确性和完整性要求较高的应用的首选。例如，在文件传输过程中，用户期望文件能够完整无误地从源端传输到目的端，任何数据丢失或错误都可能导致文件损坏无法使用，TCP 通过其复杂的连接建立、数据确认、重传机制等确保了数据的可靠交付；在电子邮件的发送和接收中，同样不容许邮件内容在传输过程中出现丢失或篡改，TCP 的可靠性保证了邮件的准确传递。</p><p>UDP 协议则以其简洁高效、低延迟的特点，在对实时性要求较高的应用场景中发挥着重要作用。例如，在即时通讯应用中，如 QQ 语音和视频通话，用户更注重信息的即时传递，少量的数据丢失或错误在一定程度上可以被接受，但如果传输延迟过高，通话将变得卡顿，严重影响用户体验，UDP 的无连接特性使得它能够快速地将数据发送出去，减少了建立和维护连接的开销，从而降低了延迟；在线直播领域也是如此，观众希望能够实时观看主播的画面和声音，UDP 能够满足这种对实时性的严格要求。</p><span id="more"></span><p>💦 <strong>用户数据报协议 UDP</strong>（User Datagram Protocol）：</p><ul><li><strong>UDP 在传送数据之前不需要先建立连接</strong>，远程主机在收到 UDP 报文后，不需要给出任何确认。</li><li>虽然 UDP <strong>不提供可靠交付</strong>，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等</li></ul><p>💦 <strong>传输控制协议 TCP</strong>（Transmission Control Protocol）：</p><ul><li>TCP 提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 不提供广播或多播服务。由于 TCP 要提供<strong>可靠</strong>的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</li><li>TCP <strong>一般用于文件传输、发送和接收邮件、远程登录等场景</strong>。</li></ul><h2 id="2-TCP-报文段首部格式"><a href="#2-TCP-报文段首部格式" class="headerlink" title="2. TCP 报文段首部格式"></a>2. TCP 报文段首部格式</h2><p>TCP 报文段的具体格式大家可以不必都记住，但是其中的几个<strong>控制位</strong>与我们接下来要讲的三次握手和四次挥手息息相关，大家一定要牢记。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144029349" alt="图片"></p><p>首部固定部分各字段意义如下：</p><ul><li><p>1 - <strong>源端口和目的端口</strong>：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址</p></li><li><p>2 - <strong>序号&#x2F;序列号</strong>（Sequense Number，SN）：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。<strong>初始序号称为 Init Sequense Number, ISN</strong>（序号&#x2F;序列号这个字段很重要，大家留个印象，下文会详细讲解）</p><p>例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。</p></li><li><p>3 - <strong>确认号 ack</strong>：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。</p></li><li><p>4 - <strong>数据偏移</strong>（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。</p></li><li><p>5 - <strong>保留</strong>：占 6 位，应置为 0，保留为今后使用。</p></li></ul><p>⭐ 大家看上图，保留位的右边还有 6 个控制位（重要），这是TCP 用来说明该报文段性质的：</p><ul><li><p><strong>紧急位 URG</strong>：当 URG &#x3D; 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。该控制位需配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）</p><p>举个例子：我们需要取消一个已经发送了很长程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这个指令将存储在接收 TCP 的缓存末尾，只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程，这样做就无法实现立即中断。</p></li><li><p><strong>确认 ACK</strong>：仅当 ACK &#x3D; 1 时确认号字段才有效，当 ACK &#x3D; 0 时确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</p></li><li><p><strong>推送 PSH</strong>：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。</p></li><li><p><strong>复位 RST</strong>：当 RST &#x3D; 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。</p></li><li><p><strong>同步 SYN</strong>：SYN &#x3D; 1 表示这是一个连接请求或连接接受报文。</p><p>当 SYN &#x3D; 1 而 ACK &#x3D; 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN &#x3D; 1 且 ACK &#x3D; 1。</p></li><li><p><strong>终止 FIN</strong>：用来释放一个连接。当 FIN &#x3D; 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p></li></ul><h2 id="3-TCP-三次握手建立连接"><a href="#3-TCP-三次握手建立连接" class="headerlink" title="3. TCP 三次握手建立连接"></a>3. TCP 三次握手建立连接</h2><h3 id="①-三次握手过程详解"><a href="#①-三次握手过程详解" class="headerlink" title="① 三次握手过程详解"></a>① 三次握手过程详解</h3><p>三次握手的原文是 <code>three-way handshake</code>，整个名词的可以翻译为：<strong>需要三个步骤才能建立握手&#x2F;连接的机制</strong>。当然，三次握手也可以叫 <code>three-message handshake</code>，通过三条消息来建立的握手&#x2F;连接。</p><p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的 <strong>初始化序列号(Init Sequense Number,  <code>ISN</code>)</strong> 为后面的可靠性传输做准备。</p><p>三次握手过程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144034490" alt="图片"></p><p>回顾一下图中字符的含义：</p><ul><li><code>SYN</code>：连接请求&#x2F;接收 报文段</li><li><code>seq</code>：发送的第一个字节的序号</li><li><code>ACK</code>：确认报文段</li><li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p><strong>刚开始客户端处于 <code>Closed</code> 的状态，而服务端处于 <code>Listen</code> 状态</strong>：</p><blockquote><p><code>CLOSED</code>：没有任何连接状态</p><p><code>LISTEN</code>：侦听来自远方 TCP 端口的连接请求</p></blockquote><p><strong>1）第一次握手</strong>：客户端向服务端发送一个 SYN 报文（SYN &#x3D; 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq &#x3D; x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 <code>SYN_Send</code> 状态。</p><blockquote><p><code>SYN-SENT</code> ：在发送连接请求后等待匹配的连接请求</p></blockquote><p><strong>2）第二次握手</strong>：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN &#x3D; 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq &#x3D; y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 <code>SYN_REVD</code> 的状态。</p><blockquote><p><code>SYN-RECEIVED</code>：在收到和发送一个连接请求后等待对连接请求的确认</p></blockquote><p><strong>3）第三次握手</strong>：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq &#x3D; x + 1（初始为 seq &#x3D; x，所以第二个报文段要 +1），此时客户端处于 <code>Establised</code> 状态。</p><p>服务器收到 ACK 报文之后，也处于 <code>Establised 状态</code>，至此，双方建立起了 TCP 连接。</p><blockquote><p><code>ESTABLISHED</code>：代表一个打开的连接，数据可以传送给用户</p></blockquote><h3 id="②-为什么要三次握手"><a href="#②-为什么要三次握手" class="headerlink" title="② 为什么要三次握手"></a>② 为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的</strong>。</p><p>只有经过三次握手才能确认双发的收发功能都正常，缺一不可：</p><ul><li><p>第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常</p></li><li><p>第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：</p><p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p><p>服务器确认了：对方发送正常，自己接收正常</p></li><li><p>第三次握手（客户端发送 ACK 报文给服务器）：</p><p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p><p>服务器确认了：自己发送、接收正常，对方发送、接收正常</p></li></ul><h3 id="③-ISN-Initial-Sequence-Number-是固定的吗"><a href="#③-ISN-Initial-Sequence-Number-是固定的吗" class="headerlink" title="③ ISN (Initial Sequence Number) 是固定的吗"></a>③ ISN (Initial Sequence Number) 是固定的吗</h3><p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据</strong>。</p><p>当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。<strong>如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的</strong>。</p><h3 id="④-三次握手过程中可以携带数据吗"><a href="#④-三次握手过程中可以携带数据吗" class="headerlink" title="④ 三次握手过程中可以携带数据吗"></a>④ 三次握手过程中可以携带数据吗</h3><p>第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手绝对不可以携带数据</strong></p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>⭐ <strong>简单的记忆就是，请求连接&#x2F;接收 即 <code>SYN = 1</code> 的时候不能携带数据</strong></p><p>而对于第三次的话，此时客户端已经处于 <code>ESTABLISHED</code> 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送&#x2F;携带数据了。</p><h3 id="⑤-半连接队列"><a href="#⑤-半连接队列" class="headerlink" title="⑤ 半连接队列"></a>⑤ 半连接队列</h3><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code> 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>当然还有一个<strong>全连接队列</strong>，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><h3 id="⑥-SYN-洪泛攻击"><a href="#⑥-SYN-洪泛攻击" class="headerlink" title="⑥ SYN 洪泛攻击"></a>⑥ SYN 洪泛攻击</h3><p>SYN 攻击就是 <strong>Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包</strong>，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</p><h3 id="⑦-如果第三次握手丢失了，客户端服务端会如何处理"><a href="#⑦-如果第三次握手丢失了，客户端服务端会如何处理" class="headerlink" title="⑦ 如果第三次握手丢失了，客户端服务端会如何处理"></a>⑦ 如果第三次握手丢失了，客户端服务端会如何处理</h3><p>服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><h2 id="4-TCP-四次挥手释放连接"><a href="#4-TCP-四次挥手释放连接" class="headerlink" title="4. TCP 四次挥手释放连接"></a>4. TCP 四次挥手释放连接</h2><h3 id="①-四次挥手过程详解"><a href="#①-四次挥手过程详解" class="headerlink" title="① 四次挥手过程详解"></a>① 四次挥手过程详解</h3><p>建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的<strong>半关闭</strong>（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 连接的释放需要发送四个包（执行四个步骤），因此称为四次挥手(<code>Four-way handshake</code>)，<strong>客户端或服务端均可主动发起挥手动作</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144040116" alt="图片"></p><p>回顾一下上图中符号的意思：</p><ul><li><code>FIN</code> ：连接终止位</li><li><code>seq</code>：发送的第一个字节的序号</li><li><code>ACK</code>：确认报文段</li><li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p>刚开始双方都处于<code>ESTABLISHED</code> 状态，假设是客户端先发起关闭请求。四次挥手的过程如下：</p><p><strong>1）第一次挥手</strong>：客户端发送一个 FIN 报文（请求连接终止：FIN &#x3D; 1），报文中会指定一个序列号 seq &#x3D; u。并<strong>停止再发送数据，主动关闭 TCP 连接</strong>。此时客户端处于 <code>FIN_WAIT1</code> 状态，等待服务端的确认。</p><blockquote><p><code>FIN-WAIT-1</code> - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></blockquote><p><strong>2）第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。</p><blockquote><p><code>CLOSE-WAIT</code> - 等待从本地用户发来的连接中断请求；</p></blockquote><p><strong>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放</strong>。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待 2）状态，等待服务端发出的连接释放报文段。</p><blockquote><p><code>FIN-WAIT-2</code> - 从远程TCP等待连接中断请求；</p></blockquote><p><strong>3）第三次挥手</strong>：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态，等待客户端的确认。</p><blockquote><p><code>LAST-ACK</code> - 等待原来发向远程TCP的连接中断请求的确认；</p></blockquote><p><strong>4）第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack &#x3D; w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq&#x3D;u+1），此时客户端处于 <strong><code>TIME_WAIT</code> （时间等待）状态</strong>。</p><blockquote><p><code>TIME-WAIT</code> - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></blockquote><p>🚨 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，<strong>需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 <code>CLOSED</code> 状态</strong>（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 <code>CLOSED</code> 状态。</p><h3 id="②-为什么要四次挥手"><a href="#②-为什么要四次挥手" class="headerlink" title="② 为什么要四次挥手"></a>② 为什么要四次挥手</h3><p>由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就<strong>完全关闭</strong>了TCP连接。</p><p><strong>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手</strong>。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis哨兵模式</title>
      <link href="/2020/05/22/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/22/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在分布式系统中，单点故障可能导致整个系统的瘫痪，影响用户体验和业务正常运转。传统的主从模式虽然在一定程度上提高了可用性，但主服务器宕机时仍需手动切换从服务器为主服务器，这一过程不仅耗时费力，还会造成服务中断。</p><p>为了克服这些问题，Redis 哨兵模式应运而生。它提供了一种自动化的故障检测和转移机制，能够实时监控 Redis 实例的运行状态，在主服务器发生故障时自动将从服务器切换为主服务器，并通过发布订阅模式通知其他从服务器进行相应配置更新，确保整个 Redis 集群的持续稳定运行。</p><p>这种模式大大提高了 Redis 服务的可靠性和容错能力，使得企业能够更好地应对高并发、大数据量的业务场景，保障系统的不间断服务，满足用户对系统性能和稳定性的严格要求。</p><span id="more"></span><h3 id="一、哨兵模式概述"><a href="#一、哨兵模式概述" class="headerlink" title="一、哨兵模式概述"></a>一、哨兵模式概述</h3><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/sen1.png"></p><p>这里的哨兵有两个作用</p><ul><li><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</p></li><li><p>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</p></li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p>用文字描述一下<strong>故障切换（failover）</strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><hr><h3 id="二、Redis配置哨兵模式"><a href="#二、Redis配置哨兵模式" class="headerlink" title="二、Redis配置哨兵模式"></a>二、Redis配置哨兵模式</h3><p>配置3个哨兵和1主2从的Redis服务器来演示这个过程。</p><p>| 服务类型  |是否是主服务器 |ip地址| 端口|<br>| :——— | :———— | :———— | :———— | :———— |<br>|redis|是|192.168.11.128|6379|<br>|redis|否|192.168.11.129|6379|<br>|redis|否|192.168.11.130|6379|<br>|sentinel|-|192.168.11.128|26379|<br>|sentinel|-|192.168.11.129|26379|<br>|sentinel|-|192.168.11.130|26379|</p><p><img src="https://cdn.jsdelivr.net/gh/RYAN-CODE0/pic/redis/sen2.png"></p><p>首先配置Redis的主从服务器，修改redis.conf文件如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使得Redis服务器可以跨网络访问</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"># 设置密码</span><br><span class="line">requirepass &quot;123456&quot;</span><br><span class="line"># 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span><br><span class="line">slaveof 192.168.11.128 6379</span><br><span class="line"># 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><p>上述内容主要是配置Redis服务器，从服务器比主服务器多一个slaveof的配置和密码。</p><p>配置3个哨兵，每个哨兵的配置都是一样的。在Redis安装目录下有一个sentinel.conf文件，copy一份进行修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 禁止保护模式</span><br><span class="line">protected-mode no</span><br><span class="line"># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span><br><span class="line">sentinel monitor mymaster 192.168.11.128 6379 2</span><br><span class="line"># sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span><br><span class="line"># sentinel auth-pass <span class="tag">&lt;<span class="name">master-name</span>&gt;</span> <span class="tag">&lt;<span class="name">password</span>&gt;</span></span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure><p>上述关闭了保护模式，便于测试。</p><p>有了上述的修改，我们可以进入Redis的安装目录的src目录，通过下面的命令启动服务器和哨兵</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 启动Redis服务器进程</span><br><span class="line">./redis-server ../redis.conf</span><br><span class="line"># 启动哨兵进程</span><br><span class="line">./redis-sentinel ../sentinel.conf</span><br></pre></td></tr></table></figure><p>注意启动的顺序。首先是主机（192.168.11.128）的Redis服务进程，然后启动从机的服务进程，最后启动3个哨兵的服务进程。</p><hr><h3 id="三、Java中使用哨兵模式"><a href="#三、Java中使用哨兵模式" class="headerlink" title="三、Java中使用哨兵模式"></a>三、Java中使用哨兵模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Redis哨兵模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSentinels</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSentinel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">5</span>);</span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 哨兵信息</span></span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;192.168.11.128:26379&quot;</span>,</span><br><span class="line">                <span class="string">&quot;192.168.11.129:26379&quot;</span>,<span class="string">&quot;192.168.11.130:26379&quot;</span>));</span><br><span class="line">        <span class="comment">// 创建连接池</span></span><br><span class="line">        <span class="type">JedisSentinelPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(<span class="string">&quot;mymaster&quot;</span>, sentinels,jedisPoolConfig,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取客户端</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource();</span><br><span class="line">        <span class="comment">// 执行两个命令</span></span><br><span class="line">        jedis.set(<span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;myvalue&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;mykey&quot;</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是通过Jedis进行使用的，同样也可以使用Spring进行配置RedisTemplate使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;poolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 最大空闲数 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 最大连接数 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 最大等待时间 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;poolConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;sentinelConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sentinelConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- JDK序列化器 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdkSerializationRedisSerializer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- String序列化器 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stringRedisSerializer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;keySerializer&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;stringRedisSerializer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultSerializer&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;stringRedisSerializer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;valueSerializer&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdkSerializationRedisSerializer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 哨兵配置 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sentinelConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.RedisSentinelConfiguration&quot;</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 服务名称 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;master&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mymaster&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 哨兵服务IP和端口 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sentinels&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;host&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.11.128&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26379&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;host&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.11.129&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26379&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.RedisNode&quot;</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;host&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.11.130&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26379&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、哨兵模式的其他配置项"><a href="#四、哨兵模式的其他配置项" class="headerlink" title="四、哨兵模式的其他配置项"></a>四、哨兵模式的其他配置项</h3><table><thead><tr><th align="left">配置项</th><th align="left">参数类型</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">port</td><td align="left">整数</td><td align="left">启动哨兵进程端口</td></tr><tr><td align="left">dir</td><td align="left">文件夹目录</td><td align="left">哨兵进程服务临时文件夹，默认为&#x2F;tmp，要保证有可写入的权限</td></tr><tr><td align="left">sentinel down-after-milliseconds</td><td align="left">&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td align="left">指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）</td></tr><tr><td align="left">sentinel parallel-syncs</td><td align="left">&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td><td align="left">指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高</td></tr><tr><td align="left">sentinel failover-timeout</td><td align="left">&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td align="left">指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟</td></tr><tr><td align="left">sentinel notification-script</td><td align="left">&lt;服务名称&gt;&lt;脚本路径&gt;</td><td align="left">指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，比较常用</td></tr></tbody></table><p>sentinel down-after-milliseconds配置项只是一个哨兵在超过规定时间依旧没有得到响应后，会自己认为主机不可用。对于其他哨兵而言，并不是这样认为。哨兵会记录这个消息，当拥有认为主观下线的哨兵达到sentinel monitor所配置的数量时，就会发起一次投票，进行failover，此时哨兵会重写Redis的哨兵配置文件，以适应新场景的需要。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引与B+树</title>
      <link href="/2020/04/11/%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/"/>
      <url>/2020/04/11/%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>对于60%的程序员而言，Java的三层架构Controller、Service、Dao可以说是“越往后走天越黑”，特别是到了Dao层，提着灯笼也只能看到脚边一米开外的河边小石子，只闻对岸风啸马嘶却不知到底是人是鬼，只能借着MyBatis或JPA这些ORM框架隔着宽宽的河举行一场又一场的刺刀战，你砍我一刀，我刺你一剑。</p><p>诚然，很多人对MySQL数据库的印象就是一个模糊的大铁柜，闭上眼睛深吸一口气仿佛还能嗅到一股铁锈味。只知柜子里藏着很多张表，表里面存着很多行数据，再详细一点的呢？不知道。</p><p>MySQL有太多太多细节，根本无法用四、五篇文章说透，但我仍希望这个系列的文章能成为非常好的入门教程，让从来没接触过SQL优化的同学也能快速建立较为系统的知识框架，方便日后学习其他专栏时进一步拓展。</p><span id="more"></span><hr><h1 id="柏青哥"><a href="#柏青哥" class="headerlink" title="柏青哥"></a>柏青哥</h1><p>大家小时候在游戏厅看过下面这种机器吗：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589354675837-5eaba89f-fb57-4fdf-aa7e-80573ada61a6-20210923150439959.png" alt="img"></p><p>日本人管它叫柏青哥（パチンコ），玩法是：</p><p>从机器最上方的唯一入口投入一颗钢珠，由于重力的作用，钢珠会往下落。机器是直立的，面板上有很多突出的圆柱，它们的作用是随机改变钢珠的落点。最终，钢珠掉落在下方的某个槽中。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589355808319-788e3454-19ae-4c57-9707-b68edc99f05c-20210923150137448.png" alt="img"></p><p>这里提柏青哥，是为后面的B+树及分析B+树搜索过程做铺垫。到时你会发现，沿着索引树搜索的过程和柏青哥小钢珠的下落过程是多么相似！</p><p>很多人都听过数据库索引，但是很少人会去思考下面几个问题：</p><ul><li><p>索引是什么</p></li><li><p>为什么需要索引</p></li><li><p>索引怎么起作用</p></li></ul><p>在历史的长河中，索引的出现几乎是必然的。不信？那就跟我重走一遍历史吧。</p><p>请大家先忘了MySQL、Oracle等乱七八糟的玩意儿，就假设你是上世纪第一批程序员，此时连正儿八经的数据库都没有，需要由你来开天辟地。目前摆在你面前的最大难题是：如何较为<strong>高效地</strong>存取数据？</p><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p>最直观的想法就是存“格子”里，也就是将数据存在线性结构的容器中，比如数组或链表。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589356217794-f7c00e60-53e2-447d-a2b5-2c97d4726d0c-20210923150143937.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589357468320-10555c9b-b1f5-41a7-922d-73ea4f70c03c-20210923150149784.png" alt="img"></p><p>用线性结构存储数据<strong>短期</strong>看是没问题的，但是一家名为SUN的公司发现，随着公司业务增长，平台要经手的用户数据越来越多，特别是今年，他们收到了很多客户的信件投诉，说网页数据的加载越来越慢了！</p><p>SUN的工程师做了个实验，一个线性表如果存了42亿条数据，想要找到id&#x3D;100的数据，游标只需爬99格即可返回，但如果id&#x3D;10000000，就要爬将近1000w个格子才能返回。对于这42亿条数据，平均查询次数是21亿次！！</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>作为改进，有人提出用树结构来存储数据。比如，如果要找id&#x3D;6的数据，那么只要比较3次，小于爬格子次数（5次）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358245965-f357a5d0-90fc-49e7-affe-8cfa11a2243d-20210923150156142.png" alt="img"></p><p>如果要找id&#x3D;9的数据，只要比较4次，小于爬格子次数（8次）。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358394072-a5d5f642-25e5-4d01-ba52-ba7251609d4a-20210923150201825.png" alt="img"></p><p>结合两次实验，SUN的工程师发现：</p><p>在一棵树中找到目标数据所需的比较次数 &#x3D; 目标数据所在的层级</p><p>如果用一棵树来存储42亿条数据，即232&#x3D;42亿，树的层级是32，最差的情况也只要查32次（需要是二叉平衡树），远远小于线性结构的平均21亿次，这是非常夸张的。</p><p>注意，在线性结构的案例中，不是我故意不用二分查找，而是不能使用二分查找。一般来说，<strong>对于线性结构的数据集合，如果要使用二分查找，那么整个数据都要事先在内存中，</strong>但显然没人会这样做！相比在内存中对线性结构进行二分查找，树在逻辑上天然支持二分查找。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608365614192-1f7e343b-f3fc-4dd6-b4c7-90d64f7569d9-20210923150207584.png" alt="img"></p><p>然而，树结构也分好几种：</p><ul><li><p>Binary Search Tree（二叉查找树）</p></li><li><p>AVL Tree（二叉平衡树）</p></li><li><p>B Tree（平衡树）</p></li><li><p>B+ Tree（大名鼎鼎的B+树，对B Tree的改进）</p></li><li><p>…</p></li></ul><p>大家可以访问<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a>这个网站动手玩一下，特别注意上面的4种树：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589360823134-4c779906-c5d8-4ea4-ab72-47af54d8af3c-20210923150214447.png" alt="img"></p><p>如果你听我的建议，打开上面的网站选择Binary Search Tree并按1,2,3,4…的顺序插入数据时，<strong>它其实变成了线性结构：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358856443-e8032dc1-b241-4f23-9c43-883c36b3b25e-20210923150222903.png" alt="img"></p><p>显然，这不是我们想要的结果，因为刚才已经讨论过，线性结构不适合存储大数据，等后期数据量大了以后要爬很多“格子”。</p><h1 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h1><p>相比来说，AVL Tree更符合SUN工程师的需求：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358993173-e6bd2cc0-279a-4d98-8fdc-68abf82b2744-20210923150229048.png" alt="img"></p><p>二叉平衡树会在数据插入完毕后<strong>自动调整节点，好让“树的层级”不至于太深。（赶紧去动手玩一下）</strong></p><p>按理来说，如果我们按二叉平衡树组织表数据的话，应该是非常完美的。你想啊，42亿数据中找一条记录最多只需比较32次，尤其是对于CPU来说，<strong>别说32次比较，哪怕32w次简单数据的比较都不会超过0.1秒。</strong>但是！问题在于这里所谓的“32w次简单数据的比较不会超过0.1秒”有个前提条件：<strong>数据必须全部在内存中。</strong></p><p>而我们的表数据因为数据量很大，而且需要持久化，所以一般来说是存在磁盘中，等需要使用时再从磁盘载入内存，也就是涉及磁盘-内存的IO操作。</p><p>通常情况下，没有人会直接把500w行数据一次性加载到内存中进行二分查找，内存极有可能顶不住（同时访问多张表，全部加载）。所以，最终我们组织数据库的方式只能是：</p><ul><li><p>把数据存在磁盘中</p></li><li><p>数据按树结构组织</p></li><li><p>查询时分块读取数据并比较，持续进行磁盘IO读取节点，直到找到目标数据</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608365864685-03842132-d684-4a5b-9ca8-42ceb43181f7-20210923150235370.png" alt="img"></p><p>每一个节点存储“一小块数据”，分多次IO读取每一块数据到内存判断，直到找到匹配的数据。</p><h1 id="二叉平衡树与磁盘IO"><a href="#二叉平衡树与磁盘IO" class="headerlink" title="二叉平衡树与磁盘IO"></a>二叉平衡树与磁盘IO</h1><p>数据存在磁盘中，没问题。</p><p>数据桉树结构组织，没问题。</p><p><strong>查询时分块读取数据，有一点点问题。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589361951577-71cfd4b1-bfd8-44cc-a968-5de2d821fe2b-20210923150241680.png" alt="img"></p><p>磁盘IO是非常耗时的操作，耗时到什么程度呢？大家可能都听过各个语言的执行效率：</p><p>C &gt; C++ &gt; Java &gt;&gt; Python</p><p>但这些都是在内存层面谈论语言自身的执行效率，而实际上开发一个Web应用，无论用上述哪个语言，对于普通应用而言，都是可以满足用户需求的，真正的瓶颈是IO（网络IO和磁盘IO）。就好比F1赛车、奥迪A4和拖拉机一起跑在北京4环的路上，限制它们的不是引擎，而是堵车。</p><p>所以，二叉平衡树虽然查找42亿数据最多只需32次，但是32次磁盘IO还是不能接受的。</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>基于上面的分析，如果考虑磁盘IO，那么原本优秀的二叉平衡树将显得不再那么优秀。错的不是二叉平衡树，而是我们没有那么大的内存，也不方便把数据都放内存（考虑数据丢失与持久化）。</p><p>但现在不是考虑谁对谁错的时候，要想优化当前数据库，关键是减少磁盘IO次数，<strong>而影响IO次数的关键因素就是树的层级（深度）！</strong>举个例子，如果目标数据在第二层，那么只要比较到第二层，就找到目标数据直接返回，不用再继续磁盘IO读取下一个节点。而如果数据在32层，那么就需要进行32次磁盘IO，比较到最后一层的节点。</p><p>那么，如何减少树的层级呢（让树变矮）？</p><p>请大家思考一下232中的“2”指的是什么？</p><p>其实就是“二叉平衡树”的“二”，而指数32代表树的层级。也就是说，如果以二叉平衡树的结构组织42亿行数据，那么树的深度是32。如果是“三叉平衡树”呢？</p><p>3?? &#x3D; 232 </p><p>3的指数大概为21。也就是说，如果用“三叉树”组织数据，那么层级将会减少到21，也就意味着磁盘IO次数最多为21次。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589362752238-4daa5676-b2c3-419f-9016-a3cf84bb057f-20210923150255800.png" alt="img"></p><p>所以，到这里我们已经有答案了：要想减少二叉平衡树的磁盘IO次数，需要增加它的“叉”，变成“N叉平衡树”，从而减少树的深度。</p><p>此时有位长者说了一句：你们心里没点B树吗。</p><p>听到这，SUN的工程师颇受启发：对哦，直接用B树就好了。</p><p>B树有个“阶”的概念，比如“三叉平衡”的B树其实叫“3阶B树”。</p><p>通过上面的图，我们会发现“N阶B树”<strong>每个节点可以存N-1个数据</strong>（二叉平衡树每个节点只存1个数据），且每个节点至多可以连接N个子节点。</p><p>这样组织的好处是，<strong>每次加载一个节点时都可以从磁盘带出更多条数据，从而减少磁盘IO的次数。</strong>比如原先比完id&#x3D;3，接下来要和id&#x3D;5比较，需要再从磁盘中把id&#x3D;5的数据读出来。而现在当前节点已经有id&#x3D;3,id&#x3D;5的数据了，直接比较即可，无需做磁盘IO。</p><p>这是典型的“空间换时间”。</p><p>但B树最难的地方不是结构本身，而是如何实现这种结构，尤其是如何通过B树组织数据库的表数据？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589370021227-2ce244b2-e5de-4aeb-8a57-5cfb81109d80-20210923150305159.png" alt="img"></p><p>举个例子，当我要找id&#x3D;7的数据时，需要先找到根节点，和id&#x3D;4的节点比较，由于7&gt;4，所以选择右侧那一支，接着因为6&lt;7&lt;8，所以这个节点中三个addr选择中间的addr，顺着这个地址找到7的节点，然后取出数据。</p><p>需要注意的是，当一个节点被加载到内存后，这个节点内部的数据就可以通过二分查找得到啦，所以那么id&#x3D;7去上图右边节点查找正确的addr是很快的。</p><p>上面只是演示了3阶B树，实际上1个节点可以存更多数据，做成N阶B树：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589370580691-8b9a4589-4f48-42cb-9daf-918ad3183d99-20210923150314176.png" alt="img"></p><p>分析到这里，历史的话剧就告一个段落，让我们看看MySQL索引的真正实现方式吧。</p><h1 id="B-树与索引"><a href="#B-树与索引" class="headerlink" title="B+树与索引"></a>B+树与索引</h1><p>实际上MySQL索引采用的是B+树，而不是B树。</p><p>为什么不用B树呢？</p><p>在操作系统中有个叫“页”的概念，是用来存储数据的一种单位，大小为4k。MySQL中也有“页”的概念，但大小为16k，你可以理解为MySQL中的“页”就是上面B树的一个个节点。</p><p>那么问题来了：你知道日常开发中，表中的一行数据大概占多少字节吗？</p><p>让我们来计算一下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589371147835-6bf74fd5-b52c-4abc-869a-88fd74c96e0a-20210923150326037.png" alt="img"></p><p>在上面这张表中，按每列数据类型推算，一行数据大概 8+150+150+150+150+9+2+9+750+5+5+8+8&#x3D;1404字节，就算1k好了，因为节点最大size是16k，所以每个节点最多只能存16行数据。</p><p>我们之前之所以从二叉平衡树转为B树，是因为B树的每个节点可以存更多数据。但上面的计算告诉我们，其实也就是比二叉平衡树多了15条数据而已。</p><p>但原则是对的，为了尽可能使树“变矮”从而减少磁盘IO，最好的做法是让<strong>一个节点尽可能地塞入更多的数据。</strong></p><p>不过把整行数据塞到节点中，有点太浪费了，我们其实可以<strong>把每一行数据的主键存进去。</strong>即使用bigint类型做主键，一个主键也就8个字节。假设每个主键对应一个addr（指针），MySQL中一个指针为6个字节，那么节点内每个主键-地址这样形式的数据能存16*1024&#x2F;14&#x3D;1170个。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589376951699-3f01f932-8684-414e-8dcb-2c0573837744-20210923150332743.png" alt="img"></p><p>这其实就是B+树对B树的改造。</p><p><strong>所谓的B+树，就是把原先B树中分散在各个节点的数据都“赶到”最底层的叶子节点，非叶子节点只存储主键-addr形式的数据：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589372895183-3540a1e5-82ba-4d3d-9dca-252f95007eee-20210923150338523.png" alt="img"></p><p>最终，一棵3层的B+树，最底下的叶子节点总共能存2000w条数据。</p><p>有部分同学可能还是不明白B+树为什么比B树能存储更多数据，这里再举个最极端的例子，假设一行表数据8k，而一个节点容量是16k，如果是B Tree，那么一个节点只能存两行数据，最终每个节点只能“夹带”3个addr，只能指向3个子节点：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589377482590-ca616c4f-89de-4de2-b459-1b7ef408a5ff-20210923150345350.png" alt="img"></p><p>但如果是B+ Tree，只存主键：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589377712338-9f1bfde7-bce8-4ecb-a9a0-27d1a5670b67-20210923150352723.png" alt="img"></p><p>那么最上面的节点可以存更多的主键，指向更多的下级节点，就有更多的“16k数据”。上面还只是分析单个节点的情况，如果放眼整棵索引树，最终叶子节点会多很多很多的“16k数据”。</p><p>从MySQL学习者的角度而言，我们只需要知道B+树2个很重要的特征：</p><ul><li>非叶子节点不存数据</li><li>叶子节点数据用链表相连</li></ul><p>所以更详细的版本是：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589448311743-b494fa66-02d0-43b8-ab9f-f920caec8af2-20210923150358426.png" alt="img"></p><p>叶子节点是有序链表，可以帮助做范围查询。</p><p>最后，还有个问题，如果我不提估计很少有人会考虑：B+树如何查找数据。</p><p>为什么会有这个疑问呢？</p><p>之前说过，B数的节点存了完整的数据，假设数据总共3层，而你要找的数据在第2层的某个节点，当你找到后便可以直接返回整行数据。而B+树为了一个节点能存入更多的addr，节点内部只存了主键id，所以即使你在第二层找到匹配的id，还是不能直接返回，必须继续往下，直到在叶子节点读取完整数据。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589421184838-106cccdb-a84e-448f-8806-58e9dfa9b76e-20210923150406906.gif" alt="img"></p><p>讨论到这，我们来对比一下B树和B+树：</p><ul><li><p>B树的节点都会存储整行数据，占用空间大存储addr少，而B+树的非叶子节点只存储主键，能容纳更多addr</p></li><li><p>由于非叶子节点能容纳更多addr，那么同一个节点能指向更多下级节点，所以相同数据量时，B+树通常更加“矮”，IO更少</p></li><li><p>B树的查询效率是不稳定的，最好情况是根节点，最差情况是叶子节点，而B+树是稳定的，每次都要查询到叶子节点</p></li><li><p>B+树的叶子节点是有序列表，非常便于范围查询</p></li></ul><p>对于第三点，很多人可能觉得B+树每次都是稳定地查询叶子节点，还不如B树（最好情况根节点就返回了）。其实上面分析过了，B+树每个节点能存储的数据是B树的1170&#x2F;16≈73倍，意味着B+树每个节点可以连接的分支更多，相同数据量的情况下，B+树远远矮于B树。比如B树的查询IO次数是1~100，而B+树恒定为3，你觉得哪个效率高？</p><p>回头看看柏青哥，钢珠掉落的过程是不是很像沿着索引查找数据呢~</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589373836878-c32bc126-fc73-48e4-ae95-d7e23ccf77c8-20210923150420395.png" alt="img"></p><p>学到这里，相信Dao层的对岸到底是什么，大家心里已经有B+树了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589374780467-c8dbebf7-eb2e-418b-8536-cc90aea27b37-20210923150427648.png" alt="img"></p><p>至此，我们回过头来给索引下个定义：</p><p><strong>索引是一种数据结构，</strong>用于高效搜索目标数据，在MySQL中具体实现为B+树（InnoDB引擎）。</p><p>最后说一句，没有所谓的“B减树”，很多人可能看到B树的英文表示法是”B-Tree”，误读为“B减树”。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础</title>
      <link href="/2020/03/22/SQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/22/SQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>实际上数据库范式不止3种，但大家熟知的就三种。</p><p>第一范式</p><p>所有列应该不可再分</p><p>比如，往contact列存储”18257500000,杭州,<a href="mailto:&#x35;&#x32;&#x33;&#x38;&#51;&#x39;&#x30;&#x30;&#48;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;">&#x35;&#x32;&#x33;&#x38;&#51;&#x39;&#x30;&#x30;&#48;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;</a>“是比较糟糕的做法，因为此时该列包含了phone、address、email三个维度的数据，应该拆成phone、address、email三个字段分别存储，这样对更新和查询都有好处。</p><p>第二范式</p><p>必须存在业务主键，且非主键字段应该依赖于全部业务主键（之所以写“全部”，因为可能存在复合主键）</p><p>说人话就是：每张表最好都设定主键。虽然某些列可能具备主键的特质（比如user表的id_card），但个人认为主键最好与业务无关，比如自增id。</p><span id="more"></span><table><thead><tr><th>id</th><th>xxx</th><th>yyy</th><th>zzz</th><th>…</th></tr></thead><tbody><tr><td>1</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>第三范式：</p><p>非主键列不能依赖除主键列以外的其他列</p><p>听起来很抽象，举个例子就明白了：</p><table><thead><tr><th><strong>t_student</strong></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>stu_name</td><td>stu_age</td><td>teacher_name</td><td>teacher_age</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>李四</td><td>40</td></tr></tbody></table><p>上面这张t_student表就违反了第三范式：非主键列teacher_name、teacher_age并不依赖id（学生的）。这种做法被称为“冗余”，它的弊端是<strong>有可能导致数据不一致。</strong>比如t_teacher表数据更新了，李四的age变成41，而代码里却没有及时维护t_student表的数据，就会导致从t_student表查出来的数据中，李四还是40岁。</p><p>改写成符合第三范式的设计：</p><table><thead><tr><th><strong>t_student</strong></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>stu_name</td><td>stu_age</td><td><strong>teacher_id</strong></td></tr><tr><td>1</td><td>张三</td><td>18</td><td><strong>10086</strong></td></tr></tbody></table><table><thead><tr><th><strong>t_teacher</strong></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>teacher_name</td><td>teacher_age</td><td>address</td></tr><tr><td>10086</td><td>李四</td><td>40</td><td>hangzhou</td></tr></tbody></table><p>总结一下三范式：</p><ul><li><p>每一列字段应该不可再分，职责单一</p></li><li><p>要有主键，最好是与业务无关的自增id</p></li><li><p>不要有冗余字段，为了避免数据更新不一致，应该拆成两张表，用（逻辑）外键关联</p></li></ul><p>一般来说，前两个范式大家都会遵守，但第三范式有时会被打破（就像上面的t_student一样）。<strong>因为实际工作中，越遵从范式化设计，表的拆分越细致，查询时需要关联的表就越多。</strong></p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.aaa, t2.bbb, t3.ccc</span><br><span class="line">FROM t1 </span><br><span class="line">LEFT JOIN t2 ON xxxx</span><br><span class="line">LEFT JOIN t3 ON xxxx;</span><br></pre></td></tr></table></figure><p>此时我们可以<strong>适当反范式化设计</strong>（反第三范式），目的是减少查询时需要关联的表的数量从而提升查询性能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.aaa, t1.bbb, t1.ccc</span><br><span class="line">FROM t1;</span><br></pre></td></tr></table></figure><p>所以才会出现上面t_student表里冗余teacher_name和teacher_age的设计。</p><p>但不论范式化设计还是反范式化设计，都不能过度：</p><ul><li>遵守第三范式，有时会让查询变得非常麻烦，要么JOIN关联，要么内存中匹配，甚至干脆无法满足需求</li><li>不遵守第三范式，则需要主动维护冗余数据，避免造成数据更新不一致</li></ul><p>但有些场景下，冗余数据百利而无一害。举个例子，比如订单表中的商品价格。商品价格会随着时间发生改变（促销等），而订单表只需记录当前下单的价格即可，不需要更新，否则你双11花了2999买的手机，过几天查询订单发现价格变成了3200，会怀疑自己是不是多付了。</p><h1 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h1><p>分类的方法很多，但这里只按自己的理解及使用频率分为4大类：</p><ul><li><p>整数类型</p></li><li><p>字符类型</p></li><li><p>小数类型</p></li><li><p>时间类型</p></li></ul><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>数值类型唯一需要注意的3点：</p><ul><li><p>如果业务允许，尽量设置unsigned</p></li><li><p>int(11)里的11和占用字节大小无关</p></li><li><p>注意各个类型的选取标准</p></li></ul><p>所谓unsigned，即无符号。比如tinyint，正常取值范围是-128<del>127。但实际业务中很少需要用到负数，比如年龄、身高等都是整数，最小为0。此时使用unsigned可以让正向范围翻倍：0</del>255。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589609778497-d64e7ece-7979-4baa-83d7-15555882f163-20210923213840093.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605039821-daa06c46-0aad-482a-a2e3-5935f95ca480-20210923213848199.png" alt="img"></p><p>如果业务需要，可以为当前字段设置默认值，比如文章状态status默认0，表示“待审核”。</p><p>另外，关于int(11)里的11，很多人都不是很清楚。其实括号里的数字和占用字节大小无关，哪怕你写成int(1)也不代表它比int(11)省空间，这只是列宽表示，比如位数不够就前面补零啥的，但对实际数值大小没有影响。<strong>总之，对于数值类型来说，每种类型占用空间大小是固定的。</strong></p><p>来看一下各种数值类型的占用空间：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占据空间</strong></th><th><strong>范围（有符号）</strong></th><th><strong>范围（无符号）</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>tinyint</td><td>1 个字节</td><td>-2^7 ~ 2^7-1</td><td>0 - 255</td><td>小整数值</td></tr><tr><td>smallint</td><td>2 个字节</td><td>-2^15 ~ 2^15-1</td><td>0 - 65535</td><td>大整数值</td></tr><tr><td>mediumint</td><td>3 个字节</td><td>-2^23 ~ 2^23-1</td><td>0 - 16777215</td><td>大整数值</td></tr><tr><td>int</td><td>4 个字节</td><td>-2^31 ~ 2^31-1</td><td>0 - 4294967295</td><td>大整数值</td></tr><tr><td>bigint</td><td>8 个字节</td><td>-2^63 ~ 2^63-1</td><td>0 - 18446744073709551615</td><td>极大整数值</td></tr></tbody></table><p>选择数值类型时，最重要的规则是“够用就好”。比如对于“性别”或“年龄”，用tinyint足够了，毕竟还没听过有人活过250岁的。这里并不是为了省磁盘空间而去扣这些细节，毕竟磁盘是最不值钱的，主要关系到索引。后面会解释，总之记住“够用就好”。</p><p>通常来说：</p><ul><li><p>主键id用bigint</p></li><li><p>age、height等普通数据用int</p></li><li><p>deleted、status、type用tinyint</p></li></ul><p>之前听说有些公司对于只有0、1两种状态的字段使用bit，也…行吧，按公司的约定来吧。隐约听过有坑，但我自己试了下没发现。大家没啥事可以自己去试试各种类型，做做实验：</p><p>此处为语雀视频卡片，点击链接查看：<a href="https://www.yuque.com/books/share/2b434c74-ed3a-470e-b148-b4c94ba14535/ghl3hi#JEUdS">Kapture 2020-12-29 at 23.26.36.mp4</a></p><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>平时大家会经常看到char(8)或者varchar(255)这样的形式对吧？经过上面的学习，你可能会觉得：哦，这也是显示作用，和实际大小无关。</p><p><strong>那你就错了。</strong></p><p><strong>字符类型的数字和实际大小有关，</strong>准确地说这里的数值和实际存储大小的<strong>上限</strong>有关。比如char(3)，表示会<strong>固定</strong>占用3个字符空间，即使存储的值不够3个字符，照样会占着那块空间，但不能超过3个字符：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605677558-0fa1e912-abbd-4568-a151-ed0d93b2130b-20210923213856943.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605713308-618696b9-23f5-45a4-8cdd-afa9f91a9803-20210923213903139.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589605740485-d2756bfc-bbbd-4c72-88ef-c29657f80faa-20210923213907419.png" alt="img"></p><p>实际开发中，一不小心就会出现上面的报错信息，此时你应该要意识到这是字符超过规定长度了。</p><p>至于varchar(255)，表示最多存储255个字符。看起来好像和char(255)没区别？实际上，char和varchar分别代表着两种类型：定长与变长。</p><p>比如int、bigint这些都是定长，而varchar是变长。</p><p>varchar作为“变长字符”，它的占用空间是可伸缩的。 varchar(255)表示最多能存储255个字符，但最终占用空间以实际存储的值为准，可能实际占用M个字符（M&lt;&#x3D;255），而char(255)则一定会占用255个字符的控件。</p><p>看起来好像varchar是百利而无一害，完爆char对吧？</p><p>char VS varchar</p><ul><li><p>char长度固定，不需要考虑边界问题，读写效率高于varchar，适合存储长度固定、频繁读写的数据</p></li><li><p>varchar长度不固定，但可以通过varchar(10)的方式指定上限，适合存储长度波动、更新不频繁的数据</p></li><li><p>char的存储长度不够灵活，而varchar则需要浪费1~2个字节来存储当前值的实际长度，且更新会导致重新计算</p></li></ul><p>关于第一点，你可以简单理解为：</p><p>char是定长，说了一个字段用3个格子存储就一定是3个格子，所以当你要找第3个数据时，只需要往右数6个格子，那么7~9就存着你要找的数据。而varchar(3)的“3”只代表上限，实际不一定占用3个格子，所以不能直接计算得到位置。</p><p>没有最完美的类型，只有最合适的类型。比如，当你需要存储手机号码或者身份证号时，用char(11)、char(18)显然更合适。但存储“个人介绍”时，用varchar更好，因为个人介绍的长度是可变的。</p><h2 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h2><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占据空间</strong></th><th><strong>是够精确</strong></th></tr></thead><tbody><tr><td>float</td><td>4个字节</td><td>非精确</td></tr><tr><td>double</td><td>8 个字节</td><td>非精确</td></tr><tr><td>decimal</td><td>每4个字节存9个数字，小数点占一个字节</td><td>精确</td></tr></tbody></table><p>对于decimal的大小，比如123456789.987654321，用decimal(18,9)存储，占9个字节，前后各4个字节，小数点一个字节。decimal的效率不如float和double。</p><p>当然，很多电商公司其实都是直接存最小单位“分”，也就没有精度问题了。</p><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占据空间</strong></th><th><strong>取值范围</strong></th></tr></thead><tbody><tr><td>date</td><td>3个字节</td><td>1000-01-01 ~ 9999-12-31</td></tr><tr><td>time</td><td>3~6个字节</td><td>-838:59:59 ~ 838:59:59</td></tr><tr><td>datetime</td><td>5~8个字节</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td></tr><tr><td>timestamp</td><td>4~7个字节</td><td>1970-01-01 00:00:01 ~ 2038-01-19 03:14:07</td></tr></tbody></table><p>DATETIME 和 TIMESTAMP的区别：</p><ul><li>时间范围不同，DATETIME更大，内存稍微大一点</li><li>TIMESTAMP的时间会根据时区变化。比如 SET time_zone&#x3D;’+10:00’，那么查询后会自动增加10小时</li></ul><p>具体跟着公司走就好了，比如我们公司甚至没用时间类型，直接用Long存秒数。</p><h1 id="类型选择小结"><a href="#类型选择小结" class="headerlink" title="类型选择小结"></a>类型选择小结</h1><ul><li><p>更小的通常更好</p></li><li><p>简单合适就好</p></li><li><p>尽量避免null（设置NOT NULL，除非业务要求可能NULL）</p></li><li><p>如果确定不会出现负数，可以使用unsigned</p></li></ul><p>NOT NULL：一定要传递值，且不能为NULL，否则报错</p><p>DEFAULT ‘xx’：传不传都可以，不传就使用默认值xx，<strong>可以传NULL</strong></p><p>NOT NULL DEFAULT ‘xx’：传不传都可以，不传就使用默认值xx，<strong>不能传NULL</strong></p><p>可以做个实验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `age_not_null_default` int(10) NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">  `age_not_null` int(10) NOT NULL,</span><br><span class="line">  `age_default` int(10) DEFAULT &#x27;0&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># age_not_null_default 要么不传，要么传非NULL值，这里选择不传，则插入默认值0</span><br><span class="line"># age_not_null 一定要传值，且不能为NULL</span><br><span class="line"># age_default 传不传都可以，可以传NULL</span><br><span class="line">INSERT INTO `test` (`age_not_null`, `age_default`) VALUES(1, null);</span><br></pre></td></tr></table></figure><h1 id="语句书写顺序"><a href="#语句书写顺序" class="headerlink" title="语句书写顺序"></a>语句书写顺序</h1><p>SELECT … FROM table WHERE … GROUP BY … HAVING … ORDER BY … LIMIT …</p><p>除了SELECT，后面几个顺序可以记忆为：温哥华OL，意思是温哥华白领。</p><h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><h2 id="隐式连接"><a href="#隐式连接" class="headerlink" title="隐式连接"></a>隐式连接</h2><p>什么是隐式连接？不用写JOIN关键字的连接。</p><p>格式是：</p><p>FROM t_a, t_b WHERE或ON 等值连接条件</p><p>隐式连接属于内连接，效果等同于：</p><p>FROM t_a [INNER] JOIN t_b ON 连接条件</p><h2 id="显式连接"><a href="#显式连接" class="headerlink" title="显式连接"></a>显式连接</h2><p><strong>内连接</strong></p><p>格式：</p><p>FROM t_a [INNER] JOIN t_b ON 连接条件</p><p>INNER写不写都可以，查询效果和隐式连接一样，连接条件写在ON后面。</p><p>如果两个表做等值判断的字段相同，比如 ON t1.id &#x3D; t2.id 可以改写为 USING(id)，但没什么卵用，我要不是这次复习，都不知道这是啥意思。所以尽量别用这种乱七八糟的写法，给同事添堵。</p><p><strong>外连接</strong></p><ul><li>LEFT JOIN</li><li>RIGHT JOIN</li></ul><p>本质是一样的，换个位置而已。</p><p><strong>自连接</strong></p><p>格式：</p><p>FROM t_a child, t_a parent ON 连接条件</p><p>自连接不是一种新的连接形式，它可以用上面的任意一种连接方式，只不过是把同一张表当做两张表，自己和自己关联。</p><p>其他的什么自然连接(NATURAL JOIN)、交叉连接(CROSS JOIN)不提了，我反正从来没用过，大家有兴趣自行了解，不徒增大家的记忆负担。</p><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询指的就是在一个查询之中嵌套了其他若干个查询。</p><p>子查询通常出现在</p><ul><li><p>WHERE后面：SELECT name FROM table_a WHERE id IN (SELECT id FROM table_b)</p></li><li><p>FROM后面：SELECT name FROM (SELECT name, age FROM table_a) temp LEFT JOIN….</p></li><li><p>EXISTST后面：没用过，大家自己可以了解一下（很真实）</p></li></ul><p>放在FROM后的子查询可以看做一张临时表，WHERE后面的子查询就是动态的查询条件而已。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis分布式锁的安全性问题</title>
      <link href="/2020/03/04/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/04/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我想和你聊一聊，关于 Redis 分布式锁的「安全性」问题。</p><p>Redis 分布式锁的话题，很多文章已经写烂了，我为什么还要写这篇文章呢？</p><p>因为我发现网上 99% 的文章，并没有把这个问题真正讲清楚。导致很多读者看了很多文章，依旧云里雾里。例如下面这些问题，你能清晰地回答上来吗？</p><ul><li>基于 Redis 如何实现一个分布式锁？</li><li>Redis 分布式锁真的安全吗？</li><li>Redis 的 Redlock 有什么问题？一定安全吗？</li><li>业界争论 Redlock，到底在争论什么？哪种观点是对的？</li><li>分布式锁到底用 Redis 还是 Zookeeper？</li><li>实现一个有「容错性」的分布式锁，都需要考虑哪些问题？</li></ul><p>这篇文章，我就来把这些问题彻底讲清楚。</p><p>读完这篇文章，你不仅可以彻底了解分布式锁，还会对「分布式系统」有更加深刻的理解。</p><span id="more"></span><p><strong>文章有点长，但干货很多，希望你可以耐心读完。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101801037.png" alt="图片"></strong></p><h2 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h2><p>在开始讲分布式锁之前，有必要简单介绍一下，为什么需要分布式锁？</p><p>与分布式锁相对应的是「单机锁」，我们在写多线程程序时，避免同时操作一个共享变量产生数据问题，通常会使用一把锁来「互斥」，以保证共享变量的正确性，其使用范围是在「同一个进程」中。</p><p>如果换做是多个进程，需要同时操作一个共享资源，如何互斥呢？</p><p>例如，现在的业务应用通常都是微服务架构，这也意味着一个应用会部署多个进程，那这多个进程如果需要修改 MySQL 中的同一行记录时，为了避免操作乱序导致数据错误，此时，我们就需要引入「分布式锁」来解决这个问题了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101752919.png" alt="图片"></p><p>想要实现分布式锁，必须借助一个外部系统，所有进程都去这个系统上申请「加锁」。</p><p>而这个外部系统，必须要实现「互斥」的能力，即两个请求同时进来，只会给一个进程返回成功，另一个返回失败（或等待）。</p><p>这个外部系统，可以是 MySQL，也可以是 Redis 或 Zookeeper。但为了追求更好的性能，我们通常会选择使用 Redis 或 Zookeeper 来做。</p><p>下面我就以 Redis 为主线，由浅入深，带你深度剖析一下，分布式锁的各种「安全性」问题，帮你彻底理解分布式锁。</p><h2 id="分布式锁怎么实现？"><a href="#分布式锁怎么实现？" class="headerlink" title="分布式锁怎么实现？"></a>分布式锁怎么实现？</h2><p>我们从最简单的开始讲起。</p><p>想要实现分布式锁，必须要求 Redis 有「互斥」的能力，我们可以使用 SETNX 命令，这个命令表示<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists，即如果 key 不存在，才会设置它的值，否则什么也不做。</p><p>两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p><p>客户端 1 申请加锁，加锁成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX lock 1</span><br><span class="line">(integer) 1     // 客户端1，加锁成功</span><br></pre></td></tr></table></figure><p>客户端 2 申请加锁，因为它后到达，加锁失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX lock 1</span><br><span class="line">(integer) 0     // 客户端2，加锁失败</span><br></pre></td></tr></table></figure><p>此时，加锁成功的客户端，就可以去操作「共享资源」，例如，修改 MySQL 的某一行数据，或者调用一个 API 请求。</p><p>操作完成后，还要及时释放锁，给后来者让出操作共享资源的机会。如何释放锁呢？</p><p>也很简单，直接使用 DEL 命令删除这个 key 即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; DEL lock // 释放锁</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>这个逻辑非常简单，整体的路程就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101730050.png" alt="图片"></p><p>但是，它存在一个很大的问题，当客户端 1 拿到锁后，如果发生下面的场景，就会造成「死锁」：</p><ol><li>程序处理业务逻辑异常，没及时释放锁</li><li>进程挂了，没机会释放锁</li></ol><p>这时，这个客户端就会一直占用这个锁，而其它客户端就「永远」拿不到这把锁了。</p><p>怎么解决这个问题呢？</p><h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><p>我们很容易想到的方案是，在申请锁时，给这把锁设置一个「租期」。</p><p>在 Redis 中实现时，就是给这个 key 设置一个「过期时间」。这里我们假设，操作共享资源的时间不会超过 10s，那么在加锁时，给这个 key 设置 10s 过期即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX lock 1    // 加锁</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE lock 10  // 10s后自动过期</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>这样一来，无论客户端是否异常，这个锁都可以在 10s 后被「自动释放」，其它客户端依旧可以拿到锁。</p><p>但这样真的没问题吗？</p><p>还是有问题。</p><p>现在的操作，加锁、设置过期是 2 条命令，有没有可能只执行了第一条，第二条却「来不及」执行的情况发生呢？例如：</p><ol><li>SETNX 执行成功，执行 EXPIRE 时由于网络问题，执行失败</li><li>SETNX 执行成功，Redis 异常宕机，EXPIRE 没有机会执行</li><li>SETNX 执行成功，客户端异常崩溃，EXPIRE 也没有机会执行</li></ol><p>总之，这两条命令不能保证是原子操作（一起成功），就有潜在的风险导致过期时间设置失败，依旧发生「死锁」问题。</p><p>怎么办？</p><p>在 Redis 2.6.12 版本之前，我们需要想尽办法，保证 SETNX 和 EXPIRE 原子性执行，还要考虑各种异常情况如何处理。</p><p>但在 Redis 2.6.12 之后，Redis 扩展了 SET 命令的参数，用这一条命令就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 一条命令保证原子性执行</span><br><span class="line">127.0.0.1:6379&gt; SET lock 1 EX 10 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>这样就解决了死锁问题，也比较简单。</p><p>我们再来看分析下，它还有什么问题？</p><p>试想这样一种场景：</p><ol><li>客户端 1 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源的时间，「超过」了锁的过期时间，锁被「自动释放」</li><li>客户端 2 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源完成，释放锁（但释放的是客户端 2 的锁）</li></ol><p>看到了么，这里存在两个严重的问题：</p><ol><li><strong>锁过期</strong>：客户端 1 操作共享资源耗时太久，导致锁被自动释放，之后被客户端 2 持有</li><li><strong>释放别人的锁</strong>：客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁</li></ol><p>导致这两个问题的原因是什么？我们一个个来看。</p><p><strong>第一个问题，可能是我们评估操作共享资源的时间不准确导致的。</strong></p><p>例如，操作共享资源的时间「最慢」可能需要 15s，而我们却只设置了 10s 过期，那这就存在锁提前过期的风险。</p><p>过期时间太短，那增大冗余时间，例如设置过期时间为 20s，这样总可以了吧？</p><p>这样确实可以「缓解」这个问题，降低出问题的概率，但依旧无法「彻底解决」问题。</p><p>为什么？</p><p>原因在于，客户端在拿到锁之后，在操作共享资源时，遇到的场景有可能是很复杂的，例如，程序内部发生异常、网络请求超时等等。</p><p>既然是「预估」时间，也只能是大致计算，除非你能预料并覆盖到所有导致耗时变长的场景，但这其实很难。</p><p>有什么更好的解决方案吗？</p><p>别急，关于这个问题，我会在后面详细来讲对应的解决方案。</p><p>我们继续来看第二个问题。</p><p><strong>第二个问题在于，一个客户端释放了其它客户端持有的锁。</strong></p><p>想一下，导致这个问题的关键点在哪？</p><p>重点在于，每个客户端在释放锁时，都是「无脑」操作，并没有检查这把锁是否还「归自己持有」，所以就会发生释放别人锁的风险，这样的解锁流程，很不「严谨」！</p><p>如何解决这个问题呢？</p><h2 id="锁被别人释放怎么办"><a href="#锁被别人释放怎么办" class="headerlink" title="锁被别人释放怎么办?"></a>锁被别人释放怎么办?</h2><p>解决办法是：客户端在加锁时，设置一个只有自己知道的「唯一标识」进去。</p><p>例如，可以是自己的线程 ID，也可以是一个 UUID（随机且唯一），这里我们以 UUID 举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 锁的VALUE设置为UUID</span><br><span class="line">127.0.0.1:6379&gt; SET lock $uuid EX 20 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><blockquote><p>这里假设 20s 操作共享时间完全足够，先不考虑锁自动过期的问题。</p></blockquote><p>之后，在释放锁时，要先判断这把锁是否还归自己持有，伪代码可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁是自己的，才释放</span></span><br><span class="line"><span class="keyword">if</span> redis.get(<span class="string">&quot;lock&quot;</span>) == $uuid:</span><br><span class="line">    redis.del(<span class="string">&quot;lock&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里释放锁使用的是 GET + DEL 两条命令，这时，又会遇到我们前面讲的原子性问题了。</p><ol><li>客户端 1 执行 GET，判断锁是自己的</li><li>客户端 2 执行了 SET 命令，强制获取到锁（虽然发生概率比较低，但我们需要严谨地考虑锁的安全性模型）</li><li>客户端 1 执行 DEL，却释放了客户端 2 的锁</li></ol><p>由此可见，这两个命令还是必须要原子执行才行。</p><p>怎样原子执行呢？Lua 脚本。</p><p>我们可以把这个逻辑，写成 Lua 脚本，让 Redis 来执行。</p><p>因为 Redis 处理每一个请求是「单线程」执行的，在执行一个 Lua 脚本时，其它请求必须等待，直到这个 Lua 脚本处理完成，这样一来，GET + DEL 之间就不会插入其它命令了。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101642484.png" alt="图片"></p><p>安全释放锁的 Lua 脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 判断锁是自己的，才释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;GET&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;DEL&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>好了，这样一路优化，整个的加锁、解锁的流程就更「严谨」了。</p><p>这里我们先小结一下，基于 Redis 实现的分布式锁，一个严谨的的流程如下：</p><ol><li>加锁：SET lock_key $unique_id EX $expire_time NX</li><li>操作共享资源</li><li>释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101626176.png" alt="图片"></p><p>好，有了这个完整的锁模型，让我们重新回到前面提到的第一个问题。</p><p>锁过期时间不好评估怎么办？</p><h2 id="锁过期时间不好评估怎么办？"><a href="#锁过期时间不好评估怎么办？" class="headerlink" title="锁过期时间不好评估怎么办？"></a>锁过期时间不好评估怎么办？</h2><p>前面我们提到，锁的过期时间如果评估不好，这个锁就会有「提前」过期的风险。</p><p>当时给的妥协方案是，尽量「冗余」过期时间，降低锁提前过期的概率。</p><p>这个方案其实也不能完美解决问题，那怎么办呢？</p><p>是否可以设计这样的方案：<strong>加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。</strong></p><p>这确实一种比较好的方案。</p><p>如果你是 Java 技术栈，幸运的是，已经有一个库把这些工作都封装好了：<strong>Redisson</strong>。</p><p>Redisson 是一个 Java 语言实现的 Redis SDK 客户端，在使用分布式锁时，它就采用了「自动续期」的方案来避免锁过期，这个守护线程我们一般也把它叫做「看门狗」线程。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101618896.png" alt="图片"></p><p>除此之外，这个 SDK 还封装了很多易用的功能：</p><ul><li>可重入锁</li><li>乐观锁</li><li>公平锁</li><li>读写锁</li><li>Redlock（红锁，下面会详细讲）</li></ul><p>这个 SDK 提供的 API 非常友好，它可以像操作本地锁的方式，操作分布式锁。如果你是 Java 技术栈，可以直接把它用起来。</p><blockquote><p>这里不重点介绍 Redisson 的使用，大家可以看官方 Github 学习如何使用，比较简单。</p></blockquote><p>到这里我们再小结一下，基于 Redis 的实现分布式锁，前面遇到的问题，以及对应的解决方案：</p><ul><li><strong>死锁</strong>：设置过期时间</li><li><strong>过期时间评估不好，锁提前过期</strong>：守护线程，自动续期</li><li><strong>锁被别人释放</strong>：锁写入唯一标识，释放锁先检查标识，再释放</li></ul><p>还有哪些问题场景，会危害 Redis 锁的安全性呢？</p><p>之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 的部署架构细节。</p><p>而我们在使用 Redis 时，一般会采用<strong>主从集群 + 哨兵</strong>的模式部署，这样做的好处在于，当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p><p><strong>那当「主从发生切换」时，这个分布锁会依旧安全吗？</strong></p><p>试想这样的场景：</p><ol><li>客户端 1 在主库上执行 SET 命令，加锁成功</li><li>此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）</li><li>从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101604473.png" alt="图片"></p><p>可见，当引入 Redis 副本后，分布锁还是可能会受到影响。</p><p>怎么解决这个问题？</p><p>为此，Redis 的作者提出一种解决方案，就是我们经常听到的 <strong>Redlock（红锁）</strong>。</p><p>它真的可以解决上面这个问题吗？</p><h2 id="Redlock-真的安全吗？"><a href="#Redlock-真的安全吗？" class="headerlink" title="Redlock 真的安全吗？"></a>Redlock 真的安全吗？</h2><p>好，终于到了这篇文章的重头戏。啊？上面讲的那么多问题，难道只是基础？</p><p>是的，那些只是开胃菜，真正的硬菜，从这里刚刚开始。</p><p>如果上面讲的内容，你还没有理解，我建议你重新阅读一遍，先理清整个加锁、解锁的基本流程。</p><p>如果你已经对 Redlock 有所了解，这里可以跟着我再复习一遍，如果你不了解 Redlock，没关系，我会带你重新认识它。</p><p>值得提醒你的是，<strong>后面我不仅仅是讲 Redlock 的原理，还会引出有关「分布式系统」中的很多问题，你最好跟紧我的思路，在脑中一起分析问题的答案。</strong></p><p>现在我们来看，Redis 作者提出的 Redlock 方案，是如何解决主从切换后，锁失效问题的。</p><p>Redlock 的方案基于 2 个前提：</p><ol><li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong></li><li>但主库要部署多个，官方推荐至少 5 个实例</li></ol><p>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><blockquote><p><strong>注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101557341.png" alt="图片"></p><p>Redlock 具体如何使用呢？</p><p>整体的流程是这样的，一共分为 5 步：</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 &gt;&#x3D;3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p>我简单帮你总结一下，有 4 个重点：</p><ol><li>客户端在多个 Redis 实例上申请加锁</li><li>必须保证大多数节点加锁成功</li><li>大多数节点加锁的总耗时，要小于锁设置的过期时间</li><li>释放锁，要向全部节点发起释放锁请求</li></ol><blockquote><p>第一次看可能不太容易理解，建议你把上面的文字多看几遍，加深记忆。</p><p>然后，记住这 5 步，非常重要，下面会根据这个流程，剖析各种可能导致锁失效的问题假设。</p></blockquote><p>好，明白了 Redlock 的流程，我们来看 Redlock 为什么要这么做。</p><p><strong>1) 为什么要在多个实例上加锁？</strong></p><p>本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用。</p><p><strong>2) 为什么大多数加锁成功，才算成功？</strong></p><p>多个 Redis 实例一起来用，其实就组成了一个「分布式系统」。</p><p>在分布式系统中，总会出现「异常节点」，所以，在谈论分布式系统问题时，需要考虑异常节点达到多少个，也依旧不会影响整个系统的「正确性」。</p><p>这是一个分布式系统「容错」问题，这个问题的结论是：<strong>如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的。</strong></p><blockquote><p>这个问题的模型，就是我们经常听到的「拜占庭将军」问题，感兴趣可以去看算法的推演过程。</p></blockquote><p><strong>3) 为什么步骤 3 加锁成功后，还要计算加锁的累计耗时？</strong></p><p>因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久，而且，因为是网络请求，网络情况是复杂的，有可能存在<strong>延迟、丢包、超时</strong>等情况发生，网络请求越多，异常发生的概率就越大。</p><p>所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经「超过」了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。</p><p><strong>4) 为什么释放锁，要操作所有节点？</strong></p><p>在某一个 Redis 节点加锁时，可能因为「网络原因」导致加锁失败。</p><p>例如，客户端在一个 Redis 实例上加锁成功，但在读取响应结果时，网络问题导致<strong>读取失败</strong>，那这把锁其实已经在 Redis 上加锁成功了。</p><p>所以，释放锁时，不管之前有没有加锁成功，需要释放「所有节点」的锁，以保证清理节点上「残留」的锁。</p><p>好了，明白了 Redlock 的流程和相关问题，看似 Redlock 确实解决了 Redis 节点异常宕机锁失效的问题，保证了锁的「安全性」。</p><p>但事实真的如此吗？</p><h2 id="Redlock-的争论谁对谁错？"><a href="#Redlock-的争论谁对谁错？" class="headerlink" title="Redlock 的争论谁对谁错？"></a>Redlock 的争论谁对谁错？</h2><p>Redis 作者把这个方案一经提出，就马上受到业界著名的分布式系统专家的<strong>质疑</strong>！</p><p>这个专家叫 <strong>Martin</strong>，是英国剑桥大学的一名分布式系统研究员。在此之前他曾是软件工程师和企业家，从事大规模数据基础设施相关的工作。它还经常在大会做演讲，写博客，写书，也是开源贡献者。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101545963.png" alt="图片"></p><p>他马上写了篇文章，质疑这个 Redlock 的算法模型是有问题的，并对分布式锁的设计，提出了自己的看法。</p><p>之后，Redis 作者 Antirez 面对质疑，不甘示弱，也写了一篇文章，反驳了对方的观点，并详细剖析了 Redlock 算法模型的更多设计细节。</p><p>而且，关于这个问题的争论，在当时互联网上也引起了非常激烈的讨论。</p><p><strong>二人思路清晰，论据充分，这是一场高手过招，也是分布式系统领域非常好的一次思想的碰撞！双方都是分布式系统领域的专家，却对同一个问题提出很多相反的论断，究竟是怎么回事？</strong></p><p>下面我会从他们的争论文章中，提取重要的观点，整理呈现给你。</p><blockquote><p>提醒：后面的信息量极大，可能不宜理解，最好放慢速度阅读。</p></blockquote><h2 id="分布式专家-Martin-对于-Relock-的质疑"><a href="#分布式专家-Martin-对于-Relock-的质疑" class="headerlink" title="分布式专家 Martin 对于 Relock 的质疑"></a>分布式专家 Martin 对于 Relock 的质疑</h2><p>在他的文章中，主要阐述了 4 个论点：</p><p><strong>1) 分布式锁的目的是什么？</strong></p><p>Martin 表示，你必须先清楚你在使用分布式锁的目的是什么？</p><p>他认为有两个目的。</p><p><strong>第一，效率。</strong></p><p>使用分布式锁的互斥能力，是避免不必要地做同样的两次工作（例如一些昂贵的计算任务）。如果锁失效，并不会带来「恶性」的后果，例如发了 2 次邮件等，无伤大雅。</p><p><strong>第二，正确性。</strong></p><p>使用锁用来防止并发进程互相干扰。如果锁失效，会造成多个进程同时操作同一条数据，产生的后果是<strong>数据严重错误、永久性不一致、数据丢失</strong>等恶性问题，就像给患者服用了重复剂量的药物，后果很严重。</p><p>他认为，如果你是为了前者——效率，那么使用单机版 Redis 就可以了，即使偶尔发生锁失效（宕机、主从切换），都不会产生严重的后果。而使用 Redlock 太重了，没必要。</p><p><strong>而如果是为了正确性，Martin 认为 Redlock 根本达不到安全性的要求，也依旧存在锁失效的问题！</strong></p><p><strong>2) 锁在分布式系统中会遇到的问题</strong></p><p>Martin 表示，一个分布式系统，更像一个复杂的「野兽」，存在着你想不到的各种异常情况。</p><p>这些异常场景主要包括三大块，这也是分布式系统会遇到的三座大山：<strong>NPC</strong>。</p><ul><li>N：Network Delay，网络延迟</li><li>P：Process Pause，进程暂停（GC）</li><li>C：Clock Drift，时钟漂移</li></ul><p>Martin 用一个进程暂停（GC）的例子，指出了 Redlock 安全性问题：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC（时间比较久）</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取到了 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到了锁，发生「冲突」</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101536288.png" alt="图片"></p><p>Martin 认为，GC 可能发生在程序的任意时刻，而且执行时间是不可控的。</p><blockquote><p>注：当然，即使是使用没有 GC 的编程语言，在发生网络延迟、时钟漂移时，也都有可能导致 Redlock 出现问题，这里 Martin 只是拿 GC 举例。</p></blockquote><p><strong>3) 假设时钟正确的是不合理的</strong></p><p>又或者，当多个 Redis 节点「时钟」发生问题时，也会导致 Redlock <strong>锁失效</strong>。</p><ol><li>客户端 1 获取节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E</li><li>节点 C 上的时钟「向前跳跃」，导致锁到期</li><li>客户端 2 获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B</li><li>客户端 1 和 2 现在都相信它们持有了锁（冲突）</li></ol><p>Martin 觉得，Redlock 必须「强依赖」多个节点的时钟是保持同步的，一旦有节点时钟发生错误，那这个算法模型就失效了。</p><blockquote><p>即使 C 不是时钟跳跃，而是「崩溃后立即重启」，也会发生类似的问题。</p></blockquote><p>Martin 继续阐述，机器的时钟发生错误，是很有可能发生的：</p><ul><li>系统管理员「手动修改」了机器时钟</li><li>机器时钟在同步 NTP 时间时，发生了大的「跳跃」</li></ul><p>总之，Martin 认为，Redlock 的算法是建立在「同步模型」基础上的，有大量资料研究表明，同步模型的假设，在分布式系统中是有问题的。</p><p>在混乱的分布式系统的中，你不能假设系统时钟就是对的，所以，你必须非常小心你的假设。</p><p><strong>4) 提出 fecing token 的方案，保证正确性</strong></p><p>相对应的，Martin 提出一种被叫作 fecing token 的方案，保证分布式锁的正确性。</p><p>这个模型流程如下：</p><ol><li>客户端在获取锁时，锁服务可以提供一个「递增」的 token</li><li>客户端拿着这个 token 去操作共享资源</li><li>共享资源可以根据 token 拒绝「后来者」的请求</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101529458.png" alt="图片"></p><p>这样一来，无论 NPC 哪种异常情况发生，都可以保证分布式锁的安全性，因为它是建立在「异步模型」上的。</p><p>而 Redlock 无法提供类似 fecing token 的方案，所以它无法保证安全性。</p><p>他还表示，<strong>一个好的分布式锁，无论 NPC 怎么发生，可以不在规定时间内给出结果，但并不会给出一个错误的结果。也就是只会影响到锁的「性能」（或称之为活性），而不会影响它的「正确性」。</strong></p><p>Martin 的结论：</p><p><strong>1、Redlock 不伦不类</strong>：它对于效率来讲，Redlock 比较重，没必要这么做，而对于正确性来说，Redlock 是不够安全的。</p><p><strong>2、时钟假设不合理</strong>：该算法对系统时钟做出了危险的假设（假设多个节点机器时钟都是一致的），如果不满足这些假设，锁就会失效。</p><p><strong>3、无法保证正确性</strong>：Redlock 不能提供类似 fencing token 的方案，所以解决不了正确性的问题。为了正确性，请使用有「共识系统」的软件，例如 Zookeeper。</p><p>好了，以上就是 Martin 反对使用 Redlock 的观点，看起来有理有据。</p><p>下面我们来看 Redis 作者 Antirez 是如何反驳的。</p><h3 id="Redis-作者-Antirez-的反驳"><a href="#Redis-作者-Antirez-的反驳" class="headerlink" title="Redis 作者 Antirez 的反驳"></a>Redis 作者 Antirez 的反驳</h3><p>在 Redis 作者的文章中，重点有 3 个：</p><p><strong>1) 解释时钟问题</strong></p><p>首先，Redis 作者一眼就看穿了对方提出的最为核心的问题：<strong>时钟问题</strong>。</p><p>Redis 作者表示，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了，允许有「误差」。</p><p>例如要计时 5s，但实际可能记了 4.5s，之后又记了 5.5s，有一定误差，但只要不超过「误差范围」锁失效时间即可，这种对于时钟的精度要求并不是很高，而且这也符合现实环境。</p><p>对于对方提到的「时钟修改」问题，Redis 作者反驳到：</p><ol><li><strong>手动修改时钟</strong>：不要这么做就好了，否则你直接修改 Raft 日志，那 Raft 也会无法工作…</li><li><strong>时钟跳跃</strong>：通过「恰当的运维」，保证机器时钟不会大幅度跳跃（每次通过微小的调整来完成），实际上这是可以做到的</li></ol><blockquote><p>为什么 Redis 作者优先解释时钟问题？因为在后面的反驳过程中，需要依赖这个基础做进一步解释。</p></blockquote><p><strong>2) 解释网络延迟、GC 问题</strong></p><p>之后，Redis 作者对于对方提出的，网络延迟、进程 GC 可能导致 Redlock 失效的问题，也做了反驳：</p><p>我们重新回顾一下，Martin 提出的问题假设：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取节点 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到锁，发生「冲突」</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101522843.png" alt="图片"></p><p>Redis 作者反驳到，这个假设其实是有问题的，Redlock 是可以保证锁安全的。</p><p>这是怎么回事呢？</p><p>还记得前面介绍 Redlock 流程的那 5 步吗？这里我再拿过来让你复习一下。</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p><strong>注意，重点是 1-3，在步骤 3，加锁成功后为什么要重新获取「当前时间戳T2」？还用 T2 - T1 的时间，与锁的过期时间做比较？</strong></p><p>Redis 作者强调：如果在 1-3 发生了网络延迟、进程 GC 等耗时长的异常情况，那在第 3 步 T2 - T1，是可以检测出来的，如果超出了锁设置的过期时间，那这时就认为加锁会失败，之后释放所有节点的锁就好了！</p><p>Redis 作者继续论述，如果对方认为，发生网络延迟、进程 GC 是在步骤 3 之后，也就是客户端确认拿到了锁，去操作共享资源的途中发生了问题，导致锁失效，那这<strong>不止是 Redlock 的问题，任何其它锁服务例如 Zookeeper，都有类似的问题，这不在讨论范畴内。</strong></p><p>这里我举个例子解释一下这个问题：</p><ol><li>客户端通过 Redlock 成功获取到锁（通过了大多数节点加锁成功、加锁耗时检查逻辑）</li><li>客户端开始操作共享资源，此时发生网络延迟、进程 GC 等耗时很长的情况</li><li>此时，锁过期自动释放</li><li>客户端开始操作 MySQL（此时的锁可能会被别人拿到，锁失效）</li></ol><p>Redis 作者这里的结论就是：</p><ul><li>客户端在拿到锁之前，无论经历什么耗时长问题，Redlock 都能够在第 3 步检测出来</li><li>客户端在拿到锁之后，发生 NPC，那 Redlock、Zookeeper 都无能为力</li></ul><p>所以，Redis 作者认为 Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p><p><strong>3) 质疑 fencing token 机制</strong></p><p>Redis 作者对于对方提出的 fecing token 机制，也提出了质疑，主要分为 2 个问题，这里最不宜理解，请跟紧我的思路。</p><p><strong>第一</strong>，这个方案必须要求要操作的「共享资源服务器」有拒绝「旧 token」的能力。</p><p>例如，要操作 MySQL，从锁服务拿到一个递增数字的 token，然后客户端要带着这个 token 去改 MySQL 的某一行，这就需要利用 MySQL 的「事物隔离性」来做。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 两个客户端必须利用事物和隔离性达到目的</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 注意 token 的判断条件</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> T <span class="keyword">SET</span> val <span class="operator">=</span> $new_val <span class="keyword">WHERE</span> id <span class="operator">=</span> $id <span class="keyword">AND</span> current_token <span class="operator">&lt;</span> $token</span><br></pre></td></tr></table></figure><p>但如果操作的不是 MySQL 呢？例如向磁盘上写一个文件，或发起一个 HTTP 请求，那这个方案就无能为力了，这对要操作的资源服务器，提出了更高的要求。</p><p>也就是说，大部分要操作的资源服务器，都是没有这种互斥能力的。</p><p><strong>再者，既然资源服务器都有了「互斥」能力，那还要分布式锁干什么？</strong></p><p>所以，Redis 作者认为这个方案是站不住脚的。</p><p><strong>第二</strong>，退一步讲，即使 Redlock 没有提供 fecing token 的能力，但 Redlock 已经提供了随机值（就是前面讲的 UUID），利用这个随机值，也可以达到与 fecing token 同样的效果。</p><p>如何做呢？</p><blockquote><p>Redis 作者只是提到了可以完成 fecing token 类似的功能，但却没有展开相关细节，根据我查阅的资料，大概流程应该如下，如有错误，欢迎交流~</p></blockquote><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端在操作共享资源之前，先把这个锁的 VALUE，在要操作的共享资源上做标记</li><li>客户端处理业务逻辑，最后，在修改共享资源时，判断这个标记是否与之前一样，一样才修改（类似 CAS 的思路）</li></ol><p>还是以 MySQL 为例，举个例子就是这样的：</p><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端要修改 MySQL 表中的某一行数据之前，先把锁的 VALUE 更新到这一行的某个字段中（这里假设为 current_token 字段)</li><li>客户端处理业务逻辑</li><li>客户端修改 MySQL 的这一行数据，把 VALUE 当做 WHERE 条件，再修改</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> T <span class="keyword">SET</span> val <span class="operator">=</span> $new_val <span class="keyword">WHERE</span> id <span class="operator">=</span> $id <span class="keyword">AND</span> current_token <span class="operator">=</span> $redlock_value</span><br></pre></td></tr></table></figure><p>可见，这种方案依赖 MySQL 的事物机制，也达到对方提到的 fecing token 一样的效果。</p><p>但这里还有个小问题，是网友参与问题讨论时提出的：<strong>两个客户端通过这种方案，先「标记」再「检查+修改」共享资源，那这两个客户端的操作顺序无法保证啊？</strong></p><p>而用 Martin 提到的 fecing token，因为这个 token 是单调递增的数字，资源服务器可以拒绝小的 token 请求，保证了操作的「顺序性」！</p><p>Redis 作者对这问题做了不同的解释，我觉得很有道理，他解释道：<strong>分布式锁的本质，是为了「互斥」，只要能保证两个客户端在并发时，一个成功，一个失败就好了，不需要关心「顺序性」。</strong></p><blockquote><p>前面 Martin 的质疑中，一直很关心这个顺序性问题，但 Redis 的作者的看法却不同。</p></blockquote><p>综上，Redis 作者的结论：</p><p><strong>1、作者同意对方关于「时钟跳跃」对 Redlock 的影响，但认为时钟跳跃是可以避免的，取决于基础设施和运维。</strong></p><p><strong>2、Redlock 在设计时，充分考虑了 NPC 问题，在 Redlock 步骤 3 之前出现 NPC，可以保证锁的正确性，但在步骤 3 之后发生 NPC，不止是 Redlock 有问题，其它分布式锁服务同样也有问题，所以不在讨论范畴内。</strong></p><p>是不是觉得很有意思？</p><p>在分布式系统中，一个小小的锁，居然可能会遇到这么多问题场景，影响它的安全性！</p><p>不知道你看完双方的观点，更赞同哪一方的说法呢？</p><p>别急，后面我还会综合以上论点，谈谈自己的理解。</p><p>好，讲完了双方对于 Redis 分布锁的争论，你可能也注意到了，Martin 在他的文章中，推荐使用 Zookeeper 实现分布式锁，认为它更安全，确实如此吗？</p><h1 id="基于-Zookeeper-的锁安全吗？"><a href="#基于-Zookeeper-的锁安全吗？" class="headerlink" title="基于 Zookeeper 的锁安全吗？"></a>基于 Zookeeper 的锁安全吗？</h1><p>如果你有了解过 Zookeeper，基于它实现的分布式锁是这样的：</p><ol><li>客户端 1 和 2 都尝试创建「临时节点」，例如 &#x2F;lock</li><li>假设客户端 1 先到达，则加锁成功，客户端 2 加锁失败</li><li>客户端 1 操作共享资源</li><li>客户端 1 删除 &#x2F;lock 节点，释放锁</li></ol><p>你应该也看到了，Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端 1 拿到锁后，只要连接不断，就可以一直持有锁。</p><p>而且，如果客户端 1 异常崩溃了，那么这个临时节点会自动删除，保证了锁一定会被释放。</p><p><strong>不错，没有锁过期的烦恼，还能在异常时自动释放锁，是不是觉得很完美？</strong></p><p>其实不然。</p><p>思考一下，客户端 1 创建临时节点后，Zookeeper 是如何保证让这个客户端一直持有锁呢？</p><p>原因就在于，<strong>客户端 1 此时会与 Zookeeper 服务器维护一个 Session，这个 Session 会依赖客户端「定时心跳」来维持连接。</strong></p><p>如果 Zookeeper 长时间收不到客户端的心跳，就认为这个 Session 过期了，也会把这个临时节点删除。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210617101445733.png" alt="图片"></p><p>同样地，基于此问题，我们也讨论一下 GC 问题对 Zookeeper 的锁有何影响：</p><ol><li>客户端 1 创建临时节点 &#x2F;lock 成功，拿到了锁</li><li>客户端 1 发生长时间 GC</li><li>客户端 1 无法给 Zookeeper 发送心跳，Zookeeper 把临时节点「删除」</li><li>客户端 2 创建临时节点 &#x2F;lock 成功，拿到了锁</li><li>客户端 1 GC 结束，它仍然认为自己持有锁（冲突）</li></ol><p>可见，即使是使用 Zookeeper，也无法保证进程 GC、网络延迟异常场景下的安全性。</p><p><strong>这就是前面 Redis 作者在反驳的文章中提到的：如果客户端已经拿到了锁，但客户端与锁服务器发生「失联」（例如 GC），那不止 Redlock 有问题，其它锁服务都有类似的问题，Zookeeper 也是一样！</strong></p><p>所以，这里我们就能得出结论了：<strong>一个分布式锁，在极端情况下，不一定是安全的。</strong></p><p>如果你的业务数据非常敏感，在使用分布式锁时，一定要注意这个问题，不能假设分布式锁 100% 安全。</p><p>好，现在我们来总结一下 Zookeeper 在使用分布式锁时优劣：</p><p>Zookeeper 的优点：</p><ol><li>不需要考虑锁的过期时间</li><li>watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁</li></ol><p>但它的劣势是：</p><ol><li>性能不如 Redis</li><li>部署和运维成本高</li><li>客户端与 Zookeeper 的长时间失联，锁被释放问题</li></ol><h2 id="我对分布式锁的理解"><a href="#我对分布式锁的理解" class="headerlink" title="我对分布式锁的理解"></a>我对分布式锁的理解</h2><p>好了，前面详细介绍了基于 Redis 的 Redlock 和 Zookeeper 实现的分布锁，在各种异常情况下的安全性问题，下面我想和你聊一聊我的看法，仅供参考，不喜勿喷。</p><p><strong>1) 到底要不要用 Redlock？</strong></p><p>前面也分析了，Redlock 只有建立在「时钟正确」的前提下，才能正常工作，如果你可以保证这个前提，那么可以拿来使用。</p><p>但保证时钟正确，我认为并不是你想的那么简单就能做到的。</p><p><strong>第一，从硬件角度来说</strong>，时钟发生偏移是时有发生，无法避免。</p><p>例如，CPU 温度、机器负载、芯片材料都是有可能导致时钟发生偏移的。</p><p><strong>第二，从我的工作经历来说</strong>，曾经就遇到过时钟错误、运维暴力修改时钟的情况发生，进而影响了系统的正确性，所以，人为错误也是很难完全避免的。</p><p>所以，我对 Redlock 的个人看法是，尽量不用它，而且它的性能不如单机版 Redis，部署成本也高，我还是会优先考虑使用主从+ 哨兵的模式 实现分布式锁。</p><p>那正确性如何保证呢？第二点给你答案。</p><p><strong>2) 如何正确使用分布式锁？</strong></p><p>在分析 Martin 观点时，它提到了 fecing token 的方案，给我了很大的启发，虽然这种方案有很大的局限性，但对于保证「正确性」的场景，是一个非常好的思路。</p><p>所以，我们可以把这两者结合起来用：</p><p><strong>1、使用分布式锁，在上层完成「互斥」目的，虽然极端情况下锁会失效，但它可以最大程度把并发请求阻挡在最上层，减轻操作资源层的压力。</strong></p><p><strong>2、但对于要求数据绝对正确的业务，在资源层一定要做好「兜底」，设计思路可以借鉴 fecing token 的方案来做。</strong></p><p>两种思路结合，我认为对于大多数业务场景，已经可以满足要求了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，总结一下。</p><p>这篇文章，我们主要探讨了基于 Redis 实现的分布式锁，究竟是否安全这个问题。</p><p>从最简单分布式锁的实现，到处理各种异常场景，再到引出 Redlock，以及两个分布式专家的辩论，得出了 Redlock 的适用场景。</p><p>最后，我们还对比了 Zookeeper 在做分布式锁时，可能会遇到的问题，以及与 Redis 的差异。</p><p>这里我把这些内容总结成了思维导图，方便你理解。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640.png" alt="图片"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章的信息量其实是非常大的，我觉得应该把分布锁的问题，彻底讲清楚了。</p><p>如果你没有理解，我建议你多读几遍，并在脑海中构建各种假定的场景，反复思辨。</p><p>在写这篇文章时，我又重新研读了两位大神关于 Redlock 争辩的这两篇文章，可谓是是收获满满，在这里也分享一些心得给你。</p><p>1、在分布式系统环境下，看似完美的设计方案，可能并不是那么「严丝合缝」，如果稍加推敲，就会发现各种问题。所以，在思考分布式系统问题时，一定要<strong>谨慎再谨慎</strong>。</p><p>2、从 Redlock 的争辩中，我们不要过多关注对错，而是要多学习大神的思考方式，以及对一个问题严格审查的严谨精神。</p><p>最后，用 Martin 在对于 Redlock 争论过后，写下的感悟来结尾：</p><p>“<strong>前人已经为我们创造出了许多伟大的成果：站在巨人的肩膀上，我们可以才得以构建更好的软件。无论如何，通过争论和检查它们是否经得起别人的详细审查，这是学习过程的一部分。但目标应该是获取知识，而不是为了说服别人，让别人相信你是对的。有时候，那只是意味着停下来，好好地想一想。</strong>”</p><p>共勉。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web用户认证机制</title>
      <link href="/2020/03/02/Web%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/03/02/Web%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>在早期的 Web 应用中，主要以静态文档浏览为主，这种无状态性并未带来明显问题。但随着互联网的演进，交互式 Web 应用逐渐成为主流。用户不再仅仅满足于浏览网页，而是期望能够进行登录、发表评论、购物、在线协作等丰富多样的操作。这些交互式功能的实现依赖于服务器能够识别用户身份，并跟踪用户在不同页面和操作之间的状态信息，以提供个性化的服务和准确的交互响应。例如，在购物网站中，用户需要将商品加入购物车，服务器必须清楚知道这些商品属于哪个用户，以便在结算时准确计算总价并处理订单；在社交平台上，用户的登录状态决定了其能够查看和操作的内容，以及与其他用户的交互权限。</p><p>为了克服 HTTP 协议无状态性带来的挑战，满足 Web 应用对用户身份识别和状态跟踪的需求，Cookie、Session 和 Token 等技术应运而生。它们在 Web 开发领域中扮演着至关重要的角色，共同构建了现代 Web 应用中用户认证和状态管理的基础架构，为实现安全、高效、个性化的 Web 服务提供了不可或缺的支持，推动了 Web 应用向更加复杂和功能强大的方向发展。</p><span id="more"></span><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>1991 年 HTTP 0.9 诞生了，当时只是为了满足大家浏览 web 文档的要求 ，所以只有 GET 请求，浏览完了就走了，两个连接之间是没有任何联系的，这也是 HTTP 为无状态的原因，因为它诞生之初就没有这个需求。</p><p>但随着交互式 Web 的兴起（所谓交互式就是你不光可以浏览，还可以登录，发评论，购物等用户操作的行为），单纯地浏览 web 已经无法满足人们的要求，比如随着网上购物的兴起，需要记录用户的购物车记录，就需要有一个机制记录每个连接的关系，这样我们就知道加入购物车的商品到底属于谁了，于是 Cookie 就诞生了。</p><blockquote><p>Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行 Session 跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。</p></blockquote><p>工作机制如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101127316" alt="图片">img</p><p>以加入购物车为例，每次浏览器请求后 server 都会将本次商品 id 存储在 Cookie 中返回给客户端，客户端会将 Cookie 保存在本地，下一次再将上次保存在本地的 Cookie 传给 server 就行了，这样每个 Cookie 都保存着用户的商品 id，购买记录也就不会丢失了</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101133075" alt="图片">img</p><p>仔细观察上图相信你不难发现随着购物车内的商品越来越多，每次请求的 cookie 也越来越大，这对每个请求来说是一个很大的负担，我只是想将一个商品加入购买车，为何要将历史的商品记录也一起返回给 server ？购物车信息其实已经记录在 server 了，浏览器这样的操作岂不是多此一举？怎么改进呢</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>仔细考虑下，由于用户的购物车信息都会保存在 Server 中，所以在 Cookie 里只要保存能识别用户身份的信息，知道是谁发起了加入购物车操作即可，这样每次请求后只要在 Cookie 里带上用户的身份信息，请求体里也只要带上本次加入购物车的商品 id，大大减少了 cookie 的体积大小，我们把这种能识别哪个请求由哪个用户发起的机制称为 Session（会话机制），生成的能识别用户身份信息的字符串称为 sessionId，它的工作机制如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101138792" alt="图片"></p><ol><li>首先用户登录，server 会为用户生成一个 session，为其分配唯一的 sessionId，这个 sessionId 是与某个用户绑定的，也就是说根据此 sessionid（假设为 abc） 可以查询到它到底是哪个用户，然后将此 sessionid 通过 cookie 传给浏览器</li><li>之后浏览器的每次添加购物车请求中只要在 cookie 里带上 sessionId&#x3D;abc 这一个键值对即可，server 根据 sessionId 找到它对应的用户后，把传过来的商品 id 保存到 server 中对应用户的购物车即可</li></ol><p>可以看到通过这种方式再也不需要在 cookie 里传所有的购物车的商品 id 了，大大减轻了请求的负担！</p><p>另外通过上文不难观察出 <strong>cookie 是存储在 client 的，而 session 保存在 server</strong>，sessionId 需要借助 cookie 的传递才有意义。</p><h3 id="session-的痛点"><a href="#session-的痛点" class="headerlink" title="session 的痛点"></a>session 的痛点</h3><p>看起来通过  cookie + session 的方式是解决了问题， 但是我们忽略了一个问题，上述情况能正常工作是因为我们假设 server 是单机工作的，但实际在生产上，为了保障高可用，一般服务器至少需要两台机器，通过负载均衡的方式来决定到底请求该打到哪台机器上。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101154301" alt="图片">balance</p><p><strong>如图示：客户端请求后，由负载均衡器（如 Nginx）来决定到底打到哪台机器</strong></p><p>假设登录请求打到了 A 机器，A 机器生成了 session 并在 cookie 里添加 sessionId 返回给了浏览器，那么问题来了：下次添加购物车时如果请求打到了 B 或者 C，由于 session 是在 A 机器生成的，此时的 B,C 是找不到 session 的，那么就会发生无法添加购物车的错误，就得重新登录了，此时请问该怎么办。主要有以下三种方式</p><blockquote><p>1、session 复制</p></blockquote><p>A 生成 session 后复制到 B, C，这样每台机器都有一份 session，无论添加购物车的请求打到哪台机器，由于 session 都能找到，故不会有问题</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101201725" alt="图片">balance (1)</p><p>这种方式虽然可行，但缺点也很明显：</p><ol><li>同一样的一份 session 保存了多份，数据冗余</li><li>如果节点少还好，但如果节点多的话，特别是像阿里，微信这种由于 DAU 上亿，可能需要部署成千上万台机器，这样节点增多复制造成的性能消耗也会很大。</li></ol><blockquote><p>2、session 粘连</p></blockquote><p>这种方式是让每个客户端请求只打到固定的一台机器上，比如浏览器登录请求打到 A 机器后，后续所有的添加购物车请求也都打到 A 机器上，Nginx 的 sticky 模块可以支持这种方式，支持按 ip 或 cookie 粘连等等，如按 ip 粘连方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcats &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 10.1.1.107:88;</span><br><span class="line">  server 10.1.1.132:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101207746" alt="图片">img</p><p>这样的话每个 client 请求到达 Nginx 后，只要它的 ip 不变，根据 ip hash 算出来的值会打到固定的机器上，也就不存在 session 找不到的问题了，当然不难看出这种方式缺点也是很明显，对应的机器挂了怎么办？</p><blockquote><p>3、session 共享</p></blockquote><p>这种方式也是目前各大公司普遍采用的方案，将 session 保存在 redis，memcached 等中间件中，请求到来时，各个机器去这些中间件取一下 session 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101212174" alt="图片">img</p><p>缺点其实也不难发现，就是每个请求都要去 redis 取一下 session，多了一次内部连接，消耗了一点性能，另外为了保证 redis 的高可用，必须做集群，当然了对于大公司来说, redis 集群基本都会部署，所以这方案可以说是大公司的首选了。</p><h3 id="Token：no-session"><a href="#Token：no-session" class="headerlink" title="Token：no session!"></a>Token：no session!</h3><p>通过上文分析我们知道通过在服务端共享 session 的方式可以完成用户的身份定位，但是不难发现也有一个小小的瑕疵：搞个校验机制我还得搭个 redis 集群？大厂确实 redis 用得比较普遍，但对于小厂来说可能它的业务量还未达到用 redis 的程度，所以有没有其他不用 server 存储 session 的用户身份校验机制呢，这就是我们今天要介绍的主角：token。</p><p>首先请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地，之后向 server 请求时在请求头带上此 token 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101217167" alt="图片">img</p><p>相信大家看了上图会发现存在两个问题</p><p>1、 token 只存储在浏览器中，服务端却没有存储，这样的话我随便搞个 token 传给 server 也行？</p><p>答：server 会有一套校验机制，校验这个 token 是否合法。</p><p>2、怎么不像 session 那样根据 sessionId 找到 userid 呢，这样的话怎么知道是哪个用户？</p><p>答：token 本身携带 uid 信息</p><p>第一个问题，如何校验 token 呢？我们可以借鉴 HTTPS 的签名机制来校验。先来看 jwt token 的组成部分</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101223022" alt="图片">img</p><p>可以看到 token 主要由三部分组成</p><ol><li>header：指定了签名算法</li><li>payload：可以指定用户 id，过期时间等非敏感数据</li><li>Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。</li></ol><p>当 server 收到浏览器传过来的 token 时，它会首先取出 token 中的 header + payload，根据密钥生成签名，然后再与 token 中的签名比对，如果成功则说明签名是合法的，即 token 是合法的。而且你会发现 payload 中存有我们的 userId，所以拿到 token 后直接在 payload 中就可获取 userid，避免了像 session 那样要从 redis 去取的开销</p><p><strong>画外音：header, payload 实际上是以 base64 的形式存在的，文中为了描述方便，省去了这一步。</strong></p><p>你会发现这种方式确实很妙，只要 server 保证密钥不泄露，那么生成的 token 就是安全的，因为如果伪造 token 的话在签名验证环节是无法通过的，就此即可判定 token 非法。</p><p>可以看到通过这种方式有效地避免了 token 必须保存在 server 的弊端，实现了分布式存储，不过需要注意的是，token 一旦由 server 生成，它就是有效的，直到过期，无法让 token 失效，除非在 server 为 token 设立一个黑名单，在校验 token 前先过一遍此黑名单，如果在黑名单里则此  token 失效，但一旦这样做的话，那就意味着黑名单就必须保存在 server，这又回到了 session 的模式，那直接用 session 不香吗。所以一般的做法是当客户端登出要让 token 失效时，直接在本地移除 token 即可，下次登录重新生成 token 就好。</p><p>另外需要注意的是 token 一般是放在 header 的 Authorization 自定义头里，不是放在 Cookie 里的，这主要是为了解决跨域不能共享 Cookie 的问题 （下文详述）</p><h3 id="Cookie-与-Token-的简单总结"><a href="#Cookie-与-Token-的简单总结" class="headerlink" title="Cookie 与 Token 的简单总结"></a>Cookie 与 Token 的简单总结</h3><blockquote><p>Cookie 有哪些局限性？</p></blockquote><p>1、 Cookie 跨站是不能共享的，这样的话如果你要实现多应用（多系统）的单点登录（SSO），使用 Cookie 来做需要的话就很困难了（要用比较复杂的 trick 来实现，有兴趣的话可以看文末参考链接）</p><p><strong>画外音: 所谓单点登录，是指在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</strong></p><p>但如果用 token 来实现 SSO 会非常简单，如下</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101228882" alt="图片">img</p><p>只要在 header 中的 authorize 字段（或其他自定义）加上 token 即可完成所有跨域站点的认证。</p><p>2、 在移动端原生请求是没有 cookie 之说的，而 sessionid 依赖于 cookie，sessionid 就不能用 cookie 来传了，如果用 token 的话，由于它是随着 header 的 authoriize 传过来的，也就不存在此问题，换句话说token 天生支持移动平台，可扩展性好</p><p>综上所述，token 具有存储实现简单，扩展性好这些特点。</p><blockquote><p>token 有哪些缺点</p></blockquote><p>那有人就问了，既然 token 这么好，那为什么各个大公司几乎都采用共享 session 的方式呢，可能很多人是第一次听到 token，token 不香吗? token 有以下两点劣势：</p><p>1、 token 太长了</p><p>token 是 header, payload 编码后的样式，所以一般要比 sessionId 长很多，很有可能超出 cookie 的大小限制（cookie 一般有大小限制的，如 4kb），如果你在 token 中存储的信息越长，那么 token 本身也会越长，这样的话由于你每次请求都会带上 token，对请求来是个不小的负担</p><p>2、 不太安全</p><p>网上很多文章说 token 更安全，其实不然，细心的你可能发现了，我们说 token 是存在浏览器的，再细问，存在浏览器的哪里？既然它太长放在 cookie 里可能导致 cookie 超限，那就只好放在 local storage 里，这样会造成安全隐患，因为 local storage 这类的本地存储是可以被 JS 直接读取的，另外由上文也提到，token 一旦生成无法让其失效，必须等到其过期才行，这样的话如果服务端检测到了一个安全威胁，也无法使相关的 token 失效。</p><p><strong>所以 token 更适合一次性的命令认证，设置一个比较短的有效期</strong></p><h3 id="误解-Cookie-相比-token-更不安全，比如-CSRF-攻击"><a href="#误解-Cookie-相比-token-更不安全，比如-CSRF-攻击" class="headerlink" title="误解: Cookie 相比 token 更不安全，比如 CSRF 攻击"></a>误解: Cookie 相比 token 更不安全，比如 CSRF 攻击</h3><p>首先我们需要解释下 CSRF 攻击是怎么回事</p><p>攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过（cookie 里带来 sessionId 等身份认证的信息），所以被访问的网站会认为是真正的用户操作而去运行。</p><p>比如用户登录了某银行网站（假设为 **<a href="http://www.examplebank.com/**%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BD%AC%E8%B4%A6%E5%9C%B0%E5%9D%80%E4%B8%BA">http://www.examplebank.com/**，并且转账地址为</a> <strong><a href="http://www.examplebank.com/withdraw?amount=1000&transferTo=PayeeName">http://www.examplebank.com/withdraw?amount=1000&amp;transferTo=PayeeName</a></strong>），登录后 cookie 里会包含登录用户的 sessionid，攻击者可以在另一个网站上放置如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;</span><br></pre></td></tr></table></figure><p>那么如果正常的用户误点了上面这张图片，由于相同域名的请求会自动带上 cookie，而 cookie 里带有正常登录用户的 sessionid，类似上面这样的转账操作在 server 就会成功，会造成极大的安全风险</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210903101238289" alt="图片">csrf 示意图</p><p>CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 cookie 都会被自动带上，这个是浏览器的机制决定的，所以很多人据此认定 cookie 不安全。</p><p>使用 token 确实避免了CSRF 的问题，但正如上文所述，由于 token 保存在 local storage，它会被 JS 读取，<strong>从存储角度来看</strong>也不安全（实际上防护 CSRF 攻击的正确方式是用 CSRF token）</p><p>所以不管是 cookie 还是 token，从存储角度来看其实都不安全，都有暴露的风险，我们所说的安全更多的是强调传输中的安全，可以用 HTTPS 协议来传输， 这样的话请求头都能被加密，也就保证了传输中的安全。</p><p>其实我们把 cookie 和 token 比较本身就不合理，一个是存储方式，一个是验证方式，正确的比较应该是 session vs token。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>session 和 token 本质上是没有区别的，都是对用户身份的认证机制，只是他们实现的校验机制不一样而已（一个保存在 server，通过在 redis 等中间件获取来校验，一个保存在 client，通过签名校验的方式来校验），多数场景上使用 session 会更合理，但如果在单点登录，一次性命令认证上使用 token 会更合适，最好在不同的业务场景中合理选型，才能达到事半功倍的效果。</p><p>巨人的肩膀</p><ul><li>Cookie Session跨站无法共享问题(单点登录解决方案)：<a href="https://blog.csdn.net/wtopps/article/details/75040224">https://blog.csdn.net/wtopps/article/details/75040224</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码规范</title>
      <link href="/2019/06/16/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2019/06/16/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>代码规范</p><span id="more"></span><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="1-1-正确使用-equals-方法"><a href="#1-1-正确使用-equals-方法" class="headerlink" title="1.1. 正确使用 equals 方法"></a>1.1. 正确使用 equals 方法</h2><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 </p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">&quot;SnailClimb&quot;</span>)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;SnailClimb&quot;</span>.equals(str);<span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>不过更推荐使用 <code>java.util.Objects#equals</code>(JDK7 引入的工具类)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(<span class="literal">null</span>,<span class="string">&quot;SnailClimb&quot;</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们看一下<code>java.util.Objects#equals</code>的源码就知道原因了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span></span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>Reference:<a href="https://blog.csdn.net/tick_tock97/article/details/72824894">Java中equals方法造成空指针异常的原因及解决方案</a></p><ul><li>每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。</li><li>可以使用 &#x3D;&#x3D; 或者 !&#x3D; 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中<code>null == null</code>将返回true。</li><li>不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</li></ul><h2 id="1-2-整型包装类值的比较"><a href="#1-2-整型包装类值的比较" class="headerlink" title="1.2. 整型包装类值的比较"></a>1.2. 整型包装类值的比较</h2><p>所有整型包装类对象值的比较必须使用equals方法。</p><p>先看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生拆箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而<code>Integer i1 = new Integer(40)</code> 会直接创建新的对象。因此，输出 false 。</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 <code>equals()</code>  方法比较</strong>。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281141849.png"></p><p><strong>注意：</strong> 如果你的IDE(IDEA&#x2F;Eclipse)上安装了阿里巴巴的p3c插件，这个插件如果检测到你用 &#x3D;&#x3D;的话会报错提示，推荐安装一个这个插件，很不错。</p><h2 id="1-3-BigDecimal"><a href="#1-3-BigDecimal" class="headerlink" title="1.3. BigDecimal"></a>1.3. BigDecimal</h2><h3 id="1-3-1-BigDecimal-的用处"><a href="#1-3-1-BigDecimal-的用处" class="headerlink" title="1.3.1. BigDecimal 的用处"></a>1.3.1. BigDecimal 的用处</h3><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b); </span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-BigDecimal-的大小比较"><a href="#1-3-2-BigDecimal-的大小比较" class="headerlink" title="1.3.2. BigDecimal 的大小比较"></a>1.3.2. BigDecimal 的大小比较</h3><p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1表示 <code>a</code> 大于 <code>b</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3-BigDecimal-保留几位小数"><a href="#1-3-3-BigDecimal-保留几位小数" class="headerlink" title="1.3.3. BigDecimal 保留几位小数"></a>1.3.3. BigDecimal 保留几位小数</h3><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">n</span> <span class="operator">=</span> m.setScale(<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.255</span></span><br></pre></td></tr></table></figure><h3 id="1-3-4-BigDecimal-的使用注意事项"><a href="#1-3-4-BigDecimal-的使用注意事项" class="headerlink" title="1.3.4. BigDecimal 的使用注意事项"></a>1.3.4. BigDecimal 的使用注意事项</h3><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210928104528.png" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></p><h3 id="1-3-5-总结"><a href="#1-3-5-总结" class="headerlink" title="1.3.5. 总结"></a>1.3.5. 总结</h3><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p><p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p><h2 id="1-4-基本数据类型与包装数据类型的使用标准"><a href="#1-4-基本数据类型与包装数据类型的使用标准" class="headerlink" title="1.4. 基本数据类型与包装数据类型的使用标准"></a>1.4. 基本数据类型与包装数据类型的使用标准</h2><p>Reference:《阿里巴巴Java开发手册》</p><ul><li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li><li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul><p>比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.</p><p><strong>说明</strong> :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p><p><strong>正例</strong> : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p><p><strong>反例</strong> : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p><h1 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h1><h2 id="2-1-Arrays-asList-使用指南"><a href="#2-1-Arrays-asList-使用指南" class="headerlink" title="2.1. Arrays.asList()使用指南"></a>2.1. Arrays.asList()使用指南</h2><p>最近使用<code>Arrays.asList()</code>遇到了一些坑，然后在网上看到这篇文章：<a href="http://javadevnotes.com/java-array-to-list-examples">Java Array to List Examples</a> 感觉挺不错的，但是还不是特别全面。所以，自己对于这块小知识点进行了简单的总结。</p><h3 id="2-1-1-简介"><a href="#2-1-1-简介" class="headerlink" title="2.1.1. 简介"></a>2.1.1. 简介</h3><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure><p>JDK 源码对于这个方法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，</span></span><br><span class="line"><span class="comment">  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-《阿里巴巴Java-开发手册》对其的描述"><a href="#2-1-2-《阿里巴巴Java-开发手册》对其的描述" class="headerlink" title="2.1.2. 《阿里巴巴Java 开发手册》对其的描述"></a>2.1.2. 《阿里巴巴Java 开发手册》对其的描述</h3><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210928104537.png" alt="阿里巴巴Java开发手-Arrays.asList()方法"></p><h3 id="2-1-3-使用时的注意事项总结"><a href="#2-1-3-使用时的注意事项总结" class="headerlink" title="2.1.3. 使用时的注意事项总结"></a>2.1.3. 使用时的注意事项总结</h3><p><strong>传递的数组必须是对象数组，而不是基本类型。</strong> </p><p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span>[] array = (<span class="type">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>我们使用包装类型数组就可以解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用集合的修改方法:<code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></table></figure><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></span><br></pre></td></tr></table></figure><p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>, java.io.Serializable</span><br><span class="line">  &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-4-如何正确的将数组转换为ArrayList"><a href="#2-1-4-如何正确的将数组转换为ArrayList" class="headerlink" title="2.1.4. 如何正确的将数组转换为ArrayList?"></a>2.1.4. 如何正确的将数组转换为ArrayList?</h3><p>stackoverflow：<a href="https://dwz.cn/vcBkTiTW">https://dwz.cn/vcBkTiTW</a></p><p><strong>1. 自己动手实现（教育目的）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.5+</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(array.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</span><br><span class="line">    l.add(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">System.out.println(arrayToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></span><br></pre></td></tr></table></figure><p><strong>2. 最简便的方法(推荐)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))</span><br></pre></td></tr></table></figure><p><strong>3. 使用 Java8 的Stream(推荐)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>4. 使用 Guava(推荐)</strong></p><p>对于不可变集合，你可以使用[<code>ImmutableList</code>]类及其[<code>of()</code>]与[<code>copyOf()</code>]工厂方法：（参数不能为空）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br></pre></td></tr></table></figure><p>对于可变集合，你可以使用[<code>Lists</code>]类及其[<code>newArrayList()</code>]工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure><p><strong>5. 使用 Apache Commons Collections</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list, str);</span><br></pre></td></tr></table></figure><p><strong>6. 使用 Java9 的 <code>List.of()</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 2, 3] */</span></span><br><span class="line"><span class="comment">/* 不支持基本数据类型 */</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Collection-toArray-方法使用的坑-如何反转数组"><a href="#2-2-Collection-toArray-方法使用的坑-如何反转数组" class="headerlink" title="2.2. Collection.toArray()方法使用的坑&amp;如何反转数组"></a>2.2. Collection.toArray()方法使用的坑&amp;如何反转数组</h2><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></span><br></pre></td></tr></table></figure><p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p><h2 id="2-3-不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#2-3-不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="2.3. 不要在 foreach 循环里进行元素的 remove&#x2F;add 操作"></a>2.3. 不要在 foreach 循环里进行元素的 remove&#x2F;add 操作</h2><p>如果要进行<code>remove</code>操作，可以调用迭代器的 <code>remove </code>方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p></blockquote><p>Java8开始，可以使用<code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure><p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210928104803.png" alt="不要在 foreach 循环里进行元素的 remove/add 操作"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负数 &gt;&gt;&gt;运算符的计算过程</title>
      <link href="/2018/09/27/%E8%B4%9F%E6%95%B0%3E%3E%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/09/27/%E8%B4%9F%E6%95%B0%3E%3E%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>“&gt;&gt;&gt;” 表示无符号右移,正数情况下, a &gt;&gt;&gt; b 等价于 a &#x2F; Math.pow(2,b)</p><p>以 -16 &gt;&gt;&gt; 2 为例子 负16右移2位</p><ol><li>将-16转为2进制 (用补码表示负数)<ul><li>16 &#x3D; 00000000 00000000 00000000 00010000</li><li>取反并补码 &#x3D; 11111111 11111111 11111111 11101111 + 1 &#x3D; 11111111 11111111 11111111 11110000</li><li>右移2位 &#x3D; 00111111 11111111 11111111 11111100 &#x3D; 10进制 1073741820</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
