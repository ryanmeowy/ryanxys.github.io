<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>low gravity</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-29T05:48:02.180Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ryan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>检索技术20讲 基础技术篇</title>
    <link href="http://example.com/2022/06/18/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF20%E8%AE%B2%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    <id>http://example.com/2022/06/18/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF20%E8%AE%B2%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E7%AF%87/</id>
    <published>2022-06-18T12:09:15.000Z</published>
    <updated>2022-10-29T05:48:02.180Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>极客时间 检索技术20讲 学习文档</p></blockquote><h2 id="何为检索"><a href="#何为检索" class="headerlink" title="何为检索"></a>何为检索</h2><p>一句话概括检索技术：它是更底层的通用技术，它研究的是如何将我们所需要的数据高效地取出来</p><p>检索相关知识全景图</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329417.jpg" alt="img"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-线性结构检索"><a href="#1-线性结构检索" class="headerlink" title="1.线性结构检索"></a>1.线性结构检索</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329615.jpeg" alt="img"></p><p>数组和链表分别代表了连续空间和不连续空间的最基础的存储方式，它们是线性表（Linear List）的典型代表。其他所有的数据结构，比如栈、队列、二叉树、B+ 树等，都不外乎是这两者的结合和变化。以栈为例，它本质就是一个限制了读写位置的数组，特点是只允许后进先出。</p><h5 id="如何检索"><a href="#如何检索" class="headerlink" title="如何检索"></a>如何检索</h5><p>如果数据是无序存储的话，无论是数组还是链表，想要查找一个指定元素是否存在，在缺乏数据分布信息的情况下，我们只能从头到尾遍历一遍，才能知道其是否存在。这样的检索效率就是 O(n)。</p><p>如果数据量较大，O(n)的检索效率肯定是不合格的，所以我们需要更高效的检索方式。</p><p>对于规模较大的数据集，我们往往是先将它通过排序算法转为有序的数据集，然后通过一些检索算法，比如二分查找算法来完成高效的检索。</p><p>二分查找也叫折半查找，它的思路很直观，就是将有序数组二分为左右两个部分，通过只在半边进行查找来提升检索效率。整体的平均查询效率就是 O(log n)，远远小于遍历整个数组的代价 O(n)。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329406.jpeg" alt="img"></p><p>检索的核心思路，其实就是通过合理组织数据，尽可能地快速减少查询范围，提高检索效率</p><h4 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h4><p>二分查找可以很大的提高有序数组的查找效率，这与数组的随机访问特性有关，通过下标，我们可以很轻易的访问到中间的元素，这是数组的 ‘连续空间存储’ 带来的优点</p><p>链表并不具备 随机访问 的特点， 如果我们想要访问链表的中间元素， 需要遍历链表到中间节点， 时间代价就是O(n/2)，所以，由于缺少了 随机访问 的特性， 链表的检索能力是偏弱的</p><p>凡事都有两面性，链表的 非连续空间存储 的特性给它带来了动态调整上的优势</p><p>想象一下，如果我们需要在有序数组中插入一个元素，为保证数组的有序，我们需要将数组中大于这个元素的所有其他元素后移一位，这其实是一个O(n)的时间代价了 ，而对于链表来说，插入和删除只需要调整前后节点的指针即可， 时间代价为O(1)</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329163.jpeg" alt="img"></p><h4 id="如何改造链表"><a href="#如何改造链表" class="headerlink" title="如何改造链表"></a>如何改造链表</h4><p>本质上，我们学习链表，就是在学习“非连续存储空间”的组织方案， 我们知道，对于“非连续空间”，可以用指针将它串联成一个整体。只要掌握了这个思想，我们就可以在不同的应用场景中，设计出适用的数据结构，而不需要拘泥于链表自身的结构限制。</p><p>一个例子：</p><p>如果我们让链表的每个节点不再只存储一个元素，而是存储一个有序数组， 这样可以大幅减少节点数量， 从而减少遍历节点带来的 低寻址效率 。</p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>1.对于有序数组的高效检索，为何使用二分检索， 而不是三七分 或 四六分？</p><p>2.在一个有序数组中，给出两个目标值 x 和 y ， 希望找出目标值之间的所有元素， 应该怎么做？</p><ol><li>因为二分可以确保概率均匀，左右都是1/2 , 最差时间复杂度就是O(log n), 而三七或四六无法保证左右概率均匀， 拿三七举例，假设有序数组一共有100个元素 ， 如果每次都要在右边进行查找，一共需要检索13次， 复杂度为O(log n) 底数大概是1.425 （100 ^ (1/13) 估算）， 二分最多只需检索7次</li><li>两次二分确定下标，两下标区间内的元素就是需要检索的元素</li></ol><h3 id="2-非线性结构检索"><a href="#2-非线性结构检索" class="headerlink" title="2.非线性结构检索"></a>2.非线性结构检索</h3><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329209.jpeg" alt="img"></p><h4 id="树结构进行如何二分查找"><a href="#树结构进行如何二分查找" class="headerlink" title="树结构进行如何二分查找"></a>树结构进行如何二分查找</h4><p>由于链表不具备 随机访问 的特性，无法以O(1)的时间代价访问中间节点，  所以无法使用二分查找 ， 那么如果我们对链表进行一些改造， 让它可以直接访问中间节点， 是不是就能使用二分查找了呢？</p><p>首先将链表的中间节点拎出来单独记录，称之为M节点， 这样我们就可以直接访问它了， 然后判断这个节点存储的元素和需要检索的元素是否一致， 如果 一致，则返回结果即可； 如果节点元素大于检索元素，则到左边继续查找， 反之则到右边查找；</p><p>对于左右两边的节点，将其视为两个独立的子链表， 逻辑和M节点一样， 单独存储左右两个节点。 因为左右两个节点都可能被从M节点访问 ， 我们需要让M节点带两个指针， 左指针指向左边的子链表， 右指针指向右边的子链表</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329975.jpeg" alt="img"></p><p>然后我们对其他节点进行一样的操作，结构就会变成</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329355.jpeg" alt="img"></p><p>这就是我们常见的二叉树</p><p>如果我们保证了链表的有序性， 那么这颗二叉树就是有序的， 左子树的所有节点值都小于根节点， 右子树的所有节点都大于根节点； 这样的有序结构，使它能够使用二分查找，快速地过滤掉一半的数据， 具备这样特点的二叉树，就是二叉检索树，又称二叉排序树</p><p>尽管有序数组和二叉检索树，在数据结构形态上看起来差异很大，但是在提高检索效率上，它们的核心原理都是一致的</p><ul><li>将数据有序化，并且根据数据存储的特点进行不同的组织。对于连续存储空间的数组而言，由于它具有“随机访问”的特性，因此直接存储即可；对于非连续存储空间的有序链表而言，由于它不具备“随机访问”的特性，因此，需要将它改造为可以快速访问到中间节点的树状结构。</li><li>在进行检索的时候，它们都是通过二分查找的思想从中间节点开始查起。如果不命中，会快速缩小一半的查询空间。这样不停迭代的查询方式，让检索的时间代价能达到 O(log n) 这个级别。</li></ul><h4 id="二叉检索树的检索空间平衡方案"><a href="#二叉检索树的检索空间平衡方案" class="headerlink" title="二叉检索树的检索空间平衡方案"></a>二叉检索树的检索空间平衡方案</h4><p>如果一颗二叉检索树的每一个节点的左指针（或右指针）都是空的， 那么它会退化为一个单链表， 检索效率退化为O(n)</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329621.jpeg" alt="img" style="zoom: 50%;" /><p>出现这种情况的最根本原因是检索空间不平衡，在当前节点不满足查询条件的时候，它无法把“一半的数据”过滤掉，而是只能过滤掉当前检索的这个节点。因此无法达到“快速减小查询范围”的目的。</p><p>因此，为了确保二叉查询树的检索效率，需要尽可能的平衡左右子树； 为了解决这个问题， 有更多的数据结构被发明出来， 比如AVL树（平衡二叉树）和红黑树；它们本质上都是二叉检索树，但它们都在保证左右子树差距不要太大上做了特殊的处理，保证了检索效率</p><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>二叉检索树是一种为了实现快速访问中间节点的对链表的改造方案， 还有另一种实现了相同功能的改造方案，称之为 跳表 （skip list）；</p><p>链表之所以访问中间节点的效率低，就是因为每个节点只存储了下一个节点的指针，要沿着这个指针遍历每个后续节点才能到达中间节点；如果我们在每个节点上增加一个指针，指向更远的节点，那么沿着这个指针遍历，就可以实现遍历速度的翻倍。</p><p>同理，我们可以为节点增加更多的指针，这些指针指向不同距离的后续节点，这样一来，链表就具备了更高效的检索能力；</p><p>一个理想的跳表，就是从头节点开始，用多个不同的步长，每隔2^n个节点做一次直接链接（n 取值为 0，1，2……），跳表中的每个节点都拥有多个不同步长的指针，我们可以在每个节点中使用一个数组next来记录这些指针，数组的长度等于指针的层数，比如next[0] 就是第一层步长为1的指针， next[1] 就是第二层步长为2的指针， next[2] 就是第三层步长为4的指针。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329702.jpg" alt="img"></p><p>假设检索目标为a6， 第一步用最大步长遍历至a5， 因为a6 大于a5， 继续遍历至a9, a6小于a9，说明a6在a5和a9之间， 接着从a5开始，使用小一级别的步长遍历至a7, 同理，可以知道a6在a5和a7之间， 继续从a5开始，使用小一级别的步长遍历，检索到a6，检索完毕， 整个过程的时间复杂度为O(log n)；</p><h4 id="跳表的检索空间平衡方案"><a href="#跳表的检索空间平衡方案" class="headerlink" title="跳表的检索空间平衡方案"></a>跳表的检索空间平衡方案</h4><p>实际情况中，  如果我们需要在跳表中插入节点，那么原有节点之间的距离就会被改变，如果要保证每个2^n个节点做一次链接的特性， 那么需要修改许多后续节点的指针，这会带来非常大的开销。</p><p>所以，我们需要在检索性能与修改指针的代价之间做一个权衡； 实际情况中，我们不需要保证链表是一个理想的平衡状态， 只需要保证它在大概率上是平衡的就可以了。</p><p>具体操作是这样， 首先通过随机函数（譬如 (1/2)^n ）来确认新增节点的指针层数，然后将新增节点和前后的节点连接起来，为每一层的指针建立前后连接关系，如下图</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329548.jpg" alt="img"></p><p>因为新节点的指针层数是随机生成的，当链表节点较少的情况下，指针分布可能会比较不合理，这也会导致检索新能不理想； 但当节点数较多时，指针会趋向均匀分布，查找空间会比较平衡，检索性能趋向于理想跳表，接近O(log n)</p><h4 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h4><p>二叉检索树和跳表都能做到 O(log n)  的查询时间代价，还拥有灵活的调整能力，并且调整代价也是 O(log n)（包括了寻找插入位置的时间代价）。而有序数组的查询时间代价也是  O(log n)，调整代价是 O(n)，那这是不是意味着二叉检索树或者跳表可以用来替代有序数组呢？有序数组自己的优势又是什么呢？</p><p>有序数组 使用的是一段连续的内存可以支持随机访问，而且由于使用的是连续的内存的 可以高效使用 CPU 的局部性原理，可以缓存要访问数据之后的数据，进而范围查询更高效</p><h3 id="3-哈希检索"><a href="#3-哈希检索" class="headerlink" title="3.哈希检索"></a>3.哈希检索</h3><p>不管是有序数组、二叉检索树还是跳表，它们的检索效率都是O(log n)，如果想要实现O(1)效率的检索，就需要用到哈希检索了。</p><h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4><p>将对象转为有限范围的正整数的表示方法，就叫作  Hash，翻译过来叫散列，也可以直接音译为哈希。而我们常说的 Hash 函数就是指具体转换方法的函数。我们将对象进行 Hash，用得到的  Hash 值作为数组下标，将对应元素存在数组中。这个数组就叫作哈希表。这样我们就可以利用数组的随机访问特性，达到 O(1) 级别的查询性能。</p><p>hash函数特点决定了它不可避免会出现hash冲突，对于冲突，通常有两种解决方案</p><ul><li>构造尽可能理想的哈希函数，使得hash以后得到的数据尽可能平均分布，从而减少冲突发生的概率</li><li>在冲突发生之后，通过一些解决方案来完成存储和查找，最常用的两种解决方案是 开放寻址法 和 链表法</li></ul><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开放寻址法， 就是在冲突发生以后，待插入的元素需要寻找新空闲的数组位置完成插入，我们可以使用一种叫做 线性探查（Linear Probing） 的方案来寻找新的空闲位置</p><p>线性探查的插入逻辑很简单， 就是按顺序寻找当前冲突数组位的下一个位置， 检查是否空闲， 空闲就插入， 否则就继续往后找。</p><p>查询逻辑与插入逻辑一致， 先根据hash值找到指定的数组位， 如果当前数组位不为空，比较 key是否一致，不一致就按顺序往下继续检索，如果遍历完后仍没有匹配的对象，则代表目标对象不在当前数组中。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082329994.jpg" alt="img"></p><p>在哈希表已经比较满的情况下，线性探查的查询和插入效率都会接近O(n)，并且更糟糕的是，线性探查会影响其他key的插入和查询效率， 线性探查会影响哈希表的整体性能，而不只是hash冲突的key</p><p>对于这个问题， 可以使用 二次探查 和 双散列 来优化</p><p>二次探查就是将线性探查的步长从 i 改为 i^2 （ i 为 1，2，3，4…. )</p><p>双散列就是使用多个hash函数计算， 如果第一个hash值冲突了，启用第二个hash函数计算， 如果继续冲突， 继续启用第三个hash函数计算 ，以此类推 。</p><p>无论是二次探查还是双散列，其实都是治标不治本， 开放寻址法因为它本身的特性， 无论使用何种方案去处理哈希冲突，都会不可避免的影响哈希表整体的性能， 哈希表越满，性能下降得越厉害，到最后无限趋近于 O(n)，这时候就需要Re-Hash ， 就是创建一个新的，更大的哈希表，将老哈希表得数据进行迁移， 这无疑会带来巨大的额外开销。 因此，在数据动态变化得场景下， 开放寻址法并不是一个好的解决方案。</p><h4 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h4><p>所谓“链表法”，就是在数组中不存储一个具体元素，而是存储一个链表头。如果一个 Key 经过 Hash 函数计算，得到了对应的数组下标，那么我们就将它加入该位置所存的链表的尾部。</p><p>这样做的好处是，如果 key3 和 key1 发生了冲突，那么 key3 会通过链表的方式链接在 key1 的后面，而不是去占据 key2 的位置。这样当 key2 插入时，就不会有冲突了。最终效果如下图。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082330783.jpg" alt="img"></p><p>链表法就是将数组和链表进行结合，既利用了数组的随机访问特性，又利用了链表的动态修改特性，同时提供了快速查询和动态修改的能力。</p><p>如果链表很长，遍历代价还是会很高，解决方案就是对链表进行改造， 改造方法在上一篇的非线性结构检索中已经提及，两种思路 ， 1.改造为二叉检索树 。 2.改造为跳表 。 检索这样的哈希表的平均时间复杂度为                O(1) + O(log n)， 如果哈希冲突比较少，那么落到链表或红黑树中的元素不会太多， 检索代价基本可以视为常数级别。</p><p>在 JDK1.8 之后，Java 中 HashMap 的实现就是在链表到了一定的长度时，将它转为红黑树；而当红黑树中的节点低于一定阈值时，就将它退化为链表。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202207082330214.jpg" alt="img"></p><h4 id="哈希表的缺点"><a href="#哈希表的缺点" class="headerlink" title="哈希表的缺点"></a>哈希表的缺点</h4><p>哈希表接近 O(1) 的检索效率是有前提条件的，就是哈希表要足够大和有足够的空闲位置，否则就会非常容易发生冲突。我们一般用装载因子（load factor）来表示哈希表的填充率。装载因子 = 哈希表中元素个数 / 哈希表的长度。</p><p>如果频繁发生冲突，大部分的数据会被持续地添加到链表或二叉检索树中，检索也会发生在链表或者二叉检索树中，这样检索效率就会退化。因此，为了保证哈希表的检索效率，我们需要预估哈希表中的数据量，提前生成足够大的哈希表。按经验来说，我们一般要预留一半以上的空闲位置，哈希表才会有足够优秀的检索效率。这就让哈希表和有序数组、二叉检索树相比，需要的存储空间更多了。</p><p>哈希表无法进行范围检索，需要遍历所有元素。</p><h4 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h4><p>假设一个哈希表是使用开放寻址法实现的，如果我们需要删除其中一个元素，可以直接删除吗？为什么呢？如果这个哈希表是使用链表法实现的会有不同吗？</p><p>不能，开放寻址法在hash冲突后，会将元素往后放，如果已经存在几个hash冲突的元素， 删除其中一个，会影响对后面元素的检索， 可以对要删除的元素加一个删除标签。</p><p>如果是链表法的话直接删除即可，链表的删除时间代价为O(1)</p><h3 id="4-状态检索"><a href="#4-状态检索" class="headerlink" title="4.状态检索"></a>4.状态检索</h3><h3 id="5-倒排索引"><a href="#5-倒排索引" class="headerlink" title="5.倒排索引"></a>5.倒排索引</h3><h4 id="5-1-倒排索引加速（一）"><a href="#5-1-倒排索引加速（一）" class="headerlink" title="5.1 倒排索引加速（一）"></a>5.1 倒排索引加速（一）</h4><h4 id="5-2-倒排索引加速（二）"><a href="#5-2-倒排索引加速（二）" class="headerlink" title="5.2 倒排索引加速（二）"></a>5.2 倒排索引加速（二）</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="搜索" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>IK Aanlysis 文档</title>
    <link href="http://example.com/2022/06/12/IK%20Aanlysis%20%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2022/06/12/IK%20Aanlysis%20%E6%96%87%E6%A1%A3/</id>
    <published>2022-06-12T07:22:10.000Z</published>
    <updated>2022-11-03T13:33:07.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="IK-Aanlysis-文档"><a href="#IK-Aanlysis-文档" class="headerlink" title="IK Aanlysis 文档"></a>IK Aanlysis 文档</h2><h3 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1.源码分析"></a>1.源码分析</h3><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205081924063.png" alt="image-20220508192403184"></p><p>我们需要关注的是cfg , core , dic三个包 ，这其中包含了ik分词器的主类， 主配置类、词元类、 词典类等关键类，后续对ik分词器的改造也是围绕这三个包来展开的 </p><p>core包括了IK的分词器接口ISegmenter，分词器核心类IKSegmenter，语义单元类Lexeme，上下文AnalyzeContext，以及子分词器LetterSegementer(英文字符子分词器),CN_QuantifierSegmenter(中文量词子分词器),CJKSegmenter(中日韩字符分词器)，</p><p>dic包括了词典类Dictionary，词典树分段类DictSegmenter，用来记录词典匹配命中记录的类Hit</p><h5 id="1-词典初始化"><a href="#1-词典初始化" class="headerlink" title="1.词典初始化"></a>1.词典初始化</h5><p>在分词器IKSegmenter首次实例化时，默认会根据DefaultConfig找到主词典和中文量词词典路径，同时DefaultConfig会根据classpath下配置文件IKAnalyzer.cfg.xml，找到扩展词典和停止词典路径，可以在该配置文件中配置自己的扩展词典和停止词典。</p><p>找到词典路径后，初始化Dictionary.java，Dictionary是单例的。在Dictionary的构造函数中加载词典。Dictionary是IK的词典管理类，真正的词典数据是存放在DictSegment中，该类实现了一种树结构，如下图。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082209853.png" alt="image-20220508220918804"></p><p>比如,要对字符串”施耐德继电器”进行分词，首先拿到字符串的第一个字符’施’,在上面的词典树中可以匹配到’施’节点，然后拿到字符串第二个字符’耐’，从上一个节点’施’往下找，找到了’耐’节点，’耐’节点是一个非终点节点,继续往下找到’德’节点,’德’节点是终点节点,所以’施耐德’是一个词</p><p>Dictionary中默认有三个DictSegment对象,  _MainDict , _QuantifierDict , _StopWords , 分别是主词典, 中文量词词典, 停用词词典(停用词词典中的词在分词时将会被忽略)</p><p>Dictionary加载主词典，将主词典保存到它的_MainDict对象中，加载完主词典后，加载扩展词典，扩展词典同样保存在_MainDict中。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082117840.png" alt="image-20220508211711777"></p><p>fillSegment方法是DictSegment加载单个词的核心方法，charArray是词的字符数组，先是从存储节点搜索词的第一个字符，如果不存在则创建一个节点用于存储第一个字符，后面递归存储，直到最后一个字符。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082215674.png" alt="image-20220508221241534"></p><p>子节点如果存粹用map存储，会比较浪费空间，因此ik采用了一种折中的方式。就是根据子节点的数量对存储结构进行调整，如果子节点的数量小于等于3，则采用数组存储，如果子节点的数量大于3，采用map存储。其中的nodeState就是用来标记当前节点</p><p>因为HashMap需要预先分配内存，所以可能存在浪费现象；但是如果全用数组存，后续采用二分查找时无法获得O(1)的时间复杂度。所以这里采用了两种方式，子节点少时用数组存，子节点多时则迁移至HashMap。</p><h5 id="2-自定义词典"><a href="#2-自定义词典" class="headerlink" title="2.自定义词典"></a>2.自定义词典</h5><p>了解了主词典的加载流程,只需要照猫画虎就行, 自定义几个DictSegment对象,如_BrandDic  ,  _CategoryDic ,  _MaterialNoDic 等 , 在config文件夹中创建对应的dic文件 </p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082121508.png" alt="image-20220508212158446"></p><p>编写字典加载方法 </p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082123981.png" alt="image-20220508212308919"></p><p>在initial方法中调用加载方法,在Dictionary对象创建时会调用此方法,将对应字典加载入内存</p><h5 id="3-基于词典的切分"><a href="#3-基于词典的切分" class="headerlink" title="3.基于词典的切分"></a>3.基于词典的切分</h5><!--todo--><h5 id="4-分词模式"><a href="#4-分词模式" class="headerlink" title="4.分词模式"></a>4.分词模式</h5><!--todo--><h5 id="5-匹配定义词性"><a href="#5-匹配定义词性" class="headerlink" title="5.匹配定义词性"></a>5.匹配定义词性</h5><p>自定义的字典加载完成后,下一步就是使用词元匹配词典来确认词性,以品牌词典举例, 分词器在获取词元的时候会调用分词器主类IKSegmenter中的next()方法来获取下一个词元,并判断是否为停用词, <strong>我们可以在这里动一些手脚, 通过匹配词典,来判断当前词元的词性</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205082130700.png" alt="image-20220508213052634"></p><p>isBrand()方法调用DictSegmenter中的match()方法,品牌词已经加载至一个字典树之内，所以整个过程也就是一个从树根层层往下走的一个层层递归的方式,首字符匹配到一个节点后,判断下面是否还有节点,有就继续往下匹配;匹配的结果一共三种UNMATCH（未匹配），MATCH（匹配）， PREFIX（前缀匹配）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 匹配词段 * @param charArray * @param begin * @param length * @param searchHit * @return Hit  */</span><span class="token class-name">Hit</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> charArray <span class="token punctuation">,</span> <span class="token keyword">int</span> begin <span class="token punctuation">,</span> <span class="token keyword">int</span> length <span class="token punctuation">,</span> <span class="token class-name">Hit</span> searchHit<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>searchHit <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果hit为空，新建</span>searchHit<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置hit的其实文本位置</span>searchHit<span class="token punctuation">.</span><span class="token function">setBegin</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//否则要将HIT状态重置</span>searchHit<span class="token punctuation">.</span><span class="token function">setUnmatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//设置hit的当前处理位置</span>searchHit<span class="token punctuation">.</span><span class="token function">setEnd</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Character</span> keyChar <span class="token operator">=</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>charArray<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">DictSegment</span> ds <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//引用实例变量为本地变量，避免查询时遇到更新的同步问题</span><span class="token class-name">DictSegment</span><span class="token punctuation">[</span><span class="token punctuation">]</span> segmentArray <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>childrenArray<span class="token punctuation">;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span> <span class="token punctuation">,</span> <span class="token class-name">DictSegment</span><span class="token punctuation">></span></span> segmentMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>childrenMap<span class="token punctuation">;</span><span class="token comment">//STEP1 在节点中查找keyChar对应的DictSegment</span><span class="token keyword">if</span><span class="token punctuation">(</span>segmentArray <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//在数组中查找</span><span class="token class-name">DictSegment</span> keySegment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DictSegment</span><span class="token punctuation">(</span>keyChar<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>segmentArray<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>storeSize <span class="token punctuation">,</span> keySegment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>position <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ds <span class="token operator">=</span> segmentArray<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>segmentMap <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//在map中查找</span>ds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">DictSegment</span><span class="token punctuation">)</span>segmentMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyChar<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//STEP2 找到DictSegment，判断词的匹配状态，是否继续递归，还是返回结果</span><span class="token keyword">if</span><span class="token punctuation">(</span>ds <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>length <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//词未匹配完，继续往下搜索</span><span class="token keyword">return</span> ds<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>charArray<span class="token punctuation">,</span> begin <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> length <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">,</span> searchHit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//搜索最后一个char</span><span class="token keyword">if</span><span class="token punctuation">(</span>ds<span class="token punctuation">.</span>nodeState <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//添加HIT状态为完全匹配</span>searchHit<span class="token punctuation">.</span><span class="token function">setMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ds<span class="token punctuation">.</span><span class="token function">hasNextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//添加HIT状态为前缀匹配</span>searchHit<span class="token punctuation">.</span><span class="token function">setPrefix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//记录当前位置的DictSegment</span>searchHit<span class="token punctuation">.</span><span class="token function">setMatchedDictSegment</span><span class="token punctuation">(</span>ds<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> searchHit<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//STEP3 没有找到DictSegment， 将HIT设置为不匹配</span><span class="token keyword">return</span> searchHit<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>匹配成功则将当前词元的type设置为brand,没有匹配上则继续匹配其他词典,直至结束.</p><h5 id="6基于规则的歧义判断"><a href="#6基于规则的歧义判断" class="headerlink" title="6基于规则的歧义判断"></a>6基于规则的歧义判断</h5><!--todo--><h3 id="2-热更新"><a href="#2-热更新" class="headerlink" title="2.热更新"></a>2.热更新</h3><p>时间戳监听类主逻辑</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分词器" scheme="http://example.com/tags/%E5%88%86%E8%AF%8D%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>analysis</title>
    <link href="http://example.com/2022/05/29/%E4%BB%80%E4%B9%88%E6%98%AF%20analysis/"/>
    <id>http://example.com/2022/05/29/%E4%BB%80%E4%B9%88%E6%98%AF%20analysis/</id>
    <published>2022-05-29T06:09:22.000Z</published>
    <updated>2022-10-29T05:51:40.801Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h2><p>analysis, 中文意思分析,指的是es在文档发送之前对文档正文的执行过程,以添加到inverted index, 这一过程包含一下几个步骤:</p><ul><li>使用字符过滤器过滤字符,由char filter完成</li><li>分词,将input按指定的规则分割为多个token, 由tokanizer完成</li><li>token过滤, 将上一步的tokens按一定规则进行处理, 由token filter完成</li><li>存入索引</li></ul><p>经过 analyzer 处理过后的文档最终以 Inverted Index 的形式保存于 Elasticsearch 中：</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205180043961.png" alt="image-20220518124327931 AM"></p><p>上图中的analyzer, 一般称之为分析器, 由三个部分组成 </p><ul><li><p>char filter  字符过滤器,是处理文档正文或搜索输入的第一步, <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-htmlstrip-charfilter.html">官方文档</a></p></li><li><p>tokenizer   分词器, 顾名思义, 它的作用就是分词, 会输出一个token stream</p></li><li><p>filter   tokens过滤器,对token stream二次处理,token过滤器不允许更改每个token的位置或字符偏移量。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-synonym-tokenfilter.html#_wordnet_synonyms">官方文档</a>,  常用的有</p><ol><li>lowercase  将所有token转为小写</li><li>stop  将停用词从token流中删除</li><li>synonym 将同义词添加到token流中 </li><li>edge_ngram 指定最细粒度和最粗粒度,对token流进行二次分词</li></ol></li></ul><p>analyzer 是char filters、tokenizer和tokens filters的组合，tokenizer代表分词器，它负责将一串文本根据词典分成一个个的词，输出的是tokens数据流，一个analyzer有且只有一个tokenizer。token filter则是对分词之后的结果进行处理，例如大小写转换、关联同义词、去掉停用词、不同国家语言映射转换等，一个analyzer可以有0个或多个filter。</p><p><strong>analyzer 只作用于text 类型的字段，而对于 keyword 类型的字段，它将不被分析和分词。keyword 字段被用于精确匹配及聚合。</strong></p><p><strong>analyzer的使用场景</strong></p><p>1.建立索引的时候, 分析文档正文用于 indexing<br>2.搜索的时候, 分析input 用于searching</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202205180118452.png" alt="image-20220518120153972 AM"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分词器" scheme="http://example.com/tags/%E5%88%86%E8%AF%8D%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>缓存一致性治理方案</title>
    <link href="http://example.com/2022/05/10/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%B2%BB%E7%90%86%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2022/05/10/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%B2%BB%E7%90%86%E6%96%B9%E6%A1%88/</id>
    <published>2022-05-10T13:54:22.000Z</published>
    <updated>2023-02-19T14:02:57.774Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="缓存一致性治理方案"><a href="#缓存一致性治理方案" class="headerlink" title="缓存一致性治理方案"></a>缓存一致性治理方案</h1><h2 id="引入缓存"><a href="#引入缓存" class="headerlink" title="引入缓存"></a>引入缓存</h2><p>最简单的场景是, 业务在起步阶段, 流量很小, 读写请求直接操作数据库即可, 这时候的架构是这样的</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2022/202302191908059.jpg" alt="img"></p><p>随着业务量的增长,  请求量越来越多, 每次请求都直接打到数据库的话, 会出现性能问题, 这时候, 缓存出现了 </p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2022/202302191909246.jpg" alt="img"></p><p>常用的缓存中间件是Redis(还有其他优秀的中间件,但我没接触过), 加入缓存之后, 随之而来的一个问题是, 数据如何放入缓存 </p><p>db的数据直接全量刷入缓存, 不设置失效时间, 通过定时任务或者是DTS同步db的数据变动到缓存, 所有读请求走缓存</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2022/202302191912621.jpg" alt="img"></p><p>这种方案下, 读请求可以直接命中缓存, 性能高, 但是缓存利用率很低, 存在很多低读取的冷数据, 另外即使你的数据同步做的再好, 也不可能做到0延时的同步, 所以数据不一致肯定会出现</p><h2 id="利用率和一致性问题"><a href="#利用率和一致性问题" class="headerlink" title="利用率和一致性问题"></a>利用率和一致性问题</h2><p>先说利用率, 我们可以缓存热数据, 逻辑是这样</p><ul><li>所有写请求走db</li><li>读请求先走缓存, 未命中则从db读取</li><li>写入缓存, 设立失效时间</li></ul><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2022/202302191919415.jpg" alt="img"></p><p>随着时间的推移, 缓存中的冷数据都会过期, 并且没有读取请求就不会重建, 一段时候后, 缓存中的数据就都是热数据了.</p><p>再说一致性, 我们知道, 定时任务和DTS是不可能做到0延时的, 所以当接收到写请求, db和缓存需要一起更新, 这里会存在一个先后的问题</p><ol><li>db先更新, 缓存后更新</li><li>缓存先更新, db后更新</li></ol><p>因为操作分两步, 所以就会存在一成功,二失败的情况. </p><ol><li>db更新成功, 缓存更新失败, 则读请求打到缓存上, 响应的是旧值, 当旧缓存过期后, 才会重建新值的缓存, 用户层面的感受是, 更改未生效或者过了一段时间才生效.</li><li>缓存更新成功, db更新失败, 则读请求打到缓存上, 响应的是最新值, 过了一段时间, 缓存失效, 从db读取了旧值进行重建, 用户层面的感受是, 当时更改成功了, 但是过了一段时间又改回去了.</li></ol><p>先后问题先按住不表, 说下并发问题</p><p>场景: T1和T2两个线程, 同时更新同一条数据, 更新方案是 「先db,后缓存」, 那么会发生什么</p><ol><li>T1更新db     x = 1 </li><li>T2更新db     x = 2</li><li>T2更新缓存  x = 2</li><li>T1更新缓存     x = 1</li></ol><p>最终结果 db  x = 2 ,  缓存  x = 1,  数据不一致了, 「先缓存,后db」的方案逻辑是一样的, 就不浪费笔墨了. </p><p>如何解决并发带来的数据不一致? 常用方案是分布式锁</p><p>线程更新数据之前, 需要先申请锁, 拿到锁的线程才允许进行更新动作, 否则阻塞或者返回失败后重试. </p><p>无论是先更新缓存还是先更新db, 都会导致利用率低的问题, 因为所有的写请求都无脑去更新缓存, 肯定会导致缓存中存在冷数据. 并且通过加锁来保证一致性, 会占用机器性能,降低响应速度, 这与引入缓存的初衷相悖.</p><h2 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h2><ol><li>先删除缓存, 后更新db</li><li>先更新db, 后删除缓存</li></ol><p>同样的,看下第二步失败的情景</p><ol><li>缓存删除后, db更新失败, 下一次读请求访问缓存, 会去db读取数据并重建缓存, 用户层面的感受是, 更改失败了 </li><li>db更新后, 缓存删除失败, 下一次读请求返回了缓存中的旧值, 只有当旧值失效, 新的读请求重建缓存后, 数据才一致 , 用户层面的感受是, 更改失败了, 但过了一段时间刷新看看又好了.</li></ol><p>再看并发问题 ,方案1在并发读写情况下</p><ol><li>T1删除了缓存 </li><li>T2读取缓存, 未命中, 从数据库读取了旧值重建缓存  x = 1</li><li>T1更新了db       x = 2</li></ol><p>最终结果 缓存 x = 1,  db x = 2, 数据不一致</p><p>方案2在并发读写的情况下</p><ol><li>缓存中无x的值</li><li>T1读取到数据库数据 x = 1</li><li>T2更新db x = 2</li><li>T2 删除了缓存</li><li>T1重建了缓存 x = 1</li></ol><p>最终结果 db x = 2, 缓存 x = 1, 数据不一致, 但是这种情况概率很低, 因为它需要满足三个条件</p><ol><li>缓存刚好失效 , 对应第一步</li><li>读写并发 </li><li>更新数据库 + 删除缓存的耗时(3 , 4 步) 小于 读取数据库+ 重建缓存的耗时 (2, 5 步)</li></ol><p>理论上, 数据库写的耗时是会比读的耗时多的, 因为写需要加锁, 所以3, 4步 的耗时 大概率是大于 2, 5 步, 所以方案2在很大概率上是可以保证一致性的.</p><h2 id="如何确保两步都成功"><a href="#如何确保两步都成功" class="headerlink" title="如何确保两步都成功"></a>如何确保两步都成功</h2><p>无论是双更新还是删除缓存的方案, 只要第二步失败, 就会导致数据不一致, 如何保证第二步成功就是解决问题的关键</p><p>最简单的方案 : 重试 , 当第二步失败, 就发起重试, 但是无脑重试也会带来别的问题</p><ol><li>立刻重试, 大概是还是失败</li><li>重试次数过多, 占用线程资源</li></ol><p>看到这里估计有经验的开发第一反应就是异步</p><p>异步重试, 可以选择开一个专用的重试线程, 但我觉得更好的方案是MQ, 将重试请求扔到MQ中, 由专门的消费者来重试, 直到成功 , 这样就完美解决 1和2两个问题.</p><p>多说一句, 引入MQ一样会带来更多问题, 增加更多的维护成本, 这取决于你的系统对一致性要求高不高, 没有银弹, 只有取舍. </p><p>引入MQ后, 架构变成了这样 </p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202302192116646.jpg" alt="img"></p><p>另外一种方案, 订阅数据库binlog(阿里的canal), 再操作缓存</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202302192116922.jpg" alt="img"></p><p>至此, 我们的方案是 先更新db, 再删除缓存, 配合MQ或者是canal做重试 </p><h2 id="主从延迟和延迟双删"><a href="#主从延迟和延迟双删" class="headerlink" title="主从延迟和延迟双删"></a>主从延迟和延迟双删</h2><p>先删除缓存,后更新db的方案下, 是由于读线程重建了缓存而导致的不一致, 如果我们在读线程建立缓存之后, 写线程再去做一次删除动作, 则数据一致性就可以得到保证</p><p>在读写分离 + 主从延迟的情况下, 先更新db, 后删除缓存的方案, 还是会出现不一致</p><ol><li>T1更新主库 x = 2</li><li>T1 删除缓存</li><li>T2 查询缓存, 未命中, 读取从库得到旧值  x = 1</li><li>T2 将 x = 1 写入缓存</li><li>从库从主库完成同步 </li></ol><p>最终结果 db = 2 , 缓存 = 1,  这里就要引出延迟双删策略了</p><p>T1在执行完删除动作后, 可以先休眠一会, 然后再进行一次删除</p><p>或者T1在执行完删除动作后, 生成一条延时消息, 放入MQ, 由消费者延时删除缓存</p><p>两个关键 :</p><ol><li>T1的休眠时间或者是延时消息的延迟时间, 需要大于主从复制的延迟时间</li><li>T1的休眠时间或者是延时消息的延迟时间, 需要大于T2查db加写缓存的时间</li></ol><p>高并发的场景下, 这个延迟时间是很难估计的, 一般是凭经验设置, 比如1-5秒 , 尽可能的降低不一致的概率</p><h2 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h2><p>要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。</p><p>相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？</p><p>没错，<strong>性能</strong>。</p><p>一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。</p><p>而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。</p><p>所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。</p><p>虽然我们可以通过加「分布锁」的方式来实现，但我们也要付出相应的代价，甚至很可能会超过引入缓存带来的性能提升。</p><p>所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。</p><p>同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>提高系统的响应速度, 可以引入缓存</li><li>引入缓存后, 要考虑db和缓存的一致性问题 ,  有两种方案 <ol><li>双更新</li><li>更新db, 删除缓存 </li></ol></li><li>双更新的方案在并发场景下无法保证一致性, 需要加分布式锁, 但是加锁会占用机器性能,降低响应速度, 这与引入缓存的初衷相悖.</li><li>采用先删缓存, 后更新db的方案, 在并发场景下会有不一致的情况, 解决方案是 延迟双删</li><li>采用先更新db , 后删除缓存的方案, 为了保证两步都执行成功, 可以使用MQ或者binlog订阅的方式进行重试 </li><li>在读写分离 + 主从复制的情况下, 采用先更新db, 后删除缓存的方案, 在并发场景下会有不一致的情况, 解决方案是 延迟双删 </li></ol><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol><li>性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案</li><li>掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题</li><li>失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案</li><li>订阅变更日志的思想，本质是把权威数据源（例如 MySQL）当做 leader 副本，让其它异质系统（例如 Redis / Elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="缓存" scheme="http://example.com/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq delay queue</title>
    <link href="http://example.com/2021/08/29/rabbitmq%20delay%20queue/"/>
    <id>http://example.com/2021/08/29/rabbitmq%20delay%20queue/</id>
    <published>2021-08-28T16:54:22.000Z</published>
    <updated>2023-05-23T14:12:52.035Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><p>在上一篇中，介绍了RabbitMQ中的死信队列是什么，何时使用以及如何使用RabbitMQ的死信队列。相信通过上一篇的学习，对于死信队列已经有了更多的了解，这一篇的内容也跟死信队列息息相关，如果你还不了解死信队列，那么建议你先进行上一篇文章的阅读。</p><p>这一篇里，我们将继续介绍RabbitMQ的高级特性，通过本篇的学习，你将收获：</p><ol><li>什么是延时队列</li><li>延时队列使用场景</li><li>RabbitMQ中的TTL</li><li>如何利用RabbitMQ来实现延时队列</li></ol><h3 id="二、本文大纲"><a href="#二、本文大纲" class="headerlink" title="二、本文大纲"></a>二、本文大纲</h3><p>以下是本文大纲：</p><p><a href="https://i.loli.net/2019/07/28/5d3d74d99699d43032.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047092.png" alt="1.png"></a></p><p>本文阅读前，需要对RabbitMQ以及死信队列有一个简单的了解。</p><h3 id="三、什么是延时队列"><a href="#三、什么是延时队列" class="headerlink" title="三、什么是延时队列"></a>三、什么是延时队列</h3><p><code>延时队列</code>，首先，它是一种队列，队列意味着内部的元素是<code>有序</code>的，元素出队和入队是有方向性的，元素从一端进入，从另一端取出。</p><p>其次，<code>延时队列</code>，最重要的特性就体现在它的<code>延时</code>属性上，跟普通的队列不一样的是，<code>普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理</code>，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。</p><p>简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p><h3 id="四、延时队列使用场景"><a href="#四、延时队列使用场景" class="headerlink" title="四、延时队列使用场景"></a>四、延时队列使用场景</h3><p>那么什么时候需要用延时队列呢？考虑一下以下场景：</p><ol><li>订单在十分钟之内未支付则自动取消。</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>账单在一周内未支付，则自动结算。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。</li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；发生店铺创建事件，十天后检查该店铺上新商品数，然后通知上新数为0的商户；发生账单生成事件，检查账单支付状态，然后自动结算未支付的账单；发生新用户注册事件，三天后检查新注册用户的活动数据，然后通知没有任何活动记录的用户；发生退款事件，在三天之后检查该订单是否已被处理，如仍未被处理，则发送消息给相关运营人员；发生预定会议事件，判断离会议开始是否只有十分钟了，如果是，则通知各个与会人员。</p><p>看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><p>更重要的一点是，不！优！雅！</p><p>没错，作为一名有追求的程序员，始终应该追求更优雅的架构和更优雅的代码风格，写代码要像写诗一样优美。【滑稽】</p><p>这时候，延时队列就可以闪亮登场了，以上场景，正是延时队列的用武之地。</p><p>既然<code>延时队列</code>可以解决很多特定场景下，带时间属性的任务需求，那么如何构造一个延时队列呢？接下来，本文将介绍如何用RabbitMQ来实现延时队列。</p><h3 id="五、RabbitMQ中的TTL"><a href="#五、RabbitMQ中的TTL" class="headerlink" title="五、RabbitMQ中的TTL"></a>五、RabbitMQ中的TTL</h3><p>在介绍延时队列之前，还需要先介绍一下RabbitMQ中的一个高级特性——<code>TTL（Time To Live）</code>。</p><p><code>TTL</code>是什么呢？<code>TTL</code>是RabbitMQ中一个消息或者队列的属性，表明<code>一条消息或者该队列中的所有消息的最大存活时间</code>，单位是毫秒。换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为“死信”（至于什么是死信，请翻看上一篇）。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。</p><p>那么，如何设置这个TTL值呢？有两种方式，第一种是在创建队列的时候设置队列的“x-message-ttl”属性，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-message-ttl"</span><span class="token punctuation">,</span> <span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> durable<span class="token punctuation">,</span> exclusive<span class="token punctuation">,</span> autoDelete<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样所有被投递到该队列的消息都最多不会存活超过6s。</p><p>另一种方式便是针对每条消息设置TTL，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties<span class="token punctuation">.</span>Builder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token function">expiration</span><span class="token punctuation">(</span><span class="token string">"6000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> mandatory<span class="token punctuation">,</span> properties<span class="token punctuation">,</span> <span class="token string">"msg body"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样这条消息的过期时间也被设置成了6s。</p><p>但这两种方式是有区别的，<strong>如果设置了队列的TTL属性，那么一旦消息过期，就会被队列丢弃，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。</strong></p><p>另外，还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p><h3 id="六、如何利用RabbitMQ实现延时队列"><a href="#六、如何利用RabbitMQ实现延时队列" class="headerlink" title="六、如何利用RabbitMQ实现延时队列"></a>六、如何利用RabbitMQ实现延时队列</h3><p>前一篇里介绍了如果设置死信队列，前文中又介绍了TTL，至此，利用RabbitMQ实现延时队列的两大要素已经集齐，接下来只需要将它们进行调和，再加入一点点调味料，延时队列就可以新鲜出炉了。</p><p>想想看，<code>延时队列</code>，不就是想要消息延迟多久被处理吗，TTL则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就万事大吉了，因为里面的消息都是希望被立即处理的消息。</p><p>从下图可以大致看出消息的流向：</p><p><a href="https://i.loli.net/2019/07/28/5d3d743143ecc85643.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047108.png" alt="23.png"></a></p><p>生产者生产一条延时消息，根据需要延时时间的不同，利用不同的routingkey将消息路由到不同的延时队列，每个队列都设置了不同的TTL属性，并绑定在同一个死信交换机中，消息过期后，根据routingkey的不同，又会被路由到不同的死信队列中，消费者只需要监听对应的死信队列进行处理即可。</p><p>下面来看代码：</p><p>先声明交换机、队列以及他们的绑定关系：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMQConfig</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAY_EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"delay.queue.demo.business.exchange"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAY_QUEUEA_NAME <span class="token operator">=</span> <span class="token string">"delay.queue.demo.business.queuea"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAY_QUEUEB_NAME <span class="token operator">=</span> <span class="token string">"delay.queue.demo.business.queueb"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAY_QUEUEA_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"delay.queue.demo.business.queuea.routingkey"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAY_QUEUEB_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"delay.queue.demo.business.queueb.routingkey"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_LETTER_EXCHANGE <span class="token operator">=</span> <span class="token string">"delay.queue.demo.deadletter.exchange"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_LETTER_QUEUEA_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"delay.queue.demo.deadletter.delay_10s.routingkey"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_LETTER_QUEUEB_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"delay.queue.demo.deadletter.delay_60s.routingkey"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_LETTER_QUEUEA_NAME <span class="token operator">=</span> <span class="token string">"delay.queue.demo.deadletter.queuea"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_LETTER_QUEUEB_NAME <span class="token operator">=</span> <span class="token string">"delay.queue.demo.deadletter.queueb"</span><span class="token punctuation">;</span>    <span class="token comment">// 声明延时Exchange</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"delayExchange"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">delayExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span>DELAY_EXCHANGE_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明死信Exchange</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"deadLetterExchange"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">deadLetterExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span>DEAD_LETTER_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明延时队列A 延时10s</span>    <span class="token comment">// 并绑定到对应的死信交换机</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"delayQueueA"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">delayQueueA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> DEAD_LETTER_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> DEAD_LETTER_QUEUEA_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// x-message-ttl  声明队列的TTL</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-message-ttl"</span><span class="token punctuation">,</span> <span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>DELAY_QUEUEA_NAME<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明延时队列B 延时 60s</span>    <span class="token comment">// 并绑定到对应的死信交换机</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"delayQueueB"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">delayQueueB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> DEAD_LETTER_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> DEAD_LETTER_QUEUEB_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// x-message-ttl  声明队列的TTL</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-message-ttl"</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>DELAY_QUEUEB_NAME<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明死信队列A 用于接收延时10s处理的消息</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"deadLetterQueueA"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">deadLetterQueueA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span>DEAD_LETTER_QUEUEA_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明死信队列B 用于接收延时60s处理的消息</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"deadLetterQueueB"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">deadLetterQueueB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span>DEAD_LETTER_QUEUEB_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明延时队列A绑定关系</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">delayBindingA</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"delayQueueA"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queue<span class="token punctuation">,</span>                                    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"delayExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> exchange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>DELAY_QUEUEA_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明业务队列B绑定关系</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">delayBindingB</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"delayQueueB"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queue<span class="token punctuation">,</span>                                    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"delayExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> exchange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>DELAY_QUEUEB_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明死信队列A绑定关系</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">deadLetterBindingA</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"deadLetterQueueA"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queue<span class="token punctuation">,</span>                                    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"deadLetterExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> exchange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>DEAD_LETTER_QUEUEA_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明死信队列B绑定关系</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">deadLetterBindingB</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"deadLetterQueueB"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queue<span class="token punctuation">,</span>                                      <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"deadLetterExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> exchange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>DEAD_LETTER_QUEUEB_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，创建两个消费者，分别对两个死信队列的消息进行消费：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLetterQueueConsumer</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> DEAD_LETTER_QUEUEA_NAME<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveA</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间：&#123;&#125;,死信队列A收到消息：&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> DEAD_LETTER_QUEUEB_NAME<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveB</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间：&#123;&#125;,死信队列B收到消息：&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是消息的生产者：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayMessageSender</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">,</span> <span class="token class-name">DelayTypeEnum</span> type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token class-name">DELAY_10s</span><span class="token operator">:</span>                rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>DELAY_EXCHANGE_NAME<span class="token punctuation">,</span> DELAY_QUEUEA_ROUTING_KEY<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token class-name">DELAY_60s</span><span class="token operator">:</span>                rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>DELAY_EXCHANGE_NAME<span class="token punctuation">,</span> DELAY_QUEUEB_ROUTING_KEY<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们暴露一个web接口来生产消息：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"rabbitmq"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMQMsgController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">DelayMessageSender</span> sender<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"sendmsg"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">,</span> <span class="token class-name">Integer</span> delayType<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间：&#123;&#125;,收到请求，msg:&#123;&#125;,delayType:&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> delayType<span class="token punctuation">)</span><span class="token punctuation">;</span>        sender<span class="token punctuation">.</span><span class="token function">sendMsg</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token class-name">DelayTypeEnum</span><span class="token punctuation">.</span><span class="token function">getDelayTypeEnumByValue</span><span class="token punctuation">(</span>delayType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>准备就绪，启动！</p><p>打开rabbitMQ的<a href="http://localhost:15672/">管理后台</a>，可以看到我们刚才创建的交换机和队列信息：</p><p><a href="https://i.loli.net/2019/07/28/5d3d54e15534398514.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047837.png" alt="2.png"></a></p><p><a href="https://i.loli.net/2019/07/28/5d3d54e17df8183993.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047418.png" alt="4.png"></a></p><p><a href="https://i.loli.net/2019/07/28/5d3d54e16952546955.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250047065.png" alt="3.png"></a></p><p>接下来，我们来发送几条消息</p><p><a href="http://localhost:8080/rabbitmq/sendmsg?msg=testMsg1&amp;delayType=1">http://localhost:8080/rabbitmq/sendmsg?msg=testMsg1&amp;delayType=1</a></p><p> <a href="http://localhost:8080/rabbitmq/sendmsg?msg=testMsg2&amp;delayType=2">http://localhost:8080/rabbitmq/sendmsg?msg=testMsg2&amp;delayType=2</a></p><p>日志如下：</p><pre class="line-numbers language-none"><code class="language-none">2019-07-28 16:02:19.813  INFO 3860 --- [nio-8080-exec-9] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:02:19 CST 2019,收到请求，msg:testMsg1,delayType:12019-07-28 16:02:19.815  INFO 3860 --- [nio-8080-exec-9] .l.DirectReplyToMessageListenerContainer : SimpleConsumer [queue&#x3D;amq.rabbitmq.reply-to, consumerTag&#x3D;amq.ctag-o-qPpkWIkRm73DIrOIVhig identity&#x3D;766339] started2019-07-28 16:02:25.829  INFO 3860 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:02:25 CST 2019,死信队列A收到消息：testMsg12019-07-28 16:02:41.326  INFO 3860 --- [nio-8080-exec-1] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:02:41 CST 2019,收到请求，msg:testMsg2,delayType:22019-07-28 16:03:41.329  INFO 3860 --- [ntContainer#0-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:03:41 CST 2019,死信队列B收到消息：testMsg2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一条消息在6s后变成了死信消息，然后被消费者消费掉，第二条消息在60s之后变成了死信消息，然后被消费掉，这样，一个还算ok的延时队列就打造完成了。</p><p>不过，等等，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有6s和60s两个时间选项，如果需要一个小时后处理，那么就需要增加TTL为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？？</p><p>嗯，仔细想想，事情并不简单。</p><h3 id="七、RabbitMQ延时队列优化"><a href="#七、RabbitMQ延时队列优化" class="headerlink" title="七、RabbitMQ延时队列优化"></a>七、RabbitMQ延时队列优化</h3><p>显然，需要一种更通用的方案才能满足需求，那么就只能将TTL设置在消息属性里了。我们来试一试。</p><p>增加一个延时队列，用于接收设置为任意延时时长的消息，增加一个相应的死信队列和routingkey：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMQConfig</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAY_EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"delay.queue.demo.business.exchange"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAY_QUEUEC_NAME <span class="token operator">=</span> <span class="token string">"delay.queue.demo.business.queuec"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAY_QUEUEC_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"delay.queue.demo.business.queuec.routingkey"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_LETTER_EXCHANGE <span class="token operator">=</span> <span class="token string">"delay.queue.demo.deadletter.exchange"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_LETTER_QUEUEC_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"delay.queue.demo.deadletter.delay_anytime.routingkey"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_LETTER_QUEUEC_NAME <span class="token operator">=</span> <span class="token string">"delay.queue.demo.deadletter.queuec"</span><span class="token punctuation">;</span>    <span class="token comment">// 声明延时Exchange</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"delayExchange"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">delayExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span>DELAY_EXCHANGE_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明死信Exchange</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"deadLetterExchange"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">deadLetterExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span>DEAD_LETTER_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明延时队列C 不设置TTL</span>    <span class="token comment">// 并绑定到对应的死信交换机</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"delayQueueC"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">delayQueueC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> DEAD_LETTER_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> DEAD_LETTER_QUEUEC_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>DELAY_QUEUEC_NAME<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明死信队列C 用于接收延时任意时长处理的消息</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"deadLetterQueueC"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">deadLetterQueueC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span>DEAD_LETTER_QUEUEC_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明延时列C绑定关系</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">delayBindingC</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"delayQueueC"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queue<span class="token punctuation">,</span>                                 <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"delayExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> exchange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>DELAY_QUEUEC_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明死信队列C绑定关系</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">deadLetterBindingC</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"deadLetterQueueC"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queue<span class="token punctuation">,</span>                                      <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"deadLetterExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> exchange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>DEAD_LETTER_QUEUEC_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>增加一个死信队列C的消费者：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> DEAD_LETTER_QUEUEC_NAME<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveC</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间：&#123;&#125;,死信队列C收到消息：&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次启动！然后访问：<a href="http://localhost:8080/rabbitmq/delayMsg?msg=testMsg1delayTime=5000">http://localhost:8080/rabbitmq/delayMsg?msg=testMsg1delayTime=5000</a> 来生产消息，注意这里的单位是毫秒。</p><pre class="line-numbers language-none"><code class="language-none">2019-07-28 16:45:07.033  INFO 31468 --- [nio-8080-exec-4] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:45:07 CST 2019,收到请求，msg:testMsg1,delayTime:50002019-07-28 16:45:11.694  INFO 31468 --- [nio-8080-exec-5] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:45:11 CST 2019,收到请求，msg:testMsg2,delayTime:50002019-07-28 16:45:12.048  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:45:12 CST 2019,死信队列C收到消息：testMsg12019-07-28 16:45:16.709  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:45:16 CST 2019,死信队列C收到消息：testMsg2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>看起来似乎没什么问题，但不要高兴的太早，在最开始的时候，就介绍过，如果使用在消息属性上设置TTL的方式，消息可能并不会按时“死亡“，因为RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列，索引如果第一个消息的延时时长很长，而第二个消息的延时时长很短，则第二个消息并不会优先得到执行。</p><p>实验一下：</p><pre class="line-numbers language-none"><code class="language-none">2019-07-28 16:49:02.957  INFO 31468 --- [nio-8080-exec-8] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:49:02 CST 2019,收到请求，msg:longDelayedMsg,delayTime:200002019-07-28 16:49:10.671  INFO 31468 --- [nio-8080-exec-9] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:49:10 CST 2019,收到请求，msg:shortDelayedMsg,delayTime:20002019-07-28 16:49:22.969  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:49:22 CST 2019,死信队列C收到消息：longDelayedMsg2019-07-28 16:49:22.970  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:49:22 CST 2019,死信队列C收到消息：shortDelayedMsg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们先发了一个延时时长为20s的消息，然后发了一个延时时长为2s的消息，结果显示，第二个消息会在等第一个消息成为死信后才会“死亡“。</p><h3 id="八、利用RabbitMQ插件实现延迟队列"><a href="#八、利用RabbitMQ插件实现延迟队列" class="headerlink" title="八、利用RabbitMQ插件实现延迟队列"></a>八、利用RabbitMQ插件实现延迟队列</h3><p>上文中提到的问题，确实是一个硬伤，如果不能实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡，就无法设计成一个通用的延时队列。</p><p>那如何解决这个问题呢？不要慌，安装一个插件即可：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> ，下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。</p><p>接下来，进入RabbitMQ的安装目录下的sbin目录，执行下面命令让该插件生效，然后重启RabbitMQ。</p><pre class="line-numbers language-none"><code class="language-none">rabbitmq-plugins enable rabbitmq_delayed_message_exchange<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们再声明几个Bean：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayedRabbitMQConfig</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAYED_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"delay.queue.demo.delay.queue"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAYED_EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"delay.queue.demo.delay.exchange"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAYED_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"delay.queue.demo.delay.routingkey"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">immediateQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span>DELAYED_QUEUE_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">CustomExchange</span> <span class="token function">customExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-delayed-type"</span><span class="token punctuation">,</span> <span class="token string">"direct"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CustomExchange</span><span class="token punctuation">(</span>DELAYED_EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"x-delayed-message"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingNotify</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"immediateQueue"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queue<span class="token punctuation">,</span>                                 <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"customExchange"</span><span class="token punctuation">)</span> <span class="token class-name">CustomExchange</span> customExchange<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>customExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>DELAYED_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">noargs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>controller层再添加一个入口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"delayMsg2"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delayMsg2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">,</span> <span class="token class-name">Integer</span> delayTime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间：&#123;&#125;,收到请求，msg:&#123;&#125;,delayTime:&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> delayTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    sender<span class="token punctuation">.</span><span class="token function">sendDelayMsg</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> delayTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>消息生产者的代码也需要修改：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendDelayMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">,</span> <span class="token class-name">Integer</span> delayTime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>DELAYED_EXCHANGE_NAME<span class="token punctuation">,</span> DELAYED_ROUTING_KEY<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> a <span class="token operator">-></span><span class="token punctuation">&#123;</span>        a<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDelay</span><span class="token punctuation">(</span>delayTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，再创建一个消费者：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> DELAYED_QUEUE_NAME<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveD</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间：&#123;&#125;,延时队列收到消息：&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一切准备就绪，启动！然后分别访问以下链接：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:8080&#x2F;rabbitmq&#x2F;delayMsg2?msg&#x3D;msg1&amp;delayTime&#x3D;20000http:&#x2F;&#x2F;localhost:8080&#x2F;rabbitmq&#x2F;delayMsg2?msg&#x3D;msg2&amp;delayTime&#x3D;2000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>日志如下：</p><pre class="line-numbers language-none"><code class="language-none">2019-07-28 17:28:13.729  INFO 25804 --- [nio-8080-exec-2] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 17:28:13 CST 2019,收到请求，msg:msg1,delayTime:200002019-07-28 17:28:20.607  INFO 25804 --- [nio-8080-exec-1] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 17:28:20 CST 2019,收到请求，msg:msg2,delayTime:20002019-07-28 17:28:22.624  INFO 25804 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 17:28:22 CST 2019,延时队列收到消息：msg22019-07-28 17:28:33.751  INFO 25804 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 17:28:33 CST 2019,延时队列收到消息：msg1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二个消息被先消费掉了，符合预期。至此，RabbitMQ实现延时队列的部分就完结了。</p><h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>延时队列在需要延时处理的场景下非常有用，使用RabbitMQ来实现延时队列可以很好的利用RabbitMQ的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过RabbitMQ集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用Java的DelayQueu，利用Redis的zset，利用Quartz或者利用kafka的时间轮，这些方式各有特点，但就像炉石传说一般，这些知识就好比手里的卡牌，知道的越多，可以用的卡牌也就越多，遇到问题便能游刃有余，所以需要大量的知识储备和经验积累才能打造出更出色的卡牌组合，让自己解决问题的能力得到更好的提升。</p><p>但另一方面，随着时间的流逝和阅历的增长，越来越感觉到自己的能力有限，无法独自面对纷繁复杂且多变的业务需求，在很多方面需要其他人的协助才能很好的完成任务。也知道闻道有先后，术业有专攻，不会再狂妄自大，觉得自己能把所有事情都搞定，也将重心慢慢转移到研究如何有效的进行团队合作上来，我相信一个高度协调的团队永远比一个人战斗要更有价值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="rabbitmq" scheme="http://example.com/tags/rabbitmq/"/>
    
    <category term="延时队列" scheme="http://example.com/tags/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq dead queue</title>
    <link href="http://example.com/2021/08/28/rabbitmq%20dead%20queue/"/>
    <id>http://example.com/2021/08/28/rabbitmq%20dead%20queue/</id>
    <published>2021-08-27T16:54:22.000Z</published>
    <updated>2021-11-24T16:55:33.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><p>RabbitMQ是流行的开源消息队列系统，使用erlang语言开发，由于其社区活跃度高，维护更新较快，性能稳定，深得很多企业的欢心（当然，也包括我现在所在公司【手动滑稽】）。</p><p>为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。但由于对死信队列的概念及配置不熟悉，导致曾一度陷入百度的汪洋大海，无法自拔，很多文章都看起来可行，但是实际上却并不能帮我解决实际问题。最终，在官网文档中找到了我想要的答案，通过官网文档的学习，才发现对于死信队列存在一些误解，导致配置死信队列之路困难重重。</p><p>于是本着记录和分享的精神，将死信队列的概念和配置完整的写下来，以便帮助遇到同样问题的朋友。</p><h3 id="二、本文大纲"><a href="#二、本文大纲" class="headerlink" title="二、本文大纲"></a>二、本文大纲</h3><p>以下是本文大纲：</p><p><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140349282-672707323.png"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250041944.png" alt="img"></a></p><p>本文阅读前，需要对RabbitMQ有一个简单的了解，偏向实战配置讲解。</p><h3 id="三、死信队列是什么"><a href="#三、死信队列是什么" class="headerlink" title="三、死信队列是什么"></a>三、死信队列是什么</h3><p>死信，在官网中对应的单词为“Dead Letter”，可以看出翻译确实非常的简单粗暴。那么死信是个什么东西呢？</p><p>“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：</p><ol><li>消息被否定确认，使用 <code>channel.basicNack</code> 或 <code>channel.basicReject</code> ，并且此时<code>requeue</code> 属性被设置为<code>false</code>。</li><li>消息在队列的存活时间超过设置的TTL时间。</li><li>消息队列的消息数量已经超过最大队列长度。</li></ol><p>那么该消息将成为“死信”。</p><p>“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。</p><h3 id="四、如何配置死信队列"><a href="#四、如何配置死信队列" class="headerlink" title="四、如何配置死信队列"></a>四、如何配置死信队列</h3><p>这一部分将是本文的关键，如何配置死信队列呢？其实很简单，大概可以分为以下步骤：</p><ol><li>配置业务队列，绑定到业务交换机上</li><li>为业务队列配置死信交换机和路由key</li><li>为死信交换机配置死信队列</li></ol><p>注意，并不是直接声明一个公共的死信队列，然后所以死信消息就自己跑到死信队列里去了。而是为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然后为每个业务队列分配一个单独的路由key。</p><p>有了死信交换机和路由key后，接下来，就像配置业务队列一样，配置死信队列，然后绑定在死信交换机上。也就是说，死信队列并不是什么特殊的队列，只不过是绑定在死信交换机上的队列。死信交换机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、Fanout、Topic】。一般来说，会为每个业务队列分配一个独有的路由key，并对应的配置一个死信队列进行监听，也就是说，一般会为每个重要的业务队列配置一个死信队列。</p><p>有了前文这些陈述后，接下来就是惊险刺激的实战环节，这里省略了RabbitMQ环境的部署和搭建环节。</p><p>先创建一个Springboot项目。然后在pom文件中添加 <code>spring-boot-starter-amqp</code> 和 <code>spring-boot-starter-web</code> 的依赖，接下来创建一个Config类，这里是关键：</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Configurationpublic class RabbitMQConfig &#123;    public static final String BUSINESS_EXCHANGE_NAME &#x3D; &quot;dead.letter.demo.simple.business.exchange&quot;;    public static final String BUSINESS_QUEUEA_NAME &#x3D; &quot;dead.letter.demo.simple.business.queuea&quot;;    public static final String BUSINESS_QUEUEB_NAME &#x3D; &quot;dead.letter.demo.simple.business.queueb&quot;;    public static final String DEAD_LETTER_EXCHANGE &#x3D; &quot;dead.letter.demo.simple.deadletter.exchange&quot;;    public static final String DEAD_LETTER_QUEUEA_ROUTING_KEY &#x3D; &quot;dead.letter.demo.simple.deadletter.queuea.routingkey&quot;;    public static final String DEAD_LETTER_QUEUEB_ROUTING_KEY &#x3D; &quot;dead.letter.demo.simple.deadletter.queueb.routingkey&quot;;    public static final String DEAD_LETTER_QUEUEA_NAME &#x3D; &quot;dead.letter.demo.simple.deadletter.queuea&quot;;    public static final String DEAD_LETTER_QUEUEB_NAME &#x3D; &quot;dead.letter.demo.simple.deadletter.queueb&quot;;    &#x2F;&#x2F; 声明业务Exchange    @Bean(&quot;businessExchange&quot;)    public FanoutExchange businessExchange()&#123;        return new FanoutExchange(BUSINESS_EXCHANGE_NAME);    &#125;    &#x2F;&#x2F; 声明死信Exchange    @Bean(&quot;deadLetterExchange&quot;)    public DirectExchange deadLetterExchange()&#123;        return new DirectExchange(DEAD_LETTER_EXCHANGE);    &#125;    &#x2F;&#x2F; 声明业务队列A    @Bean(&quot;businessQueueA&quot;)    public Queue businessQueueA()&#123;        Map&lt;String, Object&gt; args &#x3D; new HashMap&lt;&gt;(2);&#x2F;&#x2F;       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机        args.put(&quot;x-dead-letter-exchange&quot;, DEAD_LETTER_EXCHANGE);&#x2F;&#x2F;       x-dead-letter-routing-key  这里声明当前队列的死信路由key        args.put(&quot;x-dead-letter-routing-key&quot;, DEAD_LETTER_QUEUEA_ROUTING_KEY);        return QueueBuilder.durable(BUSINESS_QUEUEA_NAME).withArguments(args).build();    &#125;    &#x2F;&#x2F; 声明业务队列B    @Bean(&quot;businessQueueB&quot;)    public Queue businessQueueB()&#123;        Map&lt;String, Object&gt; args &#x3D; new HashMap&lt;&gt;(2);&#x2F;&#x2F;       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机        args.put(&quot;x-dead-letter-exchange&quot;, DEAD_LETTER_EXCHANGE);&#x2F;&#x2F;       x-dead-letter-routing-key  这里声明当前队列的死信路由key        args.put(&quot;x-dead-letter-routing-key&quot;, DEAD_LETTER_QUEUEB_ROUTING_KEY);        return QueueBuilder.durable(BUSINESS_QUEUEB_NAME).withArguments(args).build();    &#125;    &#x2F;&#x2F; 声明死信队列A    @Bean(&quot;deadLetterQueueA&quot;)    public Queue deadLetterQueueA()&#123;        return new Queue(DEAD_LETTER_QUEUEA_NAME);    &#125;    &#x2F;&#x2F; 声明死信队列B    @Bean(&quot;deadLetterQueueB&quot;)    public Queue deadLetterQueueB()&#123;        return new Queue(DEAD_LETTER_QUEUEB_NAME);    &#125;    &#x2F;&#x2F; 声明业务队列A绑定关系    @Bean    public Binding businessBindingA(@Qualifier(&quot;businessQueueA&quot;) Queue queue,                                    @Qualifier(&quot;businessExchange&quot;) FanoutExchange exchange)&#123;        return BindingBuilder.bind(queue).to(exchange);    &#125;    &#x2F;&#x2F; 声明业务队列B绑定关系    @Bean    public Binding businessBindingB(@Qualifier(&quot;businessQueueB&quot;) Queue queue,                                    @Qualifier(&quot;businessExchange&quot;) FanoutExchange exchange)&#123;        return BindingBuilder.bind(queue).to(exchange);    &#125;    &#x2F;&#x2F; 声明死信队列A绑定关系    @Bean    public Binding deadLetterBindingA(@Qualifier(&quot;deadLetterQueueA&quot;) Queue queue,                                    @Qualifier(&quot;deadLetterExchange&quot;) DirectExchange exchange)&#123;        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY);    &#125;    &#x2F;&#x2F; 声明死信队列B绑定关系    @Bean    public Binding deadLetterBindingB(@Qualifier(&quot;deadLetterQueueB&quot;) Queue queue,                                      @Qualifier(&quot;deadLetterExchange&quot;) DirectExchange exchange)&#123;        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里声明了两个Exchange，一个是业务Exchange，另一个是死信Exchange，业务Exchange下绑定了两个业务队列，业务队列都配置了同一个死信Exchange，并分别配置了路由key，在死信Exchange下绑定了两个死信队列，设置的路由key分别为业务队列里配置的路由key。</p><p>下面是配置文件application.yml：</p><pre class="line-numbers language-YML" data-language="YML"><code class="language-YML">spring:  rabbitmq:    host: localhost    password: guest    username: guest    listener:      type: simple      simple:          default-requeue-rejected: false          acknowledge-mode: manual<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里记得将<code>default-requeue-rejected</code>属性设置为false。</p><p>接下来，是业务队列的消费代码：</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Slf4j@Componentpublic class BusinessMessageReceiver &#123;    @RabbitListener(queues &#x3D; BUSINESS_QUEUEA_NAME)    public void receiveA(Message message, Channel channel) throws IOException &#123;        String msg &#x3D; new String(message.getBody());        log.info(&quot;收到业务消息A：&#123;&#125;&quot;, msg);        boolean ack &#x3D; true;        Exception exception &#x3D; null;        try &#123;            if (msg.contains(&quot;deadletter&quot;))&#123;                throw new RuntimeException(&quot;dead letter exception&quot;);            &#125;        &#125; catch (Exception e)&#123;            ack &#x3D; false;            exception &#x3D; e;        &#125;        if (!ack)&#123;            log.error(&quot;消息消费发生异常，error msg:&#123;&#125;&quot;, exception.getMessage(), exception);            channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);        &#125; else &#123;            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);        &#125;    &#125;    @RabbitListener(queues &#x3D; BUSINESS_QUEUEB_NAME)    public void receiveB(Message message, Channel channel) throws IOException &#123;        System.out.println(&quot;收到业务消息B：&quot; + new String(message.getBody()));        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后配置死信队列的消费者：</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Componentpublic class DeadLetterMessageReceiver &#123;    @RabbitListener(queues &#x3D; DEAD_LETTER_QUEUEA_NAME)    public void receiveA(Message message, Channel channel) throws IOException &#123;        System.out.println(&quot;收到死信消息A：&quot; + new String(message.getBody()));        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);    &#125;    @RabbitListener(queues &#x3D; DEAD_LETTER_QUEUEB_NAME)    public void receiveB(Message message, Channel channel) throws IOException &#123;        System.out.println(&quot;收到死信消息B：&quot; + new String(message.getBody()));        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，为了方便测试，写一个简单的消息生产者，并通过controller层来生产消息。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Componentpublic class BusinessMessageSender &#123;    @Autowired    private RabbitTemplate rabbitTemplate;    public void sendMsg(String msg)&#123;        rabbitTemplate.convertSendAndReceive(BUSINESS_EXCHANGE_NAME, &quot;&quot;, msg);    &#125;&#125;@RequestMapping(&quot;rabbitmq&quot;)@RestControllerpublic class RabbitMQMsgController &#123;    @Autowired    private BusinessMessageSender sender;    @RequestMapping(&quot;sendmsg&quot;)    public void sendMsg(String msg)&#123;        sender.sendMsg(msg);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一切准备就绪，启动！</p><p>可以从RabbitMQ的管理后台中看到一共有四个队列，除默认的Exchange外还有声明的两个Exchange。</p><p><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140506771-319482381.jpg"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250041954.jpg" alt="img"></a><br><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140536938-1122765461.jpg"><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202111250041939.jpg" alt="img"></a></p><p>接下来，访问一下url，来测试一下：</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header-name keyword">http:</span>//localhost:8080/rabbitmq/sendmsg?msg=msg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>日志：</p><pre class="line-numbers language-none"><code class="language-none">收到业务消息A：msg收到业务消息B：msg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>表示两个Consumer都正常收到了消息。这代表正常消费的消息，ack后正常返回。然后我们再来测试nck的消息。</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header-name keyword">http:</span>//localhost:8080/rabbitmq/sendmsg?msg=deadletter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将会触发业务队列A的NCK，按照预期，消息被NCK后，会抛到死信队列中，因此死信队列将会出现这个消息，日志如下：</p><pre class="line-numbers language-none"><code class="language-none">收到业务消息A：deadletter消息消费发生异常，error msg:dead letter exceptionjava.lang.RuntimeException: dead letter exception...收到死信消息A：deadletter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，死信队列的Consumer接受到了这个消息，所以流程到此为止就打通了。</p><h3 id="五、死信消息的变化"><a href="#五、死信消息的变化" class="headerlink" title="五、死信消息的变化"></a>五、死信消息的变化</h3><p>那么“死信”被丢到死信队列中后，会发生什么变化呢？</p><p>如果队列配置了参数 <code>x-dead-letter-routing-key</code> 的话，“死信”的路由key将会被替换成该参数对应的值。如果没有设置，则保留该消息原有的路由key。</p><p>举个栗子：</p><p>如果原有消息的路由key是<code>testA</code>，被发送到业务Exchage中，然后被投递到业务队列QueueA中，如果该队列没有配置参数<code>x-dead-letter-routing-key</code>，则该消息成为死信后，将保留原有的路由key<code>testA</code>，如果配置了该参数，并且值设置为<code>testB</code>，那么该消息成为死信后，路由key将会被替换为<code>testB</code>，然后被抛到死信交换机中。</p><p>另外，由于被抛到了死信交换机，所以消息的Exchange Name也会被替换为死信交换机的名称。</p><p>消息的Header中，也会添加很多奇奇怪怪的字段，修改一下上面的代码，在死信队列的消费者中添加一行日志输出：</p><pre class="line-numbers language-none"><code class="language-none">log.info(&quot;死信消息properties：&#123;&#125;&quot;, message.getMessageProperties());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后重新运行一次，即可得到死信消息Header中被添加的信息：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">死信消息properties：MessageProperties</span> <span class="token attr-value">[headers=&#123;x-first-death-exchange=dead.letter.demo.simple.business.exchange, x-death=[&#123;reason=rejected, count=1, exchange=dead.letter.demo.simple.business.exchange, time=Sun Jul 14 16:48:16 CST 2019, routing-keys=[], queue=dead.letter.demo.simple.business.queuea&#125;], x-first-death-reason=rejected, x-first-death-queue=dead.letter.demo.simple.business.queuea&#125;, correlationId=1, replyTo=amq.rabbitmq.reply-to.g2dkABZyYWJiaXRAREVTS1RPUC1DUlZGUzBOAAAPQAAAAAAB.bLbsdR1DnuRSwiKKmtdOGw==, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=dead.letter.demo.simple.deadletter.exchange, receivedRoutingKey=dead.letter.demo.simple.deadletter.queuea.routingkey, deliveryTag=1, consumerTag=amq.ctag-NSp18SUPoCNvQcoYoS2lPg, consumerQueue=dead.letter.demo.simple.deadletter.queuea]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Header中看起来有很多信息，实际上并不多，只是值比较长而已。下面就简单说明一下Header中的值：</p><table><thead><tr><th align="left">字段名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">x-first-death-exchange</td><td align="left">第一次被抛入的死信交换机的名称</td></tr><tr><td align="left">x-first-death-reason</td><td align="left">第一次成为死信的原因，<code>rejected</code>：消息在重新进入队列时被队列拒绝，由于<code>default-requeue-rejected</code> 参数被设置为<code>false</code>。<code>expired</code> ：消息过期。<code>maxlen</code> ： 队列内消息数量超过队列最大容量</td></tr><tr><td align="left">x-first-death-queue</td><td align="left">第一次成为死信前所在队列名称</td></tr><tr><td align="left">x-death</td><td align="left">历次被投入死信交换机的信息列表，同一个消息每次进入一个死信交换机，这个数组的信息就会被更新</td></tr></tbody></table><h3 id="六、死信队列应用场景"><a href="#六、死信队列应用场景" class="headerlink" title="六、死信队列应用场景"></a>六、死信队列应用场景</h3><p>通过上面的信息，我们已经知道如何使用死信队列了，那么死信队列一般在什么场景下使用呢？</p><p>一般用在较为重要的业务队列中，确保未被正确消费的消息不被丢弃，一般发生消费异常可能原因主要有由于消息信息本身存在错误导致处理异常，处理过程中参数校验异常，或者因网络波动导致的查询异常等等，当发生异常时，当然不能每次通过日志来获取原消息，然后让运维帮忙重新投递消息（没错，以前就是这么干的= =）。通过配置死信队列，可以让未正确处理的消息暂存到另一个队列中，待后续排查清楚问题后，编写相应的处理代码来处理死信消息，这样比手工恢复数据要好太多了。</p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>死信队列其实并没有什么神秘的地方，不过是绑定在死信交换机上的普通队列，而死信交换机也只是一个普通的交换机，不过是用来专门处理死信的交换机。</p><p>总结一下死信消息的生命周期：</p><ol><li>业务消息被投入业务队列</li><li>消费者消费业务队列的消息，由于处理过程中发生异常，于是进行了nck或者reject操作</li><li>被nck或reject的消息由RabbitMQ投递到死信交换机中</li><li>死信交换机将消息投入相应的死信队列</li><li>死信队列的消费者消费死信消息</li></ol><p>死信消息是RabbitMQ为我们做的一层保证，其实我们也可以不使用死信队列，而是在消息消费异常时，将消息主动投递到另一个交换机中，当你明白了这些之后，这些Exchange和Queue想怎样配合就能怎么配合。比如从死信队列拉取消息，然后发送邮件、短信、钉钉通知来通知开发人员关注。或者将消息重新投递到一个队列然后设置过期时间，来进行延时消费.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="rabbitmq" scheme="http://example.com/tags/rabbitmq/"/>
    
    <category term="死信队列" scheme="http://example.com/tags/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>大白话聊透JVM</title>
    <link href="http://example.com/2021/03/04/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%E9%80%8FJVM/"/>
    <id>http://example.com/2021/03/04/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%E9%80%8FJVM/</id>
    <published>2021-03-04T06:09:22.000Z</published>
    <updated>2021-09-28T06:06:25.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载自掘金：<a href="https://juejin.im/user/5c2400afe51d45451758aa96">说出你的愿望吧丷</a></p><p>原文地址：<a href="https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28">https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及和而不深究，但会尽量效率地把知识点都抛出来</p><h2 id="一、JVM的基本介绍"><a href="#一、JVM的基本介绍" class="headerlink" title="一、JVM的基本介绍"></a>一、JVM的基本介绍</h2><p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p><p>好，其实抛开这么专业的句子不说，就知道JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357835.png"></p><h3 id="1-1-Java文件是如何被运行的"><a href="#1-1-Java文件是如何被运行的" class="headerlink" title="1.1 Java文件是如何被运行的"></a>1.1 Java文件是如何被运行的</h3><p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p><p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong> </p><h4 id="①-类加载器"><a href="#①-类加载器" class="headerlink" title="① 类加载器"></a>① 类加载器</h4><p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进JVM里面来。<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357867.png"></p><h4 id="②-方法区"><a href="#②-方法区" class="headerlink" title="② 方法区"></a>② 方法区</h4><p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p><p>类加载器将 .class 文件搬过来就是先丢到这一块上</p><h4 id="③-堆"><a href="#③-堆" class="headerlink" title="③ 堆"></a>③ 堆</h4><p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p><h4 id="④-栈"><a href="#④-栈" class="headerlink" title="④ 栈"></a>④ 栈</h4><p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p><p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用C来进行工作的，和Java没有太大的关系。</p><h4 id="⑤-程序计数器"><a href="#⑤-程序计数器" class="headerlink" title="⑤ 程序计数器"></a>⑤ 程序计数器</h4><p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357986.png"></p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ol><li>Java文件经过编译后变成 .class 字节码文件</li><li>字节码文件通过类加载器被搬运到 JVM 虚拟机中</li><li>虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li></ol><h3 id="1-2-简单的代码例子"><a href="#1-2-简单的代码例子" class="headerlink" title="1.2 简单的代码例子"></a>1.2 简单的代码例子</h3><p>一个简单的学生类<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357161.png"></p><p>一个main方法<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357322.png"></p><p>执行main方法的步骤如下:</p><ol><li> 编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li><li> JVM 找到 App 的主程序入口，执行main方法</li><li> 这个main中的第一条语句为 Student student = new Student(“tellUrDream”) ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li> 加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li><li> 执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li><li> 执行sayName()</li></ol><p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</p><h2 id="二、类加载器的介绍"><a href="#二、类加载器的介绍" class="headerlink" title="二、类加载器的介绍"></a>二、类加载器的介绍</h2><p>之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定</p><h3 id="2-1-类加载器的流程"><a href="#2-1-类加载器的流程" class="headerlink" title="2.1 类加载器的流程"></a>2.1 类加载器的流程</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h4 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="2.1.1 加载"></a>2.1.1 加载</h4><ol><li> 将class文件加载到内存</li><li> 将静态数据结构转化成方法区中运行时的数据结构</li><li> 在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</li></ol><h4 id="2-1-2-链接"><a href="#2-1-2-链接" class="headerlink" title="2.1.2 链接"></a>2.1.2 链接</h4><ol><li> 验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li><li> 准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li><li> 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li></ol><h4 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="2.1.3 初始化"></a>2.1.3 初始化</h4><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的0变成了显式初始化的3. 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p><blockquote><p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给JVM识别的特殊方法。</p></blockquote><h4 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="2.1.4 卸载"></a>2.1.4 卸载</h4><p>GC将无用对象从内存中卸载</p><h3 id="2-2-类加载器的加载顺序"><a href="#2-2-类加载器的加载顺序" class="headerlink" title="2.2 类加载器的加载顺序"></a>2.2 类加载器的加载顺序</h3><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li> BootStrap ClassLoader：rt.jar</li><li> Extension ClassLoader: 加载扩展的jar包</li><li> App ClassLoader：指定的classpath下面的jar包</li><li> Custom ClassLoader：自定义的类加载器</li></ol><h3 id="2-3-双亲委派机制"><a href="#2-3-双亲委派机制" class="headerlink" title="2.3 双亲委派机制"></a>2.3 双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载</p><p>这样做的好处是，加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>其实这个也是一个隔离的作用，避免了我们的代码影响了JDK的代码，比如我现在要来一个</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sout<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种时候，我们的代码肯定会报错，因为在加载的时候其实是找到了rt.jar中的String.class，然后发现这也没有main方法</p><h2 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h2><h3 id="3-1-本地方法栈和程序计数器"><a href="#3-1-本地方法栈和程序计数器" class="headerlink" title="3.1 本地方法栈和程序计数器"></a>3.1 本地方法栈和程序计数器</h3><p>比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使用C来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p><p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p><p>如果执行的是native方法，那这个指针就不工作了。</p><h3 id="3-2-方法区"><a href="#3-2-方法区" class="headerlink" title="3.2 方法区"></a>3.2 方法区</h3><p>方法区主要的作用是存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。</p><h3 id="3-3-虚拟机栈和虚拟机堆"><a href="#3-3-虚拟机栈和虚拟机堆" class="headerlink" title="3.3 虚拟机栈和虚拟机堆"></a>3.3 虚拟机栈和虚拟机堆</h3><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p><h4 id="3-3-1-虚拟机栈的概念"><a href="#3-3-1-虚拟机栈的概念" class="headerlink" title="3.3.1 虚拟机栈的概念"></a>3.3.1 虚拟机栈的概念</h4><p>它是Java方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-2-虚拟机栈存在的异常"><a href="#3-3-2-虚拟机栈存在的异常" class="headerlink" title="3.3.2 虚拟机栈存在的异常"></a>3.3.2 虚拟机栈存在的异常</h4><p>如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>。</p><h4 id="3-3-3-虚拟机栈的生命周期"><a href="#3-3-3-虚拟机栈的生命周期" class="headerlink" title="3.3.3 虚拟机栈的生命周期"></a>3.3.3 虚拟机栈的生命周期</h4><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><h4 id="3-3-4-虚拟机栈的执行"><a href="#3-3-4-虚拟机栈的执行" class="headerlink" title="3.3.4 虚拟机栈的执行"></a>3.3.4 虚拟机栈的执行</h4><p>我们经常说的栈帧数据，说白了在JVM中叫栈帧，放到Java中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。</p><h4 id="3-3-5-局部变量的复用"><a href="#3-3-5-局部变量的复用" class="headerlink" title="3.3.5 局部变量的复用"></a>3.3.5 局部变量的复用</h4><p>局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。</p><p>虚拟机通过索引定位的方式使用局部变量表，范围为[0,局部变量表的slot的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些slot是可以复用的，当方法执行位置超过了某个变量，那么这个变量的slot可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p><h4 id="3-3-6-虚拟机堆的概念"><a href="#3-3-6-虚拟机堆的概念" class="headerlink" title="3.3.6 虚拟机堆的概念"></a>3.3.6 虚拟机堆的概念</h4><p>JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给GC算法进行回收。非堆内存其实我们已经说过了，就是方法区。在1.8中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是metaSpace是不存在于JVM中的，它使用的是本地内存。并有两个参数</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">MetaspaceSize：初始化元空间大小，控制发生GCMaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>移除的原因可以大致了解一下：融合HotSpot JVM和JRockit VM而做出的改变，因为JRockit是没有永久代的，不过这也间接性地解决了永久代的OOM问题。</p><h4 id="3-3-7-Eden年轻代的介绍"><a href="#3-3-7-Eden年轻代的介绍" class="headerlink" title="3.3.7 Eden年轻代的介绍"></a>3.3.7 Eden年轻代的介绍</h4><p>当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB，有兴趣可以了解一下。</p><p>当Eden空间满了之后，会触发一个叫做Minor GC（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。经过多次的 Minor GC后仍然存活的对象（<strong>这里的存活判断是15次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15</strong>）会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p><p>而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357407.png"></p><p>补充说明：关于-XX:TargetSurvivorRatio参数的问题。其实也不一定是要满足-XX:MaxTenuringThreshold才移动到老年代。可以举个例子：如对象年龄5的占30%，年龄6的占36%，年龄7的占34%，加入某个年龄段（如例子中的年龄6）后，总占用超过Survivor空间*TargetSurvivorRatio的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄6对象，就是年龄6和年龄7晋升到老年代），这时候无需等到MaxTenuringThreshold中要求的15</p><h4 id="3-3-8-如何判断一个对象需要被干掉"><a href="#3-3-8-如何判断一个对象需要被干掉" class="headerlink" title="3.3.8 如何判断一个对象需要被干掉"></a>3.3.8 如何判断一个对象需要被干掉</h4><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357718.png"></p><p>图中程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p><p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法</p><p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。</p><p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如Java，C#等都是靠这招去判定对象是否存活的。</p><p>（了解一下即可）在Java语言汇总能作为GC Roots的对象分为以下几种：</p><ol><li> 虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）</li><li> 方法区中静态变量所引用的对象（静态变量）</li><li> 方法区中常量引用的对象</li><li> 本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li><li> 已启动的且未终止的Java线程</li></ol><p>这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p><h4 id="3-3-9-如何宣告一个对象的真正死亡"><a href="#3-3-9-如何宣告一个对象的真正死亡" class="headerlink" title="3.3.9 如何宣告一个对象的真正死亡"></a>3.3.9 如何宣告一个对象的真正死亡</h4><p>首先必须要提到的是一个名叫 <strong>finalize()</strong> 的方法</p><p>finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用。</p><p>补充一句：并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在Java9中已经被标记为 <strong>deprecated</strong> ，且java.lang.ref.Cleaner（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比finalize来的更加的轻量及可靠。<br>　　<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357794.png"></p><p>判断一个对象的死亡至少需要两次标记</p><ol><li> 如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。</li><li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li></ol><p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢</p><h3 id="3-4-垃圾回收算法"><a href="#3-4-垃圾回收算法" class="headerlink" title="3.4 垃圾回收算法"></a>3.4 垃圾回收算法</h3><p>不会非常详细的展开，常用的有标记清除，复制，标记整理和分代收集算法</p><h4 id="3-4-1-标记清除算法"><a href="#3-4-1-标记清除算法" class="headerlink" title="3.4.1 标记清除算法"></a>3.4.1 标记清除算法</h4><p>标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。</p><p>其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。</p><p>不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357947.png"></p><p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题</p><h4 id="3-4-2-复制算法"><a href="#3-4-2-复制算法" class="headerlink" title="3.4.2 复制算法"></a>3.4.2 复制算法</h4><p>为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和survivor一样也是用from和to两个指针这样的玩法。fromPlace存满了，就把存活的对象copy到另一块toPlace上，然后交换指针的内容。这样就解决了碎片的问题。</p><p>这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357050.png"></p><p>不过它们分配的时候也不是按照1:1这样进行分配的，就类似于Eden和Survivor也不是等价分配是一个道理。</p><h4 id="3-4-3-标记整理算法"><a href="#3-4-3-标记整理算法" class="headerlink" title="3.4.3 标记整理算法"></a>3.4.3 标记整理算法</h4><p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357192.png"></p><h4 id="3-4-4-分代收集算法"><a href="#3-4-4-分代收集算法" class="headerlink" title="3.4.4 分代收集算法"></a>3.4.4 分代收集算法</h4><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p><p>说白了就是八仙过海各显神通，具体问题具体分析了而已。</p><h3 id="3-5-（了解）各种各样的垃圾回收器"><a href="#3-5-（了解）各种各样的垃圾回收器" class="headerlink" title="3.5 （了解）各种各样的垃圾回收器"></a>3.5 （了解）各种各样的垃圾回收器</h3><p>HotSpot VM中的垃圾回收器，以及适用场景<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357456.png"></p><p>到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old</p><p>从jdk9开始，G1收集器成为默认的垃圾收集器<br>目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。</p><h3 id="3-6-（了解）JVM的常用参数"><a href="#3-6-（了解）JVM的常用参数" class="headerlink" title="3.6 （了解）JVM的常用参数"></a>3.6 （了解）JVM的常用参数</h3><p>JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or lator)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于CMS</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr></tbody></table><p>其实还有一些打印及CMS方面的参数，这里就不以一一列举了</p><h2 id="四、关于JVM调优的一些方面"><a href="#四、关于JVM调优的一些方面" class="headerlink" title="四、关于JVM调优的一些方面"></a>四、关于JVM调优的一些方面</h2><p>根据刚刚涉及的jvm的知识点，我们可以尝试对JVM进行调优，主要就是堆内存那块</p><p>所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m。所以java堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用fullgc，所以老年代过小的话反而是会增多fullgc的）。此值对系统性能影响较大，Sun官方推荐配置为java堆的3/8。</p><h3 id="4-1-调整最大堆内存和最小堆内存"><a href="#4-1-调整最大堆内存和最小堆内存" class="headerlink" title="4.1 调整最大堆内存和最小堆内存"></a>4.1 调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(&lt;1GB)）和初始java堆最小值（默认值是物理内存的1/64(&lt;1GB))</p><p>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单</p><p>开发过程中，通常会将 -Xms 与 -Xmx两个参数配置成相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><p>我们执行下面的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Xmx="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//系统的最大空间</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"free mem="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//系统的空闲空间</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"total mem="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//当前可用的总空间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：此处设置的是Java堆大小，也就是新生代大小 + 老年代大小<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357202.png"></p><p>设置一个VM options的参数</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-Xmx20m -Xms5m -XX:+PrintGCDetails<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357274.png"></p><p>再次启动main方法</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357003.png"><br>这里GC弹出了一个Allocation Failure分配失败，这个事情发生在PSYoungGen，也就是年轻代中</p><p>这时候申请到的内存为18M，空闲内存为4.214195251464844M</p><p>我们此时创建一个字节数组看看，执行下面的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分配了1M空间给数组"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Xmx="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//系统的最大空间</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"free mem="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//系统的空闲空间</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"total mem="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357408.png"></p><p>此时free memory就又缩水了，不过total memory是没有变化的。Java会尽可能将total mem的值维持在最小堆内存大小</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分配了10M空间给数组"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Xmx="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//系统的最大空间</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"free mem="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//系统的空闲空间</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"total mem="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//当前可用的总空间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357835.png"></p><p>这时候我们创建了一个10M的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的total memory已经变成了15M，这就是已经申请了一次内存的结果。</p><p>此时我们再跑一下这个代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Xmx="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//系统的最大空间</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"free mem="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//系统的空闲空间</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"total mem="</span> <span class="token operator">+</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//当前可用的总空间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281357410.png"></p><p>此时我们手动执行了一次fullgc，此时total memory的内存空间又变回5.5M了，此时又是把申请的内存释放掉的结果。</p><h3 id="4-2-调整新生代和老年代的比值"><a href="#4-2-调整新生代和老年代的比值" class="headerlink" title="4.2 调整新生代和老年代的比值"></a>4.2 调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p><p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</p><h3 id="4-3-调整Survivor区和Eden区的比值"><a href="#4-3-调整Survivor区和Eden区的比值" class="headerlink" title="4.3 调整Survivor区和Eden区的比值"></a>4.3 调整Survivor区和Eden区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个Survivor区和eden的比值</p><p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p><h3 id="4-4-设置年轻代和老年代的大小"><a href="#4-4-设置年轻代和老年代的大小" class="headerlink" title="4.4 设置年轻代和老年代的大小"></a>4.4 设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p><p>-XX:MaxNewSize — 设置年轻代最大值</p><p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的Eden和Survivor的占比为8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的gc，需要注意。</p><h3 id="4-5-小总结"><a href="#4-5-小总结" class="headerlink" title="4.5 小总结"></a>4.5 小总结</h3><p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新生代的1/10</p><p>在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump文件，这个文件可以使用VisualVM或者Java自带的Java VisualVM工具。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;你要输出的日志路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般我们也可以通过编写脚本的方式来让OOM出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p><h3 id="4-6-永久区的设置"><a href="#4-6-永久区的设置" class="headerlink" title="4.6 永久区的设置"></a>4.6 永久区的设置</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XX:PermSize -XX:MaxPermSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。</p><p>tips：如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出OOM。</p><h3 id="4-7-JVM的栈参数调优"><a href="#4-7-JVM的栈参数调优" class="headerlink" title="4.7 JVM的栈参数调优"></a>4.7 JVM的栈参数调优</h3><h4 id="4-7-1-调整每个线程栈空间的大小"><a href="#4-7-1-调整每个线程栈空间的大小" class="headerlink" title="4.7.1 调整每个线程栈空间的大小"></a>4.7.1 调整每个线程栈空间的大小</h4><p>可以通过-Xss：调整每个线程栈空间的大小</p><p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p><h4 id="4-7-2-设置线程栈的大小"><a href="#4-7-2-设置线程栈的大小" class="headerlink" title="4.7.2 设置线程栈的大小"></a>4.7.2 设置线程栈的大小</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XXThreadStackSize：    设置线程栈的大小(0 means use default stack size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供demo了</p><h3 id="4-8-可以直接跳过了-JVM其他参数介绍"><a href="#4-8-可以直接跳过了-JVM其他参数介绍" class="headerlink" title="4.8 (可以直接跳过了)JVM其他参数介绍"></a>4.8 (可以直接跳过了)JVM其他参数介绍</h3><p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p><h4 id="4-8-1-设置内存页的大小"><a href="#4-8-1-设置内存页的大小" class="headerlink" title="4.8.1 设置内存页的大小"></a>4.8.1 设置内存页的大小</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XXThreadStackSize：    设置内存页的大小，不可设置过大，会影响Perm的大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-8-2-设置原始类型的快速优化"><a href="#4-8-2-设置原始类型的快速优化" class="headerlink" title="4.8.2 设置原始类型的快速优化"></a>4.8.2 设置原始类型的快速优化</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XX:+UseFastAccessorMethods：    设置原始类型的快速优化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-8-3-设置关闭手动GC"><a href="#4-8-3-设置关闭手动GC" class="headerlink" title="4.8.3 设置关闭手动GC"></a>4.8.3 设置关闭手动GC</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XX:+DisableExplicitGC：    设置关闭System.gc()(这个参数需要严格的测试)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-8-4-设置垃圾最大年龄"><a href="#4-8-4-设置垃圾最大年龄" class="headerlink" title="4.8.4 设置垃圾最大年龄"></a>4.8.4 设置垃圾最大年龄</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XX:MaxTenuringThreshold    设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.    对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,    则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-8-5-加快编译速度"><a href="#4-8-5-加快编译速度" class="headerlink" title="4.8.5 加快编译速度"></a>4.8.5 加快编译速度</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XX:+AggressiveOpts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加快编译速度</p><h4 id="4-8-6-改善锁机制性能"><a href="#4-8-6-改善锁机制性能" class="headerlink" title="4.8.6 改善锁机制性能"></a>4.8.6 改善锁机制性能</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XX:+UseBiasedLocking<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-8-7-禁用垃圾回收"><a href="#4-8-7-禁用垃圾回收" class="headerlink" title="4.8.7 禁用垃圾回收"></a>4.8.7 禁用垃圾回收</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-Xnoclassgc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-8-8-设置堆空间存活时间"><a href="#4-8-8-设置堆空间存活时间" class="headerlink" title="4.8.8 设置堆空间存活时间"></a>4.8.8 设置堆空间存活时间</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XX:SoftRefLRUPolicyMSPerMB    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-8-9-设置对象直接分配在老年代"><a href="#4-8-9-设置对象直接分配在老年代" class="headerlink" title="4.8.9 设置对象直接分配在老年代"></a>4.8.9 设置对象直接分配在老年代</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XX:PretenureSizeThreshold    设置对象超过多大时直接在老年代分配，默认值是0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-8-10-设置TLAB占eden区的比例"><a href="#4-8-10-设置TLAB占eden区的比例" class="headerlink" title="4.8.10 设置TLAB占eden区的比例"></a>4.8.10 设置TLAB占eden区的比例</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XX:TLABWasteTargetPercent    设置TLAB占eden区的百分比，默认值是1% 。 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-8-11设置是否优先YGC"><a href="#4-8-11设置是否优先YGC" class="headerlink" title="4.8.11设置是否优先YGC"></a>4.8.11设置是否优先YGC</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-XX:+CollectGen0First    设置FullGC时是否先YGC，默认值是false。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java GC</title>
    <link href="http://example.com/2020/11/22/%E6%B5%85%E8%B0%88Java%20GC/"/>
    <id>http://example.com/2020/11/22/%E6%B5%85%E8%B0%88Java%20GC/</id>
    <published>2020-11-22T15:21:43.000Z</published>
    <updated>2021-09-28T04:05:38.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="本节常见面试题"><a href="#本节常见面试题" class="headerlink" title="本节常见面试题"></a>本节常见面试题</h3><p>问题答案在文中都有提到</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有哪些？</li><li>介绍一下 CMS,G1 收集器。</li><li>Minor Gc 和 Full GC 有什么不同呢？</li></ul><h3 id="本文导火索"><a href="#本文导火索" class="headerlink" title="本文导火索"></a>本文导火索</h3><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157694.png"></p><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="1-揭开-JVM-内存分配与回收的神秘面纱"><a href="#1-揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="1 揭开 JVM 内存分配与回收的神秘面纱"></a>1 揭开 JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157744.png"></p><p>上图所示的 Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）</strong>：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123; &#x2F;&#x2F;survivor_capacity是survivor空间的大小 size_t desired_survivor_size &#x3D; (size_t)((((double)survivor_capacity)*TargetSurvivorRatio)&#x2F;100); size_t total &#x3D; 0; uint age &#x3D; 1; while (age &lt; table_size) &#123;     &#x2F;&#x2F;sizes数组是每个年龄段对象大小     total +&#x3D; sizes[age];     if (total &gt; desired_survivor_size) &#123;         break;     &#125;     age++; &#125; uint result &#x3D; age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>经过这次 GC 后，Eden 区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次 GC 前的“From”，新的”From”就是上次 GC 前的”To”。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157739.png" alt="堆内存常见分配策略 "></p><h3 id="1-1-对象优先在-eden-区分配"><a href="#1-1-对象优先在-eden-区分配" class="headerlink" title="1.1 对象优先在 eden 区分配"></a>1.1 对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p><p><strong>测试：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">;</span>allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">30900</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//allocation2 = new byte[900*1024];</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过以下方式运行：<br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157760.png"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code><br><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157707.png"></p><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157710.jpg"></p><p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">900</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157052.jpg"></p><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span>allocation3<span class="token punctuation">,</span>allocation4<span class="token punctuation">,</span>allocation5<span class="token punctuation">;</span>allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">32000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>allocation5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="1.2 大对象直接进入老年代"></a>1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="1-3-长期存活的对象将进入老年代"><a href="#1-3-长期存活的对象将进入老年代" class="headerlink" title="1.3 长期存活的对象将进入老年代"></a>1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="1-4-动态对象年龄判定"><a href="#1-4-动态对象年龄判定" class="headerlink" title="1.4 动态对象年龄判定"></a>1.4 动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a href="https://github.com/Snailclimb/JavaGuide/issues/1199">issue1199</a> ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p>jdk8官方文档引用 ：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a> 。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157058.png"></p><p><strong>动态年龄计算的代码如下：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;&#x2F;&#x2F;survivor_capacity是survivor空间的大小size_t desired_survivor_size &#x3D; (size_t)((((double)survivor_capacity)*TargetSurvivorRatio)&#x2F;100);size_t total &#x3D; 0;uint age &#x3D; 1;while (age &lt; table_size) &#123;  &#x2F;&#x2F;sizes数组是每个年龄段对象大小  total +&#x3D; sizes[age];  if (total &gt; desired_survivor_size) &#123;      break;  &#125;  age++;&#125;uint result &#x3D; age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672">issue672</a>)：<strong>关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。</strong><br>如果你去 Oracle 的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p></blockquote><h3 id="1-5-主要进行-gc-的区域"><a href="#1-5-主要进行-gc-的区域" class="headerlink" title="1.5 主要进行 gc 的区域"></a>1.5 主要进行 gc 的区域</h3><p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p><blockquote><p><del><em>“老年代 GC（Major GC/Full GC），指发生在老年代的 GC……”</em></del></p></blockquote><p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157143.png"></p><p><strong>总结：</strong></p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h2 id="2-对象已经死亡？"><a href="#2-对象已经死亡？" class="headerlink" title="2 对象已经死亡？"></a>2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157156.png"></p><h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGc</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ReferenceCountingGc</span> objA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ReferenceCountingGc</span> objB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>objA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>objB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>objA <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>objB <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157162.png" alt="可达性分析算法 "></p><p>可作为 GC Roots 的对象包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="2-4-不可达的对象并非“非死不可”"><a href="#2-4-不可达的对象并非“非死不可”" class="headerlink" title="2.4 不可达的对象并非“非死不可”"></a>2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="2-5-如何判断一个常量是废弃常量？"><a href="#2-5-如何判断一个常量是废弃常量？" class="headerlink" title="2.5 如何判断一个常量是废弃常量？"></a>2.5 如何判断一个常量是废弃常量？</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del></p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/747">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762">reference</a>）</strong> ：</p><ol><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol></blockquote><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="2-6-如何判断一个类是无用的类"><a href="#2-6-如何判断一个类是无用的类" class="headerlink" title="2.6 如何判断一个类是无用的类"></a>2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a>3 垃圾收集算法</h2><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157177.png" alt="垃圾收集算法分类"></p><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157224.jpeg"></p><h3 id="3-2-标记-复制算法"><a href="#3-2-标记-复制算法" class="headerlink" title="3.2 标记-复制算法"></a>3.2 标记-复制算法</h3><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157338.png" alt="复制算法"></p><h3 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157406.png" alt="标记-整理算法 "></p><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a>4 垃圾收集器</h2><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157414.png" alt="垃圾收集器分类"></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157675.png" alt=" Serial 收集器 "></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157809.png" alt="ParNew 收集器 "></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><p><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p></li></ul><h3 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseParallelGC    使用 Parallel 收集器+ 老年代串行-XX:+UseParallelOldGC    使用 Parallel 收集器+ 老年代并行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157818.png" alt="Parallel Scavenge 收集器 "></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 java -XX:+PrintCommandLineFlags -version 命令查看</p><pre class="line-numbers language-none"><code class="language-none">-XX:InitialHeapSize&#x3D;262921408 -XX:MaxHeapSize&#x3D;4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGCjava version &quot;1.8.0_211&quot;Java(TM) SE Runtime Environment (build 1.8.0_211-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p><h3 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4.Serial Old 收集器"></a>4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="4-6-CMS-收集器"><a href="#4-6-CMS-收集器" class="headerlink" title="4.6 CMS 收集器"></a>4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281157917.png" alt="CMS 垃圾收集器 "></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="4.7 G1 收集器"></a>4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="4-8-ZGC-收集器"><a href="#4-8-ZGC-收集器" class="headerlink" title="4.8 ZGC 收集器"></a>4.8 ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><p>详情可以看 ： <a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li><a href="https://my.oschina.net/hosee/blog/644618">https://my.oschina.net/hosee/blog/644618</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="GC" scheme="http://example.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Redis分布式锁(下)</title>
    <link href="http://example.com/2020/10/25/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8B)/"/>
    <id>http://example.com/2020/10/25/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8B)/</id>
    <published>2020-10-24T18:14:32.000Z</published>
    <updated>2022-07-20T14:39:39.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自定义Redis分布式锁的弊端"><a href="#自定义Redis分布式锁的弊端" class="headerlink" title="自定义Redis分布式锁的弊端"></a>自定义Redis分布式锁的弊端</h1><p>在上一篇我们自定义了一个Redis分布式锁，用来解决多节点定时任务的拉取问题（避免任务重复执行）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604497239038-11bf2996-86c7-4672-8c14-97003ad03379-20210923224039242.png" alt="img"></p><p>但仍然存在很多问题：</p><ul><li>加锁操作不是原子性的（setnx和expire两步操作不是原子性的，中间宕机会导致死锁）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> lockKey<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> expireTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> timeUnit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.先setnx</span>    <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 2.再expire</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> expireTime<span class="token punctuation">,</span> timeUnit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605942078377-4709a4b0-b840-46af-8790-eec570ccc526-20210923224051964.png" alt="img"></p><p>当然啦，高版本的SpringBoot Redis依赖其实提供了加锁的原子性操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 尝试上锁：setNX + expire * * @param lockKey    锁 * @param value      对应的值 * @param expireTime 过期时间 * @param timeUnit   时间单位 * @return */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> lockKey<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> expireTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> timeUnit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 可以设置4个参数，一步到位</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> value<span class="token punctuation">,</span> expireTime<span class="token punctuation">,</span> timeUnit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 Redis 2.6.12 版本开始（现在6.x了…）， <a href="http://doc.redisfans.com/string/set.html#set">SET</a> 命令的行为可以通过一系列参数来修改，也因为 <a href="http://doc.redisfans.com/string/set.html#set">SET</a> 命令可以通过参数来实现和 <a href="http://doc.redisfans.com/string/setnx.html#setnx">SETNX</a> 、 <a href="http://doc.redisfans.com/string/setex.html#setex">SETEX</a> 和 <a href="http://doc.redisfans.com/string/psetex.html#psetex">PSETEX</a> 三个命令的效果，所以将来的 Redis 版本可能会废弃并最终移除 <a href="http://doc.redisfans.com/string/setnx.html#setnx">SETNX</a> 、 <a href="http://doc.redisfans.com/string/setex.html#setex">SETEX</a> 和 <a href="http://doc.redisfans.com/string/psetex.html#psetex">PSETEX</a> 这三个命令。</p><ul><li>解锁操作不是原子性的（可能造成不同节点之间互相删锁）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605944419389-2d72efb4-3f0d-4082-9836-27729be483ca-20210923224114637.png" alt="img"></p><p>虽然上一篇设计的unLock()不是原子操作，但可以避免不同节点之间互相删锁</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">unLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> lockKey<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.获取锁的value，存的是MACHINE_ID</span>    <span class="token class-name">String</span> machineId <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>machineId<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> machineId<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 2.只能删除当前节点设置的锁</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>畏难情绪作祟，不想考虑锁续期的问题，企图采用队列的方式缩减定时任务执行时间，直接把任务丢到队列中。但实际上可能存在任务堆积，个别情况下会出现：上次已经拉取某个任务并丢到Redis队列中，但由于队列比较繁忙，该任务还未被执行，数据库状态也尚未更改为status=1（已执行），结果下次又拉取一遍，重复执行（简单的解决策略是：虽然无法阻止入队，但是出队消费时可以判断where status=0后执行）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606004955240-09b70762-48c9-48db-b5ce-594f57f8037d-20210923224127881.png" alt="img"></p><p>引入Redis Message Queue会让系统变得更加复杂，我之前就因为使用了上面的模型导致各种偶发性的BUG，非常不好排查。一般来说，定时任务应该设计得简单点：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605943038778-2e521c6d-d2eb-4bf8-bfee-85386d52683f-20210923224137688.png" alt="img"></p><p>也就是说，绕来绕去，想要设计一个较完备的Redis分布式锁，必须至少解决3个问题：</p><ul><li><p>加锁原子性（setnx和expire要保证原子性，否则会容易发生死锁）</p></li><li><p>解锁原子性（不能误删别人的锁）</p></li><li><p>需要考虑业务/定时任务执行的时间，并为锁续期</p></li></ul><p>如果不考虑性能啥的，加解锁原子性都可以通过lua脚本实现（利用Redis单线程的特性）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605945261112-585bd28f-7670-4518-af85-8440d044153b-20210923224146607.png" alt="img"></p><p>一次执行一个脚本，要么成功要么失败，不会和其他指令交错执行。</p><p>最难的是如何根据实际业务的执行时间给锁续期！虽然我们已经通过判断MACHINE_ID避免了不同节点互相删除锁：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605945347715-e77ca098-bd7a-4dee-beda-1e325c6247fa-20210923224152657.png" alt="img"></p><p>但本质上我们需要的是：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606005458029-94f26b64-780d-4324-910c-f36f7dd7ccaf-20210923224200340.png" alt="img"></p><p>本文我们的主要目标就是实现锁续期！</p><p>好在Redisson已经实现了，所以目标又变成：了解Redisson的锁续期机制。</p><h1 id="Redisson案例"><a href="#Redisson案例" class="headerlink" title="Redisson案例"></a>Redisson案例</h1><h2 id="Redisson环境搭建"><a href="#Redisson环境搭建" class="headerlink" title="Redisson环境搭建"></a>Redisson环境搭建</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">server:  port: 8080spring:  redis:    host: # 见小册开头《阿里云服务账号》    password: # 见小册开头《阿里云服务账号》    database: 1    # 调整控制台日志格式，稍微精简一些（非必要操作）logging:  pattern:    console: "%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %thread - %msg%n"<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--大家也可以单独引入Redisson依赖，然后通过@Configuration自己配置RedissonClient--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>redisson-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.13.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就可以在test包下测试了~</p><h2 id="lock-方法初探"><a href="#lock-方法初探" class="headerlink" title="lock()方法初探"></a>lock()方法初探</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RLockTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedissonClient</span> redissonClient<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testRLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">testLockOne</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">testLockTwo</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLockOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"bravo1988_distributed_lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testLockOne尝试加锁..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testLockOne加锁成功..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testLockOne业务开始..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testLockOne业务结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testLockOne解锁成功..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLockTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"bravo1988_distributed_lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testLockTwo尝试加锁..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testLockTwo加锁成功..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testLockTwo业务开始..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testLockTwo业务结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testLockTwo解锁成功..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><p>2020-11-21 14:24:33 - Thread-3 - testLockTwo尝试加锁…</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne尝试加锁…</p><p>=====&gt; testLockOne()执行过程中，testLockTwo()一直阻塞 &lt;=====</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne加锁成功…</p><p>2020-11-21 14:24:33 - Thread-2 - testLockOne业务开始…</p><p>2020-11-21 14:25:23 - Thread-2 - testLockOne业务结束…</p><p>2020-11-21 14:25:23 - Thread-2 - testLockOne解锁成功…</p><p>=====&gt; testLockOne()执行结束释放锁，testLockTwo()抢到锁 &lt;=====</p><p>2020-11-21 14:25:23 - Thread-3 - testLockTwo加锁成功…</p><p>2020-11-21 14:25:23 - Thread-3 - testLockTwo业务开始…</p><p>2020-11-21 14:26:13 - Thread-3 - testLockTwo业务结束…</p><p>2020-11-21 14:26:13 - Thread-3 - testLockTwo解锁成功…</p><p>通过上面的代码，我们有以下疑问：</p><ul><li><p>lock()方法是原子性的吗？</p></li><li><p>lock()有设置过期时间吗？是多少？</p></li><li><p>lock()实现锁续期了吗？</p></li><li><p>lock()方法怎么实现阻塞的？又怎么被唤醒？</p></li></ul><p>先忘了这些，跟着我们走一遍lock()源码就明白了。</p><h1 id="lock-源码解析"><a href="#lock-源码解析" class="headerlink" title="lock()源码解析"></a>lock()源码解析</h1><p>lock()加锁，去除异常的情况，无非加锁成功、加锁失败两种情况，我们先看加锁成功的情况。</p><h2 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h2><p>我们从这段最简单的代码入手：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RLockTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedissonClient</span> redissonClient<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLockSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"bravo1988_distributed_lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"准备加锁..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"加锁成功..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家跟着我们先打几个断点（SpringBoot2.3.4）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952885069-f4e16307-9030-4a38-b154-30cd4f7f5a74-20210923224243500.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952773563-dca85b18-f11c-4511-8fdb-a737075fb5fd-20210923224252102.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952860890-484897da-0ee6-45ea-8179-ddf6f357316a-20210923224340729.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952928238-e1dc233d-d877-423f-8561-f121c821d5c8-20210923224347621.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952952657-d35ba600-5996-4a67-adee-0c39535f728c-20210923224354124.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605952984223-bf8c4bda-866f-406f-b7f8-c369b6d9b1ea-20210923224359530.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605953023756-2fc503b2-44bb-47c9-baf6-a095fef000e1-20210923224410403.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605953051967-7f6f6fb5-cfba-46a5-80d1-e83f19efb80c-20210923224418693.png" alt="img"></p><p>注意啊，把截图中能看到的断点都打上。</p><p>OK，接着大家自己启动DEBUG，感受一下大致流程，然后看下面的注释：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// redisson.lock()</span><span class="token class-name">Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 为了方便辨认，我直接把传进来的参数写在参数列表上</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token keyword">long</span> leaseTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">boolean</span> interruptibly<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取当前线程id</span>    <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 尝试上锁。上锁成功返回null，上锁失败返回ttl</span>    <span class="token class-name">Long</span> ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> leaseTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 上锁成功，方法结束，回到主线程执行业务啦（后台有个定时任务在给当前锁续期）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 上锁成功就不走下面的流程了，所以这里直接省略</span>    <span class="token comment">// 略：加锁失败后续流程...</span><span class="token punctuation">&#125;</span><span class="token comment">// 尝试上锁。上锁成功返回null，上锁失败返回【当前已经存在的锁】的ttl，方便调用者判断多久之后能重新获取锁</span><span class="token keyword">private</span> <span class="token class-name">Long</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**    * 有两次调用：1.tryAcquireAsync()返回Future 2.从Future获取异步结果（异步结果就是ttl）    * 重点是tryAcquireAsync()    */</span>    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span>waitTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> leaseTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 获取过期时间（非重点）</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> future<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> commandExecutor<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 重点，加锁后返回RFuture，内部包含ttl。调用本方法可能加锁成功，也可能加锁失败，外界可以通过ttl判断</span><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span> <span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// lock()默认leaseTime=-1，所以会跳过if</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leaseTime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span>EVAL_LONG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 执行lua脚本，尝试加锁并返回RFuture。这个方法是异步的，其实是把任务提交给线程池</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span> ttlRemainingFuture <span class="token operator">=</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>                                            waitTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>                                            commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCfg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">30</span>秒<span class="token punctuation">,</span>                                            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                             threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">,</span>                                             <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span>EVAL_LONG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置回调方法，异步线程与Redis交互得到结果后会回调BiConsumer#accept()</span>    ttlRemainingFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ttlRemaining<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发生异常时直接return</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 说明加锁成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlRemaining <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 启动额外的线程，按照一定规则给当前锁续期</span>            <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回RFuture，里面有ttlRemaining</span>    <span class="token keyword">return</span> ttlRemainingFuture<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 执行lua脚本尝试上锁</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token operator">=</span><span class="token number">30</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token operator">=</span>毫秒<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    internalLockLeaseTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 大家去看一下evalWriteAsync()的参数列表，看看每个参数都代表什么，就能理解KEYS[]和ARGV[]以及整个脚本什么意思了     * 如果你仔细看lua脚本，就会明白：加锁成功时返回ttlRemaining=null，加锁失败时返回ttlRemaining=xxx（上一个锁还剩多少时间）     *     * 另外，我们自定义的Redis分布式锁采用了IdUtil生成节点id，和getLockName(threadId)本质是一样的     */</span>    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">,</span> command<span class="token punctuation">,</span>            <span class="token string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return nil; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return nil; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"return redis.call('pttl', KEYS[1]);"</span><span class="token punctuation">,</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 向Redis服务器发送脚本并返回RFuture，大家可以近似看成：往线程池提交一个任务，然后将异步结果封装到CompletableFuture</span><span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Codec</span> codec<span class="token punctuation">,</span> <span class="token class-name">RedisCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> evalCommandType<span class="token punctuation">,</span> <span class="token class-name">String</span> script<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> keys<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CommandBatchService</span> executorService <span class="token operator">=</span> <span class="token function">createCommandBatchService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">evalWriteAsync</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> codec<span class="token punctuation">,</span> evalCommandType<span class="token punctuation">,</span> script<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>commandExecutor <span class="token keyword">instanceof</span> <span class="token class-name">CommandBatchService</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        executorService<span class="token punctuation">.</span><span class="token function">executeAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605956150610-2ce6fbe0-577a-4ab1-9540-a1d176038d02-20210923224433312.png" alt="img"></p><p>整个流程比较简单，只有两个难点：</p><ul><li>lua脚本写了啥</li><li>ttlRemainingFuture.onComplete()有什么作用</li></ul><h2 id="lua脚本解读"><a href="#lua脚本解读" class="headerlink" title="lua脚本解读"></a>lua脚本解读</h2><p>大家可以通过evalWriteAsync()的参数列表推导出KEYS、ARGV分别是什么：</p><p>KEYS[] =&gt; Collections.singletonList(getName())</p><p>ARGV[] =&gt; internalLockLeaseTime, getLockName(threadId)</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- 如果不存在锁："bravo1988_distributed_lock"</span><span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'exists'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span>    <span class="token comment">-- 使用hincrby设置锁：hincrby bravo1988_distributed_lock a1b2c3d4:666 1</span>    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hincrby'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">-- 设置过期时间。ARGV[1]==internalLockLeaseTime</span>    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'pexpire'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">-- 返回null</span>    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span>     <span class="token keyword">end</span><span class="token punctuation">;</span> <span class="token comment">-- 如果当前节点已经设置"bravo1988_distributed_lock"（注意，传了ARGV[2]==节点id）</span><span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hexists'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">then</span>     <span class="token comment">-- 就COUNT++，可重入锁</span>    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hincrby'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">-- 设置过期时间。ARGV[1]==internalLockLeaseTime</span>    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'pexpire'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">-- 返回null</span>    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token punctuation">;</span> <span class="token comment">-- 已经存在锁，且不是当前节点设置的，就返回锁的过期时间ttl</span><span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'pttl'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说，Redisson设计的分布式锁是采用hash结构：</p><p><strong>LOCK_NAME</strong>（锁的KEY）+ <strong>CLIENT_ID</strong>（节点ID）+ <strong>COUNT</strong>（重入次数）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605957127624-694aaebe-2293-4641-83e8-8649823ec961-20210923224458173.png" alt="img"></p><h2 id="回调函数的作用"><a href="#回调函数的作用" class="headerlink" title="回调函数的作用"></a>回调函数的作用</h2><p>之前我们已经学过CompletableFuture的回调机制：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605406493819-8575b4ca-57e6-4afc-aba7-4840bee68138-20210923224505808.png" alt="img">RFuture#onComplete()和它很相似：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ttlRemainingFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ttlRemaining<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发生异常时直接return</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 说明加锁成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlRemaining <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 启动额外的线程，按照一定规则给当前锁续期</span>            <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>onComplete()应该也是把回调函数推到stack中，方便后面异步线程弹栈执行。</p><p>至此，我们已经解决了之前的两个问题：</p><ul><li>lua脚本是什么意思（见注释）</li><li>ttlRemainingFuture.onComplete()有什么作用（设置回调函数，等会儿会有线程调用）</li></ul><p>虽然在CompletableFuture中已经强调过，这里还是要提一下：<strong>被回调的不是onComplete(BiConsumer)，而是****BiConsumer#accept()。</strong>主线程在调用onComplete(BiConsumer)时把它作为参数传入，然后被推入栈中<strong>：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BiConsumer</span> consumer <span class="token operator">=</span> <span class="token punctuation">(</span>ttlRemaining<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 发生异常时直接return</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 说明加锁成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlRemaining <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 启动额外的线程，按照一定规则给当前锁续期</span>        <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Redisson异步回调机制"><a href="#Redisson异步回调机制" class="headerlink" title="Redisson异步回调机制"></a>Redisson异步回调机制</h2><p>现在已经确定了尝试加锁后会返回RFuture，并且我们可以通过RFuture做两件事：</p><ul><li>通过RFuture获取ttlRemaining，也就是上一个锁的过期时间，如果为null则本次加锁成功，否则加锁失败，需要等待</li><li>通过RFuture设置回调函数</li></ul><p>现在疑问是：</p><ul><li><p>异步线程是谁，哪来的？</p></li><li><p>onComplete()设置的回调函数是干嘛的？</p></li><li><p>回调时的参数(ttlRemaining, e)哪来的？</p></li></ul><p>1、3两个问题非常难，源码比较绕，这里就带大家感性地体验一下，有兴趣可以自己跟源码了解。清除刚才的全部断点，只留下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958482130-e4ac51fd-c7c6-4a1c-9b8d-bc9ce3fab6a6-20210923224532665.png" alt="img"></p><p>再次DEBUG，线程会先到达return ttlRemainingFuture，随后回调BiConsumer#accept()：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958677303-5991020a-4ff9-4399-a71c-cefd1824931c-20210923224542928.png" alt="img"></p><p>回调时线程变了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605958821470-c3a87de8-f677-4990-8a52-a42e572696d0-20210923224550800.png" alt="img"></p><p>大家有兴趣可以自己顺着调用栈逆推回去，还是比较复杂的，涉及到NIO、Promise等，源头还是在线程池，但其中又设计了Listeners的收集和循环唤醒：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Codec</span> codec<span class="token punctuation">,</span> <span class="token class-name">RedisCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> evalCommandType<span class="token punctuation">,</span> <span class="token class-name">String</span> script<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> keys<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CommandBatchService</span> executorService <span class="token operator">=</span> <span class="token function">createCommandBatchService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">evalWriteAsync</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> codec<span class="token punctuation">,</span> evalCommandType<span class="token punctuation">,</span> script<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>commandExecutor <span class="token keyword">instanceof</span> <span class="token class-name">CommandBatchService</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        executorService<span class="token punctuation">.</span><span class="token function">executeAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之，目前为止我们只需要知道：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605959979086-b4d49fc5-a37b-4872-a0d4-3f9c5a560f9d-20210923224610738.png" alt="img"></p><p>我们虽然不知道onComplete()具体如何实现回调（比CompletableFuture复杂得多），但是我们知道锁续期和RFuture的回调机制相关！</p><h2 id="Redisson如何实现锁续期"><a href="#Redisson如何实现锁续期" class="headerlink" title="Redisson如何实现锁续期"></a>Redisson如何实现锁续期</h2><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605960740451-f70e601b-0432-44a1-8e3c-34ff56b3b1c9-20210923224618495.png" alt="img"></p><p>最终会进入：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ExpirationEntry</span> ee <span class="token operator">=</span> EXPIRATION_RENEWAL_MAP<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ee <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">/**    * 启动一个定时器：Timeout newTimeout(TimerTask task, long delay, TimeUnit unit);    * 执行规则是：延迟internalLockLeaseTime/3后执行    * 注意啊，每一个定时任务只执行一遍，而且是延迟执行。    *     * 那么问题就来了：    * 1.internalLockLeaseTime/3是多久呢？    * 2.如果定时任务只执行一遍，似乎解决不了问题啊，本质上和我们手动设置过期时间一样：多久合适呢？    */</span>     <span class="token class-name">Timeout</span> task <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newTimeout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Timeout</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ExpirationEntry</span> ent <span class="token operator">=</span> EXPIRATION_RENEWAL_MAP<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ent <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">Long</span> threadId <span class="token operator">=</span> ent<span class="token punctuation">.</span><span class="token function">getFirstThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token comment">// 定时任务的目的是：重新执行一遍lua脚本，完成锁续期，把锁的ttl拨回到30s</span>            <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 设置了一个回调</span>            future<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Can't update lock "</span> <span class="token operator">+</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" expiration"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 如果宕机了，就不会续期了</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 如果锁还存在（没有unLock，说明业务还没结束），递归调用当前方法，不断续期</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// reschedule itself</span>                    <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> internalLockLeaseTime <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        ee<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*** 重新执行evalWriteAsync()，和加锁时的lua脚本比较类似，但有点不同* 这里设置expire的参数也是internalLockLeaseTime** 看来我们不得不去调查一下internalLockLeaseTime了！*/</span><span class="token keyword">protected</span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">></span></span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span>EVAL_BOOLEAN<span class="token punctuation">,</span>            <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return 1; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"return 0;"</span><span class="token punctuation">,</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你给renewExpirationAsync()打上断点，会发现每隔10秒，定时任务就会执行一遍：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969467749-64ac2a12-3b6d-4762-abf8-b457be9dc0e5-20210923224633703.png" alt="img"></p><p>联想到定时任务的delay是internalLockLeaseTime/3，所以推测internalLockLeaseTime为30秒。</p><p>点击internalLockLeaseTime，很容易跳转到对应的字段：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969607142-5897d87e-0841-4647-8ad1-02b308a7e66c-20210923224640385.png" alt="img"></p><p>再顺着getLockWatchdogTimeout()跳转，很快就会发现</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969777097-2f955c29-3f28-4ce2-a12a-b76455fb1e1e-20210923224647544.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969804198-7d2b61c3-da1b-4de1-aecd-5777a4994ee5-20210923224657200.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969855073-00958650-adfb-49c5-972e-37e797f5f23d-20210923224708071.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605969922018-f5dc76c3-0566-4d14-9018-1ea86f17ff1c-20210923224716263.png" alt="img"></p><p>确实是30秒。</p><p>梳理一下所谓的Watchdog锁续期机制：</p><ul><li>lock()第一次成功加锁时，设置的锁过期时间默认30秒，这个值来自Watchdog变量</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 重点</span><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span> <span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// lock()默认leaseTime=-1，所以会跳过if</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leaseTime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span>EVAL_LONG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 执行lua脚本加锁，返回RFuture。第二个参数就是leaseTime，来自LockWatchdogTimeout！！！</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span> ttlRemainingFuture <span class="token operator">=</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>                                            waitTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>                                            commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCfg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">30</span>秒<span class="token punctuation">,</span>                                            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                             threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">,</span>                                             <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span>EVAL_LONG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置回调方法</span>    ttlRemainingFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ttlRemaining<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发生异常时直接return</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 说明加锁成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlRemaining <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 启动额外的线程，按照一定规则给当前锁续期</span>            <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回RFuture，里面有ttlRemaining</span>    <span class="token keyword">return</span> ttlRemainingFuture<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 执行lua脚本上锁</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token operator">=</span><span class="token number">30</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token operator">=</span>毫秒<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 略...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>onComplete()设置回调，等Redis调用回来后，异步线程回调BiConsumer#accept()，进入scheduleExpirationRenewal(threadId)，开始<strong>每隔internalLockLeaseTime/3时间就给锁续期</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605961851949-8de820bf-97f6-4330-a580-da4003cc2123-20210923224729646.png" alt="img"></p><p>和加锁一样，执行lua脚本其实很快，所以这里的future.onComplete()虽说是异步，但很快就会被调用，然后就会递归调用renewExpiration()，然后又是一个TimerTask()，<strong>隔****internalLockLeaseTime/3后又给锁续期。</strong></p><p><strong>也就是说，Redisson的Watchdog定时任务虽然只延迟执行一次，但每次调用都会递归，所以相当于：重复延迟执行。</strong></p><p>还记得之前学习CompletableFuture时我写的一行注释吗：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605970707587-a80fb37d-b89e-4742-b675-4bfe03ca8b0c-20210923224741535.png" alt="img"></p><p>也就是说，只要主线程的任务不结束，就会一直给锁续期。</p><p>锁释放有两种情况：</p><ul><li>任务结束，主动unLock()删除锁</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">redisson<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisson<span class="token punctuation">.</span><span class="token function">unLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>任务结束，不调用unLock()，但由于守护线程已经结束，不会有后台线程继续给锁续期，过了30秒自动过期</li></ul><p>上面我们探讨的都是加锁成功的流程，直接ttl=null就返回了，后面一大坨都是加锁失败时的判断逻辑，其中涉及到：</p><ul><li><p>while(true)死循环</p></li><li><p>阻塞等待</p></li><li><p>释放锁时Redis的Publish通知（在后面的unLock流程会看到）</p></li><li><p>其他节点收到锁释放的信号后重新争抢锁</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975498344-dd4657b8-5442-4fcd-8693-9f5e81d09531-20210923224753386.png" alt="img"></p><p>整个过程还是非常复杂的，大家有精力可以自行百度了解，后面介绍unLock()时也会涉及一部分加锁失败相关内容。</p><h1 id="unLock-源码解析"><a href="#unLock-源码解析" class="headerlink" title="unLock()源码解析"></a>unLock()源码解析</h1><p>有了lock()的经验，unLock()就简单多了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975635261-dc6265a9-2950-433f-a7f1-d46445d0a01b-20210923224803834.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605975844381-fff7bf1c-36e2-4f63-9fc8-f5af8ebc0e0a-20210923224809682.png" alt="img"></p><p>相信大家还是能推断出KEYS[]和ARGV[]，这里就直接给出答案了：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- 参数解释：</span><span class="token comment">-- KEYS[1] => "bravo1988_distributed_lock"</span><span class="token comment">-- KEYS[2] => getChannelName()</span><span class="token comment">-- ARGV[1] => LockPubSub.UNLOCK_MESSAGE</span><span class="token comment">-- ARGV[2] => internalLockLeaseTime</span><span class="token comment">-- ARGV[3] => getLockName(threadId)</span><span class="token comment">-- 锁已经不存在，返回null</span><span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hexists'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span>    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token punctuation">;</span><span class="token comment">-- 锁还存在，执行COUNT--（重入锁的反向操作）</span><span class="token keyword">local</span> counter <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hincrby'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- COUNT--后仍然大于0（之前可能重入了多次）</span><span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span>    <span class="token comment">-- 设置过期时间</span>    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'pexpire'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">-- COUNT--后小于等于0，删除锁，并向对应的Channel发送消息（NIO），消息类型是LockPubSub.UNLOCK_MESSAGE（锁释放啦，快来抢~）</span><span class="token keyword">else</span>     redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'del'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'publish'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，当一个锁被释放时，原先持有锁的节点会通过NIO的Channel发送LockPubSub.UNLOCK_MESSAGE，告诉其他订阅的Client：我已经释放锁啦，快来抢啊！此时原本阻塞的其他节点就会重新竞争锁。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606010300656-f21b35bd-bd46-4f02-bf73-e2913664af28-20210923224832043.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606010321812-3803dd5d-3411-4060-84f1-2f797f56946e-20210923224838169.png" alt="img"></p><p>而所谓重入和反重入，简单来说就是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 加锁三次</span>redisson<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisson<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisson<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 执行业务</span><span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 相应的，就要解锁三次</span>redisson<span class="token punctuation">.</span><span class="token function">unLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisson<span class="token punctuation">.</span><span class="token function">unLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisson<span class="token punctuation">.</span><span class="token function">unLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际开发不会这样调用，但有时会出现子父类方法调用或者同一个线程反复调用使用同一把锁的多个方法，就会发生锁的重入（COUNT++），而当这些方法执行完毕逐个弹栈的过程中就会逐个unLock()解锁（COUNT–）。</p><h1 id="lock-leaseTime-unit-：自定义过期时间、且不续期"><a href="#lock-leaseTime-unit-：自定义过期时间、且不续期" class="headerlink" title="lock(leaseTime, unit)：自定义过期时间、且不续期"></a>lock(leaseTime, unit)：自定义过期时间、且不续期</h1><p>lock()默认会开启定时任务对锁进行续期，但Redisson还提供了另一个lock方法：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605976920059-cd4945a2-0932-4cc6-a2b5-9beac14475f9-20210923224857619.png" alt="img"></p><p>两个lock()唯一的区别是，内部调用lock()时，一个传了leaseTime=-1，另一个传了我们自己的leaseTime。对于外部调用者来说：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">redisson<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisson<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种写法其实一样。</p><p>当然了，通常会传入有意义的leaseTime：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605977159145-10176f3a-8e5c-4d34-9f82-d5a9a684c15e-20210923224909434.png" alt="img"></p><p><strong>这种写法除了更改了锁的默认ttl时间外，还阉割了锁续期功能。</strong>也就是说，10秒后如果任务还没执行完，就会和我们手写的Redis分布式锁一样，自动释放锁。</p><p>为什么锁续期的功能失效了呢？留给大家自己解答，这里只给出参考答案：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 重点</span><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span> <span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// lock()默认leaseTime=-1，会跳过这个if执行后面的代码。但如果是lock(10, TimeUnit.SECONDS)，会执行if并跳过后面的代码。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leaseTime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 其实和下面的tryLockInnerAsync()除了时间不一样外，没什么差别</span>        <span class="token keyword">return</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span>EVAL_LONG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 但由于上面直接return了，所以下面的都不会执行！！</span>    <span class="token comment">/*    RFuture&lt;Long> ttlRemainingFuture = tryLockInnerAsync(                                            waitTime=-1,                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=30秒,                                            TimeUnit.MILLISECONDS,                                             threadId=666,                                             RedisCommands.EVAL_LONG);    // 设置回调方法（不会执行！！）    ttlRemainingFuture.onComplete((ttlRemaining, e) -> &#123;        // 发生异常时直接return        if (e != null) &#123;            return;        &#125;        // 说明加锁成功        if (ttlRemaining == null) &#123;            // 启动额外的线程，按照一定规则给当前锁续期            scheduleExpirationRenewal(threadId);        &#125;    &#125;);    // 不会执行！！    return ttlRemainingFuture;    */</span><span class="token punctuation">&#125;</span><span class="token comment">// 执行lua脚本加锁</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token operator">=</span><span class="token number">30</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token operator">=</span>毫秒<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 略...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，直接执行lua加锁就返回了，没有机会启动定时任务和递归…</p><h1 id="tryLock-系列：让调用者自行决定加锁失败后的操作"><a href="#tryLock-系列：让调用者自行决定加锁失败后的操作" class="headerlink" title="tryLock()系列：让调用者自行决定加锁失败后的操作"></a>tryLock()系列：让调用者自行决定加锁失败后的操作</h1><p>之前我们已经观察到，如果多个节点都调用lock()，那么没获取到锁的节点线程会<strong>阻塞</strong>，直到原先持有锁的节点删除锁并publish LockPubSub.UNLOCK_MESSAGE 。</p><p>但如果调用者不希望阻塞呢？他有可能想着：如果加锁失败，我就直接放弃。</p><p>是啊，毕竟尝试加锁的目的可能完全相反：</p><ul><li>在保证线程安全的前提下，尽量让所有线程都执行成功</li><li>在保证线程安全的前提下，只让一个线程执行成功</li></ul><p>前者适用于秒杀、下单等操作，希望尽最大努力达成；后者适用于定时任务，只要让一个节点去执行，没有获取锁的节点应该fast-fail（快速失败）。</p><p>也就是说，节点获锁失败后，理论上可以有各种各样的处理方式：</p><ul><li><p>阻塞等待</p></li><li><p>直接放弃</p></li><li><p>试N次再放弃</p></li><li><p>…</p></li></ul><p><strong>但lock、****lock(leaseTime, timeUnit)替我们写死了：阻塞等待。</strong>即使lock(leaseTime, unit)，其实也是阻塞等待，只不过不会像lock()一样不断续期。</p><p>究其原因，主要是lock()这些方法对于加锁失败的判断是在内部写死的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605978662886-e09f2b51-ccb8-4fdb-b7f2-b2b162d0c57d-20210923224924265.png" alt="img"></p><p>而tryLock()方法则去掉了这层中间判断，<strong>把结果直接呈递到调用者面前，让调用者自己决定加锁失败后如何处理：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605978761456-207d8919-5a9e-451e-9460-3b4498f1b86c-20210923224932016.png" alt="img"></p><p>tryLock()直接返回true（加锁成功）和false（加锁失败），后续如何处理，全凭各个节点自己做出决定。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"bravo1988_distributed_lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> b <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 业务操作...</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 调用立即结束，不阻塞</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样讲可能有点抽象，大家可以分别点进lock()和tryLock()，自行体会。总之，tryLock()中间少了一大块逻辑，因为它不插手结果的判断。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606181778959-3b05f3f9-ba72-4ada-9d4b-cb17f2871d91-20210923224943457.png" alt="img"></p><p>另外，tryLock()在加锁成功的情况下，其实和lock()是一样的，也会触发锁续期：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979113544-fd5fd678-27b0-4ee8-af1b-bb8e82b6cf5b-20210923224950350.png" alt="img"></p><p>如果你不希望触发锁续期，可以像lock(leaseTime, unit)一样指定过期时间，还可以指定加锁失败后等待多久：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLockSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"bravo1988_distributed_lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 基本等同于lock()，加锁成功也【会自动锁续期】，但获锁失败【立即返回false】，交给调用者判断是否阻塞或放弃</span>    lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 加锁成功仍然【会自动锁续期】，但获锁失败【会等待10秒】，看看这10秒内当前锁是否释放，如果是否则尝试加锁</span>    lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 加锁成功【不会锁续期】，加锁失败【会等待10秒】，看看这10秒内当前锁是否释放，如果是否则尝试加锁</span>    lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意哈，只传两个参数时，那个time其实是传给waitTime的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979480581-3f3ecda4-159e-475a-80d3-9854b1affea3-20210923225001508.png" alt="img"></p><p>我们之前操作的都是leaseTime，此时还是-1，也就是说如果加锁成功，还是会锁续期。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979506461-ae56c20c-6a92-44be-ac30-0944c8caaa47-20210923225007411.png" alt="img"></p><p>那waitTime是用来控制什么的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1605979722684-793f715f-e2ed-498f-98e1-68b8d69519e8-20210923225013679.png" alt="img"></p><p>简而言之：</p><ul><li>tryLock()加锁失败会立即返回false，而加了waitTime可以手动指定阻塞等待的时间（等一等，万一行呢）</li><li>leaseTime的作用没变，控制的是加锁成功后要不要续期</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606183066878-ce4cc7de-8cc1-4dd1-995a-b663df428550-20210923225020644.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612490364124-289ef177-9b03-4cc0-9168-f6270728cff9-20210923225025657.jpeg" alt="img"></p><p>至此，分布式锁章节暂时告一段段落。大家有兴趣的话，可以把上一篇花里胡哨的定时任务用Redisson改写，去掉Redis Message Queue（但定时任务最好还是用xxl-job等）。</p><p>Redisson的具体使用方法可以参考尚硅谷雷丰阳老师的讲解：</p><p><a href="https://www.bilibili.com/video/BV18a4y1L7nv?p=57">https://www.bilibili.com/video/BV18a4y1L7nv?p=57</a></p><h1 id="Redisson分布式锁的缺陷"><a href="#Redisson分布式锁的缺陷" class="headerlink" title="Redisson分布式锁的缺陷"></a>Redisson分布式锁的缺陷</h1><p>在哨兵模式或者主从模式下，如果master实例宕机，可能导致多个节点同时完成加锁。</p><p>以主从模式为例，由于所有的写操作都是先在master上进行，然后再同步给各个slave节点，所以master与各个slave节点之间的数据具有一定的延迟性。对于Redisson分布式锁而言，比如客户端刚对master写入Redisson锁，然后master异步复制给各个slave节点，但这个过程中master节点宕机了，其中一个slave节点经过选举变成了master节点，好巧不巧，这个slave还没同步到Reddison锁，所以其他客户端可能再次加锁。</p><p>具体情况，大家可以百度看看，解决方案也比较多。</p><p>还是那句话，但凡涉及到分布式，都没那么简单。有时引入一个解决方案后，我们不得不面对另一个问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式锁" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Redis分布式锁(中)</title>
    <link href="http://example.com/2020/10/17/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%AD)/"/>
    <id>http://example.com/2020/10/17/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%AD)/</id>
    <published>2020-10-17T15:01:56.000Z</published>
    <updated>2021-09-24T02:38:54.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Demo构思"><a href="#Demo构思" class="headerlink" title="Demo构思"></a>Demo构思</h1><p>在我看来，同样需要使用锁，动机可能完全相反：</p><ul><li>在保证线程安全的前提下，尽量让所有线程都执行成功</li><li>在保证线程安全的前提下，只让一个线程执行成功</li></ul><p>前者适用于秒杀等场景。作为商家，当然希望在不发生线程安全问题的前提下，让每一个订单都生效，直到商品售罄。此时分布式锁的写法可以是<strong>“不断重试”</strong>或<strong>“阻塞等待”</strong>，即：递归或while true循环尝试获取、阻塞等待。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604506622183-fa1bd017-75eb-485a-beed-866826fda0a8-20210923221540849.png" alt="img"></p><p>而后者适用于分布式系统或多节点项目的定时任务，比如同一份代码部署在A、B两台服务器上，而数据库共用同一个。如果不做限制，那么在同一时刻，两台服务器都会去拉取列表执行，会发生任务重复执行的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604217589786-b289e306-b9c9-4109-8dcc-9c444b5d4354-20210923221547128.png" alt="img"></p><p>此时可以考虑使用分布式锁，在cron触发的时刻只允许一个线程去往数据库拉取任务：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604217793953-9468293c-633e-49dc-9020-c69e34cb3b3e-20210923221555357.png" alt="img"></p><p>在实现Redis分布式锁控制定时任务唯一性的同时，我们引入之前的Redis消息队列。注意，这与Redis分布式锁本身无关，就是顺便复习一遍Redis消息队列而已，大家可以只实现Redis分布式锁+定时任务的部分。</p><p>整个Demo的结构大致如图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604218829172-5ce20fc4-99d0-4a26-9b62-053c240660bd-20210923221600743.png" alt="img"></p><p>当然，实际项目中一般是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604489189715-299c40b4-85c2-47c7-9bc4-75aeee053a45-20210923221605971.png" alt="img"></p><h1 id="分布式锁为什么难设计？"><a href="#分布式锁为什么难设计？" class="headerlink" title="分布式锁为什么难设计？"></a>分布式锁为什么难设计？</h1><p>首先，要和大家说一下，但凡牵涉到分布式的处理，没有一个是简单的，上面的Demo设计也不过是玩具，用来启发 大家的思路。</p><p>为什么要把Demo设计得这么复杂呢？哈哈，因为这是我在上一家公司自己设计的，遇到了很多坑…拿出来自嘲一番，与各位共勉。</p><p>我当时的设计思路是：</p><p>由于小公司没有用什么Elastic-Job啥的，就是很普通的多节点部署。为了避免任务重复执行，我想设计一个分布式锁。但因为当时根本不知道Redisson，所以就自己百度了Redis实现分布式锁的方式，然后依葫芦画瓢自己手写了一个 。</p><p>但我写完Redis分布式锁后，在实际测试过程中发现还需要考虑锁的失效时间…</p><p>这里有两个问题：</p><ul><li>为什么要设置锁的过期时间？</li><li>锁的过期时间设置多久合适？</li></ul><p>最简单的实现方案是这样的，一般没问题：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604506681868-7e03eae9-f974-481b-be00-d32180cd2fe2-20210923221614779.png" alt="img"></p><p>但极端的情况下（项目在任务进行时重启或意外宕机），可能当前任务来不及解锁就挂了（死锁），那么下一个任务就会一直被锁在方法外等待。就好比厕所里有人被熏晕了，没法开门，而外面的人又进不去…</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604506732285-dedfe3a9-bbcd-422f-bc35-fe215bbf0035-20210923221619771.png" alt="img"></p><p>此时需要装一个自动解锁的门，到时间自动开门，也就是要给锁设置一个过期时间。但紧接着又会有第二个问题：锁的失效时间设多长合适？</p><p><strong>很难定。</strong></p><p>因为随着项目的发展，<strong>定时任务的执行时间很可能是变化的。</strong></p><p>如果设置时间过长，极端点，定为365天。假设任务正常执行，比如10分钟就结束，那么线程继续往下就会执行unLock()主动解锁。但万一和上面一样宕机了，那么这个锁就要等365天后才解开。注意，宕机可不像JVM异常，它压根不会去执行finally里的unLock()。这种情况好比有个人在厕所里上大号直接掉坑里了，而自动门默认365天打开…所以，锁过期时间设置过长的坏处，本质是一旦发生宕机来不及解锁，那么过期时间越长，影响面越广，会导致其他操作阻滞。</p><p>如果设置时间过短，上一个人还没拉完，门就“咔嚓”一声开了，尴尬不，重复执行了。</p><p>终上所述，我当时之所以设计得这么复杂，就是想尽量缩短任务执行的时间，让它尽可能短（拉取后直接丢给队列，自己不处理），这样锁的时间一般设置30分钟就没啥问题。另外，对于死锁问题，我当时没有考虑宕机的情况，只考虑了意外重启…问题还有很多，文末会再总结。</p><p>请大家阅读下面代码时思考两个问题：</p><ul><li>Demo如何处理锁的过期时间</li><li>Demo如何防止死锁</li></ul><h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><p>新建一个空的SpringBoot项目。</p><p>拷贝下方代码，构建工程：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604495698917-9216d65d-baeb-4c25-8eda-4bc3adc0b593-20210923221627242.png" alt="img"></p><p>构建完以后，拷贝一份，修改端口号为8081，避免和原先的冲突</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604232665683-4d39ad7a-58f0-4bec-b043-d2e67eb68e7b-20210923221633686.png" alt="img"></p><h2 id="统一管理Redis-Key：RedisKeyConst"><a href="#统一管理Redis-Key：RedisKeyConst" class="headerlink" title="统一管理Redis Key：RedisKeyConst"></a>统一管理Redis Key：RedisKeyConst</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 统一管理Redis Key * * @author qiyu */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">RedisKeyConst</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 分布式锁的KEY     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> RESUME_PULL_TASK_LOCK <span class="token operator">=</span> <span class="token string">"resume_pull_task_lock"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 简历异步解析任务队列     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> RESUME_PARSE_TASK_QUEUE <span class="token operator">=</span> <span class="token string">"resume_parse_task_queue"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Redis消息队列：RedisMessageQueueConsumer"><a href="#Redis消息队列：RedisMessageQueueConsumer" class="headerlink" title="Redis消息队列：RedisMessageQueueConsumer"></a>Redis消息队列：RedisMessageQueueConsumer</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 消费者，异步获取简历解析结果并存入数据库 * * @author qiyu */</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisMessageQueueConsumer</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisService</span> redisService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">AsyncResumeParser</span> asyncResumeParser<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">ObjectMapper</span> objectMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">ContextRefreshedEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"开始监听RedisMessageQueue..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 大循环，不断监听队列任务（阻塞式）</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 阻塞监听</span>                <span class="token class-name">ResumeCollectionDTO</span> resumeCollectionDTO <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ResumeCollectionDTO</span><span class="token punctuation">)</span> redisService<span class="token punctuation">.</span><span class="token function">popQueue</span><span class="token punctuation">(</span><span class="token class-name">RedisKeyConst</span><span class="token punctuation">.</span>RESUME_PARSE_TASK_QUEUE<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>resumeCollectionDTO <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> rePullCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> retryCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"从队列中取出:&#123;&#125;"</span><span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">">>>>>>>>>>>>>>>>>>>开始拉取简历:&#123;&#125;"</span><span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">Long</span> asyncPredictId <span class="token operator">=</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getAsyncPredictId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 小循环，针对每一个任务多次调用第三方接口，直到获取最终结果或丢弃任务</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                            <span class="token class-name">PredictResult</span> result <span class="token operator">=</span> asyncResumeParser<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span>asyncPredictId<span class="token punctuation">)</span><span class="token punctuation">;</span>                            rePullCount<span class="token operator">++</span><span class="token punctuation">;</span>                            <span class="token comment">// 如果已经解析完毕</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 保存数据库</span>                                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"简历:&#123;&#125;解析成功"</span><span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"resultJson:&#123;&#125;"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getResultJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token class-name">ResumeCollectionDO</span> resumeCollectionDO <span class="token operator">=</span> objectMapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getResultJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ResumeCollectionDO</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;保存简历:&#123;&#125;到数据库"</span><span class="token punctuation">,</span> resumeCollectionDO<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">// 归零</span>                                    rePullCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                    retryCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                    <span class="token function">discardTask</span><span class="token punctuation">(</span>resumeCollectionDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;保存简历失败，丢弃任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    rePullCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                    retryCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                                <span class="token punctuation">&#125;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token comment">// 远程服务还未解析完毕，重试</span>                            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rePullCount <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                        <span class="token comment">// 前3次重试，时间为1s间隔</span>                                        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"简历:&#123;&#125;尚未解析完毕, 准备进行第&#123;&#125;次重试, 停顿1s后进行"</span><span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rePullCount<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rePullCount <span class="token operator">></span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> rePullCount <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                        <span class="token comment">// 说明任务比较耗时，加长等待时间</span>                                        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"简历:&#123;&#125;尚未解析完毕, 准备进行第&#123;&#125;次重试, 停顿2s后进行"</span><span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rePullCount<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rePullCount <span class="token operator">></span> <span class="token number">6</span> <span class="token operator">&amp;&amp;</span> rePullCount <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                        <span class="token comment">// 说明任务比较耗时，加长等待时间</span>                                        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"简历:&#123;&#125;尚未解析完毕, 准备进行第&#123;&#125;次重试, 停顿3s后进行"</span><span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rePullCount<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                        <span class="token function">discardTask</span><span class="token punctuation">(</span>resumeCollectionDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;多次拉取仍未得到结果, 丢弃简历:&#123;&#125;"</span><span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                        retryCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                        rePullCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                        <span class="token keyword">break</span><span class="token punctuation">;</span>                                    <span class="token punctuation">&#125;</span>                                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                    <span class="token function">discardTask</span><span class="token punctuation">(</span>resumeCollectionDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;任务中断异常, 简历:&#123;&#125;"</span><span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    rePullCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                    retryCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                                <span class="token punctuation">&#125;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>retryCount <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token function">discardTask</span><span class="token punctuation">(</span>resumeCollectionDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>                                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;简历:&#123;&#125;重试&#123;&#125;次后放弃, rePullCount:&#123;&#125;, retryCount:&#123;&#125;"</span><span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> retryCount<span class="token punctuation">,</span> rePullCount<span class="token punctuation">,</span> retryCount<span class="token punctuation">)</span><span class="token punctuation">;</span>                                rePullCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                retryCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            retryCount<span class="token operator">++</span><span class="token punctuation">;</span>                            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"简历:&#123;&#125;远程调用异常, 准备进行第&#123;&#125;次重试..."</span><span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> retryCount<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"break......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">discardTask</span><span class="token punctuation">(</span><span class="token class-name">ResumeCollectionDTO</span> task<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 根据asyncPredictId删除任务...</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"丢弃任务:&#123;&#125;..."</span><span class="token punctuation">,</span> task<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实体类：DO-DTO"><a href="#实体类：DO-DTO" class="headerlink" title="实体类：DO+DTO"></a>实体类：DO+DTO</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResumeCollectionDO</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 简历id     */</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token comment">/**     * 简历名称     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResumeCollectionDTO</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 简历id     */</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token comment">/**     * 异步解析id，稍后根据id可获取最终解析结果     */</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> asyncPredictId<span class="token punctuation">;</span>    <span class="token comment">/**     * 简历名称     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分布式锁：RedisService"><a href="#分布式锁：RedisService" class="headerlink" title="分布式锁：RedisService"></a>分布式锁：RedisService</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RedisService</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 向队列插入消息     *     * @param queue 自定义队列名称     * @param obj   要存入的消息     */</span>    <span class="token keyword">void</span> <span class="token function">pushQueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> queue<span class="token punctuation">,</span> <span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 从队列取出消息     *     * @param queue    自定义队列名称     * @param timeout  最长阻塞等待时间     * @param timeUnit 时间单位     * @return     */</span>    <span class="token class-name">Object</span> <span class="token function">popQueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> queue<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> timeUnit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 尝试上锁     *     * @param lockKey     * @param value     * @param expireTime     * @param timeUnit     * @return     */</span>    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> lockKey<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> expireTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> timeUnit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 根据MACHINE_ID解锁（只能解自己的）     *     * @param lockKey     * @param value     * @return     */</span>    <span class="token keyword">boolean</span> <span class="token function">unLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> lockKey<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 释放锁，不管是不是自己的     *     * @param lockKey     * @param value     * @return     */</span>    <span class="token keyword">boolean</span> <span class="token function">releaseLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> lockKey<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">RedisService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>    <span class="token comment">/**     * 向队列插入消息     *     * @param queue 自定义队列名称     * @param obj   要存入的消息     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pushQueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> queue<span class="token punctuation">,</span> <span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">leftPush</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 从队列取出消息     *     * @param queue    自定义队列名称     * @param timeout  最长阻塞等待时间     * @param timeUnit 时间单位     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">popQueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> queue<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> timeUnit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPop</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> timeUnit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 尝试上锁     *     * @param lockKey     * @param value     * @param expireTime     * @param timeUnit     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> lockKey<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> expireTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> timeUnit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">.</span>TRUE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> expireTime<span class="token punctuation">,</span> timeUnit<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 根据MACHINE_ID解锁（只能解自己的）     *     * @param lockKey     * @param value     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">unLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> lockKey<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> machineId <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>machineId<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> machineId<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 释放锁，不管是不是自己的     *     * @param lockKey     * @param value     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">releaseLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> lockKey<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Boolean</span> delete <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">.</span>TRUE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>delete<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Spring启动，节点:&#123;&#125;成功释放上次简历汇聚定时任务锁"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定时任务：ResumeCollectionTask"><a href="#定时任务：ResumeCollectionTask" class="headerlink" title="定时任务：ResumeCollectionTask"></a>定时任务：ResumeCollectionTask</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@EnableScheduling</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResumeCollectionTask</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 当这份代码被部署到不同的服务器，启动时为每台机器分配一个唯一的机器ID     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MACHINE_ID <span class="token operator">=</span> <span class="token class-name">IdUtil</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisService</span> redisService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">AsyncResumeParser</span> asyncResumeParser<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>cron <span class="token operator">=</span> <span class="token string">"0 */1 * * * ?"</span><span class="token punctuation">)</span><span class="token comment">//    @Scheduled(fixedDelay = 60 * 1000L)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">resumeSchedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 尝试上锁，返回true或false，锁的过期时间设置为10分钟（实际要根据项目调整，这也是自己实现Redis分布式锁的难点之一）</span>        <span class="token keyword">boolean</span> lock <span class="token operator">=</span> redisService<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">RedisKeyConst</span><span class="token punctuation">.</span>RESUME_PULL_TASK_LOCK<span class="token punctuation">,</span> MACHINE_ID<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果当前节点成功获取锁，那么整个系统只允许当前程序去MySQL拉取待执行任务</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"节点:&#123;&#125;获取锁成功，定时任务启动"</span><span class="token punctuation">,</span> MACHINE_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token function">collectResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"定时任务异常:"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                redisService<span class="token punctuation">.</span><span class="token function">unLock</span><span class="token punctuation">(</span><span class="token class-name">RedisKeyConst</span><span class="token punctuation">.</span>RESUME_PULL_TASK_LOCK<span class="token punctuation">,</span> MACHINE_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"节点:&#123;&#125;释放锁，定时任务结束"</span><span class="token punctuation">,</span> MACHINE_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"节点:&#123;&#125;获取锁失败，放弃定时任务"</span><span class="token punctuation">,</span> MACHINE_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 任务主体：     * 1.从数据库拉取符合条件的HR邮箱     * 2.从HR邮箱拉取附件简历     * 3.调用远程服务异步解析简历     * 4.插入待处理任务到数据库，作为记录留存     * 5.把待处理任务的id丢到Redis Message Queue，让Consumer去异步处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">collectResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 跳过1、2两步，假设已经拉取到简历</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"节点:&#123;&#125;从数据库拉取任务简历"</span><span class="token punctuation">,</span> MACHINE_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ResumeCollectionDO</span><span class="token punctuation">></span></span> resumeCollectionList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        resumeCollectionList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ResumeCollectionDO</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> <span class="token string">"张三的简历.pdf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        resumeCollectionList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ResumeCollectionDO</span><span class="token punctuation">(</span><span class="token number">2L</span><span class="token punctuation">,</span> <span class="token string">"李四的简历.html"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        resumeCollectionList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ResumeCollectionDO</span><span class="token punctuation">(</span><span class="token number">3L</span><span class="token punctuation">,</span> <span class="token string">"王五的简历.doc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 模拟数据库查询耗时</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"提交任务到消息队列:&#123;&#125;"</span><span class="token punctuation">,</span> resumeCollectionList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">ResumeCollectionDO</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ResumeCollectionDO</span> resumeCollectionDO <span class="token operator">:</span> resumeCollectionList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 上传简历异步解析，得到异步结果id</span>            <span class="token class-name">Long</span> asyncPredictId <span class="token operator">=</span> asyncResumeParser<span class="token punctuation">.</span><span class="token function">asyncParse</span><span class="token punctuation">(</span>resumeCollectionDO<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 把任务插入数据库</span>            <span class="token comment">// 略...</span>            <span class="token comment">// 把任务丢到Redis Message Queue</span>            <span class="token class-name">ResumeCollectionDTO</span> resumeCollectionDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResumeCollectionDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>resumeCollectionDO<span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>            resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">setAsyncPredictId</span><span class="token punctuation">(</span>asyncPredictId<span class="token punctuation">)</span><span class="token punctuation">;</span>            redisService<span class="token punctuation">.</span><span class="token function">pushQueue</span><span class="token punctuation">(</span><span class="token class-name">RedisKeyConst</span><span class="token punctuation">.</span>RESUME_PARSE_TASK_QUEUE<span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 项目重启后先尝试删除之前的锁（如果存在），防止死锁等待     *     * @param event the event to respond to     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">ContextRefreshedEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        redisService<span class="token punctuation">.</span><span class="token function">releaseLock</span><span class="token punctuation">(</span><span class="token class-name">RedisKeyConst</span><span class="token punctuation">.</span>RESUME_PULL_TASK_LOCK<span class="token punctuation">,</span> MACHINE_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模拟第三方服务（异步）"><a href="#模拟第三方服务（异步）" class="headerlink" title="模拟第三方服务（异步）"></a>模拟第三方服务（异步）</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 第三方提供给的简历解析服务 * * @author qiyu */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncResumeParser</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">ObjectMapper</span> objectMapper<span class="token punctuation">;</span>    <span class="token comment">/**     * 模拟分配异步任务结果id，不用深究，没啥意义，反正每个任务都会得到一个id，稍后根据id返回最终解析结果     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> ASYNC_RESULT_ID <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 解析结果     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 模拟第三方服务异步解析，返回解析结果     *     * @param resumeCollectionDO     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">Long</span> <span class="token function">asyncParse</span><span class="token punctuation">(</span><span class="token class-name">ResumeCollectionDO</span> resumeCollectionDO<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> asyncPredictId <span class="token operator">=</span> ASYNC_RESULT_ID<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> resultJson <span class="token operator">=</span> objectMapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>resumeCollectionDO<span class="token punctuation">)</span><span class="token punctuation">;</span>            results<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>asyncPredictId<span class="token punctuation">,</span> resultJson<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> asyncPredictId<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JsonProcessingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 根据异步id返回解析结果，但此时未必已经解析成功     * &lt;p>     * 解析状态     * 0 初始化     * 1 处理中     * 2 调用成功     * 3 调用失败     *     * @param asyncPredictId     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">PredictResult</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token class-name">Long</span> asyncPredictId<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ParseErrorException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 随机模拟异步解析的状态</span>        <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">>=</span> <span class="token number">85</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 模拟解析完成</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> resultJson <span class="token operator">=</span> results<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>asyncPredictId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PredictResult</span><span class="token punctuation">(</span>resultJson<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 模拟解析异常</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ParseErrorException</span><span class="token punctuation">(</span><span class="token string">"简历解析异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 如果时间过短，返回status=1，表示解析中</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PredictResult</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 解析异常 * * @author qiyu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParseErrorException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Constructs a new exception with &#123;@code null&#125; as its detail message.     * The cause is not initialized, and may subsequently be initialized by a     * call to &#123;@link #initCause&#125;.     */</span>    <span class="token keyword">public</span> <span class="token class-name">ParseErrorException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * Constructs a new exception with the specified detail message.  The     * cause is not initialized, and may subsequently be initialized by     * a call to &#123;@link #initCause&#125;.     *     * @param message the detail message. The detail message is saved for     *                later retrieval by the &#123;@link #getMessage()&#125; method.     */</span>    <span class="token keyword">public</span> <span class="token class-name">ParseErrorException</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 第三方返回值 * * @author qiyu */</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PredictResult</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 解析结果     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> resultJson<span class="token punctuation">;</span>    <span class="token comment">/**     * 解析状态     * 0 初始化     * 1 处理中     * 2 调用成功     * 3 调用失败     */</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> status<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模拟异常"><a href="#模拟异常" class="headerlink" title="模拟异常"></a>模拟异常</h2><p><strong>在项目运行过程中，</strong>启动这个测试类的方法，即可观察不一样的现象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">RedisDistributedLockApplicationTests</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisService</span> redisService<span class="token punctuation">;</span>    <span class="token comment">/**     * 作为失败案例（因为不存在777L这个解析任务，AsyncResumeParse.results会返回null）     * 观察RedisMessageQueueConsumer的处理方式     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ResumeCollectionDTO</span> resumeCollectionDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResumeCollectionDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">666L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">setAsyncPredictId</span><span class="token punctuation">(</span><span class="token number">777L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        resumeCollectionDTO<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"测试1号"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        redisService<span class="token punctuation">.</span><span class="token function">pushQueue</span><span class="token punctuation">(</span><span class="token class-name">RedisKeyConst</span><span class="token punctuation">.</span>RESUME_PARSE_TASK_QUEUE<span class="token punctuation">,</span> resumeCollectionDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token comment"># </span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token comment"># </span>    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>啥都不说了，都在<del>jiu</del>代码里了。大家自己拷贝到本地，动手玩一下，加深对Redis锁和Redis消息队列的理解。</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://cloud.video.taobao.com/play/u/432628/p/1/d/hd/e/6/t/1/286252615441.mp4?auth_key=YXBwX2tleT04MDAwMDAwMTImYXV0aF9pbmZvPXsidGltZXN0YW1wRW5jcnlwdGVkIjoiMWUyYjkyMTY4NzMzYmMxMDQ2M2QyNDI5MDlhZWRjZDMifSZkdXJhdGlvbj0mdGltZXN0YW1wPTE2MzI0NTA3Mzc="}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604496815462-e6a559e8-27da-492f-b720-cf3f01e62429-20210923221905040.png" alt="img"></p><p>只有一个定时任务能去数据库拉取任务，到时多节点部署大致是下面这样（redis一般是独立部署的，和节点代码无关）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1606026519366-b528e8be-3cfc-4a9a-a574-8a6ae401b41f-20210923221915282.png" alt="img"></p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>上面展示的代码其实存在很多问题，我们会在下一篇指出并讨论解决方案。</p><p>本文仅提供思路，开阔大家的眼界，<strong>千万别在自己项目中使用！！！！</strong>我当年被这个坑惨了，花里胡哨的，尤其Consumer里一大堆的sleep()，是非常low的！！</p><p><strong>对于异步调用的结果，不要循环等待，</strong>而应该分为几步：</p><ol><li><p>调用异步接口，得到异步结果唯一id</p></li><li><p>将结果id保存到任务表中，作为一个任务</p></li><li><p>启动定时任务，根据id拉取最终结果（如果还没有结果，跳过当前任务，等下一个定时任务处理）</p></li></ol><p>分布式定时任务可以考虑xxl-job或elastic-job，分布式锁推荐使用<a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">redisson</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式锁" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Redis分布式锁(上)</title>
    <link href="http://example.com/2020/10/05/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8A)/"/>
    <id>http://example.com/2020/10/05/%E6%B5%85%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E4%B8%8A)/</id>
    <published>2020-10-05T13:33:26.000Z</published>
    <updated>2021-09-24T02:32:07.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不论面试还是实际工作中，Redis都是避无可避的技术点。在我心里，MySQL和Redis是衡量一个程序员是否“小有所成”的两把标尺。如果他能熟练使用MySQL和Redis，以小化大，充分利用现有资源出色地完成当下需求，说明他已经成长了。</p><p>本篇文章我们一起来探讨Redis分布式锁相关的内容。</p><p>说到锁，大家第一时间想到的应该是synchronized关键字或ReentrantLock，随即想到偏向锁、自旋锁、重量级锁或者CAS甚至AQS。一般来说，我不喜欢一下子引入这么多概念，可能会把问题弄复杂，但为了方便大家理解Redis分布式锁，这里稍微提一下。</p><h1 id="JVM锁"><a href="#JVM锁" class="headerlink" title="JVM锁"></a>JVM锁</h1><p>所谓JVM锁，其实指的是诸如synchronized关键字或者ReentrantLock实现的锁。之所以统称为JVM锁，是因为我们的项目其实都是跑在JVM上的。理论上每一个项目启动后，就对应一片JVM内存，后续运行时数据的生离死别都在这一片土地上。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1620095054769-ca64b8aa-6bd0-4bdc-a4da-cc7e5d181d24-20210924103005529.png" alt="图片.png"></p><h1 id="什么是锁、怎么锁？"><a href="#什么是锁、怎么锁？" class="headerlink" title="什么是锁、怎么锁？"></a>什么是锁、怎么锁？</h1><p>明白了“JVM锁”名字的由来，我们再来聊什么是“锁”，以及怎么“锁”。</p><p>有时候我们很难阐述清楚某个事物<strong>是什么</strong>，但很容易解释它<strong>能干什么</strong>，JVM锁也是这个道理。JVM锁的出现，就是为了解决线程安全问题。所谓线程安全问题，可以简单地理解为数据不一致（与预期不一致）。</p><p>什么时候可能出现线程安全问题呢？</p><p>当同时满足以下三个条件时，才可能引发线程安全问题：</p><ul><li><p>多线程环境</p></li><li><p>有共享数据</p></li><li><p>有多条语句操作共享数据/单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）</p></li></ul><p>比如线程A、B同时对int count进行+1操作（初始值假设为1），在一定的概率下两次操作最终结果可能为2，而不是3。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604203263605-6b838677-f5b4-48cd-9298-2788c694aa15-20210924103020945.png" alt="image.png"></p><p>那么加锁为什么能解决这个问题呢？</p><p>如果不考虑原子性、内存屏障等晦涩的名词，加锁之所以能保证线程安全，核心就是“互斥”。所谓互斥，就是字面意思上的<strong>互</strong>相排<strong>斥</strong>。这里的“互相”是指谁呢？就是多线程之间！</p><p>怎么实现多线程之间的互斥呢？</p><p>引入“中间人”即可。</p><p>注意，这是个非常简单且伟大的思想。在编程世界中，通过引入“中介”最终解决问题的案例不胜枚举，包括但不限于Spring、MQ。在码农之间，甚至流传着一句话：没有什么问题是引入中间层解决不了的。</p><p>而JVM锁其实就是线程和线程彼此的“中间人”，多个线程在操作加锁数据前都必须征求“中间人”的同意：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612488996804-3ea7c557-98ae-4d76-aa5a-5933c1fe6026-20210924103037552.png" alt="图片.png"></p><p>锁在这里扮演的角色其实就是守门员，是<strong>唯一</strong>的访问入口，所有的线程都要经过它的拷问。在JDK中，锁的实现机制最常见的就是两种，分别是两个派系：</p><ul><li>synchronized关键字</li><li>AQS</li></ul><p>个人觉得synchronized关键字要比AQS难理解，但AQS的源码比较抽象。这里简要介绍一下Java对象内存结构和synchronized关键字的实现原理。</p><h1 id="Java对象内存结构"><a href="#Java对象内存结构" class="headerlink" title="Java对象内存结构"></a>Java对象内存结构</h1><p>要了解synchronized关键字，首先要知道Java对象的内存结构。强调一遍，是Java<strong>对象的内存结构</strong>。</p><p>它的存在仿佛向我们抛出一个疑问：如果有机会解剖一个Java对象，我们能看到什么？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604205724123-0a6ab812-080e-4626-8a35-db6b6a41bd04-20210924103057869.png" alt="image.png"></p><p>右上图画了两个对象，只看其中一个即可。我们可以观察到，Java对象内存结构大致分为几块：</p><ul><li><p>Mark Word（锁相关）</p></li><li><p>元数据指针（class pointer，指向当前实例所属的类）</p></li><li><p>实例数据（instance data，我们平常看到的仅仅是这一块）</p></li><li><p>对齐（padding，和内存对齐有关）</p></li></ul><p>如果此前没有了解过Java对象的内存结构，你可能会感到吃惊：天呐，我还以为Java对象就只有属性和方法！</p><p>是的，我们最熟悉实例数据这一块，而且<strong>以为只有这一块。</strong>也正是这个观念的限制，导致一部分初学者很难理解synchronized。比如初学者经常会疑惑：</p><ul><li><p>为什么任何对象都可以作为锁？</p></li><li><p>Object对象锁和类锁有什么区别？</p></li><li><p>synchronized修饰的普通方法使用的锁是什么？</p></li><li><p>synchronized修饰的静态方法使用的锁是什么？</p></li></ul><p>这一切的一切，其实都可以在Java对象内存结构中的Mark Word找到答案：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604208962907-39530cce-67a1-41ff-9855-13f3297d2c10-20210924103109319.png" alt="image.png"></p><p>很多同学可能是第一次看到这幅图，会感到有点懵，没关系，我也很头大，都一样的。</p><p>Mark Word包含的信息还是蛮多的，但这里我们只需要简单地把它理解为<strong>记录锁信息</strong>的标记即可。上图展示的是32位虚拟机下的Java对象内存，如果你仔细数一数，会发现全部bit加起来刚好是32位。64位虚拟机下的结构大同小异，就不特别介绍。</p><p>Mark Word从有限的32bit中划分出2bit，专门用作锁标志位，通俗地讲就是标记当前锁的状态。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1620095815528-242114c7-277f-4777-ad33-9e38d4c62c27.png" alt="img"></p><p>正因为每个Java对象都有Mark Word，而Mark Word能标记锁状态（把自己当做锁），所以Java中任意对象都可以作为synchronized的锁：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">synchronized</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>所谓的this锁就是当前对象，而Class锁就是当前对象所属类的Class对象，本质也是Java对象。synchronized修饰的普通方法底层使用当前对象作为锁，synchronized修饰的静态方法底层使用Class对象作为锁。</strong></p><p>但如果要保证多个线程互斥，最基本的条件是它们<strong>使用同一把锁：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612489131320-62cceb64-2ba8-431d-985f-03cbe8f42df2-20210923220222012.png" alt="img"></p><p>对同一份数据加两把不同的锁是没有意义的，实际开发时应该注意避免下面的写法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 操作count</span><span class="token punctuation">&#125;</span><span class="token keyword">synchronized</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 操作count</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 操作count</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 操作count</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="synchronized与锁升级"><a href="#synchronized与锁升级" class="headerlink" title="synchronized与锁升级"></a>synchronized与锁升级</h1><p>大致介绍完Java对象内存结构后，我们再来解决一个新疑问：</p><p>为什么需要标记锁的状态呢？是否意味着synchronized锁有多种状态呢？</p><p>在JDK早期版本中，synchronized关键字的实现是直接基于重量级锁的。只要我们在代码中使用了synchronized，JVM就会向操作系统申请锁资源（不论当前是否真的是多线程环境），而向操作系统申请锁是比较耗费资源的，其中涉及到用户态和内核态的切换等，总之就是比较费事，且性能不高。</p><p>JDK为了解决JVM锁性能低下的问题，引入了ReentrantLock，它基于CAS+AQS，类似自旋锁。自旋的意思就是，在发生锁竞争的时候，未争取到锁的线程会在门外采取自旋的方式等待锁的释放，谁抢到谁执行。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1612489200273-6e3caa00-7625-42b7-9b03-e2a87ba09633-20210923220236604.png" alt="img"></p><p>自旋锁的好处是，不需要兴师动众地切换到内核态申请操作系统的重量级锁，在JVM层面即可实现自旋等待。但世界上并没有百利而无一害的灵丹妙药，CAS自旋虽然避免了状态切换等复杂操作，却要耗费部分CPU资源，尤其当可预计上锁的时间较长且并发较高的情况下，会造成几百上千个线程同时自旋，极大增加CPU的负担。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604463084016-ce0704e8-55d9-4035-9dda-15778b125560-20210923220242536.png" alt="img"></p><p>synchronized毕竟JDK亲儿子，所以大概在JDK1.6或者更早期的版本，官方对synchronized做了优化，提出了“锁升级”的概念，把synchronized的锁划分为多个状态，也就是上图中提到的：</p><ul><li><p>无锁</p></li><li><p>偏向锁</p></li><li><p>轻量级锁（自旋锁）</p></li><li><p>重量级锁</p></li></ul><p>无锁就是一个Java对象刚new出来的状态。当这个对象第一次被一个线程访问时，该线程会把自己的线程id“贴到”它的头上（Mark Word中部分位数被修改），表示“你是我的”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604211050450-4463b6fc-3864-4822-b6a5-e8ed98283b7c-20210924103138330.png" alt="image.png"></p><p>此时是不存在锁竞争的，所以并不会有什么阻塞或等待。</p><p>为什么要设计“偏向锁”这个状态呢？</p><p>大家回忆一下，项目中并发的场景真的这么多吗？并没有吧。大部分项目的大部分时候，某个变量都是单个线程在执行，此时直接向操作系统申请重量级锁显然没有必要，因为根本不会发生线程安全问题。</p><p>而一旦发生锁竞争时，synchronized便会在一定条件下升级为轻量级锁，可以理解为一种自旋锁，具体自旋多少次以及何时放弃自旋，JDK也有一套相关的控制机制，大家可以自行了解。</p><p>同样是自旋，所以synchronized也会遇到ReentrantLock的问题：如果上锁时间长且自旋线程多，又该如何？</p><p>此时就会再次升级，变成传统意义上的重量级锁，本质上操作系统会维护一个队列，用空间换时间，避免多个线程同时自旋等待耗费CPU性能，等到上一个线程结束时唤醒等待的线程参与新一轮的锁竞争即可。</p><p>拓展阅读（没太大必要）：</p><p><a href="https://www.cnblogs.com/kubidemanong/p/9520071.html">线程安全(中)–彻底搞懂synchronized(从偏向锁到重量级锁)</a></p><p><a href="https://www.jianshu.com/p/4758852cbff4">死磕Synchronized底层实现–偏向锁</a></p><h1 id="synchronized案例"><a href="#synchronized案例" class="headerlink" title="synchronized案例"></a>synchronized案例</h1><p>让我们一起来看几个案例，加深对synchronized的理解。</p><ul><li>同一个类中的synchronized method m1和method m2互斥吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290796058-a3bfc5f5-f6be-4543-8796-a2b170d36464-20210923220322058.png" alt="img"></p><p>t1线程执行m1方法时要去读this对象锁，但是t2线程并不需要读锁，两者各管各的，没有交集（不共用一把锁）</p><ul><li>同一个类中synchronized method m1中可以调用synchronized method m2吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290844351-21fa8f5e-80ac-400f-8033-88aad2dd6960-20210923220329432.png" alt="img"></p><p>synchronized是可重入锁，可以粗浅地理解为同一个线程在已经持有该锁的情况下，可以再次获取锁，并且会在某个状态量上做+1操作（ReentrantLock也支持重入）</p><ul><li>子类同步方法synchronized method m可以调用父类的synchronized method m吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290893998-8ba4a1e0-48a4-4789-9856-b5de2539ff7c-20210923220336563.png" alt="img"></p><p>子类对象初始化前，会调用父类构造方法，在结构上相当于包裹了一个父类对象，用的都是this锁对象</p><ul><li>静态同步方法和非静态同步方法互斥吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604290932744-f6d63490-b46a-4c0e-b939-c0a54764f6be-20210923220344834.png" alt="img"></p><p>各玩各的，不是同一把锁，谈不上互斥</p><h1 id="Redis分布式锁的概念"><a href="#Redis分布式锁的概念" class="headerlink" title="Redis分布式锁的概念"></a>Redis分布式锁的概念</h1><p>谈到Redis分布式锁，总是会有这样或那样的疑问：</p><ul><li><p>什么是分布式</p></li><li><p>什么是分布式锁</p></li><li><p>为什么需要分布式锁</p></li><li><p>Redis如何实现分布式锁</p></li></ul><p>前3个问题其实可以一起回答，至于Redis如何实现分布式锁，我们放在下一篇。</p><p>什么是分布式？这是个很复杂的概念，我也很难说准确，所以干脆画个图，大家各花入各眼吧：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604211829338-3b84a9f8-b551-41ba-a83e-1428ea401e13-20210923220351203.png" alt="img"></p><p>分布式有个很显著的特点是，Service A和Service B极有可能并不是部署在同一个服务器上，所以它们也不共享同一片JVM内存。<strong>而上面介绍了，要想实现线程互斥，必须保证所有访问的线程使用的是同一把锁（JVM锁此时就无法保证互斥）。</strong></p><p>对于分布式项目，有多少台服务器就有多少片JVM内存，即使每片内存中各设置一把“独一无二”的锁，从整体来看项目中的锁就不是唯一的。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604292366085-77c2f620-9dce-417e-a714-e094c690b934-20210923220359938.png" alt="img"></p><p>此时，<strong>如何保证每一个JVM上的线程共用一把锁呢？</strong></p><p>答案是：把锁抽取出来，让线程们在<strong>同一片内存</strong>相遇。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1604292683347-9f095018-1aa9-464d-848e-f26b2ae69a52-20210923220408318.png" alt="img"></p><p>但锁是不能凭空存在的，本质还是要在内存中，此时可以使用Redis缓存作为锁的宿主环境，这就是Redis能构造分布式锁的原因。</p><h1 id="Redis的锁长啥样"><a href="#Redis的锁长啥样" class="headerlink" title="Redis的锁长啥样"></a>Redis的锁长啥样</h1><p>synchronized关键字和ReentrantLock，它们都是实实在在已经实现的锁，而且还有标志位啥的。但Redis就是一个内存…怎么作为锁呢?</p><p>有一点大家要明确，Redis之所以能用来做分布式锁，肯定不只是因为它是一片内存，否则JVM本身也占有内存，为什么无法自己实现分布式锁呢？</p><p>我个人的理解是，要想自定义一个分布式锁，必须至少满足几个条件：</p><ul><li><p>多进程可见（独立于多节点系统之外的一片内存）</p></li><li><p>互斥（可以通过单线程，或者某种顺序机制）</p></li><li><p>可重入</p></li></ul><p>还有个条件，默认要支持：只有持有这把锁的客户端才能解锁</p><p>以上三点Redis都能满足。在上面三个条件下，其实怎么设计锁，完全取决于个人如何定义锁。就好比现实生活中，通常我们理解的锁就是有个钥匙孔、需要插入钥匙的金属小物件。然而锁的形态可不止这么一种，随着科技的发展，什么指纹锁、虹膜锁层出不穷，但归根结底它们之所以被称为“锁”，是因为都保证了“互斥”（我行，你不行）。</p><p>如果我们能设计一种逻辑，它能造成某个场景下的“互斥事件”，那么它就可以被称为“锁”。比如，某家很有名的网红店，一天只接待一位客人。门口没有营业员，就放了一台取号机，里面放了一张票。你如果去迟了，票就没了，你就进不了这家店。这个场景下，没票的顾客进不去，被锁在门外。此时，取票机造成了“互斥事件”，那么它就可以叫做“锁”。</p><p>而Redis提供了setnx指令，如果某个key当前不存在则设置成功并返回true，否则不再重复设置，直接返回false。这不就是编程界的取号机吗？当然，实际用到的命令可不止这一个，具体如何实现，请看下一篇~</p><p>这一篇从JVM锁聊到了Redis分布式锁，还介绍了Java的对象内存结构及synchronized底层的原理，相信大家对“锁”已经有了自己的感性认识。下一篇我们将通过分布式定时任务的案例介绍Redis分布式锁的使用场景。</p><p>下次见。</p><h1 id="思考一个问题：分布式系统是否一定要分布式锁？"><a href="#思考一个问题：分布式系统是否一定要分布式锁？" class="headerlink" title="思考一个问题：分布式系统是否一定要分布式锁？"></a>思考一个问题：分布式系统是否一定要分布式锁？</h1><p>分布式系统如果要加锁是否一定要使用分布式锁呢？</p><p>可能未必。</p><p>如果你需要的是写锁，那么可能确实需要分布式锁保证单一线程处理数据，而如果是为了防止缓存击穿（热点数据定时失效），那么使用JVM本地锁也没有太大关系。比如某个服务有10个节点，在使用JVM锁的情况下，即使某一时刻每个节点<strong>各自</strong>涌入1000个请求，虽然总共有1w个请求，但最终打到数据库的也只有10个，数据库层面是完全可以抗住这点请求量的，又由于本身是查询，所以不会造成线程安全问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式锁" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://example.com/2020/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2020/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-09-16T15:21:43.000Z</published>
    <updated>2021-09-28T05:43:20.110Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h2><h3 id="1-1-基本术语"><a href="#1-1-基本术语" class="headerlink" title="1.1. 基本术语"></a>1.1. 基本术语</h3><ol><li><strong>结点 （node）</strong> ：网络中的结点可以是计算机，集线器，交换机或路由器等。</li><li><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</li><li><strong>主机（host）</strong> ：连接在因特网上的计算机。</li><li><strong>ISP（Internet Service Provider）</strong> ：因特网服务提供者（提供商）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135211.png" alt="ISP (Internet Service Provider) Definition"></p><ol start="5"><li><strong>IXP（Internet eXchange Point）</strong> ： 互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135226.png" alt="IXP Traffic Levels During the Stratos Skydive — RIPE Labs"></p><p style="text-align:center;font-size:13px;color:gray">https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive</p><ol start="6"><li><strong>RFC(Request For Comments)</strong> ：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</li><li><strong>广域网 WAN（Wide Area Network）</strong> ：任务是通过长距离运送主机发送的数据。</li><li><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</li><li><strong>局域网 LAN（Local Area Network）</strong> ： 学校或企业大多拥有多个互连的局域网。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135238.png" alt="MAN &amp; WMAN | Red de área metropolitana, Redes informaticas, Par trenzado"></p><p style="text-align:center;font-size:13px;color:gray">http://conexionesmanwman.blogspot.com/</p><ol start="10"><li><strong>个人区域网 PAN（Personal Area Network）</strong> ：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135249.png" alt="Advantages and disadvantages of personal area network (PAN) - IT Release"></p><p style="text-align:center;font-size:13px;color:gray">https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/</p><ol start="12"><li><strong>分组（packet ）</strong> ：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</li><li><strong>存储转发（store and forward ）</strong> ：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135301.gif"></p><ol start="14"><li><strong>带宽（bandwidth）</strong> ：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</li><li><strong>吞吐量（throughput ）</strong> ：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</li></ol><h3 id="1-2-重要知识点总结"><a href="#1-2-重要知识点总结" class="headerlink" title="1.2. 重要知识点总结"></a>1.2. 重要知识点总结</h3><ol><li><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></li><li>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</li><li>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</li><li>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</li><li>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</li><li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li><li>按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN，局域网 LAN，个人区域网 PAN。</li><li><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></li><li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</li><li><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135313.png" alt="s"></p><p>下面的内容会介绍计算机网络的五层体系结构：<strong>物理层+数据链路层+网络层（网际层）+运输层+应用层</strong>。</p><h2 id="2-物理层（Physical-Layer）"><a href="#2-物理层（Physical-Layer）" class="headerlink" title="2. 物理层（Physical Layer）"></a>2. 物理层（Physical Layer）</h2><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135327.png" alt="物理层"></p><h3 id="2-1-基本术语"><a href="#2-1-基本术语" class="headerlink" title="2.1. 基本术语"></a>2.1. 基本术语</h3><ol><li><strong>数据（data）</strong> :运送消息的实体。</li><li><strong>信号（signal）</strong> ：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li><li><strong>码元（ code）</strong> ：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li><li><strong>单工（simplex ）</strong> : 只能有一个方向的通信而没有反方向的交互。</li><li><strong>半双工（half duplex ）</strong> ：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li><strong>全双工（full duplex）</strong> : 通信的双方可以同时发送和接收信息。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135336.png"></p><ol start="7"><li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135349.png"></p><ol start="8"><li><strong>奈氏准则</strong> : 在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li><li><strong>香农定理</strong> ：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li><li><strong>基带信号（baseband signal）</strong> : 来自信源的信号。指没有经过调制的数字信号或模拟信号。</li><li><strong>带通（频带）信号（bandpass signal）</strong> ：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li><li><strong>调制（modulation ）</strong> : 对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li><li><strong>信噪比（signal-to-noise ratio ）</strong> : 指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li><li><strong>信道复用（channel multiplexing ）</strong> ：指多个用户共享同一个信道。（并不一定是同时）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135359.png" alt="信道复用技术"></p><ol start="15"><li><strong>比特率（bit rate ）</strong> ：单位时间（每秒）内传送的比特数。</li><li><strong>波特率（baud rate）</strong> ：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</li><li><strong>复用（multiplexing）</strong> ：共享信道的方法。</li><li><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong> ：非对称数字用户线。</li><li><strong>光纤同轴混合网（HFC 网）</strong> :在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</li></ol><h3 id="2-2-重要知识点总结"><a href="#2-2-重要知识点总结" class="headerlink" title="2.2. 重要知识点总结"></a>2.2. 重要知识点总结</h3><ol><li><strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></li><li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li><li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</strong></li><li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li><li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li><li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li><li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li><li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li><li>了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li></ol><h3 id="2-3-补充"><a href="#2-3-补充" class="headerlink" title="2.3. 补充"></a>2.3. 补充</h3><h4 id="2-3-1-物理层主要做啥？"><a href="#2-3-1-物理层主要做啥？" class="headerlink" title="2.3.1. 物理层主要做啥？"></a>2.3.1. 物理层主要做啥？</h4><p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</p><p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p><h4 id="2-3-2-几种常用的信道复用技术"><a href="#2-3-2-几种常用的信道复用技术" class="headerlink" title="2.3.2. 几种常用的信道复用技术"></a>2.3.2. 几种常用的信道复用技术</h4><ol><li><strong>频分复用(FDM)</strong> ：所有用户在同样的时间占用不同的带宽资源。</li><li><strong>时分复用（TDM）</strong> ：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li><li><strong>统计时分复用 (Statistic TDM)</strong> ：改进的时分复用，能够明显提高信道的利用率。</li><li><strong>码分复用(CDM)</strong> ： 用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li><strong>波分复用( WDM)</strong> ：波分复用就是光的频分复用。</li></ol><h4 id="2-3-3-几种常用的宽带接入技术，主要是-ADSL-和-FTTx"><a href="#2-3-3-几种常用的宽带接入技术，主要是-ADSL-和-FTTx" class="headerlink" title="2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx"></a>2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx</h4><p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p><h2 id="3-数据链路层（Data-Link-Layer）"><a href="#3-数据链路层（Data-Link-Layer）" class="headerlink" title="3. 数据链路层（Data Link Layer）"></a>3. 数据链路层（Data Link Layer）</h2><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135410.png" alt="数据链路层"></p><h3 id="3-1-基本术语"><a href="#3-1-基本术语" class="headerlink" title="3.1. 基本术语"></a>3.1. 基本术语</h3><ol><li><strong>链路（link）</strong> ：一个结点到相邻结点的一段物理链路。</li><li><strong>数据链路（data link）</strong> ：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路。</li><li><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong> ：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</li><li><strong>帧（frame）</strong> ：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</li><li><strong>MTU（Maximum Transfer Uint ）</strong> ：最大传送单元。帧的数据部分的的长度上限。</li><li><strong>误码率 BER（Bit Error Rate ）</strong> ：在一段时间内，传输错误的比特占所传输比特总数的比率。</li><li><strong>PPP（Point-to-Point Protocol ）</strong> ：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路层协议。以下是 PPP 帧的示意图：<br><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135422.png" alt="PPP"></li><li><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong> ：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135436.png" alt="ARP (Address Resolution Protocol) explained"></p><ol start="9"><li><strong>网桥（bridge）</strong> ：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</li><li><strong>交换机（switch ）</strong> ：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</li></ol><h3 id="3-2-重要知识点总结"><a href="#3-2-重要知识点总结" class="headerlink" title="3.2. 重要知识点总结"></a>3.2. 重要知识点总结</h3><ol><li>链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li><li>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li><li>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li><li><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</li><li><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li><li>PPPoE 是为宽带上网的主机使用的链路层协议</li><li><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></li><li>计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</li><li>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li><li>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</li><li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li><li>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li></ol><h3 id="3-3-补充"><a href="#3-3-补充" class="headerlink" title="3.3. 补充"></a>3.3. 补充</h3><ol><li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点</li><li>数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></li><li>以太网的 MAC 层硬件地址</li><li>适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</li></ol><h2 id="4-网络层（Network-Layer）"><a href="#4-网络层（Network-Layer）" class="headerlink" title="4. 网络层（Network Layer）"></a>4. 网络层（Network Layer）</h2><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135448.png" alt="网络层"></p><h3 id="4-1-基本术语"><a href="#4-1-基本术语" class="headerlink" title="4.1. 基本术语"></a>4.1. 基本术语</h3><ol><li><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</li><li><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</li><li><strong>ICMP（Internet Control Message Protocol ）</strong> ：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</li><li><strong>子网掩码（subnet mask ）</strong> ：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</li><li><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</li><li><strong>默认路由（default route）</strong> ：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</li><li><strong>路由选择算法（Virtual Circuit）</strong> ：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</li></ol><h3 id="4-2-重要知识点总结"><a href="#4-2-重要知识点总结" class="headerlink" title="4.2. 重要知识点总结"></a>4.2. 重要知识点总结</h3><ol><li><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</strong></li><li>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li><li>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</li><li>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li><li><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送 ARP 请求分组</strong></li><li>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</li><li>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种 ICMP 差错报告报文和 ICMP 询问报文。</li><li><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</li><li><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></li><li>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li></ol><h2 id="5-传输层（Transport-Layer）"><a href="#5-传输层（Transport-Layer）" class="headerlink" title="5. 传输层（Transport Layer）"></a>5. 传输层（Transport Layer）</h2><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135500.png" alt="传输层"></p><h3 id="5-1-基本术语"><a href="#5-1-基本术语" class="headerlink" title="5.1. 基本术语"></a>5.1. 基本术语</h3><ol><li><strong>进程（process）</strong> ：指计算机中正在运行的程序实体。</li><li><strong>应用进程互相通信</strong> ：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</li><li><strong>传输层的复用与分用</strong> ：复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</li><li><strong>TCP（Transmission Control Protocol）</strong> ：传输控制协议。</li><li><strong>UDP（User Datagram Protocol）</strong> ：用户数据报协议。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135511.png" alt="TCP和UDP"></p><ol start="6"><li><strong>端口（port）</strong> ：端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</li><li><strong>停止等待协议（stop-and-wait）</strong> ：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</li><li><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li><li><strong>拥塞控制</strong> ：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li></ol><h3 id="5-2-重要知识点总结"><a href="#5-2-重要知识点总结" class="headerlink" title="5.2. 重要知识点总结"></a>5.2. 重要知识点总结</h3><ol><li><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></li><li><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></li><li>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</li><li><strong>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</strong></li><li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li><li>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</li><li>运输层的端口号分为服务器端使用的端口号（0<del>1023 指派给熟知端口，1024</del>49151 是登记端口号）和客户端暂时使用的端口号（49152~65535）</li><li><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></li><li><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></li><li><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一被通信两端的两个端点所确定。</strong></li><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li><li>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li><li>TCP 报文段的前 20 个字节是固定的，后面有 4n 字节是根据需要增加的选项。因此，TCP 首部的最小长度是 20 字节。</li><li><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></li><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li><li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li><li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li><li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li><li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li><li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li></ol><h3 id="5-3-补充（重要）"><a href="#5-3-补充（重要）" class="headerlink" title="5.3. 补充（重要）"></a>5.3. 补充（重要）</h3><p>以下知识点需要重点关注：</p><ol><li>端口和套接字的意义</li><li>UDP 和 TCP 的区别以及两者的应用场景</li><li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议</li><li>TCP 的滑动窗口，流量控制，拥塞控制和连接管理</li><li>TCP 的三次握手，四次挥手机制</li></ol><h2 id="6-应用层（Application-Layer）"><a href="#6-应用层（Application-Layer）" class="headerlink" title="6. 应用层（Application Layer）"></a>6. 应用层（Application Layer）</h2><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135525.png" alt="应用层"></p><h3 id="6-1-基本术语"><a href="#6-1-基本术语" class="headerlink" title="6.1. 基本术语"></a>6.1. 基本术语</h3><ol><li><strong>域名系统（DNS）</strong> ：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135535.png"></p><p style="text-align:right;font-size:12px">https://www.seobility.net/en/wiki/HTTP_headers</p><ol start="2"><li><strong>文件传输协议（FTP）</strong> ：FTP 是 File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。 “下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135547.png" alt="FTP工作过程"></p><ol start="3"><li><strong>简单文件传输协议（TFTP）</strong> ：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</li><li><strong>远程终端协议（TELNET）</strong> ：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</li><li><strong>万维网（WWW）</strong> ：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</li><li><strong>万维网的大致工作工程：</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135601.png" alt="万维网的大致工作工程"></p><ol start="7"><li><strong>统一资源定位符（URL）</strong> ：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</li><li><strong>超文本传输协议（HTTP）</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</li></ol><p>HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式。HTTP 的原理如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135627.png"></p><ol start="10"><li><strong>代理服务器（Proxy Server）</strong> ： 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</li><li><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135644.png" alt="一个电子邮件被发送的过程"></p><p style="text-align:right;font-size:12px">https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/<p><ol start="11"><li><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210927135707.png" alt="搜索引擎"></p><ol start="12"><li><strong>垂直搜索引擎</strong> ：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</li><li><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</li><li><strong>目录索引</strong> ：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</li></ol><h3 id="6-2-重要知识点总结"><a href="#6-2-重要知识点总结" class="headerlink" title="6.2. 重要知识点总结"></a>6.2. 重要知识点总结</h3><ol><li>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</li><li>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</li><li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</li><li>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li></ol><h3 id="6-3-补充（重要）"><a href="#6-3-补充（重要）" class="headerlink" title="6.3. 补充（重要）"></a>6.3. 补充（重要）</h3><p>以下知识点需要重点关注：</p><ol><li>应用层的常见协议（重点关注 HTTP 协议）</li><li>域名系统-从域名解析出 IP 地址</li><li>访问一个网站大致的过程</li><li>系统调用和应用编程接口概念</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机原理" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化(4)-索引与优化原理(下)</title>
    <link href="http://example.com/2020/08/19/SQL%E4%BC%98%E5%8C%96(4)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8B)/"/>
    <id>http://example.com/2020/08/19/SQL%E4%BC%98%E5%8C%96(4)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8B)/</id>
    <published>2020-08-19T13:02:23.000Z</published>
    <updated>2021-09-23T13:49:06.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>继续上一篇，本节重点介绍联合索引。</p><h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><p>之前我们已经接触了一部分索引优化相关的概念，但更多的是我一个人在讲，大家被动地接收。如何验证文章所说的正确性，以及一条SQL是否真的用到了索引呢？</p><p>这个时候就该Explain上场了，使用方式有两种：</p><ul><li>借助Navicat等软件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610247075143-d475fc88-120c-4ca9-a27d-204b7d6ecf45-20210923214500198.png" alt="img"></p><ul><li>直接使用Explain命令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610247009784-07acd78b-aaf8-4cf6-ae50-6a83e381f027-20210923214507859.png" alt="img"></p><p>大家把它当做一个命令即可，是MySQL提供的专门用来分析SQL执行计划的，比如语句是否使用了关联查询、是否使用了索引、扫描行数等。使用场景一般是：</p><ul><li>当你发现某条SQL很慢时，可以借助Explain分析一下是否走索引</li><li>当你修改某条SQL后，借助Explain查看是否达到预期</li></ul><p>Explain有很多指标，重点看type、key、Extra：</p><table><thead><tr><th>列名</th><th>解释</th></tr></thead><tbody><tr><td>id</td><td>查询编号</td></tr><tr><td>select_type</td><td>查询类型：显示本行是简单还是复杂查询</td></tr><tr><td>table</td><td>涉及到的表</td></tr><tr><td>partitions</td><td>匹配的分区：查询将匹配记录所在的分区。仅当使用 partition 关键字时才显示该列。对于非分区表，该值为 NULL。</td></tr><tr><td><strong>type</strong></td><td>本次查询的表连接类型</td></tr><tr><td>possible_keys</td><td>可能选择的索引</td></tr><tr><td><strong>key</strong></td><td>实际选择的索引</td></tr><tr><td>key_len</td><td>被选择的索引长度：一般用于判断联合索引有多少列被选择了</td></tr><tr><td>ref</td><td>与索引比较的列</td></tr><tr><td>rows</td><td>预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确</td></tr><tr><td>filtered</td><td>按条件筛选的行的百分比</td></tr><tr><td><strong>Extra</strong></td><td>附加信息</td></tr></tbody></table><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><table><thead><tr><th>type 的值</th><th>解释</th></tr></thead><tbody><tr><td>system</td><td>查询对象表只有一行数据，且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况</td></tr><tr><td>const</td><td>基于主键或唯一索引查询，最多返回一条结果</td></tr><tr><td>eq_ref</td><td>表连接时基于主键或非 NULL 的唯一索引完成扫描</td></tr><tr><td>ref</td><td>基于普通索引的等值查询，或者表间等值连接</td></tr><tr><td>fulltext</td><td>全文检索</td></tr><tr><td>ref_or_null</td><td>表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值</td></tr><tr><td>index_merge</td><td>利用多个索引</td></tr><tr><td>unique_subquery</td><td>子查询中使用唯一索引</td></tr><tr><td>index_subquery</td><td>子查询中使用普通索引</td></tr><tr><td>range</td><td>利用索引进行范围查询</td></tr><tr><td>index</td><td>全索引扫描</td></tr><tr><td>ALL</td><td>全表扫描</td></tr></tbody></table><h2 id="possible-keys、key、key-len"><a href="#possible-keys、key、key-len" class="headerlink" title="possible_keys、key、key_len"></a>possible_keys、key、key_len</h2><p>possible_keys是MySQL预估会使用的索引（基本不用看），key才是最终实际选择的索引，可以结合key_len来推测联合索引的“使用率”。比如联合索引index(a,b,c)，假设每个索引长度为1，而key_len却是2，那么可以推测联合索引只用了前两个。</p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>Extra是最难的，含义也最多，和索引覆盖、排序等都有关系。</p><table><thead><tr><th>Extra 常见的值</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td>Using filesort</td><td>将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</td><td>explain select * from t1 order by create_time;</td></tr><tr><td>Using temporary</td><td>需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时</td><td>explain select * from t1 group by create_time;</td></tr><tr><td>Using index</td><td>使用覆盖索引</td><td>explain select a from t1 where a=111;</td></tr><tr><td>Using where</td><td>使用 where 语句来处理结果</td><td>explain select * from t1 where create_time=‘2019-06-18 14:38:24’;</td></tr><tr><td>Impossible WHERE</td><td>对 where 子句判断的结果总是 false 而不能选择任何数据</td><td>explain select * from t1 where 1&lt;0;</td></tr><tr><td>Using join buffer (Block Nested Loop)</td><td>关联查询中，被驱动表的关联字段没索引</td><td>explain select * from t1 straight_join t2 on (t1.create_time=t2.create_time);</td></tr><tr><td>Using index condition</td><td>先条件过滤索引，再查数据</td><td>explain select * from t1 where a &gt;900 and a like “%9”;</td></tr><tr><td>Select tables optimized away</td><td>使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</td><td>explain select max(a) from t1;</td></tr></tbody></table><p>Explain更详细的解释可以参考：<a href="https://www.bilibili.com/video/BV1KW411u7vy?p=20">https://www.bilibili.com/video/BV1KW411u7vy?p=20</a></p><h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><p>联合索引其实要比单列索引难很多，很多SQL优化原则都是针对万恶的联合索引搞出来的，比如大名鼎鼎的“最左匹配原则”。</p><p><strong>虽然联合索引容易引发各种问题，看起来不那么容易驯服，但它在提高索引利用率、加快分组、排序等方面却有着很大的作用，</strong>所以实际开发时，联合索引一般来说应该优于单列索引。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589537787486-ed93cbb6-a245-49eb-8e8f-42fe6ce51893-20210923214519728.png" alt="img"></p><p>我不知道大家是否好奇<strong>联合索引到底长啥样</strong>，反正我当初学习SQL优化时，就有很多的疑问：</p><ul><li><p>联合索引到底长啥样？</p></li><li><p>查询时是怎么检索的呢？</p></li><li><p>为什么对于联合索引index(a, b, c)，查询条件WHERE b=1, c=2无法利用索引呢？</p></li></ul><p>我们先回答第一、第二个问题，第三个问题我们分为三小节，专门讨论所谓的“最左匹配原则”。</p><p>联合索引到底长什么样呢？</p><ul><li>还是一棵树，不会因为是联合索引，就变成多棵树</li><li>索引节点会存储多列，比如原先单列索引的节点会存储[name, name, name…]，而多列索引的节点内会存储[[name, age], [name, age], [name, age]…]</li></ul><p>为了帮大家更好地理解联合索引，我们一起探讨一个问题：</p><p>当我们向建有联合索引的表中插入一条数据时，发生了什么？</p><p>假设现在数据库的记录是这样的(最底下是有序链表，即叶子节点的数据)：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610674696496-4561304d-995a-4035-812f-880cbf5f7a77-20210923214527578.png" alt="img"></p><p>除了主键索引，其他都是辅助索引，联合索引也不例外。所以，上图叶子节点的数据应该是id，但为了更直观，我画成name和age。</p><p>现在要往数据库插入一条数据(bravo, 18, “杭州”, “18255555556”)，插入时需要维护索引，所以需要沿着索引找到数据所在的位置并在叶子节点的表数据中插入：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589544348046-f14690a1-2d1a-44b2-a87e-592802d19765-20210923214533926.png" alt="img"></p><p><strong>插入数据的过程其实伴随着索引的维护，</strong>插入后整棵索引树就变成了这样：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589544632849-3010099d-1849-4dea-9817-dbd57d41b7ea-20210923214538925.png" alt="img"></p><p>通过分析上面数据的插入过程，你会发现，在插入时其实会进行索引比较，先比较name再比较age。<strong>换句话说，这样沿着索引比较后插入的数据，本身就是有序的，符合联合索引的顺序。</strong></p><p>比如班级排座位，老师按照两个条件综合排序，先按身高排，身高一样的，成绩好的坐后面。那么放学走出教室时，顺序自然就是先按身高排，矮的先出来，高的后出来，身高相同的成绩差的先出来。</p><p>所以，对于下面这条SQL：</p><p>SELECT 学生 FROM ‘三年二班’ ORDER BY 身高, 成绩</p><p>你认为MySQL还有排序的必要吗？直接把三年二班的学生从头数到尾拎出来即可。</p><p>这就是所谓的“索引能加快排序速度”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1594511066391-5c4d07d0-0020-4fc1-8242-c93bc1603177-20210923214545481.png" alt="img"></p><p>因为本身插入或更新时，都是按照某种规则维护的。当你ORDER BY的规则与维护索引的规则一致时（都是根据身高、成绩），此时索引就能加快排序，<strong>因为这个时候根本不用排序。</strong></p><p>所以记住，最快的排序就是不用排序，也就是利用索引排序。把对顺序的维护<strong>分散到</strong>每一次增删改的过程中，而不是查询时再匆忙从零开始排序。</p><h2 id="最左匹配原则：WHERE条件查询"><a href="#最左匹配原则：WHERE条件查询" class="headerlink" title="最左匹配原则：WHERE条件查询"></a>最左匹配原则：WHERE条件查询</h2><p>接着，让我们思考一下“为什么对于联合索引index(name, age)，条件WHERE age=25无法利用索引”。</p><p>上面分析过，数据总是要经过索引比较后才插入，所以数据天然就是按索引顺序排列的。当我们拿着WHERE子句的条件（age=25）顺着索引树比较时，是得不到正确的结果的。因为当初这棵树排序的第一个条件是name，而不是age。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589545510186-c162bc1b-fe5f-45a0-9a45-72227ee7934a-20210923214551939.png" alt="img"></p><p>由于整棵树的排序规则是“先根据name排列，再根据age排列”，你硬要直接拿age查询，最终结果可能会南辕北辙。还是以学生排座位举例，人家明明是<strong>先按照身高</strong>排序，<strong>再按照成绩</strong>排序，那么注定成绩不会成“递增”或“递减”的趋势（请观察右边分数列），而面对没有相关趋势的数据，我们只能遍历查找：</p><ul><li><p>180cm 98分</p></li><li><p>182cm 96分</p></li><li><p>182cm 97分</p></li><li><p>183cm 99分</p></li><li><p>184cm 93分</p></li><li><p>184cm 95分</p></li></ul><p>分数的相关趋势只有在“身高一致”这个前提下才会显现，是<strong>局部</strong>特征（绿色块、蓝色块的分数确实呈现某种趋势）：</p><ul><li><p>180cm 98分</p></li><li><p>182cm 96分</p></li><li><p>182cm 97分</p></li><li><p>183cm 99分</p></li><li><p>184cm 93分</p></li><li><p>184cm 95分</p></li></ul><p>当然，实际上MySQL在解析SQL时并不会真的像上面一样进行逻辑分析，而是直接进行语法匹配和成本预估，发现WHERE条件不符合联合索引的“最左匹配原则”时，直接放弃走索引，选择全表扫描。</p><p>那么，怎么才能利用index(name, age)这个联合索引呢？</p><p>把查询条件变成 WHERE name=bravo, age=18即可！此时它会先按照name比较，再按照age比较，刚好和联合索引的顺序一致，也就是和排序顺位一致：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589546040377-acd3e6b0-1a78-4d3d-9a0d-8d9cd6e4a17d-20210923214558226.png" alt="img"></p><p>也就是说，此时WHERE子句的条件顺序刚好能满足最左匹配原则。</p><p>假设联合索引是index(a, b, c)，来看几个最左匹配原则的案例：</p><ul><li><p>WHERE a, b, c ✔️</p></li><li><p>WHERE a, b ✔️（只能匹配a,b）</p></li><li><p>WHERE a, c ✔️（只能匹配a）</p></li><li><p>WHERE b, c（❌）</p></li></ul><p>上面WHERE a, c的查询过程是怎么样的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589618860739-a778f594-32c2-4bd0-8575-53788640d3a7-20210923214605529.png" alt="img"></p><p>也就是说，WHERE后条件如果能走索引，就能站在更高的地方判断条件是否符合，否则只能<strong>作为判断条件</strong>深入节点内部的数据逐个比对。</p><p>如果能走全部索引，就可以少几次比较，甚至可能少几次IO：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589557584392-8bb5a6fe-c7b9-4f87-ac48-07465eade3af-20210923214613726.png" alt="img"></p><p>另外，除了不能缺少联合索引中的查询字段外，还要注意尽量不要使用范围查询。</p><p>比如，联合索引是index(a, b, c)：</p><ul><li>WHERE a=1, b&gt;2, c=3 ✔️（只能匹配a, b）</li></ul><p>注意一下即可，毕竟真要做范围查询也不是我们能决定的，无非索引利用率低一些罢了。</p><h2 id="最左匹配原则：ORDER-BY"><a href="#最左匹配原则：ORDER-BY" class="headerlink" title="最左匹配原则：ORDER BY"></a>最左匹配原则：ORDER BY</h2><p>上面说过了，对于index(name, age)的索引树，最底层的数据本身就是先按name，再按age排序的。当ORDER BY的条件刚好是ORDER BY name, age时，直接查询即可，无需排序，因为数据在插入时就按索引顺序排好了。</p><p>现在我们反过来讨论，如果没有利用索引排序，或者无法利用索引排序时，会发生什么呢？</p><p>filesort！</p><p>所谓filesort是EXPLAIN命令中extra一列的某个指标，当extra出现filesort这个指标时，说明我们的SQL没有走索引排序，而是利用内存或磁盘自己重新排序。</p><p>那么，什么情况下会导致ORDER BY无法利用索引排序呢？</p><p>以联合索引index(name, age)为例，以下情况无法利用索引排序：</p><ul><li>ORDER BY age, name（字段顺序不一致）</li><li>ORDER BY name DESC, age ASC（字段排序方式不同步，DESC和ASC混着来）</li></ul><p>第一种情况：</p><p>因为索引里的数据是先按name、后按age排序的，而你想要先按age再按name排序，对不起，你自己对结果集重新排吧，我不管了。</p><p>特别要注意，对于联合索引index(a,b,c)，WHERE条件无论是a,b,c、a,c,b还是b,c,a…都没关系，比如女生找男朋友要身高180以上、长得帅的，如果你“反过来”，长得帅、身高180以上也是可以的。但是排序不同，顺序必须和联合索引一致，否则语义是不同的。比如，先按身高再按分数和先按分数再按身高是两种完全不同的排序策略，结果自然也不同。</p><p>大家不妨做个实验，对于(‘a’, 17),(‘a’, 16), (‘b’, 18), (‘c’, 18)，(‘d’, 15)先按name正序再按age正序的结果是：</p><ul><li><p>(‘a’, 16)</p></li><li><p>(‘a’, 17)</p></li><li><p>(‘b’, 18)</p></li><li><p>(‘c’, 18)</p></li><li><p>(‘d’, 15)</p></li></ul><p>而先按age正序再按name正序的结果是：</p><ul><li><p>(‘d’, 15)</p></li><li><p>(‘a’, 16)</p></li><li><p>(‘a’, 17)</p></li><li><p>(‘b’, 18)</p></li><li><p>(‘c’, 18)</p></li></ul><p>所以对于index(name, age)，ORDER BY age, name排序顺序与索引不一致，是无法利用索引排序的。</p><p>第二种情况：</p><p>维护索引时默认都是name ASC, name ASC排序，如果你需要name DESC，age ASC，对不起，你自己对结果集重新排吧，我不管了。</p><p>理由同上。</p><p>但以下情况仍可以利用索引排序：</p><ul><li>ORDER BY name DESC, age DESC（字段顺序和索引顺序一致即可，全部DESC或ASC都没关系）</li></ul><p>为什么ORDER BY name DESC, address DESC也能利用索引排序呢？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608985883366-5221f525-a2b1-4d49-a62d-44da6eb92008-20210923214621711.png" alt="img"></p><p>假设右边数据是联合索引自动排序的，而现在查询的排序规则是ORDER BY name DESC, age DESC。我们先尝试一下，如果右边的数据真的按ORDER BY name DESC, age DESC排序，会是什么样呢？</p><p><strong>其实就是左边数据倒过来！</strong></p><p>所以 ORDER BY name DESC, age DESC看起来好像无法利用索引，但其实索引数据反着来刚好符合期望的排序。</p><p>总之，大家应该理解为索引排序是“很消极”的：</p><p>反正索引当初就这么排的，如果你刚好想要这种排序，就直接拿数据即可。但你如果想要的排序不是我现有的这种，对不起，你自己爱咋整咋整，但我明确告诉你，<strong>重新排序会让整个查询变慢。</strong></p><p>说了这么多，我们来验证一下。</p><p>创建表：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589547567889-6a812a41-3b19-4536-a4d6-960327eff327-20210923214629930.png" alt="img"></p><p>给name、address加了联合索引。</p><p>共1000w数据：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548017233-53960dfe-8407-4c37-8f14-a930eb6bfadb-20210923214636772.png" alt="img"></p><p>先介绍两个简单的指标，具体的Explain命令后面介绍：</p><p>Extra列中，如果出现了Using filesort，说明没有走索引排序，也就是说本次查询自己额外做了排序。</p><p>ORDER BY name（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548043565-c2fabb16-a7eb-433b-acb2-bce7842152e2-20210923214645356.png" alt="img"></p><p>ORDER BY name, address（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548082945-066e09ba-8d76-4593-a252-1b20376dcb02-20210923214651758.png" alt="img"></p><p>ORDER BY  <code>name</code> DESC, address DESC（正常）：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548127165-ccb2ae5c-8bbe-4861-ba9f-481d263b4664-20210923214656860.png" alt="img"></p><p>Using index指的是索引覆盖，是个好消息，意味着本次查询不会回表。</p><p>索引失效案例：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548196364-2aeee667-a9b3-4f59-8289-f501a6b9b010-20210923214703042.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589548223133-3f1b433d-430e-4110-831f-d49b6461481b-20210923214710565.png" alt="img"></p><p>当前叶子节点链表上的数据是按索引排的（先name后address），而SQL希望的排序方式是先address后name。既然不能有效利用索引的排序，只能把结果集取出来重新排序。</p><p><strong>总之，如果想利用索引排序，那么ORDER BY的顺序必须符合最左前缀原则，顺序完全一致，且DESC和ASC不能混用。</strong></p><p>OK，上面讲的都是ORDER BY本身的一些规则，接下来我们把战场扩大些，把WHERE也引进来。</p><p>当WHERE和ORDER BY搭配，就会产生一种“例外情况”：<strong>对于index(a,b,c)，SELECT * FROM table WHERE</strong> <strong>a</strong><strong>=1 ORDER BY</strong> <strong>b,c****也是可以利用索引排序的。</strong></p><p>单独观察ORDER BY后面的字段，由于不符合“最左匹配原则”，理应不能走联合索引才对。</p><p>加入WHERE后怎么就可以了呢？</p><p>道理其实很简单，比如原本学生的排序是身高、体重、分数：</p><ul><li><p>180cm 65kg 98分</p></li><li><p>182cm 65kg 96分</p></li><li><p>182cm 65kg 97分</p></li><li><p>183cm 62kg 99分</p></li><li><p>184cm 63kg 93分</p></li><li><p>184cm 64kg 95分</p></li></ul><p>虽然ORDER BY b, c看起来不完整，但只要我定死身高为182（WHERE a=182），那实际筛选出来的学生其实就是先按体重、再按分数排序的，也就是ORDER BY b, c。</p><p>当没有通过a过滤时，数据整体没有相关性，但被a过滤后，局部数据就呈现相关性。</p><p>但这个“例外”本身还有个例外，就是：WHERE的条件不能是范围查询。</p><p>比如：</p><p>SELECT * FROM table WHERE a&gt;1 ORDER BY b,c;</p><p>这条语句是无法利用联合索引index(a,b,c)排序的，理由同上面讲得一样，a&gt;1筛选出来的结果集并不能保证b,c是预期的顺序。</p><p>上面说过，WHERE height=182 ORDER BY weight, score是可以走索引排序的，因为局部范围内能保证走索引排序，而WHERE height&gt;=182 ORDER BY weight, score，显然就不满足索引排序。</p><ul><li><p>180cm 65kg 98分</p></li><li><p>182cm 65kg 96分</p></li><li><p>182cm 65kg 97分</p></li><li><p>183cm 62kg 99分</p></li><li><p>184cm 63kg 93分</p></li><li><p>184cm 64kg 95分</p></li></ul><h2 id="最左匹配原则：GROUP-BY"><a href="#最左匹配原则：GROUP-BY" class="headerlink" title="最左匹配原则：GROUP BY"></a>最左匹配原则：GROUP BY</h2><p>这个没什么好说的，GROUP BY其实可以看成两步：<strong>先排序，后归并。</strong></p><p>一般对于GROUP BY的优化，就是尽可能让它也走索引排序。当它和联合索引顺序一致时，GROUP BY会跳过排序，直接归并，从而达到优化的目的。</p><p>后面我们专门安排一个章节，汇总一下优化规则，上面的内容理解即可。</p><h1 id="联合索引的使用场景"><a href="#联合索引的使用场景" class="headerlink" title="联合索引的使用场景"></a>联合索引的使用场景</h1><p>GROUP BY没什么好讲的，可以理解为排序的基础上在进行归并，所以学习联合索引时，主要关注WHERE和ORDER BY即可。</p><h2 id="场景一：多条件查询，提高利用率"><a href="#场景一：多条件查询，提高利用率" class="headerlink" title="场景一：多条件查询，提高利用率"></a>场景一：多条件查询，提高利用率</h2><p>如果发现很多SQL的WHERE条件经常是多个相同的字段，比如SELECT xxx WHERE a,b,c、SELECT xxx WHERE a,b、SELECT xxx WHERE a,c等，此时可以考虑创建联合索引index(a,b,c)。</p><p>这里有几条规则需要注意：</p><ul><li><p>WHERE条件的书写顺序并不影响是否走联合索引。比如WHERE a,b,c和WHERE b,c,a都可以走index(a,b,c)</p></li><li><p>但WHERE b,c是不行的，因为缺少a，而WHERE a,c只能利用部分索引</p></li><li><p>创建索引时，最好把区分度高的排在前面（注意，我说的是创建索引的顺序，而不是WHERE条件的顺序）</p></li></ul><p>第三条需要大家再仔细品味一下，比如要给id_card和name建立联合索引，如果你建的是index(name, id_card)，就会浪费无畏的IO在name查找上：先找到全国同名同姓的，再根据id_card匹配。而如果创建index(id_card, name)，那么id_card是唯一的，区分度极高，基本就是一击必中。</p><h2 id="场景二：避免回表"><a href="#场景二：避免回表" class="headerlink" title="场景二：避免回表"></a>场景二：避免回表</h2><p>上一篇已经介绍过了，如果走辅助索引并回表，就会无端多一次对主键索引的扫描。比如对于只有主键索引和name索引的表执行以下SQL：</p><p>SELECT id, name, age FROM table name=’xxxx’，</p><p>由于name索引只包含了id和name，而SELECT的列却是id、name、age，此时MySQL底层不得不回表，拿着id再跑一遍主键索引，把age给捞出来。</p><p>可行的解决办法是：添加联合索引index(name, age)，这样辅助索引上就同时包含id、name、age，可以直接返回。</p><p>当然啦，<strong>并不是只有联合索引才能使用索引覆盖，</strong>只要辅助索引上的字段满足SELECT的列即可，所以即使是单列索引index(name)，也是可以避免回表的，比如SELECT id, name FROM table WHERE name=’xxx’。</p><p><strong>但大家要认识到，实际开发索引覆盖可遇不可求，基本还是回表的情况多一些。</strong>比如，即使你定了联合索引index(name, age)，但实际上却是要查询所有列怎么办？此时还是要乖乖回表（好歹走了辅助索引了，知足吧）。</p><h2 id="场景三：索引排序"><a href="#场景三：索引排序" class="headerlink" title="场景三：索引排序"></a>场景三：索引排序</h2><p>当你建了联合索引index(a,b,c)，那么每次增删改都会按这个顺序维护。如果查询是需要的顺序刚好是a,b,c，就可以直接返回数据，无需排序，美其名约“利用索引排序”。</p><p>有个比较特别的地方是，WHERE和ORDER BY可以“联手”玩转联合索引，比如对于index(a,b,c)，并不是只有WHERE a,b,c或者ORDER BY a,b,c才能利用联合索引，WHERE a=1 ORDER BY b,c也是可以的~</p><p>讲完了这三个场景，再稍微注意一下联合索引失效的问题即可（只说两个最常用的）：</p><ul><li>最左匹配原则</li><li>注意范围查询，比如WHERE a&gt;1 and b=2 and c=3，那么就只能用到a啦</li></ul><h2 id="场景四：COUNT统计"><a href="#场景四：COUNT统计" class="headerlink" title="场景四：COUNT统计"></a>场景四：COUNT统计</h2><p>虽说一般大数据量不推荐直接使用COUNT函数，但绝大部分公司都是小公司，一张表不会很大，所以初期COUNT也无妨，但最好尽量走索引。比如要求统计天猫平台下的店主粉丝数量：</p><p>SELECT COUNT(*) FROM t_user_follow WHERE uid=123 and platform=6 and follow_status=1;</p><p>此时最好建立联合索引index(uid, platform, follow_status)，速度会稍微快一些。</p><p>其实场景四不过是联合索引的一个特例，这里单独提出来，就是为了给大家提个醒：哦？COUNT也能用上联合索引啊！</p><h1 id="MySQL的架构图"><a href="#MySQL的架构图" class="headerlink" title="MySQL的架构图"></a>MySQL的架构图</h1><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589599142582-6d0f9da2-d57b-4816-bf63-707f9337fe9d-20210923214721874.png" alt="img"></p><p>看到那个查询优化器了吗，比如index(a,b,c)联合索引，即使我们写成 WHERE a=1, c=3, b=2也能走全索引，就是因为它帮我们优化了顺序。</p><p>好了，虽然上面的内容不一定全部正确，但个人认为利大于弊，起码能让你快速、清晰地理解SQL优化的底层原理，相信大家对于市面上任意的SQL优化课程都能快速吸收。</p><p>如果要用一句话概括SQL优化，应该是下面这句：</p><p>所谓SQL优化，其实就是让查询优化器<strong>根据程序员的意愿</strong>选择匹配的执行计划，最终减少查询中产生的IO。</p><p>这几篇下来，大家应该对索引是什么、如何进行SQL优化有了整体的认知。</p><h1 id="教程推荐"><a href="#教程推荐" class="headerlink" title="教程推荐"></a>教程推荐</h1><p>SQL优化如果仅仅是想学到能应付日常工作，其实不难。但对于初学者（尤其是非科班），最难的其实是入门，比如索引的概念等。前面的几篇的作用，就是帮大家跨过最开始的不适区，接下来我觉得大家其实已经可以自学了。</p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><a href="https://www.bilibili.com/video/BV1KW411u7vy?from=search&seid=131710834280412195">尚硅谷——MySQL优化</a></p><p><a href="https://www.bilibili.com/video/BV1es411u7we?p=1">https://www.bilibili.com/video/BV1es411u7we?p=1</a></p><p>复习时尽量注意以下知识节点：</p><ol><li><p>MySQL常用数据类型及选择（肯定有人对int(11)和varchar(255)里的数字迷茫吧？）</p></li><li><p>数据库范式与反范式的取舍</p></li><li><p>SQL基础：简单查询、关联查询、子查询、GROUP BY、HAVING、ORDER BY、LIMIT，重点关注GROUP BY和ORDER BY，它俩最常用也最难理解</p></li><li><p>常用函数，比如now()等</p></li><li><p>什么是索引、索引的数据结构是什么（只考虑InnoDB）</p></li><li><p>索引加快查询的原理、聚簇索引和非聚簇索引的概念</p></li><li><p>索引的优缺点</p></li><li><p>如何利用Explain分析执行计划、慢查询日志</p></li><li><p>索引失效的几种场景(最左匹缀、!=、LIKE %…、列函数计算等)</p></li><li><p>SQL改写的几种场景与策略</p></li></ol><p>有了小册几篇文章的铺垫，现在大家再来看上面的视频会轻松很多。</p><p>如果一开始就给大家看上面的视频，会懵。确实不如燕十八老师讲的通俗易懂…</p><h2 id="专栏"><a href="#专栏" class="headerlink" title="专栏"></a>专栏</h2><p>如果希望继续深入，可以继续选择专栏观看。</p><p><a href="https://www.imooc.com/read/43">https://www.imooc.com/read/43</a></p><p><a href="https://time.geekbang.org/column/intro/139">https://time.geekbang.org/column/intro/139</a></p><p>建议先看第一个，虽然第二个确实厉害点，但不如第一个简单易懂。个人认为有些细节确实不知道也没什么，最重要的是有较为系统认识即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化(3)-索引与优化原理(上)</title>
    <link href="http://example.com/2020/08/13/SQL%E4%BC%98%E5%8C%96(3)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8A)/"/>
    <id>http://example.com/2020/08/13/SQL%E4%BC%98%E5%8C%96(3)-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86(%E4%B8%8A)/</id>
    <published>2020-08-12T17:31:09.000Z</published>
    <updated>2021-09-23T13:43:28.726Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上一篇，我们重走了一遍数据库索引的历史，认识了B+树结构，这一篇我们回归现实中的MySQL数据库，初步学习具体的SQL优化原则，并尝试从索引底层原理出发，分析为什么会有那么多的“规则”。</p><h1 id="为什么要学习SQL优化"><a href="#为什么要学习SQL优化" class="headerlink" title="为什么要学习SQL优化"></a>为什么要学习SQL优化</h1><p>我的前东家是做招聘服务的，所以不可避免地要查询行业分类。通常来说，前端可以采用根据parentId分步加载的方式获取行业类别，但有些场景也需要全量嵌套查询：查询行业分类及其子分类。</p><p>这里我们就假定直接查询所有分类及其子分类：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584876552845-1508cebc-e24b-4812-b5f1-d44df431105b-20210923151052749.png" alt="img"></p><p>我自己设计了一个简单版的表结构，大概如下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584876666317-5f0f97f0-aa23-4be1-a7bf-e1d8fce54587-20210923151044115.png" alt="img"></p><p>表中有1106条数据：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877002375-f8dd6ff0-eff5-485b-a2e7-277a049ffdaa-20210923151103929.png" alt="img"></p><p>经过《实用小算法》的学习，我们很容易写出以下代码：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 查询行业分类及其子分类 *&#x2F;@Testpublic void testCascade() &#123;    &#x2F;&#x2F; 查询数据库，得到所有行业类别    List&lt;SysPosition&gt; sysPositionList &#x3D; sysPositionMapper.selectAll();    long start &#x3D; System.currentTimeMillis();    Map&lt;String, SysPosition&gt; sysPositionMap &#x3D; new HashMap&lt;&gt;();    List&lt;SysPosition&gt; result &#x3D; new ArrayList&lt;&gt;();    &#x2F;&#x2F; 第一步：List转Map    for (SysPosition sysPosition : sysPositionList) &#123;        sysPositionMap.put(sysPosition.getCode(), sysPosition);    &#125;    &#x2F;&#x2F; 第二步：遍历List，利用Map完成嵌套    for (SysPosition sysPosition : sysPositionList) &#123;        if (&quot;-1&quot;.equals(sysPosition.getParentCode())) &#123;            result.add(sysPosition);        &#125; else &#123;            SysPosition parent &#x3D; sysPositionMap.get(sysPosition.getParentCode());            parent.getChildren().add(sysPosition);        &#125;    &#125;    long end &#x3D; System.currentTimeMillis();    System.out.println(&quot;耗时：&quot; + (end - start));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在《实用小算法》中，我们分析过效率：List转Map这种方式会有2N次循环，也就是会循环2212次。</p><p>大家猜上面程序耗时多少？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877133249-0f113716-f40b-4824-be73-a6fbc5eac808-20210923151113333.png" alt="img"></p><p>只需1<strong>毫秒</strong>。</p><p>对于CPU来说，计算内存中的数据是非常快的，几千次的循环基本可以忽略不计。</p><p>你们想知道之前《实用小算法》的第一版算法耗时多少吗？测一下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877340185-9be080f5-c98b-4ef3-9dbc-6b6e690f36a4-20210923151121192.png" alt="img"></p><p>也<strong>只要</strong>33毫秒。</p><p>要知道，第一版算法在这种情况下可是循环了1106*1106 = 100w+次！！<strong>但是对于CPU来说，不足挂齿。</strong>当然，这是单次调用的差距，想象一下这个接口每天要被几十万、甚至几百万用户调用，累计差距还是很可观的。</p><p>通过上面的案例，我想说的是：绝大多数情况下，内存中数据的处理耗时几乎可以忽略不计。</p><p>大家有没有发现，上面的程序并没有把Mapper查询数据库的操作计入时间？数据库select操作会很耗时吗？</p><p>我在某网站的专栏中看到过关于数据库insert的一段话：</p><p>插入行所需的时间由以下因素决定（参考MySQL 5.7参考手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html">8.2.4.1优化INSERT语句</a>）</p><ul><li><p>连接：30%</p></li><li><p>向服务器发送查询：20%</p></li><li><p>解析查询：20%</p></li><li><p>插入行：10% * 行的大小</p></li><li><p>插入索引：10% * 索引数</p></li><li><p>结束：10%</p></li></ul><p>可发现大部分时间耗费在客户端与服务端通信的时间，因此可以使用 insert 包含多个值来减少客户端和服务器之间的通信。我们通过实验来验证下一次插入多行与一次插入一行的效率对比。</p><p>上面虽然说得是insert，但select的情况其实也差不多。现在我把Mapper查询的时间也包括进来：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877601504-4c6d4ea7-967a-4e78-9d0c-1219fc21c491-20210923151138685.png" alt="img"></p><p><strong>竟然暴增到496毫秒！！</strong></p><p>好了，这个例子告诉我们，网络请求（以及IO操作）是非常耗时的操作，我们应该尽量避免在循环中调用网络请求或进行IO操作，比如：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1584877845815-757a0f69-eaee-42bc-90b4-d4949e03cb0c-20210923151148208.png" alt="img"></p><p>这是非常差劲的写法。</p><p>OK，到这里大家应该能形成一个认知：一次正常的请求，最可能出现性能瓶颈的地方就是网络请求及IO操作（通常而言性能瓶颈往往出现在数据库）。</p><p>要想优化数据的查询，大方向有两个：</p><ul><li>优化关系型数据库本身，比如增加索引等</li><li>借助大数据和ES，转嫁查询压力（本质已经和关系型数据库无关了）</li></ul><p>对于一般小公司而言，大数据和ES还是稀罕物，所以当我们讨论性能优化时，SQL优化几乎是重点！和SQL的性能提升相比，代码的优化有时是微不足道的。<strong>即使有优化，归根到底其实还是减少、减小对数据库的请求。</strong>大家应该要感到高兴，因为你们终于也将登堂入室，要去探索SQL优化了。</p><p>没有特殊情况的话，本文讨论的内容都是基于InnoDB引擎</p><p>在我看来，对于一般的Java开发而言，SQL优化分为几个层次：</p><ul><li><p>索引优化 70%</p></li><li><p>事务及锁 20%</p></li><li><p>读写分离等 10%</p></li></ul><p>其中，索引优化是最重要、也是一般Java开发人员最常用的手段。</p><h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><p>索引的分类可能有不同维度，这里不追求特别准确的分类，毕竟不是做学术，只要感性认识几种即可。</p><p>打开Navicat，尝试创建索引时会发现有4种索引类型可以选择：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589520399248-9a8373e7-567f-4ab5-9d74-f39ac0bb3332-20210923151215022.png" alt="img"></p><ul><li><p>全文索引</p></li><li><p>普通索引</p></li><li><p>空间索引</p></li><li><p>唯一索引</p></li></ul><p>普通索引就可以组织树结构了，而唯一索引在普通索引的基础上还要求索引列不能重复。比如，假设我们给student表的name列加了唯一索引，如果表中已经存在”张三”，那么再次插入”张三”将会报错。</p><p>MySQL这种关系型数据库并不适合进行全文检索（考虑Elastic Search），所以全文索引一般很少使用。</p><p>至于空间索引，我也不知道是什么。</p><p>实际开发常用的索引只有<strong>普通索引</strong>和<strong>唯一索引</strong>，其他的可以不用理会（主键索引其实相当于唯一索引+非NULL）。</p><h1 id="索引的实现方式"><a href="#索引的实现方式" class="headerlink" title="索引的实现方式"></a>索引的实现方式</h1><p>常见的索引实现方式有两种，通过B+树结构或hash算法实现。</p><p><strong>特别注意，这里虽然写的是”BTREE”，但MySQL确实使用的是B+Tree。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589533482892-ea6a7e77-c129-45e3-8519-827ae57c69c7-20210923151221445.png" alt="img"></p><p>这个概念，其实和上面“索引的类型”并不冲突。</p><p>比如，对于普通索引，我们可以使用B+树的结构组织索引，也可以使用hash算法实现。经过上一篇的学习，我们对B+树结构已经比较了解，所以这里单独聊一下hash索引。</p><p>所谓hash索引，其实就是利用<strong>哈希算法为索引列计算得到唯一的存储地址</strong>，一般来说这个地址是不会重复的（重复的情况被称为哈希冲突）。</p><p>举个燕十八老师说的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589533947057-755cdba3-b196-44cd-88c4-813dc6397463-20210923151227170.png" alt="img"></p><p>在墙上装一根弹性永不衰变的弹簧，每次拿不同的物件把弹簧压到极限后放开，不同的物件最终落点会不同。比如你上回存了一本书，那么下次想要找到这本书时，只需要拿一本<strong>一模一样的书</strong>重新弹一下，即可在本次落点处找到上次那本书。</p><p>数据库hash索引的设计也类似，假设你要存入id=10086的数据，就需要通过hash算法对id进行计算，得到一个存储位置后写入数据。下次拿着id=10086查询时，只要按同样的算法再次计算，就能马上找到对应的数据，是不是很快呢~</p><p>需要注意的是，弹簧的例子用来比喻hash算法虽然挺形象的，但可能会让人误以为越重的物品落点越近，越轻的物品落点越远，进而得出结论：hash索引可以进行范围查找。</p><p>其实并不是如此。</p><p>hash算法有个比较显著的特征：即使源数据具备一定的相关性，经过hash映射后得到的结果也会变得“很散”，没有规律可循。回到之前的例子中，你可以理解为重量并不是影响书本最终落点的唯一因素，书的材质、形状等都占有一定比例，最终体现到空气阻力上导致落点的不规则。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608951320970-75bcceba-6e55-4737-9e29-8a7da83502b6-20210923151233076.png" alt="img"></p><p>不知道大家还是否记得，在JavaSE阶段接触HashMap时，很多人会发现put的顺序和get的顺序并不一定相同。比如put的顺序是1000克、500克、300克，而get的顺序却是500克、300克、1000克。也就是说，经过hash计算后，数据的相关性会大大减弱。</p><p>所以，当你希望查找500g~1000g的书本时，就无法利用边界值进行范围查找。而B+树<strong>叶子节点是有序链表</strong>，范围查询非常方便。</p><p><strong>hash索引除了无法进行范围查找外，还不能进行模糊搜索。</strong></p><p>hash算法本身代表着精确定位，依赖于计算的入参得出“唯一”的值，所以无法进行模糊匹配。比如，你给我”bravo”，我可以计算唯一的hash值，你给我”bra%”，我会以为这人就叫”bra%”，也计算一个值，<strong>而****这个值代表着”bra%”计算得到的落点，而不是”所有以bra开头的数据”的落点</strong>，显然是不对的。</p><p>但B+树可以进行模糊搜索，你可以姑且认为因为它会顺着树查找，并在装有数据的节点内调用类似Java的String#startWith()方法进行比较。</p><p>hash索引的优劣势</p><ul><li>优势：速度非常快，只需一次计算即可得到地址，时间复杂度O(1)，而B+树是O(logn)</li><li>劣势：不支持模糊查询、范围查询、索引排序（本身就是不规则的，如何利用索引排序呢）</li></ul><p>最后，《实用小算法》中List转HashMap的操作其实就是借鉴了hash索引！</p><h1 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h1><p>索引的创建时机一般有两处：</p><ul><li>起初，建表时顺便建立索引</li><li>后期，修改表结构创建索引（一般都是这样，因为很难未卜先知，提前优化等于瞎优化）</li></ul><p>比如，一开始就创建索引：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589520661369-1d8b2328-8dca-4f08-8fb4-94df84b770b5-20210923151242400.png" alt="img"></p><p>这张表有两个索引：主键索引、auditor_id普通索引。</p><p>主键索引并不属于上面介绍的4种索引类型之一，但所谓的Primary Key可以看做 唯一索引 + NOT NULL约束。</p><p>后期如果需要添加索引，可以通过两种方式：</p><ul><li>SQL语句</li><li>Navicat图形界面</li></ul><p>利用SQL语句添加索引：</p><pre class="line-numbers language-none"><code class="language-none">-- 1.添加PRIMARY KEY（主键索引） ALTER TABLE &#96;table_name&#96; ADD PRIMARY KEY (&#96;column&#96;) ;-- 2.添加UNIQUE(唯一索引) ALTER TABLE &#96;table_name&#96; ADD UNIQUE (&#96;column&#96;);-- 3.添加INDEX(普通索引) ALTER TABLE &#96;table_name&#96; ADD INDEX index_name (&#96;column&#96;);-- 4.添加FULLTEXT(全文索引) ALTER TABLE &#96;table_name&#96; ADD FULLTEXT (&#96;column&#96;);-- 5.添加联合索引 ALTER TABLE &#96;table_name&#96; ADD INDEX index_name (&#96;column1&#96;, &#96;column2&#96;, &#96;column3&#96;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本案例中，可以写：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE &#96;moneywithdraw&#96; ADD INDEX idx_auditor_id (&#96;auditor_id&#96;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用Navicat图形界面创建<strong>单列索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589521376561-1c62b92e-60ae-4d06-ad73-6cfa4c69101b-20210923151251589.png" alt="img"></p><p>利用Navicat图形界面创建<strong>联合索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589521546600-37ba8127-ad31-4f94-a137-e1986de9354f-20210923151256752.png" alt="img"></p><p>哦，对了，数据量太大的表，不要自己随便加索引，搞不好会锁表哦…后面有机会再说。总之，你可以“懂索引”，但要“动索引”前，最好三思。</p><h1 id="索引的好与坏"><a href="#索引的好与坏" class="headerlink" title="索引的好与坏"></a>索引的好与坏</h1><p>提到索引，很多人就会说：哦，索引能提高查询速度。一般这么说的人，可能学得还不错，但绝对还没有完全掌握索引的底层原理。</p><p>如果你认为索引的优势只是加快查询，那就太小看索引了。</p><p>索引的优势是：</p><ul><li><p>加快查询速度（包括关联查询）</p></li><li><p>加快排序速度（ORDER BY）</p></li><li><p>加快分组速度（GROUP BY）</p></li></ul><p>虽然加快排序、加快分组最终还是体现在加快查询速度上，但能主动意识到这一点算是一种突破。只有当你意识到索引能加快排序和分组，你才会在写ORDER BY和GROUP BY时有意识地利用索引分组和排序（最左匹配原则），从而写出更优的SQL。</p><p>索引的劣势：</p><ul><li><p>创建索引是需要付出代价的，主要体现在维护成本、空间成本和回表成本。也就是说<strong>索引能提高查询效率，但往往会降低增删改的速度</strong>（字典新增几百个字，需要额外编排目录吧，要多占几页纸吧）</p></li><li><p>如果使用了联合索引，还需要考虑索引失效问题（下篇介绍联合索引）</p></li><li><p>太多的索引会增加查询优化器的选择时间（选择太多也麻烦）</p></li></ul><h1 id="建索引的原则"><a href="#建索引的原则" class="headerlink" title="建索引的原则"></a>建索引的原则</h1><p>很多人觉得SQL优化才是重中之重，创建索引只需要一行代码即可，没什么大不了的。但现在你已经知道了索引的优势与劣势，你会明白“在合适的时候、合适的字段建立索引”是多么空泛的口号。创建索引的判断依据究竟是什么呢？</p><p>创建索引有4个大原则：</p><ul><li><p>索引并不是越多越好，联合索引应该优于多个单列索引</p></li><li><p>索引应该建立在区分度高的字段上</p></li><li><p>尽量给查询频繁的字段创建索引，避免为修改频繁的字段创建索引</p></li><li><p>避免重复索引</p></li></ul><p>第一个原则背后的原因是，实际上数据库一次查询只会选择<strong>一棵索引树</strong>（不包括回表），更专业的说法是每次查询只会选择一个执行计划。即使你给a,b,c,d,e,f,g…所有列都加了索引，SELECT xx, xxx FROM table WHERE …时，数据库也只会<strong>择优****选择</strong>一个执行计划进行查询。</p><p>需要注意的是，<strong>每建一个索引，就需要维护一棵索引树，</strong>所以索引绝对不是越多越好，不合适的索引会增加数据库的负担。比如，你已经搞了一个根据拼音查找汉字的目录，又想根据偏旁部首来，那没辙了，只能劳烦您自己再搞一个目录了。</p><p>看到这，你可能会反问：我靠，那MySQL也太笨了吧，为什么这么死心眼一次只利用一个索引？</p><p>比较粗浅的理由是：你根据拼音查完汉字以后，还会根据偏旁部首再查一遍吗？</p><p>比较正经的理由是：按我个人的理解，索引本身的出发点是“走完一遍索引后，数据库应该返回<strong>精确的结果</strong>或<strong>很小的结果集</strong>”，从成本上考虑，此时再走一遍索引还不如直接遍历结果集来得快。当然，要想一次索引就得到精确的结果集，着实需要下一番苦功夫。给哪个字段加索引好呢？我建议，应该尽可能给区分度高的字段添加索引。</p><p>什么是区分度很高？这就是建索引的第二个原则啦。比如，表中有100w学生数据，你如果在sex列加索引，那么根据sex大概只能过滤掉50w数据，剩下的结果集仍然很大，说明这个索引建得不太合适，区分度太低了。</p><p>第三个原则就是字面意思。比如一本字典根据内容编好目录以后，隔三差五地就有新词汇要往里面加，或者经常要修改汉字读音，一顿操作后必然要连累目录，只能重新编排啦。也就是说，为了保证目录能正确指向对应的汉字，每次增删改后都要额外多一个操作：重新修订目录。</p><p>总之要意识到索引在加快查询的同时几乎必然会对修改产生负担，所以创建索引并没有那么简单，它绝对是一门“平衡的艺术”。</p><p>第四个原则是，比如已经建立a索引，又建立index(a,b,c)联合索引，此时单列索引a就是冗余的，因为联合索引已经可以保证符合条件时会利用a索引。<strong>在物理存储上，a单列索引和index(a, b, c)是两个独立的B+树，</strong>重复的索引会增加维护成本。</p><p>以上四个原则，后面的内容还会重新提到。</p><h1 id="MySQL常用引擎"><a href="#MySQL常用引擎" class="headerlink" title="MySQL常用引擎"></a>MySQL常用引擎</h1><p>MySQL的引擎有很多种，但最常听到的就MyISAM和InnoDB，而实际开发几乎99%选择使用InnoDB，而且MySQL5.6还是哪个版本以后默认引擎就从MyISAM变成了InnoDB，所以这里着重介绍InnoDB，简略介绍MyISAM。</p><p>对于两种引擎的介绍，可以看：<a href="https://www.bilibili.com/video/BV1RE41187Yo?p=9">存储引擎简介</a></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589527342910-49ca1484-7ba5-4924-944f-d1008cd46e85-20210923151312836.png" alt="img"></p><p>这里主要想和大家讨论MyISAM和InnoDB在索引组织上的区别。大家应该都已经知道，MyISAM和InnoDB存储数据的方式是不同的。</p><p>MyISAM的每张表在存储时会分为3个文件：</p><ul><li><p>表结构</p></li><li><p>表数据</p></li><li><p>索引</p></li></ul><p>也就是说，表数据和索引是分别独立存储的。</p><p>而InnoDB的表数据在存储时只分为2个文件：</p><ul><li>表结构</li><li>表数据+索引</li></ul><p>需要注意的是，InnoDB所有表的数据和索引都在同一个文件里（见下一个小节）。</p><h1 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h1><p>对于BTREE索引而言，从数据的组织形式来看，索引又可以分为两大类：</p><ul><li>聚簇索引</li><li>非聚簇索引</li></ul><p>所谓聚簇索引，可以简单理解为索引和数据是“聚合”在一起的，而非聚簇索引的数据和索引是分开的。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589532501128-7bf641bd-946e-446b-9a0f-a581b3f13887-20210923151325454.png" alt="img"></p><p>根据InnoDB引擎的<strong>主键索引</strong>查询时无需回表，每一行完整的数据都直接挂在叶子节点下，可以直接返回。也就是说，对于InnoDB的<strong>主键索引</strong>而言，数据即索引，索引即数据。<img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589586538060-89e3781c-22ed-4b16-a734-d5466af2d6aa-20210923151335790.png" alt="img"></p><p>MyISAM不是很重要，不提了。</p><p>InnoDB的索引也并不是都不需要回表，根据是否需要回表其实可以分为两类：主键索引、辅助索引（或者叫二级索引、普通索引）。</p><p>会什么要做这种区分呢？</p><p>假设一个场景：</p><p>新建一张表后，自然会产生主键索引。但后期发现name字段查询很频繁，于是加了name索引。</p><p><strong>如果name索引也和主键索引一样挂着数据，那么两个索引数据就会重复。想象一下，现在磁盘中有一颗叫name的树和一棵叫id的树，一个以name为节点，一个以id为节点，相同的是最底层叶子节点都挂着完整的表数据。也就是说，磁盘中存了两份一模一样的student数据。且不说数据冗余，更新时还可能产生数据不一致（要同步数据，确保多张表的数据一致性）。</strong></p><p>所以InnoDB的做法是，辅助索引只存储索引列+主键，必要时进行“回表”操作：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589536446002-5fddd16a-59f2-4928-b10e-088aaa01f927-20210923151343933.png" alt="img"></p><p>由于SELECT * FROM stu WHERE name=’bravo’中，查询的数据是*，也就是整行数据。而上面的辅助索引只存了主键+name，所以必须回表：拿着主键再去跑一遍主键索引，最终返回整行数据。</p><p>现在，我们可以给MyISAM和InnoDB的索引分类做个简单的总结：</p><ul><li><p>MyISAM：非聚簇索引，需要回表</p></li><li><p>InnoDB：</p></li><li><ul><li>聚簇索引：主键索引，叶子节点是表数据，不需要回表</li><li>非聚簇索引：辅助索引（唯一索引、普通索引），叶子节点是主键，必要时需要根据主键回表查询</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608956710604-75cdbc20-a59e-473f-9e98-b963ac3cd49d-20210923151351478.png" alt="img"></p><p>InnoDB每张表只能有一个主键索引，辅助索引则可以有多个。表数据只有一份，挂在主键索引下面。</p><p>需要注意的是，如有可能，应该尽量避免回表。<strong>SQL优化的本质其实就是减少/减小磁盘IO</strong>，而回表必然会增加磁盘IO次数。</p><p>举个例子，假设某张表总共就两棵索引树：主键索引+name辅助索引，两棵树高度都是3。由于只有主键索引下才挂着表数据，所以对于SELECT * FROM table WHERE name=’xxx’来说，需要先走辅助索引取得id，再根据id走一遍主键索引。假设两棵树需要的数据都在第三层，那么这条SQL需要进行6次逻辑IO访问。而如果直接根据id查询，就可以直接走主键索引，IO次数为3。</p><p>所以，<strong>通常情况下</strong>辅助索引查询都是需要回表的，比主键索引查询多扫描一棵索引树（自身+主键索引），实际编写SQL时，应该尽量走主键索引。</p><p>那么，<strong>什么情况下</strong>辅助索引可以避免回表吗？</p><h1 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h1><p>索引覆盖这个名字，咋一听不知所云，所以很多初学者一直搞不明白什么意思，其实它最大的作用就是：避免回表。</p><p>下面通过一个案例来说明。</p><p>假设有个需求：前端需要支持<strong>根据用户名模糊搜索订单，</strong>而页面需要的字段如下。</p><table><thead><tr><th><strong>id</strong></th><th><strong>productName</strong></th><th><strong>price</strong></th><th><strong>userName</strong></th><th><strong>userAge</strong></th></tr></thead><tbody><tr><td>1</td><td>iphone12</td><td>5999</td><td>bravo1988</td><td>18</td></tr></tbody></table><p>一个可行的方案是：</p><ol><li><p>在t_user表中根据name搜索用户，得到user_id、user_name、user_age</p></li><li><p>在t_order表中根据user_id查询订单</p></li><li><p>在内存中根据user_id匹配order和user数据后返回</p></li></ol><p>由于t_user表此时的查询条件是user_name，为了加快t_user表的查询速度，可以给user_name加普通索引。但，这样真的好吗？我劝！不要犯这样的聪明，小聪明啊。</p><p>你要知道，此时我们从t_user表查询的可不止user_name，还有user_age和id。如果只是给user_name加了索引，那么此时磁盘中产生的索引树是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610162572296-97295d9c-ab7c-444b-a99a-6c8ea8f106eb-20210923151400366.png" alt="img"></p><p>这棵树的非叶子节点是user_name，叶子节点是id，<strong>也就是说从这棵树上我们只能得到user_name和user_id</strong>，至于user_age，MySQL底层只能跳出name索引树，然后跑到隔壁主键索引获取。整个过程被称为回表，而回表意味着多跑一趟。</p><p>此时我们可以给user_name和user_age加一个联合索引，这样就能产生所谓的“索引覆盖”：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1610162521710-d2586c99-f888-4db1-b713-3a69dc59028d-20210923151409810.png" alt="img"></p><p>当辅助索引上的字段完全满足本次查询的列时，就是所谓的索引覆盖，这是一个好消息，意味着不需要回表，查询效率将会大大提高。这也是为什么SQL优化原则中经常会强调：尽量只取必要的字段，避免SELECT *（提高索引覆盖的几率，查询的字段越多，几率越低）。</p><p>即使目前表中只有两个字段且已经索引覆盖，也不要写SELECT *。因为后期随着业务扩展，这张表会新增其他字段，此时SELECT *将不再覆盖索引！</p><p>为了方便记忆，大家可以把索引覆盖理解为 索引的字段 &gt;= 查询需要的字段。比如联合索引的字段是index(a,b,c)，那么此时SELCT a, b就会发生索引覆盖，索引覆盖最大的好处是避免回表。</p><p>需要强调的是，覆盖索引和联合索引没有必然关系。比如我只给user_name加单索引，而我查询语句是</p><p>SELECT id, user_name FROM t_user WHERE name=’bravo’;</p><p>此时也是索引覆盖。所以，<strong>能否索引覆盖不取决于索引单方面，需要查询配合。</strong></p><p>关于联合索引，我们放在下一篇介绍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化(2)-索引与B+树</title>
    <link href="http://example.com/2020/08/11/SQL%E4%BC%98%E5%8C%96-%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/"/>
    <id>http://example.com/2020/08/11/SQL%E4%BC%98%E5%8C%96-%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/</id>
    <published>2020-08-11T15:11:02.000Z</published>
    <updated>2021-09-23T07:17:13.432Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于60%的程序员而言，Java的三层架构Controller、Service、Dao可以说是“越往后走天越黑”，特别是到了Dao层，提着灯笼也只能看到脚边一米开外的河边小石子，只闻对岸风啸马嘶却不知到底是人是鬼，只能借着MyBatis或JPA这些ORM框架隔着宽宽的河举行一场又一场的刺刀战，你砍我一刀，我刺你一剑。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589374354625-30b6de0f-8337-4db5-964b-6c6df7ae09ad-20210923150111295.png" alt="img"></p><p>诚然，很多人对MySQL数据库的印象就是一个模糊的大铁柜，闭上眼睛深吸一口气仿佛还能嗅到一股铁锈味。只知柜子里藏着很多张表，表里面存着很多行数据，再详细一点的呢？不知道。</p><p>MySQL有太多太多细节，根本无法用四、五篇文章说透，但我仍希望这个系列的文章能成为非常好的入门教程，让从来没接触过SQL优化的同学也能快速建立较为系统的知识框架，方便日后学习其他专栏时进一步拓展。</p><hr><h1 id="柏青哥"><a href="#柏青哥" class="headerlink" title="柏青哥"></a>柏青哥</h1><p>大家小时候在游戏厅看过下面这种机器吗：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589354675837-5eaba89f-fb57-4fdf-aa7e-80573ada61a6-20210923150439959.png" alt="img"></p><p>日本人管它叫柏青哥（パチンコ），玩法是：</p><p>从机器最上方的唯一入口投入一颗钢珠，由于重力的作用，钢珠会往下落。机器是直立的，面板上有很多突出的圆柱，它们的作用是随机改变钢珠的落点。最终，钢珠掉落在下方的某个槽中。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589355808319-788e3454-19ae-4c57-9707-b68edc99f05c-20210923150137448.png" alt="img"></p><p>这里提柏青哥，是为后面的B+树及分析B+树搜索过程做铺垫。到时你会发现，沿着索引树搜索的过程和柏青哥小钢珠的下落过程是多么相似！</p><p>很多人都听过数据库索引，但是很少人会去思考下面几个问题：</p><ul><li><p>索引是什么</p></li><li><p>为什么需要索引</p></li><li><p>索引怎么起作用</p></li></ul><p>在历史的长河中，索引的出现几乎是必然的。不信？那就跟我重走一遍历史吧。</p><p>请大家先忘了MySQL、Oracle等乱七八糟的玩意儿，就假设你是上世纪第一批程序员，此时连正儿八经的数据库都没有，需要由你来开天辟地。目前摆在你面前的最大难题是：如何较为<strong>高效地</strong>存取数据？</p><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p>最直观的想法就是存“格子”里，也就是将数据存在线性结构的容器中，比如数组或链表。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589356217794-f7c00e60-53e2-447d-a2b5-2c97d4726d0c-20210923150143937.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589357468320-10555c9b-b1f5-41a7-922d-73ea4f70c03c-20210923150149784.png" alt="img"></p><p>用线性结构存储数据<strong>短期</strong>看是没问题的，但是一家名为SUN的公司发现，随着公司业务增长，平台要经手的用户数据越来越多，特别是今年，他们收到了很多客户的信件投诉，说网页数据的加载越来越慢了！</p><p>SUN的工程师做了个实验，一个线性表如果存了42亿条数据，想要找到id=100的数据，游标只需爬99格即可返回，但如果id=10000000，就要爬将近1000w个格子才能返回。对于这42亿条数据，平均查询次数是21亿次！！</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>作为改进，有人提出用树结构来存储数据。比如，如果要找id=6的数据，那么只要比较3次，小于爬格子次数（5次）</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358245965-f357a5d0-90fc-49e7-affe-8cfa11a2243d-20210923150156142.png" alt="img"></p><p>如果要找id=9的数据，只要比较4次，小于爬格子次数（8次）。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358394072-a5d5f642-25e5-4d01-ba52-ba7251609d4a-20210923150201825.png" alt="img"></p><p>结合两次实验，SUN的工程师发现：</p><p>在一棵树中找到目标数据所需的比较次数 = 目标数据所在的层级</p><p>如果用一棵树来存储42亿条数据，即232=42亿，树的层级是32，最差的情况也只要查32次（需要是二叉平衡树），远远小于线性结构的平均21亿次，这是非常夸张的。</p><p>注意，在线性结构的案例中，不是我故意不用二分查找，而是不能使用二分查找。一般来说，<strong>对于线性结构的数据集合，如果要使用二分查找，那么整个数据都要事先在内存中，</strong>但显然没人会这样做！相比在内存中对线性结构进行二分查找，树在逻辑上天然支持二分查找。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608365614192-1f7e343b-f3fc-4dd6-b4c7-90d64f7569d9-20210923150207584.png" alt="img"></p><p>然而，树结构也分好几种：</p><ul><li><p>Binary Search Tree（二叉查找树）</p></li><li><p>AVL Tree（二叉平衡树）</p></li><li><p>B Tree（平衡树）</p></li><li><p>B+ Tree（大名鼎鼎的B+树，对B Tree的改进）</p></li><li><p>…</p></li></ul><p>大家可以访问<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a>这个网站动手玩一下，特别注意上面的4种树：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589360823134-4c779906-c5d8-4ea4-ab72-47af54d8af3c-20210923150214447.png" alt="img"></p><p>如果你听我的建议，打开上面的网站选择Binary Search Tree并按1,2,3,4…的顺序插入数据时，<strong>它其实变成了线性结构：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358856443-e8032dc1-b241-4f23-9c43-883c36b3b25e-20210923150222903.png" alt="img"></p><p>显然，这不是我们想要的结果，因为刚才已经讨论过，线性结构不适合存储大数据，等后期数据量大了以后要爬很多“格子”。</p><h1 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h1><p>相比来说，AVL Tree更符合SUN工程师的需求：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589358993173-e6bd2cc0-279a-4d98-8fdc-68abf82b2744-20210923150229048.png" alt="img"></p><p>二叉平衡树会在数据插入完毕后<strong>自动调整节点，好让“树的层级”不至于太深。（赶紧去动手玩一下）</strong></p><p>按理来说，如果我们按二叉平衡树组织表数据的话，应该是非常完美的。你想啊，42亿数据中找一条记录最多只需比较32次，尤其是对于CPU来说，<strong>别说32次比较，哪怕32w次简单数据的比较都不会超过0.1秒。</strong>但是！问题在于这里所谓的“32w次简单数据的比较不会超过0.1秒”有个前提条件：<strong>数据必须全部在内存中。</strong></p><p>而我们的表数据因为数据量很大，而且需要持久化，所以一般来说是存在磁盘中，等需要使用时再从磁盘载入内存，也就是涉及磁盘-内存的IO操作。</p><p>通常情况下，没有人会直接把500w行数据一次性加载到内存中进行二分查找，内存极有可能顶不住（同时访问多张表，全部加载）。所以，最终我们组织数据库的方式只能是：</p><ul><li><p>把数据存在磁盘中</p></li><li><p>数据按树结构组织</p></li><li><p>查询时分块读取数据并比较，持续进行磁盘IO读取节点，直到找到目标数据</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1608365864685-03842132-d684-4a5b-9ca8-42ceb43181f7-20210923150235370.png" alt="img"></p><p>每一个节点存储“一小块数据”，分多次IO读取每一块数据到内存判断，直到找到匹配的数据。</p><h1 id="二叉平衡树与磁盘IO"><a href="#二叉平衡树与磁盘IO" class="headerlink" title="二叉平衡树与磁盘IO"></a>二叉平衡树与磁盘IO</h1><p>数据存在磁盘中，没问题。</p><p>数据桉树结构组织，没问题。</p><p><strong>查询时分块读取数据，有一点点问题。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589361951577-71cfd4b1-bfd8-44cc-a968-5de2d821fe2b-20210923150241680.png" alt="img"></p><p>磁盘IO是非常耗时的操作，耗时到什么程度呢？大家可能都听过各个语言的执行效率：</p><p>C &gt; C++ &gt; Java &gt;&gt; Python</p><p>但这些都是在内存层面谈论语言自身的执行效率，而实际上开发一个Web应用，无论用上述哪个语言，对于普通应用而言，都是可以满足用户需求的，真正的瓶颈是IO（网络IO和磁盘IO）。就好比F1赛车、奥迪A4和拖拉机一起跑在北京4环的路上，限制它们的不是引擎，而是堵车。</p><p>所以，二叉平衡树虽然查找42亿数据最多只需32次，但是32次磁盘IO还是不能接受的。</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>基于上面的分析，如果考虑磁盘IO，那么原本优秀的二叉平衡树将显得不再那么优秀。错的不是二叉平衡树，而是我们没有那么大的内存，也不方便把数据都放内存（考虑数据丢失与持久化）。</p><p>但现在不是考虑谁对谁错的时候，要想优化当前数据库，关键是减少磁盘IO次数，<strong>而影响IO次数的关键因素就是树的层级（深度）！</strong>举个例子，如果目标数据在第二层，那么只要比较到第二层，就找到目标数据直接返回，不用再继续磁盘IO读取下一个节点。而如果数据在32层，那么就需要进行32次磁盘IO，比较到最后一层的节点。</p><p>那么，如何减少树的层级呢（让树变矮）？</p><p>请大家思考一下232中的“2”指的是什么？</p><p>其实就是“二叉平衡树”的“二”，而指数32代表树的层级。也就是说，如果以二叉平衡树的结构组织42亿行数据，那么树的深度是32。如果是“三叉平衡树”呢？</p><p>3?? = 232 </p><p>3的指数大概为21。也就是说，如果用“三叉树”组织数据，那么层级将会减少到21，也就意味着磁盘IO次数最多为21次。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589362752238-4daa5676-b2c3-419f-9016-a3cf84bb057f-20210923150255800.png" alt="img"></p><p>所以，到这里我们已经有答案了：要想减少二叉平衡树的磁盘IO次数，需要增加它的“叉”，变成“N叉平衡树”，从而减少树的深度。</p><p>此时有位长者说了一句：你们心里没点B树吗。</p><p>听到这，SUN的工程师颇受启发：对哦，直接用B树就好了。</p><p>B树有个“阶”的概念，比如“三叉平衡”的B树其实叫“3阶B树”。</p><p>通过上面的图，我们会发现“N阶B树”<strong>每个节点可以存N-1个数据</strong>（二叉平衡树每个节点只存1个数据），且每个节点至多可以连接N个子节点。</p><p>这样组织的好处是，<strong>每次加载一个节点时都可以从磁盘带出更多条数据，从而减少磁盘IO的次数。</strong>比如原先比完id=3，接下来要和id=5比较，需要再从磁盘中把id=5的数据读出来。而现在当前节点已经有id=3,id=5的数据了，直接比较即可，无需做磁盘IO。</p><p>这是典型的“空间换时间”。</p><p>但B树最难的地方不是结构本身，而是如何实现这种结构，尤其是如何通过B树组织数据库的表数据？</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589370021227-2ce244b2-e5de-4aeb-8a57-5cfb81109d80-20210923150305159.png" alt="img"></p><p>举个例子，当我要找id=7的数据时，需要先找到根节点，和id=4的节点比较，由于7&gt;4，所以选择右侧那一支，接着因为6&lt;7&lt;8，所以这个节点中三个addr选择中间的addr，顺着这个地址找到7的节点，然后取出数据。</p><p>需要注意的是，当一个节点被加载到内存后，这个节点内部的数据就可以通过二分查找得到啦，所以那么id=7去上图右边节点查找正确的addr是很快的。</p><p>上面只是演示了3阶B树，实际上1个节点可以存更多数据，做成N阶B树：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589370580691-8b9a4589-4f48-42cb-9daf-918ad3183d99-20210923150314176.png" alt="img"></p><p>分析到这里，历史的话剧就告一个段落，让我们看看MySQL索引的真正实现方式吧。</p><h1 id="B-树与索引"><a href="#B-树与索引" class="headerlink" title="B+树与索引"></a>B+树与索引</h1><p>实际上MySQL索引采用的是B+树，而不是B树。</p><p>为什么不用B树呢？</p><p>在操作系统中有个叫“页”的概念，是用来存储数据的一种单位，大小为4k。MySQL中也有“页”的概念，但大小为16k，你可以理解为MySQL中的“页”就是上面B树的一个个节点。</p><p>那么问题来了：你知道日常开发中，表中的一行数据大概占多少字节吗？</p><p>让我们来计算一下：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589371147835-6bf74fd5-b52c-4abc-869a-88fd74c96e0a-20210923150326037.png" alt="img"></p><p>在上面这张表中，按每列数据类型推算，一行数据大概 8+150+150+150+150+9+2+9+750+5+5+8+8=1404字节，就算1k好了，因为节点最大size是16k，所以每个节点最多只能存16行数据。</p><p>我们之前之所以从二叉平衡树转为B树，是因为B树的每个节点可以存更多数据。但上面的计算告诉我们，其实也就是比二叉平衡树多了15条数据而已。</p><p>但原则是对的，为了尽可能使树“变矮”从而减少磁盘IO，最好的做法是让<strong>一个节点尽可能地塞入更多的数据。</strong></p><p>不过把整行数据塞到节点中，有点太浪费了，我们其实可以<strong>把每一行数据的主键存进去。</strong>即使用bigint类型做主键，一个主键也就8个字节。假设每个主键对应一个addr（指针），MySQL中一个指针为6个字节，那么节点内每个主键-地址这样形式的数据能存16*1024/14=1170个。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589376951699-3f01f932-8684-414e-8dcb-2c0573837744-20210923150332743.png" alt="img"></p><p>这其实就是B+树对B树的改造。</p><p><strong>所谓的B+树，就是把原先B树中分散在各个节点的数据都“赶到”最底层的叶子节点，非叶子节点只存储主键-addr形式的数据：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589372895183-3540a1e5-82ba-4d3d-9dca-252f95007eee-20210923150338523.png" alt="img"></p><p>最终，一棵3层的B+树，最底下的叶子节点总共能存2000w条数据。</p><p>有部分同学可能还是不明白B+树为什么比B树能存储更多数据，这里再举个最极端的例子，假设一行表数据8k，而一个节点容量是16k，如果是B Tree，那么一个节点只能存两行数据，最终每个节点只能“夹带”3个addr，只能指向3个子节点：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589377482590-ca616c4f-89de-4de2-b459-1b7ef408a5ff-20210923150345350.png" alt="img"></p><p>但如果是B+ Tree，只存主键：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589377712338-9f1bfde7-bce8-4ecb-a9a0-27d1a5670b67-20210923150352723.png" alt="img"></p><p>那么最上面的节点可以存更多的主键，指向更多的下级节点，就有更多的“16k数据”。上面还只是分析单个节点的情况，如果放眼整棵索引树，最终叶子节点会多很多很多的“16k数据”。</p><p>从MySQL学习者的角度而言，我们只需要知道B+树2个很重要的特征：</p><ul><li>非叶子节点不存数据</li><li>叶子节点数据用链表相连</li></ul><p>所以更详细的版本是：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589448311743-b494fa66-02d0-43b8-ab9f-f920caec8af2-20210923150358426.png" alt="img"></p><p>叶子节点是有序链表，可以帮助做范围查询。</p><p>最后，还有个问题，如果我不提估计很少有人会考虑：B+树如何查找数据。</p><p>为什么会有这个疑问呢？</p><p>之前说过，B数的节点存了完整的数据，假设数据总共3层，而你要找的数据在第2层的某个节点，当你找到后便可以直接返回整行数据。而B+树为了一个节点能存入更多的addr，节点内部只存了主键id，所以即使你在第二层找到匹配的id，还是不能直接返回，必须继续往下，直到在叶子节点读取完整数据。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589421184838-106cccdb-a84e-448f-8806-58e9dfa9b76e-20210923150406906.gif" alt="img"></p><p>讨论到这，我们来对比一下B树和B+树：</p><ul><li><p>B树的节点都会存储整行数据，占用空间大存储addr少，而B+树的非叶子节点只存储主键，能容纳更多addr</p></li><li><p>由于非叶子节点能容纳更多addr，那么同一个节点能指向更多下级节点，所以相同数据量时，B+树通常更加“矮”，IO更少</p></li><li><p>B树的查询效率是不稳定的，最好情况是根节点，最差情况是叶子节点，而B+树是稳定的，每次都要查询到叶子节点</p></li><li><p>B+树的叶子节点是有序列表，非常便于范围查询</p></li></ul><p>对于第三点，很多人可能觉得B+树每次都是稳定地查询叶子节点，还不如B树（最好情况根节点就返回了）。其实上面分析过了，B+树每个节点能存储的数据是B树的1170/16≈73倍，意味着B+树每个节点可以连接的分支更多，相同数据量的情况下，B+树远远矮于B树。比如B树的查询IO次数是1~100，而B+树恒定为3，你觉得哪个效率高？</p><p>回头看看柏青哥，钢珠掉落的过程是不是很像沿着索引查找数据呢~</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589373836878-c32bc126-fc73-48e4-ae95-d7e23ccf77c8-20210923150420395.png" alt="img"></p><p>学到这里，相信Dao层的对岸到底是什么，大家心里已经有B+树了：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/1589374780467-c8dbebf7-eb2e-418b-8536-cc90aea27b37-20210923150427648.png" alt="img"></p><p>至此，我们回过头来给索引下个定义：</p><p><strong>索引是一种数据结构，</strong>用于高效搜索目标数据，在MySQL中具体实现为B+树（InnoDB引擎）。</p><p>最后说一句，没有所谓的“B减树”，很多人可能看到B树的英文表示法是”B-Tree”，误读为“B减树”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>聊下Spring Cloud Netflix</title>
    <link href="http://example.com/2020/08/04/spring-cloud/"/>
    <id>http://example.com/2020/08/04/spring-cloud/</id>
    <published>2020-08-04T09:05:33.000Z</published>
    <updated>2021-09-28T05:53:34.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文基于 Spring Cloud Netflix 。Spring Cloud Alibaba 也是非常不错的选择哦！</p><p>授权转载自：<a href="https://juejin.im/post/5de2553e5188256e885f4fa3">https://juejin.im/post/5de2553e5188256e885f4fa3</a></p></blockquote><p>首先我给大家看一张图，如果大家对这张图有些地方不太理解的话，我希望你们看完我这篇文章会恍然大悟。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348675.jpg" alt="Spring Cloud 总体架构"></p><h2 id="什么是Spring-cloud"><a href="#什么是Spring-cloud" class="headerlink" title="什么是Spring cloud"></a>什么是Spring cloud</h2><blockquote><p>构建分布式系统不需要复杂和容易出错。Spring Cloud 为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。Spring Cloud 构建于 Spring Boot 之上，使得开发者很容易入手并快速应用于生产中。</p></blockquote><p>官方果然官方，介绍都这么有板有眼的。</p><p>我所理解的 <code>Spring Cloud</code> 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 <strong>服务发现注册</strong> 、<strong>配置中心</strong> 、<strong>消息总线</strong> 、<strong>负载均衡</strong> 、<strong>断路器</strong> 、<strong>数据监控</strong> 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p><h2 id="Spring-Cloud-的版本"><a href="#Spring-Cloud-的版本" class="headerlink" title="Spring Cloud 的版本"></a>Spring Cloud 的版本</h2><p>当然这个只是个题外话。</p><p><code>Spring Cloud</code> 的版本号并不是我们通常见的数字版本号，而是一些很奇怪的单词。这些单词均为英国伦敦地铁站的站名。同时根据字母表的顺序来对应版本时间顺序，比如：最早 的 <code>Release</code> 版本 <code>Angel</code>，第二个 <code>Release</code> 版本 <code>Brixton</code>（英国地名），然后是 <code>Camden</code>、 <code>Dalston</code>、<code>Edgware</code>、<code>Finchley</code>、<code>Greenwich</code>、<code>Hoxton</code>。</p><h2 id="Spring-Cloud-的服务发现框架——Eureka"><a href="#Spring-Cloud-的服务发现框架——Eureka" class="headerlink" title="Spring Cloud 的服务发现框架——Eureka"></a>Spring Cloud 的服务发现框架——Eureka</h2><blockquote><p><code>Eureka</code>是基于<code>REST</code>（代表性状态转移）的服务，主要在 <code>AWS</code> 云中用于定位服务，以实现负载均衡和中间层服务器的故障转移。我们称此服务为<code>Eureka</code>服务器。Eureka还带有一个基于 <code>Java</code> 的客户端组件 <code>Eureka Client</code>，它使与服务的交互变得更加容易。客户端还具有一个内置的负载平衡器，可以执行基本的循环负载平衡。在 <code>Netflix</code>，更复杂的负载均衡器将 <code>Eureka</code> 包装起来，以基于流量，资源使用，错误条件等多种因素提供加权负载均衡，以提供出色的弹性。</p></blockquote><p>总的来说，<code>Eureka</code> 就是一个服务发现框架。何为服务，何又为发现呢？</p><p>举一个生活中的例子，就比如我们平时租房子找中介的事情。</p><p>在没有中介的时候我们需要一个一个去寻找是否有房屋要出租的房东，这显然会非常的费力，一你找凭一个人的能力是找不到很多房源供你选择，再者你也懒得这么找下去(找了这么久，没有合适的只能将就)。<strong>这里的我们就相当于微服务中的 <code>Consumer</code> ，而那些房东就相当于微服务中的 <code>Provider</code> 。消费者 <code>Consumer</code> 需要调用提供者 <code>Provider</code> 提供的一些服务，就像我们现在需要租他们的房子一样。</strong></p><p>但是如果只是租客和房东之间进行寻找的话，他们的效率是很低的，房东找不到租客赚不到钱，租客找不到房东住不了房。所以，后来房东肯定就想到了广播自己的房源信息(比如在街边贴贴小广告)，这样对于房东来说已经完成他的任务(将房源公布出去)，但是有两个问题就出现了。第一、其他不是租客的都能收到这种租房消息，这在现实世界没什么，但是在计算机的世界中就会出现 <strong>资源消耗</strong> 的问题了。第二、租客这样还是很难找到你，试想一下我需要租房，我还需要东一个西一个地去找街边小广告，麻不麻烦？</p><p>那怎么办呢？我们当然不会那么傻乎乎的，第一时间就是去找 <strong>中介</strong> 呀，它为我们提供了统一房源的地方，我们消费者只需要跑到它那里去找就行了。而对于房东来说，他们也只需要把房源在中介那里发布就行了。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348705.png"></p><p>那么现在，我们的模式就是这样的了。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348841.png"></p><p>但是，这个时候还会出现一些问题。</p><ol><li>房东注册之后如果不想卖房子了怎么办？我们是不是需要让房东 <strong>定期续约</strong> ？如果房东不进行续约是不是要将他们从中介那里的注册列表中 <strong>移除</strong> 。</li><li>租客是不是也要进行 <strong>注册</strong> 呢？不然合同乙方怎么来呢？</li><li>中介可不可以做 <strong>连锁店</strong> 呢？如果这一个店因为某些不可抗力因素而无法使用，那么我们是否可以换一个连锁店呢？</li></ol><p>针对上面的问题我们来重新构建一下上面的模式图</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348029.jpg" alt="租房-中介模式图"></p><p>好了，举完这个:chestnut:我们就可以来看关于 <code>Eureka</code> 的一些基础概念了，你会发现这东西理解起来怎么这么简单。:punch::punch::punch:</p><p><strong>服务发现</strong>：其实就是一个“中介”，整个过程中有三个角色：**服务提供者(出租房子的)、服务消费者(租客)、服务中介(房屋中介)**。</p><p><strong>服务提供者</strong>： 就是提供一些自己能够执行的一些服务给外界。</p><p><strong>服务消费者</strong>： 就是需要使用一些服务的“用户”。</p><p><strong>服务中介</strong>： 其实就是服务提供者和服务消费者之间的“桥梁”，服务提供者可以把自己注册到服务中介那里，而服务消费者如需要消费一些服务(使用一些功能)就可以在服务中介中寻找注册在服务中介的服务提供者。</p><p><strong>服务注册 Register</strong>：</p><p>官方解释：当 <code>Eureka</code> 客户端向 <code>Eureka Server</code> 注册时，它提供自身的<strong>元数据</strong>，比如IP地址、端口，运行状况指示符URL，主页等。</p><p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>)在中介 (服务器 <code>Eureka Server</code>) 那里登记房屋的信息，比如面积，价格，地段等等(元数据 <code>metaData</code>)。</p><p><strong>服务续约 Renew</strong>：</p><p>官方解释：**<code>Eureka</code> 客户会每隔30秒(默认情况下)发送一次心跳来续约**。 通过续约来告知 <code>Eureka Server</code> 该 <code>Eureka</code> 客户仍然存在，没有出现问题。 正常情况下，如果 <code>Eureka Server</code> 在90秒没有收到 <code>Eureka</code> 客户的续约，它会将实例从其注册表中删除。</p><p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>) 定期告诉中介 (服务器 <code>Eureka Server</code>) 我的房子还租(续约) ，中介 (服务器<code>Eureka Server</code>) 收到之后继续保留房屋的信息。</p><p><strong>获取注册列表信息 Fetch Registries</strong>： </p><p>官方解释：<code>Eureka</code> 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 <code>Eureka</code> 客户端的缓存信息不同, <code>Eureka</code> 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，<code>Eureka</code> 客户端则会重新获取整个注册表信息。 <code>Eureka</code> 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。<code>Eureka</code> 客户端和 <code>Eureka</code> 服务器可以使用JSON / XML格式进行通讯。在默认的情况下 <code>Eureka</code> 客户端使用压缩 <code>JSON</code> 格式来获取注册列表的信息。</p><p>结合中介理解：租客(消费者 <code>Eureka Client Consumer</code>) 去中介 (服务器 <code>Eureka Server</code>) 那里获取所有的房屋信息列表 (客户端列表 <code>Eureka Client List</code>) ，而且租客为了获取最新的信息会定期向中介 (服务器 <code>Eureka Server</code>) 那里获取并更新本地列表。</p><p><strong>服务下线 Cancel</strong>：</p><p>官方解释：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<code>DiscoveryManager.getInstance().shutdownComponent();</code></p><p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>) 告诉中介  (服务器 <code>Eureka Server</code>) 我的房子不租了，中介之后就将注册的房屋信息从列表中剔除。</p><p><strong>服务剔除 Eviction</strong>：</p><p>官方解释：在默认的情况下，<strong>当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除</strong>，即服务剔除。</p><p>结合中介理解：房东(提供者 <code>Eureka Client Provider</code>) 会定期联系 中介  (服务器 <code>Eureka Server</code>) 告诉他我的房子还租(续约)，如果中介  (服务器 <code>Eureka Server</code>) 长时间没收到提供者的信息，那么中介会将他的房屋信息给下架(服务剔除)。</p><p>下面就是 <code>Netflix</code> 官方给出的 <code>Eureka</code> 架构图，你会发现和我们前面画的中介图别无二致。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348074.png" alt="Eureka架构图"></p><p>当然，可以充当服务发现的组件有很多：<code>Zookeeper</code> ，<code>Consul</code> ， <code>Eureka</code> 等。</p><p>更多关于 <code>Eureka</code> 的知识(自我保护，初始注册策略等等)可以自己去官网查看，或者查看我的另一篇文章 <a href="https://juejin.im/post/5dd497e3f265da0ba7718018">深入理解 Eureka</a>。</p><h2 id="负载均衡之-Ribbon"><a href="#负载均衡之-Ribbon" class="headerlink" title="负载均衡之 Ribbon"></a>负载均衡之 Ribbon</h2><h3 id="什么是-RestTemplate"><a href="#什么是-RestTemplate" class="headerlink" title="什么是 RestTemplate?"></a>什么是 <code>RestTemplate</code>?</h3><p>不是讲 <code>Ribbon</code> 么？怎么扯到了 <code>RestTemplate</code> 了？你先别急，听我慢慢道来。</p><p>我不听我不听我不听:hear_no_evil::hear_no_evil::hear_no_evil:。</p><p>我就说一句！**<code>RestTemplate</code>是<code>Spring</code>提供的一个访问Http服务的客户端类**，怎么说呢？就是微服务之间的调用是使用的 <code>RestTemplate</code> 。比如这个时候我们 消费者B 需要调用 提供者A 所提供的服务我们就需要这么写。如我下面的伪代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">RestTemplate</span> restTemplate<span class="token punctuation">;</span><span class="token comment">// 这里是提供者A的ip地址，但是如果使用了 Eureka 那么就应该是提供者A的名称</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> SERVICE_PROVIDER_A <span class="token operator">=</span> <span class="token string">"http://localhost:8081"</span><span class="token punctuation">;</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/judge"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">judge</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Request</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> url <span class="token operator">=</span> SERVICE_PROVIDER_A <span class="token operator">+</span> <span class="token string">"/service1"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">postForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> request<span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 如果你对源码感兴趣的话，你会发现上面我们所讲的 <code>Eureka</code> 框架中的 <strong>注册</strong>、<strong>续约</strong> 等，底层都是使用的 <code>RestTemplate</code> 。</p><h3 id="为什么需要-Ribbon？"><a href="#为什么需要-Ribbon？" class="headerlink" title="为什么需要 Ribbon？"></a>为什么需要 Ribbon？</h3><p><code>Ribbon</code>  是 <code>Netflix</code> 公司的一个开源的负载均衡 项目，是一个客户端/进程内负载均衡器，<strong>运行在消费者端</strong>。</p><p>我们再举个:chestnut:，比如我们设计了一个秒杀系统，但是为了整个系统的 <strong>高可用</strong> ，我们需要将这个系统做一个集群，而这个时候我们消费者就可以拥有多个秒杀系统的调用途径了，如下图。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348206.jpg" style="zoom:50%;" /><p>如果这个时候我们没有进行一些 <strong>均衡操作</strong> ，如果我们对 <code>秒杀系统1</code> 进行大量的调用，而另外两个基本不请求，就会导致 <code>秒杀系统1</code> 崩溃，而另外两个就变成了傀儡，那么我们为什么还要做集群，我们高可用体现的意义又在哪呢？</p><p>所以 <code>Ribbon</code> 出现了，注意我们上面加粗的几个字——<strong>运行在消费者端</strong>。指的是，<code>Ribbon</code> 是运行在消费者端的负载均衡器，如下图。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348411.jpg" style="zoom:50%;" /><p>其工作原理就是 <code>Consumer</code> 端获取到了所有的服务列表之后，在其<strong>内部</strong>使用<strong>负载均衡算法</strong>，进行对多个系统的调用。</p><h3 id="Nginx-和-Ribbon-的对比"><a href="#Nginx-和-Ribbon-的对比" class="headerlink" title="Nginx 和 Ribbon 的对比"></a>Nginx 和 Ribbon 的对比</h3><p>提到 <strong>负载均衡</strong> 就不得不提到大名鼎鼎的 <code>Nignx</code> 了，而和 <code>Ribbon</code> 不同的是，它是一种<strong>集中式</strong>的负载均衡器。</p><p>何为集中式呢？简单理解就是 <strong>将所有请求都集中起来，然后再进行负载均衡</strong>。如下图。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348438.jpg" style="zoom:50%;" /><p>我们可以看到 <code>Nginx</code> 是接收了所有的请求进行负载均衡的，而对于 <code>Ribbon</code> 来说它是在消费者端进行的负载均衡。如下图。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348837.jpg" style="zoom:50%;" /><blockquote><p>请注意 <code>Request</code> 的位置，在 <code>Nginx</code> 中请求是先进入负载均衡器，而在 <code>Ribbon</code> 中是先在客户端进行负载均衡才进行请求的。</p></blockquote><h3 id="Ribbon-的几种负载均衡算法"><a href="#Ribbon-的几种负载均衡算法" class="headerlink" title="Ribbon 的几种负载均衡算法"></a>Ribbon 的几种负载均衡算法</h3><p>负载均衡，不管 <code>Nginx</code> 还是 <code>Ribbon</code> 都需要其算法的支持，如果我没记错的话 <code>Nginx</code> 使用的是 轮询和加权轮询算法。而在 <code>Ribbon</code> 中有更多的负载均衡调度算法，其默认是使用的 <code>RoundRobinRule</code> 轮询策略。</p><ul><li>**<code>RoundRobinRule</code>**：轮询策略。<code>Ribbon</code> 默认采用的策略。若经过一轮轮询没有找到可用的 <code>provider</code>，其最多轮询 10 轮。若最终还没有找到，则返回 <code>null</code>。</li><li><strong><code>RandomRule</code></strong>: 随机策略，从所有可用的 <code>provider</code> 中随机选择一个。</li><li><strong><code>RetryRule</code></strong>: 重试策略。先按照 <code>RoundRobinRule</code> 策略获取 <code>provider</code>，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。</li></ul><p>🐦🐦🐦 还有很多，这里不一一举:chestnut:了，你最需要知道的是默认轮询算法，并且可以更换默认的负载均衡算法，只需要在配置文件中做出修改就行。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">providerName</span><span class="token punctuation">:</span>  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，在 <code>Ribbon</code> 中你还可以<strong>自定义负载均衡算法</strong>，你只需要实现 <code>IRule</code> 接口，然后修改配置文件或者自定义 <code>Java Config</code> 类。</p><h2 id="什么是-Open-Feign"><a href="#什么是-Open-Feign" class="headerlink" title="什么是 Open Feign"></a>什么是 Open Feign</h2><p>有了 <code>Eureka</code>  ，<code>RestTemplate</code> ，<code>Ribbon</code>，  我们就可以愉快地进行服务间的调用了，但是使用 <code>RestTemplate</code> 还是不方便，我们每次都要进行这样的调用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">RestTemplate</span> restTemplate<span class="token punctuation">;</span><span class="token comment">// 这里是提供者A的ip地址，但是如果使用了 Eureka 那么就应该是提供者A的名称</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> SERVICE_PROVIDER_A <span class="token operator">=</span> <span class="token string">"http://localhost:8081"</span><span class="token punctuation">;</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/judge"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">judge</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Request</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> url <span class="token operator">=</span> SERVICE_PROVIDER_A <span class="token operator">+</span> <span class="token string">"/service1"</span><span class="token punctuation">;</span>    <span class="token comment">// 是不是太麻烦了？？？每次都要 url、请求、返回类型的 </span>    <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">postForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> request<span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样每次都调用 <code>RestRemplate</code> 的 <code>API</code> 是否太麻烦，我能不能像<strong>调用原来代码一样进行各个服务间的调用呢？</strong></p><p>:bulb::bulb::bulb:聪明的小朋友肯定想到了，那就用 <strong>映射</strong> 呀，就像域名和IP地址的映射。我们可以将被调用的服务代码映射到消费者端，这样我们就可以 **“无缝开发” **啦。</p><blockquote><p> <code>OpenFeign</code> 也是运行在消费者端的，使用 <code>Ribbon</code> 进行负载均衡，所以 <code>OpenFeign</code> 直接内置了 <code>Ribbon</code>。</p></blockquote><p>在导入了 <code>Open Feign</code> 之后我们就可以进行愉快编写  <code>Consumer</code> 端代码了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 使用 @FeignClient 注解来指定提供者的名字</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"eureka-client-provider"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TestClient</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/provider/xxx"</span><span class="token punctuation">,</span>    method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token class-name">CommonResponse</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Plan</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">getPlans</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> planGetRequest request<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们在 <code>Controller</code> 就可以像原来调用 <code>Service</code> 层代码一样调用它了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 这里就相当于原来自动注入的 Service</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">TestClient</span> testClient<span class="token punctuation">;</span>    <span class="token comment">// controller 调用 service 层代码</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/test"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResponse</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Plan</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> planGetRequest request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> testClient<span class="token punctuation">.</span><span class="token function">getPlans</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="必不可少的-Hystrix"><a href="#必不可少的-Hystrix" class="headerlink" title="必不可少的 Hystrix"></a>必不可少的 Hystrix</h2><h3 id="什么是-Hystrix之熔断和降级"><a href="#什么是-Hystrix之熔断和降级" class="headerlink" title="什么是 Hystrix之熔断和降级"></a>什么是 Hystrix之熔断和降级</h3><blockquote><p>在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。</p></blockquote><p>总体来说 <code>Hystrix</code> 就是一个能进行 <strong>熔断</strong> 和 <strong>降级</strong> 的库，通过使用它能提高整个系统的弹性。</p><p>那么什么是 熔断和降级 呢？再举个:chestnut:，此时我们整个微服务系统是这样的。服务A调用了服务B，服务B再调用了服务C，但是因为某些原因，服务C顶不住了，这个时候大量请求会在服务C阻塞。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348032.jpg" style="zoom:50%;" /><p>服务C阻塞了还好，毕竟只是一个系统崩溃了。但是请注意这个时候因为服务C不能返回响应，那么服务B调用服务C的的请求就会阻塞，同理服务B阻塞了，那么服务A也会阻塞崩溃。</p><blockquote><p>请注意，为什么阻塞会崩溃。因为这些请求会消耗占用系统的线程、IO 等资源，消耗完你这个系统服务器不就崩了么。</p></blockquote><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348243.jpg" style="zoom:50%;" /><p>这就叫 <strong>服务雪崩</strong>。妈耶，上面两个 <strong>熔断</strong> 和 <strong>降级</strong> 你都没给我解释清楚，你现在又给我扯什么 <strong>服务雪崩</strong> ？:tired_face::tired_face::tired_face:</p><p>别急，听我慢慢道来。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348317.png"></p><p>不听我也得讲下去！</p><p>所谓 <strong>熔断</strong> 就是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过 <strong>断路器</strong> 直接将此请求链路断开。</p><p>也就是我们上面服务B调用服务C在指定时间窗内，调用的失败率到达了一定的值，那么 <code>Hystrix</code> 则会自动将 服务B与C 之间的请求都断了，以免导致服务雪崩现象。</p><p>其实这里所讲的 <strong>熔断</strong> 就是指的 <code>Hystrix</code> 中的 <strong>断路器模式</strong> ，你可以使用简单的 <code>@HystrixCommand</code> 注解来标注某个方法，这样 <code>Hystrix</code> 就会使用 <strong>断路器</strong> 来“包装”这个方法，每当调用时间超过指定时间时(默认为1000ms)，断路器将会中断对这个方法的调用。</p><p>当然你可以对这个注解的很多属性进行设置，比如设置超时时间，像这样。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@HystrixCommand</span><span class="token punctuation">(</span>    commandProperties <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@HystrixProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"execution.isolation.thread.timeoutInMilliseconds"</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">"1200"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Xxx</span><span class="token punctuation">></span></span> <span class="token function">getXxxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...省略代码逻辑</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，我查阅了一些博客，发现他们都将 <strong>熔断</strong> 和 <strong>降级</strong> 的概念混淆了，以我的理解，<strong>降级是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户友好的回复</strong>。这也就对应着 <code>Hystrix</code> 的 <strong>后备处理</strong> 模式。你可以通过设置 <code>fallbackMethod</code> 来给一个方法设置备用的代码逻辑。比如这个时候有一个热点新闻出现了，我们会推荐给用户查看详情，然后用户会通过id去查询新闻的详情，但是因为这条新闻太火了(比如最近什么*易对吧)，大量用户同时访问可能会导致系统崩溃，那么我们就进行 <strong>服务降级</strong> ，一些请求会做一些降级处理比如当前人数太多请稍后查看等等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 指定了后备方法调用</span><span class="token annotation punctuation">@HystrixCommand</span><span class="token punctuation">(</span>fallbackMethod <span class="token operator">=</span> <span class="token string">"getHystrixNews"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/get/news"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">News</span> <span class="token function">getNews</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用新闻系统的获取新闻api 代码逻辑省略</span><span class="token punctuation">&#125;</span><span class="token comment">// </span><span class="token keyword">public</span> <span class="token class-name">News</span> <span class="token function">getHystrixNews</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 做服务降级</span>    <span class="token comment">// 返回当前人数太多，请稍后查看</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="什么是Hystrix之其他"><a href="#什么是Hystrix之其他" class="headerlink" title="什么是Hystrix之其他"></a>什么是Hystrix之其他</h3><p>我在阅读 《Spring微服务实战》这本书的时候还接触到了一个 <strong>舱壁模式</strong> 的概念。在不使用舱壁模式的情况下，服务A调用服务B，这种调用默认的是 <strong>使用同一批线程来执行</strong> 的，而在一个服务出现性能问题的时候，就会出现所有线程被刷爆并等待处理工作，同时阻塞新请求，最终导致程序崩溃。而舱壁模式会将远程资源调用隔离在他们自己的线程池中，以便可以控制单个表现不佳的服务，而不会使该程序崩溃。</p><p>具体其原理我推荐大家自己去了解一下，本篇文章中对 <strong>舱壁模式</strong> 不做过多解释。当然还有 <strong><code>Hystrix</code> 仪表盘</strong>，它是<strong>用来实时监控 <code>Hystrix</code> 的各项指标信息的</strong>，这里我将这个问题也抛出去，希望有不了解的可以自己去搜索一下。</p><h2 id="微服务网关——Zuul"><a href="#微服务网关——Zuul" class="headerlink" title="微服务网关——Zuul"></a>微服务网关——Zuul</h2><blockquote><p>ZUUL 是从设备和 web 站点到 Netflix 流应用后端的所有请求的前门。作为边界服务应用，ZUUL 是为了实现动态路由、监视、弹性和安全性而构建的。它还具有根据情况将请求路由到多个 Amazon Auto Scaling Groups（亚马逊自动缩放组，亚马逊的一种云计算方式） 的能力</p></blockquote><p>在上面我们学习了 <code>Eureka</code> 之后我们知道了 <em>服务提供者</em>  是 <em>消费者</em> 通过 <code>Eureka Server</code> 进行访问的，即 <code>Eureka Server</code> 是 <em>服务提供者</em> 的统一入口。那么整个应用中存在那么多 <em>消费者</em> 需要用户进行调用，这个时候用户该怎样访问这些 <em>消费者工程</em> 呢？当然可以像之前那样直接访问这些工程。但这种方式没有统一的消费者工程调用入口，不便于访问与管理，而 Zuul 就是这样的一个对于 <em>消费者</em> 的统一入口。</p><blockquote><p>如果学过前端的肯定都知道 Router 吧，比如 Flutter 中的路由，Vue，React中的路由，用了 Zuul 你会发现在路由功能方面和前端配置路由基本是一个理。:smile: 我偶尔撸撸 Flutter。</p></blockquote><p>大家对网关应该很熟吧，简单来讲网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行<strong>鉴权</strong>、<strong>限流</strong>、 <strong>路由</strong>、<strong>监控</strong>等功能。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348558.jpg" style="zoom:50%;" /><p>没错，网关有的功能，<code>Zuul</code> 基本都有。而 <code>Zuul</code> 中最关键的就是 <strong>路由和过滤器</strong> 了，在官方文档中 <code>Zuul</code> 的标题就是</p><blockquote><p>Router and Filter : Zuul</p></blockquote><h3 id="Zuul-的路由功能"><a href="#Zuul-的路由功能" class="headerlink" title="Zuul 的路由功能"></a>Zuul 的路由功能</h3><h4 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h4><p>本来想给你们复制一些代码，但是想了想，因为各个代码配置比较零散，看起来也比较零散，我决定还是给你们画个图来解释吧。</p><blockquote><p>请不要因为我这么好就给我点赞 :thumbsup: 。 疯狂暗示。</p></blockquote><p>比如这个时候我们已经向 <code>Eureka Server</code> 注册了两个 <code>Consumer</code> 、三个 <code>Provicer</code> ，这个时候我们再加个 <code>Zuul</code> 网关应该变成这样子了。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348954.jpg" style="zoom:50%;" /><p>emmm，信息量有点大，我来解释一下。关于前面的知识我就不解释了:neutral_face:。</p><p>首先，<code>Zuul</code> 需要向 <code>Eureka</code> 进行注册，注册有啥好处呢？</p><p>你傻呀，<code>Consumer</code> 都向 <code>Eureka Server</code> 进行注册了，我网关是不是只要注册就能拿到所有 <code>Consumer</code> 的信息了？</p><p>拿到信息有什么好处呢？</p><p>我拿到信息我是不是可以获取所有的 <code>Consumer</code> 的元数据(名称，ip，端口)？</p><p>拿到这些元数据有什么好处呢？拿到了我们是不是直接可以做<strong>路由映射</strong>？比如原来用户调用 <code>Consumer1</code> 的接口 <code>localhost:8001/studentInfo/update</code> 这个请求，我们是不是可以这样进行调用了呢？<code>localhost:9000/consumer1/studentInfo/update</code> 呢？你这样是不是恍然大悟了？</p><blockquote><p>这里的url为了让更多人看懂所以没有使用 restful 风格。</p></blockquote><p>上面的你理解了，那么就能理解关于 <code>Zuul</code> 最基本的配置了，看下面。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9000</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 这里只要注册 Eureka 就行了</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>9997/eureka<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在启动类上加入 <code>@EnableZuulProxy</code> 注解就行了。没错，就是那么简单:smiley:。</p><h4 id="统一前缀"><a href="#统一前缀" class="headerlink" title="统一前缀"></a>统一前缀</h4><p>这个很简单，就是我们可以在前面加一个统一的前缀，比如我们刚刚调用的是 <code>localhost:9000/consumer1/studentInfo/update</code>，这个时候我们在 <code>yaml</code> 配置文件中添加如下。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">zuul</span><span class="token punctuation">:</span>  <span class="token key atrule">prefix</span><span class="token punctuation">:</span> /zuul<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样我们就需要通过 <code>localhost:9000/zuul/consumer1/studentInfo/update</code> 来进行访问了。</p><h4 id="路由策略配置"><a href="#路由策略配置" class="headerlink" title="路由策略配置"></a>路由策略配置</h4><p>你会发现前面的访问方式(直接使用服务名)，需要将微服务名称暴露给用户，会存在安全性问题。所以，可以自定义路径来替代微服务名称，即自定义路由策略。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">zuul</span><span class="token punctuation">:</span>  <span class="token key atrule">routes</span><span class="token punctuation">:</span>    <span class="token key atrule">consumer1</span><span class="token punctuation">:</span> /FrancisQ1/<span class="token important">**</span>    <span class="token key atrule">consumer2</span><span class="token punctuation">:</span> /FrancisQ2/<span class="token important">**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候你就可以使用 <code> </code>localhost:9000/zuul/FrancisQ1/studentInfo/update` 进行访问了。</p><h4 id="服务名屏蔽"><a href="#服务名屏蔽" class="headerlink" title="服务名屏蔽"></a>服务名屏蔽</h4><p>这个时候你别以为你好了，你可以试试，在你配置完路由策略之后使用微服务名称还是可以访问的，这个时候你需要将服务名屏蔽。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">zuul</span><span class="token punctuation">:</span>  <span class="token key atrule">ignore-services</span><span class="token punctuation">:</span> <span class="token string">"*"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="路径屏蔽"><a href="#路径屏蔽" class="headerlink" title="路径屏蔽"></a>路径屏蔽</h4><p><code>Zuul</code> 还可以指定屏蔽掉的路径 URI，即只要用户请求中包含指定的 URI 路径，那么该请求将无法访问到指定的服务。通过该方式可以限制用户的权限。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">zuul</span><span class="token punctuation">:</span>  <span class="token key atrule">ignore-patterns</span><span class="token punctuation">:</span> <span class="token important">**/auto/**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样关于 auto 的请求我们就可以过滤掉了。</p><blockquote><p>** 代表匹配多级任意路径</p><p>*代表匹配一级任意路径</p></blockquote><h4 id="敏感请求头屏蔽"><a href="#敏感请求头屏蔽" class="headerlink" title="敏感请求头屏蔽"></a>敏感请求头屏蔽</h4><p>默认情况下，像 <code>Cookie</code>、<code>Set-Cookie</code> 等敏感请求头信息会被 <code>zuul</code> 屏蔽掉，我们可以将这些默认屏蔽去掉，当然，也可以添加要屏蔽的请求头。</p><h3 id="Zuul-的过滤功能"><a href="#Zuul-的过滤功能" class="headerlink" title="Zuul 的过滤功能"></a>Zuul 的过滤功能</h3><p>如果说，路由功能是 <code>Zuul</code> 的基操的话，那么<strong>过滤器</strong>就是 <code>Zuul</code>的利器了。毕竟所有请求都经过网关(Zuul)，那么我们可以进行各种过滤，这样我们就能实现 <strong>限流</strong>，<strong>灰度发布</strong>，<strong>权限控制</strong> 等等。</p><h4 id="简单实现一个请求时间日志打印"><a href="#简单实现一个请求时间日志打印" class="headerlink" title="简单实现一个请求时间日志打印"></a>简单实现一个请求时间日志打印</h4><p>要实现自己定义的 <code>Filter</code> 我们只需要继承 <code>ZuulFilter</code> 然后将这个过滤器类以 <code>@Component</code> 注解加入 Spring 容器中就行了。</p><p>在给你们看代码之前我先给你们解释一下关于过滤器的一些注意点。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348400.jpg" style="zoom:50%;" /><p>过滤器类型：<code>Pre</code>、<code>Routing</code>、<code>Post</code>。前置<code>Pre</code>就是在请求之前进行过滤，<code>Routing</code>路由过滤器就是我们上面所讲的路由策略，而<code>Post</code>后置过滤器就是在 <code>Response</code> 之前进行过滤的过滤器。你可以观察上图结合着理解，并且下面我会给出相应的注释。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 加入Spring容器</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PreRequestFilter</span> <span class="token keyword">extends</span> <span class="token class-name">ZuulFilter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 返回过滤器类型 这里是前置过滤器</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">filterType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">FilterConstants</span><span class="token punctuation">.</span>PRE_TYPE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定过滤顺序 越小越先执行，这里第一个执行</span>    <span class="token comment">// 当然不是只真正第一个 在Zuul内置中有其他过滤器会先执行</span>    <span class="token comment">// 那是写死的 比如 SERVLET_DETECTION_FILTER_ORDER = -3</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">filterOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 什么时候该进行过滤</span>    <span class="token comment">// 这里我们可以进行一些判断，这样我们就可以过滤掉一些不符合规定的请求等等</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果过滤器允许通过则怎么进行处理</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ZuulException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 这里我设置了全局的RequestContext并记录了请求开始时间</span>        <span class="token class-name">RequestContext</span> ctx <span class="token operator">=</span> <span class="token class-name">RequestContext</span><span class="token punctuation">.</span><span class="token function">getCurrentContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"startTime"</span><span class="token punctuation">,</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// lombok的日志</span><span class="token annotation punctuation">@Slf4j</span><span class="token comment">// 加入 Spring 容器</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccessLogFilter</span> <span class="token keyword">extends</span> <span class="token class-name">ZuulFilter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 指定该过滤器的过滤类型</span>    <span class="token comment">// 此时是后置过滤器</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">filterType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">FilterConstants</span><span class="token punctuation">.</span>POST_TYPE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// SEND_RESPONSE_FILTER_ORDER 是最后一个过滤器</span>    <span class="token comment">// 我们此过滤器在它之前执行</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">filterOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">FilterConstants</span><span class="token punctuation">.</span>SEND_RESPONSE_FILTER_ORDER <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 过滤时执行的策略</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ZuulException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RequestContext</span> context <span class="token operator">=</span> <span class="token class-name">RequestContext</span><span class="token punctuation">.</span><span class="token function">getCurrentContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 从RequestContext获取原先的开始时间 并通过它计算整个时间间隔</span>        <span class="token class-name">Long</span> startTime <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"startTime"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 这里我可以获取HttpServletRequest来获取URI并且打印出来</span>        <span class="token class-name">String</span> uri <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> duration <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"uri: "</span> <span class="token operator">+</span> uri <span class="token operator">+</span> <span class="token string">", duration: "</span> <span class="token operator">+</span> duration <span class="token operator">/</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面就简单实现了请求时间日志打印功能，你有没有感受到 <code>Zuul</code> 过滤功能的强大了呢？</p><p>没有？好的、那我们再来。</p><h4 id="令牌桶限流"><a href="#令牌桶限流" class="headerlink" title="令牌桶限流"></a>令牌桶限流</h4><p>当然不仅仅是令牌桶限流方式，<code>Zuul</code> 只要是限流的活它都能干，这里我只是简单举个:chestnut:。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348632.jpg" alt="令牌桶限流" style="zoom:50%;" /><p>我先来解释一下什么是 <strong>令牌桶限流</strong> 吧。</p><p>首先我们会有个桶，如果里面没有满那么就会以一定 <strong>固定的速率</strong> 会往里面放令牌，一个请求过来首先要从桶中获取令牌，如果没有获取到，那么这个请求就拒绝，如果获取到那么就放行。很简单吧，啊哈哈、</p><p>下面我们就通过 <code>Zuul</code> 的前置过滤器来实现一下令牌桶限流。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>lgq<span class="token punctuation">.</span>zuul<span class="token punctuation">.</span>filter</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">RateLimiter</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>zuul<span class="token punctuation">.</span></span><span class="token class-name">ZuulFilter</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>zuul<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">RequestContext</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>zuul<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">ZuulException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>zuul<span class="token punctuation">.</span>filters<span class="token punctuation">.</span>support<span class="token punctuation">.</span></span><span class="token class-name">FilterConstants</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RouteFilter</span> <span class="token keyword">extends</span> <span class="token class-name">ZuulFilter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 定义一个令牌桶，每秒产生2个令牌，即每秒最多处理2个请求</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">RateLimiter</span> RATE_LIMITER <span class="token operator">=</span> <span class="token class-name">RateLimiter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">filterType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">FilterConstants</span><span class="token punctuation">.</span>PRE_TYPE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">filterOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ZuulException</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"放行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RequestContext</span> context <span class="token operator">=</span> <span class="token class-name">RequestContext</span><span class="token punctuation">.</span><span class="token function">getCurrentContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>RATE_LIMITER<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"访问量超载"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 指定当前请求未通过过滤</span>            context<span class="token punctuation">.</span><span class="token function">setSendZuulResponse</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 向客户端返回响应码429，请求数量过多</span>            context<span class="token punctuation">.</span><span class="token function">setResponseStatusCode</span><span class="token punctuation">(</span><span class="token number">429</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就能将请求数量控制在一秒两个，有没有觉得很酷？</p><h3 id="关于-Zuul-的其他"><a href="#关于-Zuul-的其他" class="headerlink" title="关于 Zuul  的其他"></a>关于 Zuul  的其他</h3><p><code>Zuul</code> 的过滤器的功能肯定不止上面我所实现的两种，它还可以实现 <strong>权限校验</strong>，包括我上面提到的 <strong>灰度发布</strong> 等等。</p><p>当然，<code>Zuul</code> 作为网关肯定也存在 <strong>单点问题</strong> ，如果我们要保证 <code>Zuul</code> 的高可用，我们就需要进行 <code>Zuul</code> 的集群配置，这个时候可以借助额外的一些负载均衡器比如 <code>Nginx</code> 。</p><p>##Spring Cloud配置管理——Config</p><h3 id="为什么要使用进行配置管理？"><a href="#为什么要使用进行配置管理？" class="headerlink" title="为什么要使用进行配置管理？"></a>为什么要使用进行配置管理？</h3><p>当我们的微服务系统开始慢慢地庞大起来，那么多 <code>Consumer</code> 、<code>Provider</code> 、<code>Eureka Server</code> 、<code>Zuul</code> 系统都会持有自己的配置，这个时候我们在项目运行的时候可能需要更改某些应用的配置，如果我们不进行配置的统一管理，我们只能<strong>去每个应用下一个一个寻找配置文件然后修改配置文件再重启应用</strong>。</p><p>首先对于分布式系统而言我们就不应该去每个应用下去分别修改配置文件，再者对于重启应用来说，服务无法访问所以直接抛弃了可用性，这是我们更不愿见到的。</p><p>那么有没有一种方法<strong>既能对配置文件统一地进行管理，又能在项目运行时动态修改配置文件呢？</strong></p><p>那就是我今天所要介绍的 <code>Spring Cloud Config</code> 。</p><blockquote><p>能进行配置管理的框架不止 <code>Spring Cloud Config</code> 一种，大家可以根据需求自己选择（<code>disconf</code>，阿波罗等等）。而且对于 <code>Config</code> 来说有些地方实现的不是那么尽人意。</p></blockquote><h3 id="Config-是什么"><a href="#Config-是什么" class="headerlink" title="Config 是什么"></a>Config 是什么</h3><blockquote><p><code>Spring Cloud Config</code> 为分布式系统中的外部化配置提供服务器和客户端支持。使用 <code>Config</code> 服务器，可以在中心位置管理所有环境中应用程序的外部属性。</p></blockquote><p>简单来说，<code>Spring Cloud Config</code> 就是能将各个 应用/系统/模块 的配置文件存放到 <strong>统一的地方然后进行管理</strong>(Git 或者 SVN)。</p><p>你想一下，我们的应用是不是只有启动的时候才会进行配置文件的加载，那么我们的 <code>Spring Cloud Config</code> 就暴露出一个接口给启动应用来获取它所想要的配置文件，应用获取到配置文件然后再进行它的初始化工作。就如下图。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348766.jpg" style="zoom:50%;" /><p>当然这里你肯定还会有一个疑问，如果我在应用运行时去更改远程配置仓库(Git)中的对应配置文件，那么依赖于这个配置文件的已启动的应用会不会进行其相应配置的更改呢？</p><p>答案是不会的。</p><p>什么？那怎么进行动态修改配置文件呢？这不是出现了 <strong>配置漂移</strong> 吗？你个渣男:rage:，你又骗我！</p><p>别急嘛，你可以使用 <code>Webhooks</code> ，这是  <code>github</code> 提供的功能，它能确保远程库的配置文件更新后客户端中的配置信息也得到更新。</p><p>噢噢，这还差不多。我去查查怎么用。</p><p>慢着，听我说完，<code>Webhooks</code> 虽然能解决，但是你了解一下会发现它根本不适合用于生产环境，所以基本不会使用它的。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348821.png"></p><p>而一般我们会使用 <code>Bus</code> 消息总线 + <code>Spring Cloud Config</code> 进行配置的动态刷新。</p><h2 id="引出-Spring-Cloud-Bus"><a href="#引出-Spring-Cloud-Bus" class="headerlink" title="引出 Spring Cloud Bus"></a>引出 Spring Cloud Bus</h2><blockquote><p>用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。</p></blockquote><p>你可以简单理解为 <code>Spring Cloud Bus</code> 的作用就是<strong>管理和广播分布式系统中的消息</strong>，也就是消息引擎系统中的广播模式。当然作为 <strong>消息总线</strong> 的 <code>Spring Cloud Bus</code> 可以做很多事而不仅仅是客户端的配置刷新功能。</p><p>而拥有了 <code>Spring Cloud Bus</code> 之后，我们只需要创建一个简单的请求，并且加上 <code>@ResfreshScope</code> 注解就能进行配置的动态修改了，下面我画了张图供你理解。</p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281348224.jpg" style="zoom:50%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章中我带大家初步了解了 <code>Spring Cloud</code> 的各个组件，他们有</p><ul><li><code>Eureka</code> 服务发现框架</li><li><code>Ribbon</code> 进程内负载均衡器</li><li><code>Open Feign</code> 服务调用映射</li><li><code>Hystrix</code> 服务降级熔断器</li><li><code>Zuul</code> 微服务网关</li><li><code>Config</code> 微服务统一配置中心</li><li><code>Bus</code> 消息总线</li></ul><p>如果你能这个时候能看懂文首那张图，也就说明了你已经对 <code>Spring Cloud</code> 微服务有了一定的架构认识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring Cloud" scheme="http://example.com/tags/Spring-Cloud/"/>
    
    <category term="分布式框架" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>UDP&amp;TCP</title>
    <link href="http://example.com/2020/07/29/UDP%20&amp;%20TCP%20/"/>
    <id>http://example.com/2020/07/29/UDP%20&amp;%20TCP%20/</id>
    <published>2020-07-29T01:15:05.000Z</published>
    <updated>2021-09-28T05:10:37.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>讲解 TCP 三次握手和四次握手之前，我们先了解一下 TCP 和 UDP 这两个重量级的传输层协议。</p><p>💦 <strong>用户数据报协议 UDP</strong>（User Datagram Protocol）：</p><ul><li><strong>UDP 在传送数据之前不需要先建立连接</strong>，远程主机在收到 UDP 报文后，不需要给出任何确认。</li><li>虽然 UDP <strong>不提供可靠交付</strong>，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等</li></ul><p>💦 <strong>传输控制协议 TCP</strong>（Transmission Control Protocol）：</p><ul><li>TCP 提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 不提供广播或多播服务。由于 TCP 要提供<strong>可靠</strong>的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</li><li>TCP <strong>一般用于文件传输、发送和接收邮件、远程登录等场景</strong>。</li></ul><h2 id="2-TCP-报文段首部格式"><a href="#2-TCP-报文段首部格式" class="headerlink" title="2. TCP 报文段首部格式"></a>2. TCP 报文段首部格式</h2><p>TCP 报文段的具体格式大家可以不必都记住，但是其中的几个<strong>控制位</strong>与我们接下来要讲的三次握手和四次挥手息息相关，大家一定要牢记。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144029349" alt="图片"></p><p>首部固定部分各字段意义如下：</p><ul><li><p>1 - <strong>源端口和目的端口</strong>：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址</p></li><li><p>2 - <strong>序号/序列号</strong>（Sequense Number，SN）：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。<strong>初始序号称为 Init Sequense Number, ISN</strong>（序号/序列号这个字段很重要，大家留个印象，下文会详细讲解）</p><p>例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。</p></li><li><p>3 - <strong>确认号 ack</strong>：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。</p></li><li><p>4 - <strong>数据偏移</strong>（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。</p></li><li><p>5 - <strong>保留</strong>：占 6 位，应置为 0，保留为今后使用。</p></li></ul><p>⭐ 大家看上图，保留位的右边还有 6 个控制位（重要），这是TCP 用来说明该报文段性质的：</p><ul><li><p><strong>紧急位 URG</strong>：当 URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。该控制位需配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）</p><p>举个例子：我们需要取消一个已经发送了很长程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这个指令将存储在接收 TCP 的缓存末尾，只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程，这样做就无法实现立即中断。</p></li><li><p><strong>确认 ACK</strong>：仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</p></li><li><p><strong>推送 PSH</strong>：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。</p></li><li><p><strong>复位 RST</strong>：当 RST = 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。</p></li><li><p><strong>同步 SYN</strong>：SYN = 1 表示这是一个连接请求或连接接受报文。</p><p>当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 且 ACK = 1。</p></li><li><p><strong>终止 FIN</strong>：用来释放一个连接。当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p></li></ul><h2 id="3-TCP-三次握手建立连接"><a href="#3-TCP-三次握手建立连接" class="headerlink" title="3. TCP 三次握手建立连接"></a>3. TCP 三次握手建立连接</h2><h3 id="①-三次握手过程详解"><a href="#①-三次握手过程详解" class="headerlink" title="① 三次握手过程详解"></a>① 三次握手过程详解</h3><p>三次握手的原文是 <code>three-way handshake</code>，整个名词的可以翻译为：<strong>需要三个步骤才能建立握手/连接的机制</strong>。当然，三次握手也可以叫 <code>three-message handshake</code>，通过三条消息来建立的握手/连接。</p><p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的 <strong>初始化序列号(Init Sequense Number,  <code>ISN</code>)</strong> 为后面的可靠性传输做准备。</p><p>三次握手过程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144034490" alt="图片"></p><p>回顾一下图中字符的含义：</p><ul><li><code>SYN</code>：连接请求/接收 报文段</li><li><code>seq</code>：发送的第一个字节的序号</li><li><code>ACK</code>：确认报文段</li><li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p><strong>刚开始客户端处于 <code>Closed</code> 的状态，而服务端处于 <code>Listen</code> 状态</strong>：</p><blockquote><p><code>CLOSED</code>：没有任何连接状态</p><p><code>LISTEN</code>：侦听来自远方 TCP 端口的连接请求</p></blockquote><p><strong>1）第一次握手</strong>：客户端向服务端发送一个 SYN 报文（SYN = 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq = x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 <code>SYN_Send</code> 状态。</p><blockquote><p><code>SYN-SENT</code> ：在发送连接请求后等待匹配的连接请求</p></blockquote><p><strong>2）第二次握手</strong>：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN = 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq = y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 <code>SYN_REVD</code> 的状态。</p><blockquote><p><code>SYN-RECEIVED</code>：在收到和发送一个连接请求后等待对连接请求的确认</p></blockquote><p><strong>3）第三次握手</strong>：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 <code>Establised</code> 状态。</p><p>服务器收到 ACK 报文之后，也处于 <code>Establised 状态</code>，至此，双方建立起了 TCP 连接。</p><blockquote><p><code>ESTABLISHED</code>：代表一个打开的连接，数据可以传送给用户</p></blockquote><h3 id="②-为什么要三次握手"><a href="#②-为什么要三次握手" class="headerlink" title="② 为什么要三次握手"></a>② 为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的</strong>。</p><p>只有经过三次握手才能确认双发的收发功能都正常，缺一不可：</p><ul><li><p>第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常</p></li><li><p>第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：</p><p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p><p>服务器确认了：对方发送正常，自己接收正常</p></li><li><p>第三次握手（客户端发送 ACK 报文给服务器）：</p><p>客户端确认了：自己发送、接收正常，对方发送、接收正常；</p><p>服务器确认了：自己发送、接收正常，对方发送、接收正常</p></li></ul><h3 id="③-ISN-Initial-Sequence-Number-是固定的吗"><a href="#③-ISN-Initial-Sequence-Number-是固定的吗" class="headerlink" title="③ ISN (Initial Sequence Number) 是固定的吗"></a>③ ISN (Initial Sequence Number) 是固定的吗</h3><p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据</strong>。</p><p>当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。<strong>如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的</strong>。</p><h3 id="④-三次握手过程中可以携带数据吗"><a href="#④-三次握手过程中可以携带数据吗" class="headerlink" title="④ 三次握手过程中可以携带数据吗"></a>④ 三次握手过程中可以携带数据吗</h3><p>第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手绝对不可以携带数据</strong></p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>⭐ <strong>简单的记忆就是，请求连接/接收 即 <code>SYN = 1</code> 的时候不能携带数据</strong></p><p>而对于第三次的话，此时客户端已经处于 <code>ESTABLISHED</code> 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。</p><h3 id="⑤-半连接队列"><a href="#⑤-半连接队列" class="headerlink" title="⑤ 半连接队列"></a>⑤ 半连接队列</h3><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code> 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>当然还有一个<strong>全连接队列</strong>，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><h3 id="⑥-SYN-洪泛攻击"><a href="#⑥-SYN-洪泛攻击" class="headerlink" title="⑥ SYN 洪泛攻击"></a>⑥ SYN 洪泛攻击</h3><p>SYN 攻击就是 <strong>Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包</strong>，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</p><h3 id="⑦-如果第三次握手丢失了，客户端服务端会如何处理"><a href="#⑦-如果第三次握手丢失了，客户端服务端会如何处理" class="headerlink" title="⑦ 如果第三次握手丢失了，客户端服务端会如何处理"></a>⑦ 如果第三次握手丢失了，客户端服务端会如何处理</h3><p>服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><h2 id="4-TCP-四次挥手释放连接"><a href="#4-TCP-四次挥手释放连接" class="headerlink" title="4. TCP 四次挥手释放连接"></a>4. TCP 四次挥手释放连接</h2><h3 id="①-四次挥手过程详解"><a href="#①-四次挥手过程详解" class="headerlink" title="① 四次挥手过程详解"></a>① 四次挥手过程详解</h3><p>建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的<strong>半关闭</strong>（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 连接的释放需要发送四个包（执行四个步骤），因此称为四次挥手(<code>Four-way handshake</code>)，<strong>客户端或服务端均可主动发起挥手动作</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/640-20210923144040116" alt="图片"></p><p>回顾一下上图中符号的意思：</p><ul><li><code>FIN</code> ：连接终止位</li><li><code>seq</code>：发送的第一个字节的序号</li><li><code>ACK</code>：确认报文段</li><li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p>刚开始双方都处于<code>ESTABLISHED</code> 状态，假设是客户端先发起关闭请求。四次挥手的过程如下：</p><p><strong>1）第一次挥手</strong>：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并<strong>停止再发送数据，主动关闭 TCP 连接</strong>。此时客户端处于 <code>FIN_WAIT1</code> 状态，等待服务端的确认。</p><blockquote><p><code>FIN-WAIT-1</code> - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></blockquote><p><strong>2）第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。</p><blockquote><p><code>CLOSE-WAIT</code> - 等待从本地用户发来的连接中断请求；</p></blockquote><p><strong>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放</strong>。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待 2）状态，等待服务端发出的连接释放报文段。</p><blockquote><p><code>FIN-WAIT-2</code> - 从远程TCP等待连接中断请求；</p></blockquote><p><strong>3）第三次挥手</strong>：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态，等待客户端的确认。</p><blockquote><p><code>LAST-ACK</code> - 等待原来发向远程TCP的连接中断请求的确认；</p></blockquote><p><strong>4）第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 <strong><code>TIME_WAIT</code> （时间等待）状态</strong>。</p><blockquote><p><code>TIME-WAIT</code> - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></blockquote><p>🚨 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，<strong>需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 <code>CLOSED</code> 状态</strong>（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 <code>CLOSED</code> 状态。</p><h3 id="②-为什么要四次挥手"><a href="#②-为什么要四次挥手" class="headerlink" title="② 为什么要四次挥手"></a>② 为什么要四次挥手</h3><p>由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就<strong>完全关闭</strong>了TCP连接。</p><p><strong>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手</strong>。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="Communication protocol" scheme="http://example.com/tags/Communication-protocol/"/>
    
  </entry>
  
  <entry>
    <title>单例模式都在这了</title>
    <link href="http://example.com/2020/07/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2020/07/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-24T06:09:22.000Z</published>
    <updated>2021-10-22T12:56:56.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java中单例(Singleton)模式是一种广泛使用的设计模式。单例模式的主要作用是保证在Java程序中，某个类只有一个实例存在。</p><p>它的核心在于，<strong>单例模式可以保证一个类仅创建一个实例，并提供一个访问它的全局访问点</strong>。</p><p><strong>一些管理器和控制器常被设计成单例模式</strong> 。</p><h3 id="单例模式好处"><a href="#单例模式好处" class="headerlink" title="单例模式好处"></a>单例模式好处</h3><ul><li>它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间；</li><li>能够避免由于操作多个实例导致的逻辑错误。</li><li>如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。</li></ul><p>单例模式有很多种写法，大部分写法都或多或少有一些不足。下面将分别对这几种写法进行介绍。</p><p><strong>该模式有三个基本要点</strong>：</p><p><strong>一是这个类只能有一个实例；</strong><br><strong>二是它必须自行创建这个实例；</strong><br><strong>三是它必须自行向整个系统提供这个实例</strong>。</p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 自行创建实例</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 构造函数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 通过该函数向整个系统提供实例</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从代码中我们看到，类的构造函数定义为private的，保证其他类不能实例化此类，然后提供了一个静态实例并返回给调用者。饿汉模式是最简单的一种实现方式，<strong>饿汉模式在类加载的时候就对实例进行创建，实例在整个程序周期都存在。</strong></p><p>它的好处是只在类加载的时候创建一次实例，不会存在多个线程创建多个实例的情况，避免了多线程同步的问题。<br>它的缺点也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。<br> 这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况。但是，如果单例占用的内存比较大，或单例只是在某个特定场景下才会用到，使用饿汉模式就不合适了，这时候就需要用到懒汉模式进行延迟加载。</p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 懒汉模式</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 不实例化</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 构造函数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 通过该函数向整个系统提供实例</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> instance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 当 instance 为 null 时，则实例化对象，否则直接返回对象</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 实例化对象</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token comment">// 返回已存在的对象</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>好处：懒汉模式中单例是在需要的时候才去创建的，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。</li><li>适用于：如果某个单例使用的次数少，并且创建单例消耗的资源较多，那么就需要实现单例的按需创建，这个时候使用懒汉模式就是一个不错的选择。</li><li>缺点：但是这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的getInstance()方法，导致创建多个实例，因此需要加锁解决线程同步问题，实现如下:</li></ul><p>以上代码在单线程下运行是没有问题的，但要运行在多线程下，就会出现实例化多个类对象的情况。这是怎么回事呢？</p><p>当线程 A 进入到 if 判断条件后，开始实例化对象，此时 instance 依然为 null；又有线程 B 进入到 if 判断条件中，之后也会通过条件判断，进入到方法里面创建一个实例对象。</p><p>所以我们需要对该方法进行加锁，保证多线程情况下仅创建一个实例。这里我们使用 Synchronized 同步锁来修饰 getInstance 方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 懒汉模式 + synchronized 同步锁</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 不实例化</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 构造函数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 加同步锁，通过该函数向整个系统提供实例</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> instance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 当 instance 为 null 时，则实例化对象，否则直接返回对象</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 实例化对象</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token comment">// 返回已存在的对象</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但同步锁会增加锁竞争，带来系统性能开销，从而导致系统性能下降，因此这种方式也会降低单例模式的性能。</p><p>还有，<strong>每次请求获取类对象时，都会通过 getInstance() 方法获取，除了第一次为 null，其它每次请求基本都是不为 null 的。在没有加同步锁之前，是因为 if 判断条件为 null 时，才导致创建了多个实例。基于以上两点，我们可以考虑将同步锁放在 if 条件里面，这样就可以减少同步锁资源竞争</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 懒汉模式 + synchronized 同步锁</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 不实例化</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 构造函数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 加同步锁，通过该函数向整个系统提供实例</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> instance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 当 instance 为 null 时，则实例化对象，否则直接返回对象</span>          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 实例化对象</span>          <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token comment">// 返回已存在的对象</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 你是不是觉得这样就可以了呢？答案是依然会创建多个实例。<strong>这是因为当多个线程进入到 if 判断条件里，虽然有同步锁，但是进入到判断条件里面的线程依然会依次获取到锁创建对象，然后再释放同步锁</strong>。所以我们还需要在同步锁里面再加一个判断条件</p><h3 id="双重校验锁【推荐】"><a href="#双重校验锁【推荐】" class="headerlink" title="双重校验锁【推荐】"></a>双重校验锁【推荐】</h3><ol><li>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。</li><li>一半的人写不出双检锁，还有一半的人说不出它的隐患和Java1.5是如何对它修正的。</li><li>它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，</li><li>但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。</li></ol><ul><li><strong>加锁的懒汉模式看起来即解决了线程并发问题，又实现了延迟加载，然而它存在着性能问题，依然不够完美。</strong></li><li><strong>synchronized修饰的同步方法比一般方法要慢很多，如果多次调用getInstance()，累积的性能损耗就比较大了。</strong></li><li><strong>因此就有了双重校验锁，先看下它的实现代码。</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 懒汉模式 + synchronized 同步锁 + double-check</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 不实例化</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 构造函数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 加同步锁，通过该函数向整个系统提供实例</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> instance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象</span>          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 同步锁</span>             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> instance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 第二次判断</span>                instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 实例化对象</span>             <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token comment">// 返回已存在的对象</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到上面在同步代码块内多了一层instance为空的判断。由于单例对象只需要创建一次，如果后面再次调用getInstance()只需要直接返回单例对象。</p><ul><li>因此，大部分情况下，调用getInstance()都不会执行到同步代码块，从而提高了程序性能。</li><li>不过还需要考虑一种情况，假如两个线程A、B，A执行了if (instance == null)语句，它会认为单例对象没有创建，此时线程切到B也执行了同样的语句，B也认为单例对象没有创建，然后两个线程依次执行同步代码块，并分别创建了一个单例对象。为了解决这个问题，还需要在同步代码块中增加if (instance == null)语句，也就是上面看到的代码中的校验2。</li><li>双检锁隐患：<br><strong>我们看到双重校验锁即实现了延迟加载，又解决了线程并发问题，同时还解决了执行效率问题，是否真的就万无一失了呢？</strong></li></ul><ul><li>这里要提到Java中的指令重排优化和 Happens-Before 规则。所谓指令重排优化是指在不改变原语义的情况下，通过调整指令的执行顺序让程序运行的更快。</li><li>JVM中并没有规定编译器优化相关的内容，也就是说JVM可以自由的进行指令重排序的优化。</li><li>这个问题的关键就在于由于指令重排优化的存在，导致初始化Singleton和将对象地址赋给instance字段的顺序是不确定的。</li><li>在某个线程创建单例对象时，在构造方法被调用之前，就为该对象分配了内存空间并将对象的字段设置为默认值。</li><li>此时就可以将分配的内存地址赋值给instance字段了，然而该对象可能还没有初始化。若紧接着另外一个线程来调用getInstance，取到的就是状态不正确的对象，程序就会出错。</li></ul><h4 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h4><p><strong>通过字面意思，你可能会误以为是前一个操作发生在后一个操作之前。然而真正的意思是，前一个操作的结果可以被后续的操作获取。这条规则规范了编译器对程序的重排序优化。</strong></p><ul><li><strong>JDK5的修正</strong>：以上就是双重校验锁会失效的原因，不过还好在JDK1.5及之后版本增加了volatile关键字。<ul><li>volatile的一个语义是禁止指令重排序优化，也就保证了instance变量被赋值的时候对象已经是初始化过的，从而避免了上面说到的问题。</li><li>Java中的volatile 变量是什么？</li></ul></li></ul><p>理解volatile关键字的作用的前提是要理解Java内存模型，volatile关键字的作用主要有两个：</p><ol><li>多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</li><li>代码底层执行不像我们看到的高级语言—-Java程序这么简单，<br>它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。<strong>使用volatile则会对禁止语义重排序</strong>，当然这也一定程度上降低了代码执行效率</li></ol><ul><li>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</li><li>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。 </li><li>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生。</li></ul><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 懒汉模式 + synchronized 同步锁 + double-check</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 不实例化</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//list 属性</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 构造函数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 加同步锁，通过该函数向整个系统提供实例</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> instance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象</span>          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 同步锁</span>             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> instance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 第二次判断</span>                instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 实例化对象</span>             <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token comment">// 返回已存在的对象</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态内部类【推荐】"><a href="#静态内部类【推荐】" class="headerlink" title="静态内部类【推荐】"></a>静态内部类【推荐】</h3><p>除了上面的三种方式，还有另外一种实现单例的方式，通过静态内部类来实现。<br>首先看一下它的实现代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 懒汉模式 内部类实现</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// list 属性</span>  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 构造函数</span>list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 内部类实现</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InnerSingleton</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 自行创建实例</span><span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token class-name">InnerSingleton</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span><span class="token comment">// 返回内部类中的静态变量</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li> 这种方式同样利用了类加载机制来保证只创建一个instance实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。</li><li>不一样的是，它是在内部类里面去创建对象实例。</li><li>这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举模式最安全，反射和序列化都是单例。</p><p>《Effective Java》作者也是强烈推荐枚举方式实现单例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Resource</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">/** * 枚举类型是线程安全的，并且只会装载一次 */</span><span class="token keyword">private</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span><span class="token punctuation">&#123;</span>    INSTANCE<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Resource</span> instance<span class="token punctuation">;</span>     <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">private</span> <span class="token class-name">Resource</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Resource</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>上面的类Resource是我们要应用单例模式的资源，具体可以表现为网络连接，数据库连接，线程池等等。 </li><li>获取资源的方式很简单，只要 Singleton.INSTANCE.getInstance() 即可获得所要实例。</li></ul><p><strong>下面我们来看看单例是如何被保证的：</strong> </p><ol><li>首先，在枚举中我们<strong>明确了构造方法限制为私有</strong>，在我们访问枚举实例时会执行构造方法。</li><li>同时每个<strong>枚举实例都是static final类型的</strong>，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。 </li><li>也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的INSTANCE也被保证实例化一次。 </li></ol><ul><li>可以看到，枚举实现单例还是比较简单的，除此之外我们再来看一下Enum这个类的声明：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Enum</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>可以看到，枚举也提供了序列化机制。某些情况，比如我们要通过网络传输一个数据库连接的句柄，会提供很多帮助。 </li><li>最后借用 《Effective Java》一书中的话， 单元素的枚举类型已经成为实现Singleton的最佳方法。</li></ul><p>或者使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">DataSourceEnum</span> <span class="token punctuation">&#123;</span>    DATASOURCE<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">DBConnection</span> connection <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">DataSourceEnum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        connection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DBConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">DBConnection</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> connection<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @Title: java单例之enum实现方式 * @ClassName: EnumSingleton.java * @Description:   * * @Copyright 2016-2018 - Powered By 研发中心 * @author: 王延飞 * @date:  2018-02-07 20:02 * @version V1.0   */</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumSingleton</span><span class="token punctuation">&#123;</span>   <span class="token keyword">private</span> <span class="token class-name">EnumSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">EnumSingleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span><span class="token punctuation">&#123;</span>       INSTANCE<span class="token punctuation">;</span>       <span class="token keyword">private</span> <span class="token class-name">EnumSingleton</span> singleton<span class="token punctuation">;</span>       <span class="token comment">//JVM会保证此方法绝对只调用一次</span>       <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnumSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">public</span> <span class="token class-name">EnumSingleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">EnumSingleton</span> obj1 <span class="token operator">=</span> <span class="token class-name">EnumSingleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">EnumSingleton</span> obj2 <span class="token operator">=</span> <span class="token class-name">EnumSingleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//输出结果：obj1==obj2?true</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"obj1==obj2?"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>obj1<span class="token operator">==</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面提到的四种实现单例的方式都有共同的缺点：</p><ol><li>需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例。</li><li>可以使用反射强行调用私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）。</li></ol><p>而枚举类很好的解决了这两个问题，使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。</p><h3 id="单例模式的线程安全性"><a href="#单例模式的线程安全性" class="headerlink" title="单例模式的线程安全性"></a>单例模式的线程安全性</h3><p>首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p><p>（1）饿汉式：线程安全</p><p>（2）懒汉式：非线程安全</p><p>（3）双检锁：线程安全</p><p>（4）静态内部类：线程安全</p><p>（5）枚举：线程安全</p><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；</p><p>如果我们是写一些工具类，则优先考虑使用懒汉模式，因为很多项目可能会引用到 jar 包，但未必会使用到这个工具类，懒汉模式实现的单例可以避免提前被加载到内存中，占用系统资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>开发注意事项</title>
    <link href="http://example.com/2020/06/16/%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://example.com/2020/06/16/%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2020-06-16T15:21:43.000Z</published>
    <updated>2021-09-28T04:03:57.995Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="1-1-正确使用-equals-方法"><a href="#1-1-正确使用-equals-方法" class="headerlink" title="1.1. 正确使用 equals 方法"></a>1.1. 正确使用 equals 方法</h2><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 </p><p>举个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"SnailClimb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token string">"SnailClimb"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过更推荐使用 <code>java.util.Objects#equals</code>(JDK7 引入的工具类)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token string">"SnailClimb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们看一下<code>java.util.Objects#equals</code>的源码就知道原因了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> a<span class="token punctuation">,</span> <span class="token class-name">Object</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><p>Reference:<a href="https://blog.csdn.net/tick_tock97/article/details/72824894">Java中equals方法造成空指针异常的原因及解决方案</a></p><ul><li>每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。</li><li>可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中<code>null == null</code>将返回true。</li><li>不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</li></ul><h2 id="1-2-整型包装类值的比较"><a href="#1-2-整型包装类值的比较" class="headerlink" title="1.2. 整型包装类值的比较"></a>1.2. 整型包装类值的比较</h2><p>所有整型包装类对象值的比较必须使用equals方法。</p><p>先看下面这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token operator">==</span>i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>Integer i1=40</code> 这一行代码会发生拆箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而<code>Integer i1 = new Integer(40)</code> 会直接创建新的对象。因此，输出 false 。</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 <code>equals()</code>  方法比较</strong>。</p><p><img src="https://ryansimg.oss-cn-shanghai.aliyuncs.com/2021/202109281141849.png"></p><p><strong>注意：</strong> 如果你的IDE(IDEA/Eclipse)上安装了阿里巴巴的p3c插件，这个插件如果检测到你用 ==的话会报错提示，推荐安装一个这个插件，很不错。</p><h2 id="1-3-BigDecimal"><a href="#1-3-BigDecimal" class="headerlink" title="1.3. BigDecimal"></a>1.3. BigDecimal</h2><h3 id="1-3-1-BigDecimal-的用处"><a href="#1-3-1-BigDecimal-的用处" class="headerlink" title="1.3.1. BigDecimal 的用处"></a>1.3.1. BigDecimal 的用处</h3><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token number">1.0f</span> <span class="token operator">-</span> <span class="token number">0.9f</span><span class="token punctuation">;</span><span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">0.9f</span> <span class="token operator">-</span> <span class="token number">0.8f</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0.100000024</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0.099999964</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BigDecimal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BigDecimal</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"0.9"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BigDecimal</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"0.8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BigDecimal</span> x <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">BigDecimal</span> y <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 0.1 */</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 0.1 */</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* true */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-2-BigDecimal-的大小比较"><a href="#1-3-2-BigDecimal-的大小比较" class="headerlink" title="1.3.2. BigDecimal 的大小比较"></a>1.3.2. BigDecimal 的大小比较</h3><p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1表示 <code>a</code> 大于 <code>b</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BigDecimal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BigDecimal</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"0.9"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-3-BigDecimal-保留几位小数"><a href="#1-3-3-BigDecimal-保留几位小数" class="headerlink" title="1.3.3. BigDecimal 保留几位小数"></a>1.3.3. BigDecimal 保留几位小数</h3><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BigDecimal</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1.255433"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BigDecimal</span> n <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">setScale</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ROUND_HALF_DOWN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1.255</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-4-BigDecimal-的使用注意事项"><a href="#1-3-4-BigDecimal-的使用注意事项" class="headerlink" title="1.3.4. BigDecimal 的使用注意事项"></a>1.3.4. BigDecimal 的使用注意事项</h3><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210928104528.png" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></p><h3 id="1-3-5-总结"><a href="#1-3-5-总结" class="headerlink" title="1.3.5. 总结"></a>1.3.5. 总结</h3><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p><p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p><h2 id="1-4-基本数据类型与包装数据类型的使用标准"><a href="#1-4-基本数据类型与包装数据类型的使用标准" class="headerlink" title="1.4. 基本数据类型与包装数据类型的使用标准"></a>1.4. 基本数据类型与包装数据类型的使用标准</h2><p>Reference:《阿里巴巴Java开发手册》</p><ul><li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li><li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul><p>比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.</p><p><strong>说明</strong> :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p><p><strong>正例</strong> : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p><p><strong>反例</strong> : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p><h1 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h1><h2 id="2-1-Arrays-asList-使用指南"><a href="#2-1-Arrays-asList-使用指南" class="headerlink" title="2.1. Arrays.asList()使用指南"></a>2.1. Arrays.asList()使用指南</h2><p>最近使用<code>Arrays.asList()</code>遇到了一些坑，然后在网上看到这篇文章：<a href="http://javadevnotes.com/java-array-to-list-examples">Java Array to List Examples</a> 感觉挺不错的，但是还不是特别全面。所以，自己对于这块小知识点进行了简单的总结。</p><h3 id="2-1-1-简介"><a href="#2-1-1-简介" class="headerlink" title="2.1.1. 简介"></a>2.1.1. 简介</h3><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> myList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//上面两个语句等价于下面一条语句</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> myList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">,</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>JDK 源码对于这个方法的说明：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。  */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">asList</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-2-《阿里巴巴Java-开发手册》对其的描述"><a href="#2-1-2-《阿里巴巴Java-开发手册》对其的描述" class="headerlink" title="2.1.2. 《阿里巴巴Java 开发手册》对其的描述"></a>2.1.2. 《阿里巴巴Java 开发手册》对其的描述</h3><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210928104537.png" alt="阿里巴巴Java开发手-Arrays.asList()方法"></p><h3 id="2-1-3-使用时的注意事项总结"><a href="#2-1-3-使用时的注意事项总结" class="headerlink" title="2.1.3. 使用时的注意事项总结"></a>2.1.3. 使用时的注意事项总结</h3><p><strong>传递的数组必须是对象数组，而不是基本类型。</strong> </p><p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">List</span> myList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数组地址值</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//报错：ArrayIndexOutOfBoundsException</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> myList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>我们使用包装类型数组就可以解决这个问题。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>使用集合的修改方法:<code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span> myList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//运行时报错：UnsupportedOperationException</span>myList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//运行时报错：UnsupportedOperationException</span>myList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//运行时报错：UnsupportedOperationException</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span> myList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//class java.util.Arrays$ArrayList</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span>      <span class="token keyword">implements</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>  <span class="token punctuation">&#123;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">&#125;</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">&#125;</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">&#125;</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">&#125;</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> action<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">&#125;</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token class-name">UnaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> operator<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">&#125;</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-1-4-如何正确的将数组转换为ArrayList"><a href="#2-1-4-如何正确的将数组转换为ArrayList" class="headerlink" title="2.1.4. 如何正确的将数组转换为ArrayList?"></a>2.1.4. 如何正确的将数组转换为ArrayList?</h3><p>stackoverflow：<a href="https://dwz.cn/vcBkTiTW">https://dwz.cn/vcBkTiTW</a></p><p><strong>1. 自己动手实现（教育目的）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//JDK1.5+</span><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">arrayToList</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> l <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">T</span> s <span class="token operator">:</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    l<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">arrayToList</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//class java.util.ArrayList</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2. 最简便的方法(推荐)</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3. 使用 Java8 的Stream(推荐)</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">List</span> myList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> myArray2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">List</span> myList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>myArray2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 使用 Guava(推荐)</strong></p><p>对于不可变集合，你可以使用[<code>ImmutableList</code>]类及其[<code>of()</code>]与[<code>copyOf()</code>]工厂方法：（参数不能为空）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> il <span class="token operator">=</span> <span class="token class-name">ImmutableList</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">,</span> <span class="token string">"elements"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// from varargs</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> il <span class="token operator">=</span> <span class="token class-name">ImmutableList</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>aStringArray<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// from array</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于可变集合，你可以使用[<code>Lists</code>]类及其[<code>newArrayList()</code>]工厂方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> l1 <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span>anotherListOrCollection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// from collection</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> l2 <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span>aStringArray<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// from array</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> l3 <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token string">"or"</span><span class="token punctuation">,</span> <span class="token string">"string"</span><span class="token punctuation">,</span> <span class="token string">"elements"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// from varargs</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>5. 使用 Apache Commons Collections</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>6. 使用 Java9 的 <code>List.of()</code>方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* [1, 2, 3] */</span><span class="token comment">/* 不支持基本数据类型 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#2-2-Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="2.2. Collection.toArray()方法使用的坑&amp;如何反转数组"></a>2.2. Collection.toArray()方法使用的坑&amp;如何反转数组</h2><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>    <span class="token string">"dog"</span><span class="token punctuation">,</span> <span class="token string">"lazy"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"over"</span><span class="token punctuation">,</span> <span class="token string">"jumps"</span><span class="token punctuation">,</span> <span class="token string">"fox"</span><span class="token punctuation">,</span> <span class="token string">"brown"</span><span class="token punctuation">,</span> <span class="token string">"quick"</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token operator">=</span>list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//没有指定类型的话会报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p><h2 id="2-3-不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#2-3-不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="2.3. 不要在 foreach 循环里进行元素的 remove/add 操作"></a>2.3. 不要在 foreach 循环里进行元素的 remove/add 操作</h2><p>如果要进行<code>remove</code>操作，可以调用迭代器的 <code>remove </code>方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p></blockquote><p>Java8开始，可以使用<code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list<span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span>filter <span class="token operator">-></span> filter <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 删除list中的所有偶数 */</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* [1, 3, 5, 7, 9] */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p><p><img src="https://cdn.jsdelivr.net/gh/ryanxys/pic/ryan/20210928104803.png" alt="不要在 foreach 循环里进行元素的 remove/add 操作"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>双亲委派机制</title>
    <link href="http://example.com/2020/06/15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2020/06/15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</id>
    <published>2020-06-15T14:03:46.000Z</published>
    <updated>2021-09-28T05:10:47.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在介绍双亲委派机制的时候，不得不提ClassLoader（类加载器）。说ClassLoader之前，我们得先了解下Java的基本知识。<br>  Java是运行在Java的虚拟机(JVM)中的，但是它是如何运行在JVM中了呢？我们在IDE中编写的Java源代码被编译器编译成.class的字节码文件。然后由我们得ClassLoader负责将这些class文件给加载到JVM中去执行。<br>  JVM中提供了三层的ClassLoader：</p><p>Bootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader。</p><p>ExtClassLoader：主要负责加载jre/lib/ext目录下的一些扩展的jar。</p><p>AppClassLoader：主要负责加载应用程序的主函数类</p><p>那如果有一个我们写的Hello.java编译成的Hello.class文件，它是如何被加载到JVM中的呢？别着急，请继续往下看。</p><p>双亲委派机制</p><p>我打开了我的AndroidStudio，搜索了下“ClassLoader”,然后打开“java.lang”包下的ClassLoader类。然后将代码翻到loadClass方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//              -----??-----</span><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>    <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 首先，检查是否已经被类加载器加载过</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 存在父加载器，递归的交由父加载器</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 直到最上面的Bootstrap类加载器</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// ClassNotFoundException thrown if class not found</span>                <span class="token comment">// from the non-null parent class loader</span>            <span class="token punctuation">&#125;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// If still not found, then invoke findClass in order</span>                <span class="token comment">// to find the class.</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这段代码已经很好的解释了双亲委派机制，为了大家更容易理解，我做了一张图来描述一下上面这段代码的流程：  </p><p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70.png"></p><p>从上图中我们就更容易理解了，当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。那么有人就有下面这种疑问了？</p><p>为什么要设计这种机制</p><p>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。</p><p>总结了一张脑图如下：</p><img src="https://cdn.jsdelivr.net/gh/XS-RYAN/pic/ryan/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70-20210719110251508.png" style="zoom:200%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
</feed>
